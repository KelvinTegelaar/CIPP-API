using namespace System.Net
using namespace System.Collections.Generic
using namespace System.Text.RegularExpressions
using namespace Microsoft.Azure.Functions.PowerShellWorker
#Region './Private/Convert-QuarantinePermissionsValue.ps1' -1

function Convert-QuarantinePermissionsValue {
    [CmdletBinding(DefaultParameterSetName = 'DecimalValue')]
    param (
        [Parameter(Mandatory, Position = 0, ParameterSetName = "StringValue")]
        [ValidateNotNullOrEmpty()]
        [string]$InputObject,

        [Parameter(Position = 0, ParameterSetName = "DecimalValue")]
        [int]$PermissionToViewHeader = 0,
        [Parameter(Position = 1, ParameterSetName = "DecimalValue")]
        [int]$PermissionToDownload = 0,
        [Parameter(Mandatory, Position = 2, ParameterSetName = "DecimalValue")]
        [int]$PermissionToAllowSender,
        [Parameter(Mandatory, Position = 3, ParameterSetName = "DecimalValue")]
        [int]$PermissionToBlockSender,
        [Parameter(Mandatory, Position = 4, ParameterSetName = "DecimalValue")]
        [int]$PermissionToRequestRelease,
        [Parameter(Mandatory, Position = 5, ParameterSetName = "DecimalValue")]
        [int]$PermissionToRelease,
        [Parameter(Mandatory, Position = 6, ParameterSetName = "DecimalValue")]
        [int]$PermissionToPreview,
        [Parameter(Mandatory, Position = 7, ParameterSetName = "DecimalValue")]
        [int]$PermissionToDelete
    )

    #Converts string value with EndUserQuarantinePermissions received from Get-QuarantinePolicy
    if (($PSCmdlet.ParameterSetName) -eq "StringValue") {
        try {
            # Remove square brackets and split into lines
            $InputObject = $InputObject.Trim('[', ']')
            $hashtable = @{}
            $InputObject -split "`n" | ForEach-Object {
                $key, $value = $_ -split ":\s*"
                $hashtable[$key.Trim()] = [System.Convert]::ToBoolean($value.Trim())
            }
            return $hashtable
        }
        catch {
            throw "Convert-QuarantinePermissionsValue: Failed to convert string to hashtable."
        }
    }

    #Converts selected end user quarantine permissions to decimal value used by EndUserQuarantinePermissionsValue property in New-QuarantinePolicy and Set-QuarantinePolicy
    elseif (($PSCmdlet.ParameterSetName) -eq "DecimalValue") {
        try {
            # both PermissionToRequestRelease and PermissionToRelease cannot be set to true at the same time
            if($PermissionToRequestRelease -eq 1 -and $PermissionToRelease -eq 1) {
                throw "PermissionToRequestRelease and PermissionToRelease cannot both be set to true."
            }

            # Convert each permission to a binary string
            $BinaryValue = [string]@(
                $PermissionToViewHeader,
                $PermissionToDownload,
                $PermissionToAllowSender,
                $PermissionToBlockSender,
                $PermissionToRequestRelease,
                $PermissionToRelease,
                $PermissionToPreview,
                $PermissionToDelete
            ) -replace '\s',''

            # Convert the binary string to an Decimal value
            return [convert]::ToInt32($BinaryValue,2)
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            throw "Convert-QuarantinePermissionsValue: Failed to convert QuarantinePermissions to QuarantinePermissionsValue. Error: $ErrorMessage"
        }
    }
}
#EndRegion './Private/Convert-QuarantinePermissionsValue.ps1' 72
#Region './Private/Get-ExoOnlineStringBytes.ps1' -1

function Get-ExoOnlineStringBytes {
    param([string]$SizeString)

    # This exists because various exo cmdlets like to return a human readable string like "3.322 KB (3,402 bytes)" but not the raw bytes value
    
    if ($SizeString -match '\(([0-9,]+) bytes\)') {
        return [int64]($Matches[1] -replace ',','')
    }
    
    return 0
}
#EndRegion './Private/Get-ExoOnlineStringBytes.ps1' 12
#Region './Private/Get-StringHash.ps1' -1

function Get-StringHash {
    Param($String)
    $StringBuilder = New-Object System.Text.StringBuilder
    [System.Security.Cryptography.HashAlgorithm]::Create('SHA1').ComputeHash([System.Text.Encoding]::UTF8.GetBytes($String)) | ForEach-Object {
        [Void]$StringBuilder.Append($_.ToString('x2'))
    }
    $StringBuilder.ToString()
}
#EndRegion './Private/Get-StringHash.ps1' 9
#Region './Public/Add-CIPPAlias.ps1' -1

function Add-CIPPAlias {
    [CmdletBinding()]
    param (
        $User,
        $Aliases,
        $UserPrincipalName,
        $TenantFilter,
        $APIName = 'Add Alias',
        $Headers
    )

    try {
        foreach ($Alias in $Aliases) {
            Write-Host "Adding alias $Alias to $User"
            New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$User" -tenantid $TenantFilter -type 'patch' -body "{`"mail`": `"$Alias`"}" -verbose
        }
        Write-Host "Resetting primary alias to $User"
        New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$User" -tenantid $TenantFilter -type 'patch' -body "{`"mail`": `"$User`"}" -verbose
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added alias $($Alias) to $($UserPrincipalName)" -Sev 'Info'
        return ("Added Aliases: $($Aliases -join ',')")
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Failed to set alias. Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        throw "Failed to set alias: $($ErrorMessage.NormalizedError)"
    }
}

#EndRegion './Public/Add-CIPPAlias.ps1' 28
#Region './Public/Add-CIPPApplicationPermission.ps1' -1

function Add-CIPPApplicationPermission {
    [CmdletBinding()]
    param(
        $RequiredResourceAccess,
        $TemplateId,
        $ApplicationId,
        $TenantFilter
    )
    if ($ApplicationId -eq $env:ApplicationID -and $TenantFilter -eq $env:TenantID) {
        #return @('Cannot modify application permissions for CIPP-SAM on partner tenant')
        $RequiredResourceAccess = 'CIPPDefaults'
    }
    Set-Location (Get-Item $PSScriptRoot).FullName
    if ($RequiredResourceAccess -eq 'CIPPDefaults') {
        #$RequiredResourceAccess = (Get-Content '.\SAMManifest.json' | ConvertFrom-Json).requiredResourceAccess

        $Permissions = Get-CippSamPermissions -NoDiff
        $RequiredResourceAccess = [System.Collections.Generic.List[object]]::new()

        foreach ($AppId in $Permissions.Permissions.PSObject.Properties.Name) {
            $AppPermissions = @($Permissions.Permissions.$AppId.applicationPermissions)
            $Resource = @{
                resourceAppId  = $AppId
                resourceAccess = [System.Collections.Generic.List[object]]::new()
            }
            foreach ($Permission in $AppPermissions) {
                $Resource.ResourceAccess.Add(@{
                        id   = $Permission.id
                        type = 'Role'
                    })
            }

            $RequiredResourceAccess.Add($Resource)
        }
    } else {
        if (!$RequiredResourceAccess -and $TemplateId) {
            Write-Information "Adding application permissions for template $TemplateId"
            $TemplateTable = Get-CIPPTable -TableName 'templates'
            $Filter = "RowKey eq '$TemplateId' and PartitionKey eq 'AppApprovalTemplate'"
            $Template = (Get-CIPPAzDataTableEntity @TemplateTable -Filter $Filter).JSON | ConvertFrom-Json -ErrorAction SilentlyContinue
            $ApplicationId = $Template.AppId
            $Permissions = $Template.Permissions
            $RequiredResourceAccess = [System.Collections.Generic.List[object]]::new()
            foreach ($AppId in $Permissions.PSObject.Properties.Name) {
                $AppPermissions = @($Permissions.$AppId.applicationPermissions)
                $Resource = @{
                    resourceAppId  = $AppId
                    resourceAccess = [System.Collections.Generic.List[object]]::new()
                }
                foreach ($Permission in $AppPermissions) {
                    $Resource.ResourceAccess.Add(@{
                            id   = $Permission.id
                            type = 'Role'
                        })
                }

                $RequiredResourceAccess.Add($Resource)
            }
        }
    }


    $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -skipTokenCache $true -tenantid $TenantFilter -NoAuthCheck $true
    $ourSVCPrincipal = $ServicePrincipalList | Where-Object -Property AppId -EQ $ApplicationId
    if (!$ourSVCPrincipal) {
        #Our Service Principal isn't available yet. We do a sleep and reexecute after 3 seconds.
        Start-Sleep -Seconds 5
        $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -skipTokenCache $true -tenantid $TenantFilter -NoAuthCheck $true
        $ourSVCPrincipal = $ServicePrincipalList | Where-Object -Property AppId -EQ $ApplicationId
    }

    $Results = [System.Collections.Generic.List[string]]::new()

    $CurrentRoles = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals/$($ourSVCPrincipal.id)/appRoleAssignments" -tenantid $TenantFilter -skipTokenCache $true -NoAuthCheck $true

    $Grants = foreach ($App in $RequiredResourceAccess) {
        $svcPrincipalId = $ServicePrincipalList | Where-Object -Property AppId -EQ $App.resourceAppId
        if (!$svcPrincipalId) {
            try {
                $Body = @{
                    appId = $App.resourceAppId
                } | ConvertTo-Json -Compress
                $svcPrincipalId = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/servicePrincipals' -tenantid $TenantFilter -body $Body -type POST
            } catch {
                $Results.add("Failed to create service principal for $($App.resourceAppId): $(Get-NormalizedError -message $_.Exception.Message)")
                continue
            }
        }
        foreach ($SingleResource in $App.ResourceAccess | Where-Object -Property Type -EQ 'Role') {
            if ($SingleResource.id -in $CurrentRoles.appRoleId) { continue }
            [pscustomobject]@{
                principalId = $($ourSVCPrincipal.id)
                resourceId  = $($svcPrincipalId.id)
                appRoleId   = "$($SingleResource.Id)"
            }
        }
    }
    $counter = 0
    foreach ($Grant in $Grants) {
        try {
            $SettingsRequest = New-GraphPOSTRequest -body (ConvertTo-Json -InputObject $Grant -Depth 5) -uri "https://graph.microsoft.com/beta/servicePrincipals/$($ourSVCPrincipal.id)/appRoleAssignedTo" -tenantid $TenantFilter -type POST -NoAuthCheck $true
            $counter++
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $Results.add("Failed to grant $($Grant.appRoleId) to $($Grant.resourceId): $ErrorMessage")
        }
    }
    "Added $counter Application permissions to $($ourSVCPrincipal.displayName)"
    return $Results
}
#EndRegion './Public/Add-CIPPApplicationPermission.ps1' 111
#Region './Public/Add-CIPPAzDataTableEntity.ps1' -1

function Add-CIPPAzDataTableEntity {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding(DefaultParameterSetName = 'OperationType')]
    param(
        $Context,
        $Entity,
        [switch]$CreateTableIfNotExists,

        [Parameter(ParameterSetName = 'Force')]
        [switch]$Force,

        [Parameter(ParameterSetName = 'OperationType')]
        [ValidateSet('Add', 'UpsertMerge', 'UpsertReplace')]
        [string]$OperationType = 'Add'
    )

    # Validate input parameters
    if ($null -eq $Context) {
        throw 'Context parameter cannot be null'
    }

    if ($null -eq $Entity) {
        Write-Warning 'Entity parameter is null - nothing to process'
        return
    }

    $Parameters = @{
        Context                = $Context
        CreateTableIfNotExists = $CreateTableIfNotExists
    }
    if ($PSCmdlet.ParameterSetName -eq 'Force') {
        $Parameters.Force = $Force
    } else {
        $Parameters.OperationType = $OperationType
    }

    $MaxRowSize = 500000 - 100
    $MaxSize = 30kb

    foreach ($SingleEnt in @($Entity)) {
        try {
            # Skip null entities
            if ($null -eq $SingleEnt) {
                Write-Warning 'Skipping null entity'
                continue
            }

            if ($null -eq $SingleEnt.PartitionKey -or $null -eq $SingleEnt.RowKey) {
                throw 'PartitionKey or RowKey is null'
            }

            # Ensure entity is not empty
            if ($SingleEnt -is [hashtable] -and $SingleEnt.Count -eq 0) {
                Write-Warning 'Skipping empty hashtable entity'
                continue
            } elseif ($SingleEnt -is [PSCustomObject] -and ($SingleEnt.PSObject.Properties | Measure-Object).Count -eq 0) {
                Write-Warning 'Skipping empty PSCustomObject entity'
                continue
            }

            # Additional validation for AzBobbyTables compatibility
            try {
                # Ensure all property values are not null for string properties
                if ($SingleEnt -is [hashtable]) {
                    foreach ($key in @($SingleEnt.Keys)) {
                        if ($null -eq $SingleEnt[$key]) {
                            $SingleEnt.Remove($key)
                        }
                    }
                } elseif ($SingleEnt -is [PSCustomObject]) {
                    $propsToRemove = [system.Collections.Generic.List[string]]::new()
                    foreach ($prop in $SingleEnt.PSObject.Properties) {
                        if ($null -eq $prop.Value) {
                            $propsToRemove.Add($prop.Name)
                        }
                    }
                    foreach ($propName in $propsToRemove) {
                        $SingleEnt.PSObject.Properties.Remove($propName)
                    }
                }
            } catch {
                Write-Warning "Error during entity validation: $($_.Exception.Message)"
            }

            Add-AzDataTableEntity @Parameters -Entity $SingleEnt -ErrorAction Stop

        } catch [System.Exception] {
            if ($_.Exception.ErrorCode -in @('PropertyValueTooLarge', 'EntityTooLarge', 'RequestBodyTooLarge')) {
                try {
                    Write-Information 'Entity is too large. Splitting entity into multiple parts.'

                    $largePropertyNames = [System.Collections.Generic.List[string]]::new()
                    $entitySize = 0

                    if ($SingleEnt -is [System.Management.Automation.PSCustomObject]) {
                        $SingleEnt = $SingleEnt | ConvertTo-Json -Depth 100 -Compress | ConvertFrom-Json -AsHashtable
                    }

                    foreach ($key in $SingleEnt.Keys) {
                        $propertySize = [System.Text.Encoding]::UTF8.GetByteCount($SingleEnt[$key].ToString())
                        $entitySize += $propertySize
                        if ($propertySize -gt $MaxSize) {
                            $largePropertyNames.Add($key)
                        }
                    }

                    if (($largePropertyNames | Measure-Object).Count -gt 0) {
                        $splitInfoList = [System.Collections.Generic.List[object]]::new()
                        foreach ($largePropertyName in $largePropertyNames) {
                            $dataString = $SingleEnt[$largePropertyName]
                            $splitCount = [math]::Ceiling($dataString.Length / $MaxSize)
                            $splitData = [System.Collections.Generic.List[object]]::new()
                            for ($i = 0; $i -lt $splitCount; $i++) {
                                $start = $i * $MaxSize
                                $splitData.Add($dataString.Substring($start, [Math]::Min($MaxSize, $dataString.Length - $start))) > $null
                            }
                            $splitDataCount = $splitData.Count
                            $splitPropertyNames = [System.Collections.Generic.List[object]]::new()
                            for ($i = 0; $i -lt $splitDataCount; $i++) {
                                $splitPropertyNames.Add("${largePropertyName}_Part$i")
                            }

                            $splitInfo = @{
                                OriginalHeader = $largePropertyName
                                SplitHeaders   = $splitPropertyNames
                            }
                            $splitInfoList.Add($splitInfo)
                            $SingleEnt.Remove($largePropertyName)

                            for ($i = 0; $i -lt $splitDataCount; $i++) {
                                $SingleEnt[$splitPropertyNames[$i]] = $splitData[$i]
                            }
                        }
                        $SingleEnt['SplitOverProps'] = ($splitInfoList | ConvertTo-Json -Compress).ToString()
                    }

                    $entitySize = [System.Text.Encoding]::UTF8.GetByteCount($($SingleEnt | ConvertTo-Json -Compress))
                    if ($entitySize -gt $MaxRowSize) {
                        $rows = [System.Collections.Generic.List[object]]::new()
                        $originalPartitionKey = $SingleEnt.PartitionKey
                        $originalRowKey = $SingleEnt.RowKey
                        $entityIndex = 0

                        while ($entitySize -gt $MaxRowSize) {
                            Write-Information "Entity size is $entitySize. Splitting entity into multiple parts."
                            $newEntity = @{}
                            $newEntity['PartitionKey'] = $originalPartitionKey
                            $newEntity['RowKey'] = if ($entityIndex -eq 0) { $originalRowKey } else { "$($originalRowKey)-part$entityIndex" }
                            $newEntity['OriginalEntityId'] = $originalRowKey
                            $newEntity['PartIndex'] = $entityIndex
                            $entityIndex++

                            $propertiesToRemove = [System.Collections.Generic.List[object]]::new()
                            foreach ($key in $SingleEnt.Keys) {
                                if ($key -in @('RowKey', 'PartitionKey')) { continue }
                                $newEntitySize = [System.Text.Encoding]::UTF8.GetByteCount($($newEntity | ConvertTo-Json -Compress))
                                if ($newEntitySize -lt $MaxRowSize) {
                                    $propertySize = [System.Text.Encoding]::UTF8.GetByteCount($SingleEnt[$key].ToString())
                                    if ($propertySize -gt $MaxRowSize) {
                                        $dataString = $SingleEnt[$key]
                                        $splitCount = [math]::Ceiling($dataString.Length / $MaxSize)
                                        $splitData = [System.Collections.Generic.List[object]]::new()
                                        for ($i = 0; $i -lt $splitCount; $i++) {
                                            $start = $i * $MaxSize
                                            $splitData.Add($dataString.Substring($start, [Math]::Min($MaxSize, $dataString.Length - $start))) > $null
                                        }

                                        $splitPropertyNames = [System.Collections.Generic.List[object]]::new()
                                        for ($i = 0; $i -lt $splitData.Count; $i++) {
                                            $splitPropertyNames.Add("${key}_Part$i")
                                        }

                                        for ($i = 0; $i -lt $splitData.Count; $i++) {
                                            $newEntity[$splitPropertyNames[$i]] = $splitData[$i]
                                        }
                                    } else {
                                        $newEntity[$key] = $SingleEnt[$key]
                                    }
                                    $propertiesToRemove.Add($key)
                                }
                            }

                            foreach ($prop in $propertiesToRemove) {
                                $SingleEnt.Remove($prop)
                            }

                            $rows.Add($newEntity)
                            $entitySize = [System.Text.Encoding]::UTF8.GetByteCount($($SingleEnt | ConvertTo-Json -Compress))
                        }

                        if ($SingleEnt.Count -gt 0) {
                            $SingleEnt['RowKey'] = "$($originalRowKey)-part$entityIndex"
                            $SingleEnt['OriginalEntityId'] = $originalRowKey
                            $SingleEnt['PartIndex'] = $entityIndex
                            $SingleEnt['PartitionKey'] = $originalPartitionKey
                            $rows.Add($SingleEnt)
                        }

                        foreach ($row in $rows) {
                            Write-Information "current entity is $($row.RowKey) with $($row.PartitionKey). Our size is $([System.Text.Encoding]::UTF8.GetByteCount($($row | ConvertTo-Json -Compress)))"
                            $NewRow = ([PSCustomObject]$row) | Select-Object * -ExcludeProperty Timestamp
                            Add-AzDataTableEntity @Parameters -Entity $NewRow
                        }

                    } else {
                        $NewEnt = ([PSCustomObject]$SingleEnt) | Select-Object * -ExcludeProperty Timestamp
                        Add-AzDataTableEntity @Parameters -Entity $NewEnt
                        if ($NewEnt.PSObject.Properties['OriginalEntityId'] -eq $null -and $NewEnt.PSObject.Properties['PartIndex'] -eq $null) {
                            $partIndex = 1
                            while ($true) {
                                $partRowKey = "$($NewEnt.RowKey)-part$partIndex"
                                try {
                                    Remove-AzDataTableEntity -Context $Context -PartitionKey $NewEnt.PartitionKey -RowKey $partRowKey -ErrorAction Stop
                                    Write-Information "Deleted obsolete part: $partRowKey"
                                    $partIndex++
                                } catch {
                                    break
                                }
                            }
                        }
                    }

                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-Warning 'AzBobbyTables Error'
                    throw "Error processing entity: $ErrorMessage Linenumber: $($_.InvocationInfo.ScriptLineNumber)"
                }
            } else {
                try { Write-Information ($_.Exception | ConvertTo-Json) } catch { Write-Information $_.Exception }
                Write-Information "THE ERROR IS $($_.Exception.message). The size of the entity is $entitySize."
                Write-Information "Parameters are: $($Parameters | ConvertTo-Json -Compress)"
                Write-Information $_.InvocationInfo.PositionMessage
                throw $_
            }
        }
    }
}
#EndRegion './Public/Add-CIPPAzDataTableEntity.ps1' 241
#Region './Public/Add-CIPPBPAField.ps1' -1

function Add-CIPPBPAField {
    param (
        $BPAName = 'CIPP Standards v1.0 - Table view',
        $FieldName,
        $FieldValue,
        $StoreAs,
        $Tenant
    )
    $Table = Get-CippTable -tablename 'cachebpav2'
    $TenantName = Get-Tenants | Where-Object -Property defaultDomainName -EQ $Tenant
    $CurrentContentsObject = (Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$BPAName' and PartitionKey eq '$($TenantName.customerId)'")
    Write-Information "Adding $FieldName to $BPAName for $Tenant. content is $FieldValue"
    if ($CurrentContentsObject.RowKey) {
        $CurrentContents = @{}
        $CurrentContentsObject.PSObject.Properties.Name | ForEach-Object {
            $CurrentContents[$_] = $CurrentContentsObject.$_
        }
        $Result = $CurrentContents
    } else {
        $Result = @{
            Tenant       = "$($TenantName.displayName)"
            GUID         = "$($TenantName.customerId)"
            RowKey       = $BPAName
            PartitionKey = "$($TenantName.customerId)"
            LastRefresh  = [string]$(Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
        }
    }
    switch -Wildcard ($StoreAs) {
        '*bool' {
            $Result["$fieldName"] = [bool]$FieldValue
        }
        'JSON' {
            if ($null -eq $FieldValue) { $JsonString = '{}' } else { $JsonString = (ConvertTo-Json -Depth 15 -InputObject $FieldValue -Compress) }
            $Result[$fieldName] = [string]$JsonString
        }
        'string' {
            $Result[$fieldName], [string]$FieldValue
        }
    }
    Add-CIPPAzDataTableEntity @Table -Entity $Result -Force
}
#EndRegion './Public/Add-CIPPBPAField.ps1' 42
#Region './Public/Add-CIPPDelegatedPermission.ps1' -1

function Add-CIPPDelegatedPermission {
    [CmdletBinding()]
    param(
        $RequiredResourceAccess,
        $TemplateId,
        $ApplicationId,
        $NoTranslateRequired,
        $TenantFilter
    )
    Write-Host 'Adding Delegated Permissions'
    Set-Location (Get-Item $PSScriptRoot).FullName

    if ($ApplicationId -eq $env:ApplicationID -and $TenantFilter -eq $env:TenantID) {
        #return @('Cannot modify delgated permissions for CIPP-SAM on partner tenant')
        $RequiredResourceAccess = 'CIPPDefaults'
    }

    if ($RequiredResourceAccess -eq 'CIPPDefaults') {
        $Permissions = Get-CippSamPermissions -NoDiff
        $NoTranslateRequired = $Permissions.Type -eq 'Table'
        $RequiredResourceAccess = [System.Collections.Generic.List[object]]::new()
        foreach ($AppId in $Permissions.Permissions.PSObject.Properties.Name) {
            $DelegatedPermissions = @($Permissions.Permissions.$AppId.delegatedPermissions)
            $ResourceAccess = [System.Collections.Generic.List[object]]::new()
            foreach ($Permission in $DelegatedPermissions) {
                $ResourceAccess.Add(@{
                        id   = $Permission.value
                        type = 'Scope'
                    })
            }
            $Resource = @{
                resourceAppId  = $AppId
                resourceAccess = @($ResourceAccess)
            }
            $RequiredResourceAccess.Add($Resource)
        }

        if ($TenantFilter -eq $env:TenantID -or $TenantFilter -eq 'PartnerTenant') {
            $RequiredResourceAccess = $RequiredResourceAccess + ($AdditionalPermissions | Where-Object { $RequiredResourceAccess.resourceAppId -notcontains $_.resourceAppId })
        } else {
            # remove the partner center permission if not pushing to partner tenant
            $RequiredResourceAccess = $RequiredResourceAccess | Where-Object { $_.resourceAppId -ne 'fa3d9a0c-3fb0-42cc-9193-47c7ecd2edbd' }
        }
    } else {
        if (!$RequiredResourceAccess -and $TemplateId) {
            Write-Information "Adding delegated permissions for template $TemplateId"
            $TemplateTable = Get-CIPPTable -TableName 'templates'
            $Filter = "RowKey eq '$TemplateId' and PartitionKey eq 'AppApprovalTemplate'"
            $Template = (Get-CIPPAzDataTableEntity @TemplateTable -Filter $Filter).JSON | ConvertFrom-Json -ErrorAction SilentlyContinue
            $ApplicationId = $Template.AppId
            $Permissions = $Template.Permissions
            $NoTranslateRequired = $true
            $RequiredResourceAccess = [System.Collections.Generic.List[object]]::new()
            foreach ($AppId in $Permissions.PSObject.Properties.Name) {
                $DelegatedPermissions = @($Permissions.$AppId.delegatedPermissions)
                $ResourceAccess = [System.Collections.Generic.List[object]]::new()
                foreach ($Permission in $DelegatedPermissions) {
                    $ResourceAccess.Add(@{
                            id   = $Permission.value
                            type = 'Scope'
                        })
                }
                $Resource = @{
                    resourceAppId  = $AppId
                    resourceAccess = @($ResourceAccess)
                }
                $RequiredResourceAccess.Add($Resource)
            }
        }
    }

    $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $Translator = Get-Content (Join-Path $ModuleBase 'lib\data\PermissionsTranslator.json') | ConvertFrom-Json
    $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=appId,id,displayName&`$top=999" -tenantid $TenantFilter -skipTokenCache $true -NoAuthCheck $true
    $ourSVCPrincipal = $ServicePrincipalList | Where-Object -Property appId -EQ $ApplicationId
    $Results = [System.Collections.Generic.List[string]]::new()

    $CurrentDelegatedScopes = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals/$($ourSVCPrincipal.id)/oauth2PermissionGrants" -skipTokenCache $true -tenantid $TenantFilter -NoAuthCheck $true

    foreach ($App in $RequiredResourceAccess) {
        if (!$App) {
            continue
        }
        $svcPrincipalId = $ServicePrincipalList | Where-Object -Property appId -EQ $App.resourceAppId
        if (!$svcPrincipalId) {
            try {
                $Body = @{
                    appId = $App.resourceAppId
                } | ConvertTo-Json -Compress
                $svcPrincipalId = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/servicePrincipals' -tenantid $TenantFilter -body $Body -type POST -NoAuthCheck $true
            } catch {
                $Results.add("Failed to create service principal for $($App.resourceAppId): $(Get-NormalizedError -message $_.Exception.Message)")
                continue
            }
        }

        $DelegatedScopes = $App.resourceAccess | Where-Object -Property type -EQ 'Scope'

        if ($NoTranslateRequired) {
            $NewScope = @($DelegatedScopes | ForEach-Object { $_.id } | Sort-Object -Unique) -join ' '
        } else {
            $NewScope = foreach ($Scope in $DelegatedScopes.id) {
                if ($Scope -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$') {
                    $TranslatedScope = ($Translator | Where-Object -Property id -EQ $Scope).value
                    if ($TranslatedScope) {
                        $TranslatedScope
                    }
                } else {
                    $Scope
                }
            }
            $NewScope = (@($NewScope) | Sort-Object -Unique) -join ' '
        }

        $OldScope = ($CurrentDelegatedScopes | Where-Object -Property Resourceid -EQ $svcPrincipalId.id)

        if (!$OldScope) {
            if ([string]::IsNullOrEmpty($NewScope) -or $NewScope -eq ' ') {
                $Results.add("No delegated permissions to add for $($svcPrincipalId.displayName)")
                continue
            }
            try {
                $Createbody = @{
                    clientId    = $ourSVCPrincipal.id
                    consentType = 'AllPrincipals'
                    resourceId  = $svcPrincipalId.id
                    scope       = $NewScope
                } | ConvertTo-Json -Compress
                $CreateRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/oauth2PermissionGrants' -tenantid $TenantFilter -body $Createbody -type POST -NoAuthCheck $true
                $Results.add("Successfully added permissions for $($svcPrincipalId.displayName)")
            } catch {
                $Results.add("Failed to add permissions for $($svcPrincipalId.displayName): $(Get-NormalizedError -message $_.Exception.Message)")
                continue
            }
        } else {
            # Cleanup multiple scope entries and patch first id
            if (($OldScope.id | Measure-Object).Count -gt 1) {
                $OldScopeId = $OldScope.id[0]
                $OldScope.id | ForEach-Object {
                    if ($_ -ne $OldScopeId) {
                        try {
                            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/oauth2PermissionGrants/$_" -tenantid $TenantFilter -type DELETE -NoAuthCheck $true
                        } catch {
                        }
                    }
                }
            } else {
                $OldScopeId = $OldScope.id
            }
            $compare = Compare-Object -ReferenceObject $OldScope.scope.Split(' ') -DifferenceObject $NewScope.Split(' ')
            if (!$compare) {
                $Results.add("All delegated permissions exist for $($svcPrincipalId.displayName)")
                continue
            }

            if ([string]::IsNullOrEmpty($NewScope) -or $NewScope -eq ' ') {
                # No permissions to update
                $Results.add("No delegated permissions to update for $($svcPrincipalId.displayName)")
                continue
            }

            $Patchbody = @{
                scope = "$NewScope"
            } | ConvertTo-Json -Compress
            try {
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/oauth2PermissionGrants/$($OldScopeId)" -tenantid $TenantFilter -body $Patchbody -type PATCH -NoAuthCheck $true
            } catch {
                $Results.add("Failed to update permissions for $($svcPrincipalId.displayName): $(Get-NormalizedError -message $_.Exception.Message)")
                continue
            }
            # Added permissions
            $Added = ($Compare | Where-Object { $_.SideIndicator -eq '=>' }).InputObject -join ' '
            $Removed = ($Compare | Where-Object { $_.SideIndicator -eq '<=' }).InputObject -join ' '
            $Results.add("Successfully updated permissions for $($svcPrincipalId.displayName). $(if ($Added) { "Added: $Added"}) $(if ($Removed) { "Removed: $Removed"})")
        }
    }

    return $Results
}
#EndRegion './Public/Add-CIPPDelegatedPermission.ps1' 180
#Region './Public/Add-CIPPGDAPRoleTemplate.ps1' -1

function Add-CIPPGDAPRoleTemplate {
    <#
    .SYNOPSIS
    This function is used to add a new role template

    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param(
        $TemplateId,
        $RoleMappings,
        [switch]$Overwrite
    )

    $Table = Get-CIPPTable -TableName 'GDAPRoleTemplates'
    $Templates = Get-CIPPAzDataTableEntity @Table
    if ($Templates.RowKey -contains $TemplateId -and !$Overwrite.IsPresent) {
        $ExistingTemplate = $Templates | Where-Object -Property RowKey -EQ $RowKey
        try {
            $ExistingRoleMappings = $ExistingTemplate.RoleMappings | ConvertFrom-Json
        } catch {
            $ExistingRoleMappings = @()
        }
        $NewRoleMappings = [System.Collections.Generic.List[object]]@()

        $ExistingRoleMappings | ForEach-Object {
            $NewRoleMappings.Add($_)
        }
        # Merge the new role mappings with the existing role mappings, exclude ones that have a duplicate roleDefinitionId
        $RoleMappings | ForEach-Object {
            if ($_.roleDefinitionId -notin $ExistingRoleMappings.roleDefinitionId) {
                $NewRoleMappings.Add($_)
            }
        }
        $NewRoleMappings = @($NewRoleMappings | Sort-Object -Property GroupName) | ConvertTo-Json -Compress
        $ExistingTemplate.RoleMappings = [string]$NewRoleMappings
        $Template = $ExistingTemplate
    } else {
        $Template = [PSCustomObject]@{
            PartitionKey = 'RoleTemplate'
            RowKey       = $TemplateId
            RoleMappings = [string](@($RoleMappings | Sort-Object -Property GroupName) | ConvertTo-Json -Compress)
        }
    }
    Add-CIPPAzDataTableEntity @Table -Entity $Template -Force
}
#EndRegion './Public/Add-CIPPGDAPRoleTemplate.ps1' 48
#Region './Public/Add-CIPPGroupMember.ps1' -1

function Add-CIPPGroupMember {
    <#
    .SYNOPSIS
    Adds one or more members to a specified group in Microsoft Graph.

    .DESCRIPTION
    This function adds one or more members to a specified group in Microsoft Graph, supporting different group types such as Distribution lists and Mail-Enabled Security groups.

    .PARAMETER Headers
    The headers to include in the request, typically containing authentication tokens. This is supplied automatically by the API

    .PARAMETER GroupType
    The type of group to which the member is being added, such as Security, Distribution list or Mail-Enabled Security.

    .PARAMETER GroupId
    The unique identifier of the group to which the member will be added.

    .PARAMETER Member
    An array of members to add to the group.

    .PARAMETER TenantFilter
    The tenant identifier to filter the request.

    .PARAMETER APIName
    The name of the API operation being performed. Defaults to 'Add Group Member'.
    #>
    [CmdletBinding()]
    param(
        $Headers,
        [string]$GroupType,
        [string]$GroupId,
        [string[]]$Member,
        [string]$TenantFilter,
        [string]$APIName = 'Add Group Member'
    )
    try {
        if ($Member -like '*#EXT#*') { $Member = [System.Web.HttpUtility]::UrlEncode($Member) }
        $ODataBindString = 'https://graph.microsoft.com/v1.0/directoryObjects/{0}'
        $Requests = foreach ($m in $Member) {
            @{
                id     = $m
                url    = "users/$($m)?`$select=id,userPrincipalName"
                method = 'GET'
            }
        }
        $Users = New-GraphBulkRequest -Requests @($Requests) -tenantid $TenantFilter

        if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
            $ExoBulkRequests = [System.Collections.Generic.List[object]]::new()
            $ExoLogs = [System.Collections.Generic.List[object]]::new()

            foreach ($User in $Users) {
                $Params = @{ Identity = $GroupId; Member = $User.body.userPrincipalName; BypassSecurityGroupManagerCheck = $true }
                $ExoBulkRequests.Add(@{
                        CmdletInput = @{
                            CmdletName = 'Add-DistributionGroupMember'
                            Parameters = $Params
                        }
                    })
                $ExoLogs.Add(@{
                        message = "Added member $($User.body.userPrincipalName) to $($GroupId) group"
                        target  = $User.body.userPrincipalName
                    })
            }

            if ($ExoBulkRequests.Count -gt 0) {
                $RawExoRequest = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($ExoBulkRequests)
                $LastError = $RawExoRequest | Select-Object -Last 1

                foreach ($ExoError in $LastError.error) {
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoError -Sev 'Error'
                    throw $ExoError
                }

                foreach ($ExoLog in $ExoLogs) {
                    $ExoError = $LastError | Where-Object { $ExoLog.target -in $_.target -and $_.error }
                    if (!$LastError -or ($LastError.error -and $LastError.target -notcontains $ExoLog.target)) {
                        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoLog.message -Sev 'Info'
                    }
                }
            }
        } else {
            # Build one bulk request list; New-GraphBulkRequest handles internal chunking
            $AddRequests = foreach ($User in $Users) {
                @{
                    id      = $User.body.id
                    method  = 'POST'
                    url     = "/groups/$($GroupId)/members/`$ref"
                    body    = @{ '@odata.id' = ($ODataBindString -f $User.body.id) }
                    headers = @{ 'Content-Type' = 'application/json' }
                }
            }
            $AddResults = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($AddRequests)
            $SuccessfulUsers = [system.collections.generic.list[string]]::new()
            foreach ($Result in $AddResults) {
                if ($Result.status -lt 200 -or $Result.status -gt 299) {
                    $FailedUsername = $Users | Where-Object { $_.body.id -eq $Result.id } | Select-Object -ExpandProperty body | Select-Object -ExpandProperty userPrincipalName
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to add member $($FailedUsername): $($Result.body.error.message)" -Sev 'Error'
                } else {
                    $UserPrincipalName = $Users | Where-Object { $_.body.id -eq $Result.id } | Select-Object -ExpandProperty body | Select-Object -ExpandProperty userPrincipalName
                    $SuccessfulUsers.Add($UserPrincipalName)
                }
            }
        }
        $UserList = ($SuccessfulUsers -join ', ')
        $Results = "Successfully added user $UserList to $($GroupId)."
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev 'Info'
        return $Results
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $UserList = if ($Users) { ($Users.body.userPrincipalName -join ', ') } else { ($Member -join ', ') }
        $Results = "Failed to add user $UserList to $($GroupId) - $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev 'error' -LogData $ErrorMessage
        throw $Results
    }
}
#EndRegion './Public/Add-CIPPGroupMember.ps1' 117
#Region './Public/Add-CIPPScheduledTask.ps1' -1

function Add-CIPPScheduledTask {
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    param(
        [Parameter(Mandatory = $true, ParameterSetName = 'Default')]
        [pscustomobject]$Task,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [bool]$Hidden,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        $DisallowDuplicateName = $false,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$SyncType = $null,

        [Parameter(Mandatory = $false, ParameterSetName = 'RunNow')]
        [switch]$RunNow,

        [Parameter(Mandatory = $true, ParameterSetName = 'RunNow')]
        [string]$RowKey,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [string]$DesiredStartTime = $null,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Parameter(Mandatory = $false, ParameterSetName = 'RunNow')]
        $Headers
    )

    try {

        $Table = Get-CIPPTable -TableName 'ScheduledTasks'

        if ($RunNow.IsPresent -and $RowKey) {
            try {
                $Filter = "PartitionKey eq 'ScheduledTask' and RowKey eq '$($RowKey)'"
                $ExistingTask = (Get-CIPPAzDataTableEntity @Table -Filter $Filter)
                $ExistingTask.ScheduledTime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
                $ExistingTask.TaskState = 'Planned'
                Add-CIPPAzDataTableEntity @Table -Entity $ExistingTask -Force
                Write-LogMessage -headers $Headers -API 'RunNow' -message "Task $($ExistingTask.Name) scheduled to run now" -Sev 'Info' -Tenant $ExistingTask.Tenant
                return "Task $($ExistingTask.Name) scheduled to run now"
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -headers $Headers -API 'RunNow' -message "Could not run task: $ErrorMessage" -Sev 'Error'
                return "Could not run task: $ErrorMessage"
            }
        } else {
            if ($DisallowDuplicateName) {
                $Filter = "PartitionKey eq 'ScheduledTask' and Name eq '$($Task.Name)'"
                $ExistingTask = (Get-CIPPAzDataTableEntity @Table -Filter $Filter)
                if ($ExistingTask) {
                    return "Task with name $($Task.Name) already exists"
                }
            }

            $propertiesToCheck = @('Webhook', 'Email', 'PSA')
            $PostExecutionObject = ($propertiesToCheck | Where-Object { $task.PostExecution.$_ -eq $true })
            $PostExecution = $PostExecutionObject ? @($PostExecutionObject -join ',') : ($Task.PostExecution.value -join ',')
            $Parameters = [System.Collections.Hashtable]@{}
            foreach ($Key in $task.Parameters.PSObject.Properties.Name) {
                $Param = $task.Parameters.$Key

                if ($null -eq $Param -or $Param -eq '' -or ($Param | Measure-Object).Count -eq 0) {
                    continue
                }

                # handle different object types in params
                if ($Param -is [System.Collections.IDictionary] -or $Param[0].Key) {
                    Write-Information "Parameter $Key is a hashtable"
                    $ht = @{}
                    foreach ($p in $Param.GetEnumerator()) {
                        $ht[$p.Key] = $p.Value
                    }
                    $Parameters[$Key] = [PSCustomObject]$ht
                    Write-Information "Converted $Key to PSObject $($Parameters[$Key] | ConvertTo-Json -Compress)"
                } elseif ($Param -is [System.Object[]] -and -not ($Param -is [string])) {
                    Write-Information "Parameter $Key is an enumerable object"
                    $Param = $Param | ForEach-Object {
                        if ($null -eq $_) {
                            # Skip null entries
                            return
                        }
                        if ($_ -is [System.Collections.IDictionary]) {
                            [PSCustomObject]$_
                        } elseif ($_ -is [PSCustomObject]) {
                            $_
                        } else {
                            $_
                        }
                    } | Where-Object { $null -ne $_ }
                    $Parameters[$Key] = $Param
                } else {
                    Write-Information "Parameter $Key is a simple value"
                    $Parameters[$Key] = $Param
                }
            }

            if ($Headers) {
                $Parameters.Headers = $Headers | Select-Object -Property 'x-forwarded-for', 'x-ms-client-principal', 'x-ms-client-principal-idp', 'x-ms-client-principal-name'
            }

            $Parameters = ($Parameters | ConvertTo-Json -Depth 10 -Compress)
            $AdditionalProperties = [System.Collections.Hashtable]@{}
            foreach ($Prop in $task.AdditionalProperties) {
                if ($null -eq $Prop.Value -or $Prop.Value -eq '' -or ($Prop.Value | Measure-Object).Count -eq 0) {
                    continue
                }
                $AdditionalProperties[$Prop.Key] = $Prop.Value
            }
            $AdditionalProperties = ([PSCustomObject]$AdditionalProperties | ConvertTo-Json -Compress)
            if ($Parameters -eq 'null') { $Parameters = '' }
            if (!$Task.RowKey) {
                $RowKey = (New-Guid).Guid
            } else {
                $RowKey = $Task.RowKey
            }

            $Recurrence = if ([string]::IsNullOrEmpty($task.Recurrence.value)) {
                $task.Recurrence
            } else {
                $task.Recurrence.value
            }

            if ($task.PSObject.Properties.Name -notcontains 'ScheduledTime') {
                $task | Add-Member -MemberType NoteProperty -Name 'ScheduledTime' -Value 0 -Force
            }

            if ($DesiredStartTime) {
                try {
                    # Parse the epoch time
                    $epochSeconds = [int64]$DesiredStartTime
                    # Set ScheduledTime to the desired time
                    $task.ScheduledTime = $epochSeconds
                } catch {
                    Write-Warning "Failed to parse DesiredStartTime: $DesiredStartTime. Using provided ScheduledTime."
                    # Fall back to default
                    if ([int64]$task.ScheduledTime -eq 0 -or [string]::IsNullOrEmpty($task.ScheduledTime)) {
                        $task.ScheduledTime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
                    }
                }
            } else {
                # No DesiredStartTime - use current behavior (immediate execution)
                if ([int64]$task.ScheduledTime -eq 0 -or [string]::IsNullOrEmpty($task.ScheduledTime)) {
                    $task.ScheduledTime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
                }
            }
            $excludedTenants = if ($task.excludedTenants.value) {
                $task.excludedTenants.value -join ','
            }

            # Handle tenant filter - support both single tenant and tenant groups
            $tenantFilter = $task.TenantFilter.value ? $task.TenantFilter.value : $task.TenantFilter
            $originalTenantFilter = $task.TenantFilter

            # If tenant filter is a complex object (from form), extract the value
            if ($tenantFilter -is [PSCustomObject] -and $tenantFilter.value) {
                $originalTenantFilter = $tenantFilter
                $tenantFilter = $tenantFilter.value
            }

            # If tenant filter is a string but still seems to be JSON, try to parse it
            if ($tenantFilter -is [string] -and $tenantFilter.StartsWith('{')) {
                try {
                    $parsedTenantFilter = $tenantFilter | ConvertFrom-Json
                    if ($parsedTenantFilter.value) {
                        $originalTenantFilter = $parsedTenantFilter
                        $tenantFilter = $parsedTenantFilter.value
                    }
                } catch {
                    # If parsing fails, use the string as is
                    Write-Warning "Could not parse tenant filter JSON: $tenantFilter"
                }
            }

            $entity = @{
                PartitionKey         = [string]'ScheduledTask'
                TaskState            = [string]'Planned'
                RowKey               = [string]$RowKey
                Tenant               = [string]$tenantFilter
                excludedTenants      = [string]$excludedTenants
                Name                 = [string]$task.Name
                Command              = [string]$task.Command.value
                Parameters           = [string]$Parameters
                ScheduledTime        = [string]$task.ScheduledTime
                Recurrence           = [string]$Recurrence
                PostExecution        = [string]$PostExecution
                AdditionalProperties = [string]$AdditionalProperties
                Hidden               = [bool]$Hidden
                Results              = 'Planned'
                AlertComment         = [string]$task.AlertComment
            }


            # Always store DesiredStartTime if provided
            if ($DesiredStartTime) {
                $entity['DesiredStartTime'] = [string]$DesiredStartTime
            }

            # Store the original tenant filter for group expansion during execution
            if ($originalTenantFilter -is [PSCustomObject] -and $originalTenantFilter.type -eq 'Group') {
                $entity['TenantGroup'] = [string]($originalTenantFilter | ConvertTo-Json -Compress)
            } elseif ($originalTenantFilter -is [string] -and $originalTenantFilter.StartsWith('{')) {
                # Check if it's a serialized group object
                try {
                    $parsedOriginal = $originalTenantFilter | ConvertFrom-Json
                    if ($parsedOriginal.type -eq 'Group') {
                        $entity['TenantGroup'] = [string]$originalTenantFilter
                    }
                } catch {
                    # Not a JSON object, ignore
                }
            }

            if ($task.Trigger) {
                $entity.Trigger = [string]($task.Trigger | ConvertTo-Json -Compress)
                $TriggerType = $task.Trigger.Type.value ?? $task.Trigger.Type
                if ($TriggerType -eq 'DeltaQuery') {
                    $Parameters = @{}
                    if ($task.Trigger.WatchedAttributes -and ($task.Trigger.WatchedAttributes | Measure-Object).Count -gt 0) {
                        $Parameters.'$select' = $task.Trigger.WatchedAttributes | ForEach-Object { $_.value ?? $_ } -join ','
                    }
                    if ($task.Trigger.ResourceFilter) {
                        $ResourceFilterValues = $task.Trigger.ResourceFilter | ForEach-Object { $_.value ?? $_ }
                        $Parameters.'$filter' = "id eq '" + ($ResourceFilterValues -join "' or id eq '") + "'"
                    }
                    $Resource = $task.Trigger.DeltaResource.value ?? $task.Trigger.DeltaResource

                    if ($entity.TenantGroup) {
                        $tenantFilter = $entity.TenantGroup | ConvertFrom-Json
                    }
                    $DeltaQuery = @{
                        TenantFilter = $tenantFilter
                        Resource     = $Resource
                        Parameters   = $Parameters
                        PartitionKey = $RowKey
                    }

                    try {
                        $null = New-GraphDeltaQuery @DeltaQuery
                        Write-Information "Created delta query for resource $($Resource)"
                    } catch {
                        Write-Warning "Failed to create delta query for resource $($Resource): $($_.Exception.Message)"
                    }
                }
            }

            if ($SyncType) {
                $entity.SyncType = $SyncType
            }
            try {
                Add-CIPPAzDataTableEntity @Table -Entity $entity -Force
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-Information $_.InvocationInfo.PositionMessage
                Write-Information ($entity | ConvertTo-Json)
                return "Error - Could not add task: $ErrorMessage"
            }
            Write-LogMessage -headers $Headers -API 'ScheduledTask' -message "Added task $($entity.Name) with ID $($entity.RowKey)" -Sev 'Info' -Tenant $tenantFilter
            return "Successfully added task: $($entity.Name)"
        }
    } catch {
        Write-Warning "Failed to add scheduled task: $($_.Exception.Message)"
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        #Write-Information ($Task | ConvertTo-Json)
        throw "Error - Could not add task: $ErrorMessage"
    }
}
#EndRegion './Public/Add-CIPPScheduledTask.ps1' 269
#Region './Public/Alerts/Get-CIPPAlertAdminPassword.ps1' -1


function Get-CIPPAlertAdminPassword {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $TenantId = (Get-Tenants | Where-Object -Property defaultDomainName -EQ $TenantFilter).customerId
        $AlertData = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/roleManagement/directory/roleAssignments?`$filter=roleDefinitionId eq '62e90394-69f5-4237-9190-012177145e10'&`$expand=principal" -tenantid $($TenantFilter) | Where-Object { ($_.principalOrganizationId -EQ $TenantId) -and ($_.principal.'@odata.type' -eq '#microsoft.graph.user') } | ForEach-Object {
            $LastChanges = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/users/$($_.principalId)?`$select=UserPrincipalName,lastPasswordChangeDateTime" -tenant $($TenantFilter)
            if ($LastChanges.LastPasswordChangeDateTime -gt (Get-Date).AddDays(-1)) {
                $LastChanges | Select-Object -Property UserPrincipalName, lastPasswordChangeDateTime
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get admin password changes for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertAdminPassword.ps1' 27
#Region './Public/Alerts/Get-CIPPAlertApnCertExpiry.ps1' -1

function Get-CIPPAlertApnCertExpiry {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $Apn = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/applePushNotificationCertificate' -tenantid $TenantFilter
        $AlertData = if ($Apn.expirationDateTime -lt (Get-Date).AddDays(30) -and $Apn.expirationDateTime -gt (Get-Date).AddDays(-7)) {
            $Apn | Select-Object -Property appleIdentifier, expirationDateTime
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        #no error because if a tenant does not have an APN, it'll error anyway.
        #Write-AlertMessage -tenant $($TenantFilter) -message "Failed to check APN certificate expiry for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertApnCertExpiry.ps1' 26
#Region './Public/Alerts/Get-CIPPAlertAppCertificateExpiry.ps1' -1

function Get-CIPPAlertAppCertificateExpiry {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        Write-Host "Checking app expire for $($TenantFilter)"
        $appList = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications?`$select=appId,displayName,keyCredentials" -tenantid $TenantFilter
    } catch {
        return
    }

    $AlertData = foreach ($App in $applist) {
        Write-Host "checking $($App.displayName)"
        if ($App.keyCredentials) {
            foreach ($Credential in $App.keyCredentials) {
                if ($Credential.endDateTime -lt (Get-Date).AddDays(30) -and $Credential.endDateTime -gt (Get-Date).AddDays(-7)) {
                    Write-Host ("Application '{0}' has certificates expiring on {1}" -f $App.displayName, $Credential.endDateTime)
                    @{ DisplayName = $App.displayName; Expires = $Credential.endDateTime }
                }
            }
        }
    }
    Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
}
#EndRegion './Public/Alerts/Get-CIPPAlertAppCertificateExpiry.ps1' 34
#Region './Public/Alerts/Get-CIPPAlertAppleTerms.ps1' -1

function Get-CIPPAlertAppleTerms {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    # 0 = Expired
    # 1 = expired?
    # 2 = unknown
    # 3 = Terms & Conditions
    # 4 = Warning

    try {
        Write-Host "Checking Apple Terms for $($TenantFilter)"
        $AppleTerms = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/depOnboardingSettings' -tenantid $TenantFilter
    } catch {
        return
    }

    if ($AppleTerms.lastSyncErrorCode -eq 3) {
        $AlertData = [PSCustomObject]@{
            Message                    = 'New Apple Business Manager terms are ready to accept.'
            AppleIdentifier            = $AppleTerms.appleIdentifier
            TokenName                  = $AppleTerms.tokenName
            TokenExpirationDateTime    = $AppleTerms.tokenExpirationDateTime
            LastSyncErrorCode          = $AppleTerms.lastSyncErrorCode
            LastSuccessfulSyncDateTime = $AppleTerms.lastSuccessfulSyncDateTime
            LastSyncTriggeredDateTime  = $AppleTerms.lastSyncTriggeredDateTime
            Tenant                     = $TenantFilter
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertAppleTerms.ps1' 41
#Region './Public/Alerts/Get-CIPPAlertAppSecretExpiry.ps1' -1

function Get-CIPPAlertAppSecretExpiry {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        Write-Host "Checking app expire for $($TenantFilter)"
        $appList = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications?`$select=appId,displayName,passwordCredentials" -tenantid $TenantFilter
    } catch {
        return
    }

    $AlertData = [System.Collections.Generic.List[PSCustomObject]]::new()

    foreach ($App in $applist) {
        Write-Host "checking $($App.displayName)"
        if ($App.passwordCredentials) {
            foreach ($Credential in $App.passwordCredentials) {
                if ($Credential.endDateTime -lt (Get-Date).AddDays(30) -and $Credential.endDateTime -gt (Get-Date).AddDays(-7)) {
                    Write-Host ("Application '{0}' has secrets expiring on {1}" -f $App.displayName, $Credential.endDateTime)

                    $Message = [PSCustomObject]@{
                        AppName    = $App.displayName
                        AppId      = $App.appId
                        Expires    = $Credential.endDateTime
                        Tenant     = $TenantFilter
                    }
                    $AlertData.Add($Message)
                }
            }
        }
    }
    Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
}
#EndRegion './Public/Alerts/Get-CIPPAlertAppSecretExpiry.ps1' 43
#Region './Public/Alerts/Get-CippAlertBreachAlert.ps1' -1


function Get-CippAlertBreachAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $TenantFilter
    )
    try {
        $Search = New-BreachTenantSearch -TenantFilter $TenantFilter
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $Search -PartitionKey BreachAlert
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get New Breaches for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CippAlertBreachAlert.ps1' 20
#Region './Public/Alerts/Get-CIPPAlertDefenderIncidents.ps1' -1


function Get-CIPPAlertDefenderIncidents {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $AlertData = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/security/incidents?`$top=50&`$filter=status eq 'active'" -tenantid $TenantFilter | ForEach-Object {
            [PSCustomObject]@{
                IncidentID   = $_.id
                CreatedAt    = $_.createdDateTime
                Severity     = $_.severity
                IncidentName = $_.displayName
                IncidentUrl  = $_.incidentWebUrl
                Tenant       = $TenantFilter
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        # Pretty sure this one is gonna be spammy cause of licensing issues, so it's commented out -Bobby
        # Write-AlertMessage -tenant $($TenantFilter) -message "Could not get Defender incident data for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertDefenderIncidents.ps1' 32
#Region './Public/Alerts/Get-CIPPAlertDefenderMalware.ps1' -1


function Get-CIPPAlertDefenderMalware {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $TenantId = (Get-Tenants | Where-Object -Property defaultDomainName -EQ $TenantFilter).customerId
        $AlertData = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/managedTenants/windowsDeviceMalwareStates?`$top=999&`$filter=tenantId eq '$($TenantId)'" | Where-Object { $_.malwareThreatState -eq 'Active' } | ForEach-Object {
            [PSCustomObject]@{
                DeviceName               = $_.managedDeviceName
                MalwareName              = $_.malwareDisplayName
                MalwareSeverity          = $_.malwareSeverity
                ThreatState              = $_.malwareThreatState
                AdditionalInformationUrl = $_.additionalInformationUrl
                InitialDetectionDateTime = $_.initialDetectionDateTime
                LastStateChangeDateTime  = $_.lastStateChangeDateTime
                DetectionCount           = $_.detectionCount
                Tenant                   = $TenantFilter
                TenantId                 = $_.tenantId
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get malware data for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertDefenderMalware.ps1' 36
#Region './Public/Alerts/Get-CIPPAlertDefenderStatus.ps1' -1

function Get-CIPPAlertDefenderStatus {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $TenantId = (Get-Tenants | Where-Object -Property defaultDomainName -EQ $TenantFilter).customerId
        $AlertData = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/managedTenants/windowsProtectionStates?`$top=999&`$filter=tenantId eq '$($TenantId)'" | Where-Object { $_.realTimeProtectionEnabled -eq $false -or $_.MalwareprotectionEnabled -eq $false } | ForEach-Object {
            [PSCustomObject]@{
                ManagedDeviceName              = $_.managedDeviceName
                RealTimeProtectionEnabled      = $_.realTimeProtectionEnabled
                MalwareProtectionEnabled       = $_.malwareProtectionEnabled
                NetworkInspectionSystemEnabled = $_.networkInspectionSystemEnabled
                ManagedDeviceHealthState       = $_.managedDeviceHealthState
                AttentionRequired              = $_.attentionRequired
                LastSyncDateTime               = $_.lastSyncDateTime
                OsVersion                      = $_.osVersion
                Tenant                         = $TenantFilter
                TenantId                       = $_.tenantId
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get defender status for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertDefenderStatus.ps1' 35
#Region './Public/Alerts/Get-CIPPAlertDepTokenExpiry.ps1' -1

function Get-CIPPAlertDepTokenExpiry {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        try {
            $DepTokens = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/depOnboardingSettings' -tenantid $TenantFilter
            $AlertData = foreach ($Dep in $DepTokens) {
                if ($Dep.tokenExpirationDateTime -lt (Get-Date).AddDays(30) -and $Dep.tokenExpirationDateTime -gt (Get-Date).AddDays(-7)) {
                    $Message = 'Apple Device Enrollment Program token expiring on {0}' -f $Dep.tokenExpirationDateTime
                    $Dep | Select-Object -Property tokenName, @{Name = 'Message'; Expression = { $Message } }
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

        } catch {}


    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Failed to check Apple Device Enrollment Program token expiry for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertDepTokenExpiry.ps1' 32
#Region './Public/Alerts/Get-CIPPAlertDeviceCompliance.ps1' -1


function Get-CIPPAlertDeviceCompliance {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $AlertData = New-GraphGETRequest -uri "https://graph.microsoft.com/v1.0/deviceManagement/managedDevices?`$filter=complianceState eq 'noncompliant'&`$select=id,deviceName,managedDeviceOwnerType,complianceState,lastSyncDateTime&`$top=999" -tenantid $TenantFilter
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get compliance state for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertDeviceCompliance.ps1' 21
#Region './Public/Alerts/Get-CIPPAlertEntraConnectSyncStatus.ps1' -1


function Get-CIPPAlertEntraConnectSyncStatus {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        # Set Hours with fallback to 72 hours
        $Hours = if ($InputValue) { [int]$InputValue } else { 72 }
        $ConnectSyncStatus = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/organization?$select=onPremisesLastPasswordSyncDateTime,onPremisesLastSyncDateTime,onPremisesSyncEnabled' -tenantid $TenantFilter

        if ($ConnectSyncStatus.onPremisesSyncEnabled -eq $true) {
            $LastPasswordSync = $ConnectSyncStatus.onPremisesLastPasswordSyncDateTime
            $SyncDateTime = $ConnectSyncStatus.onPremisesLastSyncDateTime
            # Get the older of the two sync times
            $LastSync = if ($SyncDateTime -lt $LastPasswordSync) { $SyncDateTime; $Cause = 'DirectorySync' } else { $LastPasswordSync; $Cause = 'PasswordSync' }

            if ($LastSync -lt (Get-Date).AddHours(-$Hours).ToUniversalTime()) {

                $AlertData = @{
                    Message           = "Entra Connect $Cause for $($TenantFilter) has not run for over $Hours hours. Last sync was at $($LastSync.ToString('o'))"
                    LastSync          = $LastSync
                    Cause             = $Cause
                    LastPasswordSync  = $LastPasswordSync
                    LastDirectorySync = $SyncDateTime
                    Tenant            = $TenantFilter
                }
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get Entra Connect Sync Status for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertEntraConnectSyncStatus.ps1' 42
#Region './Public/Alerts/Get-CIPPAlertEntraLicenseUtilization.ps1' -1

function Get-CIPPAlertEntraLicenseUtilization {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        # Set threshold with fallback to 110%
        $Threshold = if ($InputValue) { [int]$InputValue } else { 110 }

        $LicenseData = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/reports/azureADPremiumLicenseInsight' -tenantid $($TenantFilter)
        $Alerts = [System.Collections.Generic.List[string]]::new()

        # Check P1 License utilization
        if ($LicenseData.entitledP1LicenseCount -gt 0 -or $LicenseData.entitledP2LicenseCount -gt 0) {
            $P1Used = $LicenseData.p1FeatureUtilizations.conditionalAccess.userCount
            $P1Entitled = $LicenseData.entitledP1LicenseCount + $LicenseData.entitledP2LicenseCount
            $P1Usage = ($P1Used / $P1Entitled) * 100
            $P1Overage = $P1Used - $P1Entitled

            if ($P1Usage -gt $Threshold -and $P1Overage -ge 5) {
                $Alerts.Add("P1 License utilization is at $([math]::Round($P1Usage,2))% (Using $P1Used of $P1Entitled licenses, over by $P1Overage)")
            }
        }

        # Check P2 License utilization
        if ($LicenseData.entitledP2LicenseCount -gt 0) {
            $P2Used = $LicenseData.p2FeatureUtilizations.riskBasedConditionalAccess.userCount
            $P2Entitled = $LicenseData.entitledP2LicenseCount
            $P2Usage = ($P2Used / $P2Entitled) * 100
            $P2Overage = $P2Used - $P2Entitled

            if ($P2Usage -gt $Threshold -and $P2Overage -ge 5) {
                $Alerts.Add("P2 License utilization is at $([math]::Round($P2Usage,2))% (Using $P2Used of $P2Entitled licenses, over by $P2Overage)")
            }
        }

        if ($Alerts.Count -gt 0) {
            $AlertData = "License Over-utilization Alert (Threshold: $Threshold%, Min Overage: 5): $($Alerts -join ' | ')"
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -message "Failed to check license utilization: $($ErrorMessage.NormalizedError)" -API 'License Utilization Alert' -tenant $TenantFilter -sev Info -LogData $ErrorMessage
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertEntraLicenseUtilization.ps1' 54
#Region './Public/Alerts/Get-CIPPAlertExpiringLicenses.ps1' -1

function Get-CIPPAlertExpiringLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        # Parse input parameters - default to 30 days if not specified
        # Support both old format (direct value) and new format (object with properties)
        if ($InputValue -is [hashtable] -or $InputValue -is [PSCustomObject]) {
            $DaysThreshold = if ($InputValue.ExpiringLicensesDays) { [int]$InputValue.ExpiringLicensesDays } else { 30 }
            $UnassignedOnly = if ($null -ne $InputValue.ExpiringLicensesUnassignedOnly) { [bool]$InputValue.ExpiringLicensesUnassignedOnly } else { $false }
        } else {
            # Backward compatibility: if InputValue is a simple value, treat it as days threshold
            $DaysThreshold = if ($InputValue) { [int]$InputValue } else { 30 }
            $UnassignedOnly = $false
        }
        
        $AlertData = Get-CIPPLicenseOverview -TenantFilter $TenantFilter | ForEach-Object {
            $TermData = $_.TermInfo | ConvertFrom-Json
            $UnassignedCount = [int]$_.CountAvailable
            
            # If unassigned only filter is enabled, skip licenses with no unassigned units
            if ($UnassignedOnly -and $UnassignedCount -le 0) {
                return
            }
            
            foreach ($Term in $TermData) {
                if ($Term.DaysUntilRenew -lt $DaysThreshold -and $Term.DaysUntilRenew -gt 0) {
                    $Message = if ($UnassignedOnly) {
                        "$($_.License) has $UnassignedCount unassigned license(s) expiring in $($Term.DaysUntilRenew) days. The estimated term is $($Term.Term)"
                    } else {
                        "$($_.License) will expire in $($Term.DaysUntilRenew) days. The estimated term is $($Term.Term)"
                    }
                    
                    Write-Host $Message
                    [PSCustomObject]@{
                        Message        = $Message
                        License        = $_.License
                        SkuId          = $_.skuId
                        DaysUntilRenew = $Term.DaysUntilRenew
                        Term           = $Term.Term
                        Status         = $Term.Status
                        TotalLicenses  = $Term.TotalLicenses
                        CountUsed      = $_.CountUsed
                        CountAvailable = $UnassignedCount
                        NextLifecycle  = $Term.NextLifecycle
                        Tenant         = $_.Tenant
                    }
                }
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertExpiringLicenses.ps1' 64
#Region './Public/Alerts/Get-CIPPAlertGlobalAdminNoAltEmail.ps1' -1

function Get-CIPPAlertGlobalAdminNoAltEmail {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        # Get all Global Admin accounts using the role template ID
        $globalAdmins = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/directoryRoles/roleTemplateId=62e90394-69f5-4237-9190-012177145e10/members?`$select=id,displayName,userPrincipalName,otherMails" -tenantid $($TenantFilter) -AsApp $true | Where-Object {
            $_.userDisplayName -ne 'On-Premises Directory Synchronization Service Account' -and $_.'@odata.type' -eq '#microsoft.graph.user'
        }

        # Filter for Global Admins without alternate email addresses
        $adminsWithoutAltEmail = $globalAdmins | Where-Object {
            $null -eq $_.otherMails -or $_.otherMails.Count -eq 0
        }

        if ($adminsWithoutAltEmail.Count -gt 0) {
            $AlertData = foreach ($admin in $adminsWithoutAltEmail) {
                [PSCustomObject]@{
                    DisplayName       = $admin.displayName
                    UserPrincipalName = $admin.userPrincipalName
                    Id                = $admin.id
                    Tenant            = $TenantFilter
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    } catch {
        Write-LogMessage -message "Failed to check alternate email status for Global Admins: $($_.exception.message)" -API 'Global Admin Alt Email Alerts' -tenant $TenantFilter -sev Error
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertGlobalAdminNoAltEmail.ps1' 39
#Region './Public/Alerts/Get-CIPPAlertHuntressRogueApps.ps1' -1

function Get-CIPPAlertHuntressRogueApps {
    <#
    .SYNOPSIS
        Check for rogue apps in a Tenant
    .DESCRIPTION
        This function checks for rogue apps in the tenant by comparing the service principals in the tenant with a list of known rogue apps provided by Huntress.
    .FUNCTIONALITY
        Entrypoint
    .LINK
        https://huntresslabs.github.io/rogueapps/
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $RogueApps = Invoke-RestMethod -Uri 'https://raw.githubusercontent.com/huntresslabs/rogueapps/main/public/rogueapps.json'
        $RogueAppFilter = $RogueApps.appId -join "','"
        $ServicePrincipals = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$filter=appId in ('$RogueAppFilter')" -tenantid $TenantFilter
        # If IgnoreDisabledApps is true, filter out disabled service principals
        if ($InputValue -eq $true) {
            $ServicePrincipals = $ServicePrincipals | Where-Object { $_.accountEnabled -eq $true }
        }

        if (($ServicePrincipals | Measure-Object).Count -gt 0) {
            $AlertData = foreach ($ServicePrincipal in $ServicePrincipals) {
                $RogueApp = $RogueApps | Where-Object { $_.appId -eq $ServicePrincipal.appId }
                [pscustomobject]@{
                    'App Name'       = $RogueApp.appDisplayName
                    'App Id'         = $RogueApp.appId
                    'Description'    = $RogueApp.description
                    'Enabled'        = $ServicePrincipal.accountEnabled
                    'Created'        = $ServicePrincipal.createdDateTime
                    'Tags'           = $RogueApp.tags -join ', '
                    'References'     = $RogueApp.references -join ', '
                    'Huntress Added' = $RogueApp.dateAdded
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    } catch {
        #Write-AlertMessage -tenant $($TenantFilter) -message "Failed to check for rogue apps for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertHuntressRogueApps.ps1' 49
#Region './Public/Alerts/Get-CIPPAlertInactiveLicensedUsers.ps1' -1

function Get-CIPPAlertInactiveLicensedUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        [Parameter(Mandatory = $false)]
        [switch]$IncludeNeverSignedIn, # Include users who have never signed in (default is to skip them), future use would allow this to be set in an alert configuration
        $TenantFilter
    )

    try {
        try {
            $Lookup = (Get-Date).AddDays(-90).ToUniversalTime()

            # Build base filter - cannot filter assignedLicenses server-side
            $BaseFilter = if ($InputValue -eq $true) { 'accountEnabled eq true' } else { '' }

            $Uri = if ($BaseFilter) {
                "https://graph.microsoft.com/beta/users?`$filter=$BaseFilter&`$select=id,UserPrincipalName,signInActivity,mail,userType,accountEnabled,assignedLicenses"
            } else {
                "https://graph.microsoft.com/beta/users?`$select=id,UserPrincipalName,signInActivity,mail,userType,accountEnabled,assignedLicenses"
            }

            $GraphRequest = New-GraphGetRequest -uri $Uri -scope 'https://graph.microsoft.com/.default' -tenantid $TenantFilter |
                Where-Object { $null -ne $_.assignedLicenses -and $_.assignedLicenses.Count -gt 0 }

            $AlertData = foreach ($user in $GraphRequest) {
                $lastInteractive = $user.signInActivity.lastSignInDateTime
                $lastNonInteractive = $user.signInActivity.lastNonInteractiveSignInDateTime

                # Find most recent sign-in
                $lastSignIn = $null
                if ($lastInteractive -and $lastNonInteractive) {
                    $lastSignIn = if ([DateTime]$lastInteractive -gt [DateTime]$lastNonInteractive) { $lastInteractive } else { $lastNonInteractive }
                } elseif ($lastInteractive) {
                    $lastSignIn = $lastInteractive
                } elseif ($lastNonInteractive) {
                    $lastSignIn = $lastNonInteractive
                }

                # Check if inactive
                $isInactive = (-not $lastSignIn) -or ([DateTime]$lastSignIn -le $Lookup)
                # Skip users who have never signed in by default (unless IncludeNeverSignedIn is specified)
                if (-not $IncludeNeverSignedIn -and -not $lastSignIn) { continue }
                # Only process inactive users
                if ($isInactive) {
                    if (-not $lastSignIn) {
                        $Message = 'User {0} has never signed in but still has a license assigned.' -f $user.UserPrincipalName
                    } else {
                        $daysSinceSignIn = [Math]::Round(((Get-Date) - [DateTime]$lastSignIn).TotalDays)
                        $Message = 'User {0} has been inactive for {1} days but still has a license assigned. Last sign-in: {2}' -f $user.UserPrincipalName, $daysSinceSignIn, $lastSignIn
                    }

                    [PSCustomObject]@{
                        UserPrincipalName = $user.UserPrincipalName
                        Id                = $user.id
                        lastSignIn        = $lastSignIn
                        Message           = $Message
                        Tenant            = $TenantFilter
                    }
                }
            }

            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        } catch {}
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Failed to check inactive users with licenses for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertInactiveLicensedUsers.ps1' 75
#Region './Public/Alerts/Get-CIPPAlertLicenseAssignmentErrors.ps1' -1

function Get-CIPPAlertLicenseAssignmentErrors {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $TenantFilter,
        [Alias('input')]
        $InputValue
    )

    # Define error code translations for human-readable messages
    $ErrorTranslations = @(
        @{
            ErrorCode   = 'CountViolation'
            Description = 'Not enough licenses available - the organization has exceeded the number of available licenses for this SKU'
        },
        @{
            ErrorCode   = 'MutuallyExclusiveViolation'
            Description = 'Conflicting licenses assigned - this license cannot be assigned alongside another license the user already has'
        },
        @{
            ErrorCode   = 'ProhibitedInUsageLocationViolation'
            Description = "License not available in user's location - this license cannot be assigned to users in the user's current usage location"
        },
        @{
            ErrorCode   = 'UniquenessViolation'
            Description = 'Duplicate license assignment - this license can only be assigned once per user'
        },
        @{
            ErrorCode   = 'Unknown'
            Description = 'Unknown license assignment error - an unspecified error occurred during license assignment'
        }
    )

    try {
        # Get all users with license assignment states from Graph API
        $Users = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$select=id,userPrincipalName,displayName,licenseAssignmentStates&`$top=999" -tenantid $TenantFilter

        # Filter users who have license assignment violations
        $UsersWithViolations = $Users | Where-Object {
            $_.licenseAssignmentStates -and
            ($_.licenseAssignmentStates | Where-Object {
                $_.error -and (
                    $_.error -like '*CountViolation*' -or
                    $_.error -like '*MutuallyExclusiveViolation*' -or
                    $_.error -like '*ProhibitedInUsageLocationViolation*' -or
                    $_.error -like '*UniquenessViolation*' -or
                    $_.error -like '*Unknown*'
                )
            })
        }

        # Build alert messages for users with violations
        $LicenseAssignmentErrors = foreach ($User in $UsersWithViolations) {
            $ViolationErrors = $User.licenseAssignmentStates | Where-Object {
                $_.error -and (
                    $_.error -like '*CountViolation*' -or
                    $_.error -like '*MutuallyExclusiveViolation*' -or
                    $_.error -like '*ProhibitedInUsageLocationViolation*' -or
                    $_.error -like '*UniquenessViolation*' -or
                    $_.error -like '*Unknown*'
                )
            }

            foreach ($Violation in $ViolationErrors) {
                # Find matching error translation
                $ErrorTranslation = $ErrorTranslations | Where-Object { $Violation.error -like "*$($_.ErrorCode)*" } | Select-Object -First 1
                $HumanReadableError = if ($ErrorTranslation) {
                    $ErrorTranslation.Description
                } else {
                    "Unknown license assignment error: $($Violation.error)"
                }

                $PrettyName = Convert-SKUname -SkuID $Violation.skuId

                $Message = "$($User.userPrincipalName): $HumanReadableError (License: $PrettyName)"
                [PSCustomObject]@{
                    Message           = $Message
                    UserPrincipalName = $User.userPrincipalName
                    Error             = $HumanReadableError
                    LicenseName       = $PrettyName
                    SkuId             = $Violation.skuId
                    DisplayName       = $User.displayName
                    Id                = $User.id
                    Tenant            = $TenantFilter
                }
            }
        }

        # If errors are found, write alert
        if ($LicenseAssignmentErrors) {
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $LicenseAssignmentErrors
        }

    } catch {
        Write-LogMessage -message "Failed to check license assignment errors: $($_.exception.message)" -API 'License Assignment Alerts' -tenant $TenantFilter -sev Error
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertLicenseAssignmentErrors.ps1' 102
#Region './Public/Alerts/Get-CIPPAlertLicensedUsersWithRoles.ps1' -1

function Get-CIPPAlertLicensedUsersWithRoles {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    # Get all users with assigned licenses
    $LicensedUsers = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$top=999&`$select=userPrincipalName,assignedLicenses,displayName" -tenantid $TenantFilter | Where-Object { $_.assignedLicenses -and $_.assignedLicenses.Count -gt 0 }
    if (-not $LicensedUsers -or $LicensedUsers.Count -eq 0) {
        Write-Information "No licensed users found for tenant $TenantFilter"
        return $true
    }
    # Get all directory roles with their members
    $DirectoryRoles = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/directoryRoles?`$expand=members" -tenantid $TenantFilter
    if (-not $DirectoryRoles -or $DirectoryRoles.Count -eq 0) {
        Write-Information "No directory roles found for tenant $TenantFilter"
        return
    }
    $UsersToAlertOn = $LicensedUsers | Where-Object { $_.userPrincipalName -in $DirectoryRoles.members.userPrincipalName }


    if ($UsersToAlertOn.Count -gt 0) {
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $UsersToAlertOn
    } else {
        Write-Information "No licensed users with roles found for tenant $TenantFilter"
    }


}
#EndRegion './Public/Alerts/Get-CIPPAlertLicensedUsersWithRoles.ps1' 37
#Region './Public/Alerts/Get-CIPPAlertLowDomainScore.ps1' -1

function Get-CIPPAlertLowDomainScore {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $TenantFilter,
        [Alias('input')]
        [ValidateRange(0, 100)]
        [int]$InputValue = 70
    )

    $DomainData = Get-CIPPDomainAnalyser -TenantFilter $TenantFilter
    $LowScoreDomains = $DomainData | Where-Object { $_.ScorePercentage -lt $InputValue -and $_.ScorePercentage -ne '' } | ForEach-Object {
        [PSCustomObject]@{
            Message          = "$($_.Domain): Domain security score is $($_.ScorePercentage)%, which is below the threshold of $InputValue%. Issues: $($_.ScoreExplanation)"
            Domain           = $_.Domain
            ScorePercentage  = $_.ScorePercentage
            ScoreExplanation = $_.ScoreExplanation
            Tenant           = $TenantFilter
        }
    }

    if ($LowScoreDomains) {
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $LowScoreDomains
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertLowDomainScore.ps1' 30
#Region './Public/Alerts/Get-CIPPAlertLowTenantAlignment.ps1' -1

function Get-CIPPAlertLowTenantAlignment {
    <#
    .SYNOPSIS
        Alert for low tenant alignment percentage
    .DESCRIPTION
        This alert checks tenant alignment scores against standards templates and alerts when the alignment percentage falls below the specified threshold.
    .PARAMETER TenantFilter
        The tenant to check alignment for
    .PARAMETER InputValue
        The minimum alignment percentage threshold (0-100). Default is 80.
    .FUNCTIONALITY
        Entrypoint
    .EXAMPLE
        Get-CIPPAlertLowTenantAlignment -TenantFilter "contoso.onmicrosoft.com" -InputValue 75
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $TenantFilter,
        [Alias('input')]
        [ValidateRange(0, 100)]
        [int]$InputValue = 99
    )

    try {
        # Get tenant alignment data using the new function
        $AlignmentData = Get-CIPPTenantAlignment -TenantFilter $TenantFilter

        if (-not $AlignmentData) {
            Write-AlertMessage -tenant $TenantFilter -message "No alignment data found for tenant $TenantFilter. This may indicate no standards templates are configured or applied to this tenant."
            return
        }

        $LowAlignmentAlerts = $AlignmentData | Where-Object { $_.AlignmentScore -lt $InputValue } | ForEach-Object {
            [PSCustomObject]@{
                TenantFilter             = $_.TenantFilter
                StandardName             = $_.StandardName
                StandardId               = $_.StandardId
                AlignmentScore           = $_.AlignmentScore
                LicenseMissingPercentage = $_.LicenseMissingPercentage
                LatestDataCollection     = $_.LatestDataCollection
            }
        }

        if ($LowAlignmentAlerts.Count -gt 0) {
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $LowAlignmentAlerts
        }

    } catch {
        Write-AlertMessage -tenant $TenantFilter -message "Could not get tenant alignment data for $TenantFilter`: $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertLowTenantAlignment.ps1' 53
#Region './Public/Alerts/Get-CIPPAlertMFAAdmins.ps1' -1

function Get-CIPPAlertMFAAdmins {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $CAPolicies = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/v1.0/identity/conditionalAccess/policies?$top=999' -tenantid $TenantFilter -ErrorAction Stop)
        foreach ($Policy in $CAPolicies) {
            if ($policy.grantControls.customAuthenticationFactors -eq 'RequireDuoMfa') {
                $DuoActive = $true
            }
        }
        if (!$DuoActive) {
            $Users = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/reports/authenticationMethods/userRegistrationDetails?`$top=999&filter=IsAdmin eq true and isMfaRegistered eq false and userType eq 'member'&`$select=id,userDisplayName,userPrincipalName,lastUpdatedDateTime,isMfaRegistered,IsAdmin" -tenantid $($TenantFilter) -AsApp $true |
                Where-Object { $_.userDisplayName -ne 'On-Premises Directory Synchronization Service Account' }
            if ($Users.UserPrincipalName) {
                $AlertData = foreach ($user in $Users) {
                    [PSCustomObject]@{
                        Message           = "Admin user $($user.userDisplayName) ($($user.userPrincipalName)) does not have MFA registered."
                        UserPrincipalName = $user.userPrincipalName
                        DisplayName       = $user.userDisplayName
                        Id                = $user.id
                        LastUpdated       = $user.lastUpdatedDateTime
                        Tenant            = $TenantFilter
                    }
                }

                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

            }
        } else {
            Write-LogMessage -message 'Potentially using Duo for MFA, could not check MFA status for Admins with 100% accuracy' -API 'MFA Alerts - Informational' -tenant $TenantFilter -sev Info
        }
    } catch {
        Write-LogMessage -message "Failed to check MFA status for Admins: $($_.exception.message)" -API 'MFA Alerts - Informational' -tenant $TenantFilter -sev Error
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertMFAAdmins.ps1' 45
#Region './Public/Alerts/Get-CIPPAlertMFAAlertUsers.ps1' -1

function Get-CIPPAlertMFAAlertUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {

        $Users = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/reports/authenticationMethods/userRegistrationDetails?`$top=999&filter=IsAdmin eq false and isMfaRegistered eq false and userType eq 'member'&`$select=userDisplayName,userPrincipalName,lastUpdatedDateTime,isMfaRegistered,IsAdmin" -tenantid $($TenantFilter) -AsApp $true |
            Where-Object { $_.userDisplayName -ne 'On-Premises Directory Synchronization Service Account' -and $_.userPrincipalName -notmatch '^package_[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}@' }
        if ($Users) {
            $AlertData = foreach ($user in $Users) {
                [PSCustomObject]@{
                    UserPrincipalName = $user.userPrincipalName
                    DisplayName       = $user.userDisplayName
                    LastUpdated       = $user.lastUpdatedDateTime
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

        }

    } catch {
        Write-LogMessage -message "Failed to check MFA status for all users: $($_.exception.message)" -API 'MFA Alerts - Informational' -tenant $TenantFilter -sev Info
    }

}
#EndRegion './Public/Alerts/Get-CIPPAlertMFAAlertUsers.ps1' 34
#Region './Public/Alerts/Get-CIPPAlertMXRecordChanged.ps1' -1

function Get-CIPPAlertMXRecordChanged {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $TenantFilter,
        [Alias('input')]
        $InputValue
    )

    try {
        $DomainData = Get-CIPPDomainAnalyser -TenantFilter $TenantFilter
        $CacheTable = Get-CippTable -tablename 'CacheMxRecords'
        $PreviousResults = Get-CIPPAzDataTableEntity @CacheTable -Filter "PartitionKey eq '$TenantFilter'"

        $ChangedDomains = foreach ($Domain in $DomainData) {
            $PreviousDomain = $PreviousResults | Where-Object { $_.Domain -eq $Domain.Domain }
            if ($PreviousDomain -and $PreviousDomain.ActualMXRecords -ne $Domain.ActualMXRecords) {
                "$($Domain.Domain): MX records changed from [$($PreviousDomain.ActualMXRecords -join ', ')] to [$($Domain.ActualMXRecords -join ', ')]"
            }
        }

        if ($ChangedDomains) {
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $ChangedDomains
        }

        # Update cache with current data
        foreach ($Domain in $DomainData) {
            $CacheEntity = @{
                PartitionKey    = $TenantFilter
                RowKey          = $Domain.Domain
                Domain          = $Domain.Domain
                ActualMXRecords = $Domain.ActualMXRecords
                LastRefresh     = $Domain.LastRefresh
                MailProvider    = $Domain.MailProvider
            }
            Add-CIPPAzDataTableEntity @CacheTable -Entity $CacheEntity -Force
        }
    } catch {
        Write-LogMessage -message "Failed to check MX record changes: $($_.Exception.Message)" -API 'MX Record Alert' -tenant $TenantFilter -sev Error
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertMXRecordChanged.ps1' 46
#Region './Public/Alerts/Get-CIPPAlertNewAppApproval.ps1' -1


function Get-CIPPAlertNewAppApproval {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter,
        $Headers
    )
    try {
        $Approvals = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/identityGovernance/appConsent/appConsentRequests?`$filter=userConsentRequests/any (u:u/status eq 'InProgress')" -tenantid $TenantFilter
        if ($Approvals.count -gt 0) {
            $TenantGUID = (Get-Tenants -TenantFilter $TenantFilter -SkipDomains).customerId
            $AlertData = [System.Collections.Generic.List[PSCustomObject]]::new()
            foreach ($App in $Approvals) {
                $userConsentRequests = New-GraphGetRequest -Uri "https://graph.microsoft.com/v1.0/identityGovernance/appConsent/appConsentRequests/$($App.id)/userConsentRequests" -tenantid $TenantFilter
                $userConsentRequests | ForEach-Object {
                    $consentUrl = if ($App.consentType -eq 'Static') {
                        # if something is going wrong here you've probably stumbled on a fourth variation - rvdwegen
                        "https://login.microsoftonline.com/$($TenantFilter)/adminConsent?client_id=$($App.appId)&bf_id=$($App.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    } elseif ($App.pendingScopes.displayName) {
                        "https://login.microsoftonline.com/$($TenantFilter)/v2.0/adminConsent?client_id=$($App.appId)&scope=$($App.pendingScopes.displayName -Join(' '))&bf_id=$($App.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    } else {
                        "https://login.microsoftonline.com/$($TenantFilter)/adminConsent?client_id=$($App.appId)&bf_id=$($App.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    }

                    $Message = [PSCustomObject]@{
                        RequestId   = $_.id
                        AppName     = $App.appDisplayName
                        RequestUser = $_.createdBy.user.userPrincipalName
                        Reason      = $_.reason
                        RequestDate = $_.createdDateTime
                        Status      = $_.status # Will allways be InProgress as we filter to only get these but this will reduce confusion when an alert is generated
                        AppId       = $App.appId
                        Scopes      = ($App.pendingScopes.displayName -join ', ')
                        ConsentURL  = $consentUrl
                        Tenant      = $TenantFilter
                        TenantId    = $TenantGUID
                    }
                    $AlertData.Add($Message)
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    } catch {
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertNewAppApproval.ps1' 53
#Region './Public/Alerts/Get-CIPPAlertNewRiskyUsers.ps1' -1

function Get-CIPPAlertNewRiskyUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $TenantFilter
    )
    $Deltatable = Get-CIPPTable -Table DeltaCompare
    try {
        # Check if tenant has P2 capabilities
        $Capabilities = Get-CIPPTenantCapabilities -TenantFilter $TenantFilter
        if (-not ($Capabilities.AAD_PREMIUM_P2 -eq $true)) {
            Write-AlertMessage -tenant $($TenantFilter) -message 'Tenant does not have Azure AD Premium P2 licensing required for risky users detection'
            return
        }

        $Filter = "PartitionKey eq 'RiskyUsersDelta' and RowKey eq '{0}'" -f $TenantFilter
        $RiskyUsersDelta = (Get-CIPPAzDataTableEntity @Deltatable -Filter $Filter).delta | ConvertFrom-Json -ErrorAction SilentlyContinue

        # Get current risky users with more detailed information
        $NewDelta = (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/identityProtection/riskyUsers' -tenantid $TenantFilter) | Select-Object userPrincipalName, riskLevel, riskState, riskDetail, riskLastUpdatedDateTime, isProcessing, history

        $NewDeltatoSave = $NewDelta | ConvertTo-Json -Depth 10 -Compress -ErrorAction SilentlyContinue | Out-String
        $DeltaEntity = @{
            PartitionKey = 'RiskyUsersDelta'
            RowKey       = [string]$TenantFilter
            delta        = "$NewDeltatoSave"
        }
        Add-CIPPAzDataTableEntity @DeltaTable -Entity $DeltaEntity -Force

        if ($RiskyUsersDelta) {
            $AlertData = $NewDelta | Where-Object { $_.userPrincipalName -notin $RiskyUsersDelta.userPrincipalName } | ForEach-Object {
                $RiskHistory = if ($_.history) {
                    $latestHistory = $_.history | Sort-Object -Property riskLastUpdatedDateTime -Descending | Select-Object -First 1
                    "Previous Risk Level: $($latestHistory.riskLevel), Last Updated: $($latestHistory.riskLastUpdatedDateTime)"
                } else {
                    'No previous risk history'
                }

                # Map risk level to severity
                $Severity = switch ($_.riskLevel) {
                    'high' { 'Critical' }
                    'medium' { 'Warning' }
                    'low' { 'Info' }
                    default { 'Info' }
                }

                [PSCustomObject]@{
                    Message = "New risky user detected: $($_.userPrincipalName)"
                    Details = @{
                        RiskLevel    = $_.riskLevel
                        RiskState    = $_.riskState
                        RiskDetail   = $_.riskDetail
                        LastUpdated  = $_.riskLastUpdatedDateTime
                        IsProcessing = $_.isProcessing
                        RiskHistory  = $RiskHistory
                        Severity     = $Severity
                    }
                    Tenant  = $TenantFilter
                }
            }

            if ($AlertData) {
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get risky users for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertNewRiskyUsers.ps1' 75
#Region './Public/Alerts/Get-CIPPAlertNewRole.ps1' -1

function Get-CIPPAlertNewRole {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    $Deltatable = Get-CIPPTable -Table DeltaCompare
    try {
        $Filter = "PartitionKey eq 'AdminDelta' and RowKey eq '{0}'" -f $TenantFilter
        $AdminDelta = (Get-CIPPAzDataTableEntity @Deltatable -Filter $Filter).delta | ConvertFrom-Json -ErrorAction SilentlyContinue
        $NewDelta = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/directoryRoles?`$expand=members" -tenantid $TenantFilter) | Select-Object displayName, Members | ForEach-Object {
            @{
                GroupName = $_.displayName
                Members   = $_.Members.UserPrincipalName
            }
        }
        $NewDeltatoSave = $NewDelta | ConvertTo-Json -Depth 10 -Compress -ErrorAction SilentlyContinue | Out-String
        $DeltaEntity = @{
            PartitionKey = 'AdminDelta'
            RowKey       = [string]$TenantFilter
            delta        = "$NewDeltatoSave"
        }
        Add-CIPPAzDataTableEntity @DeltaTable -Entity $DeltaEntity -Force

        if ($AdminDelta) {
            $AlertData = foreach ($Group in $NewDelta) {
                $OldDelta = $AdminDelta | Where-Object { $_.GroupName -eq $Group.GroupName }
                $Group.members | Where-Object { $_ -notin $OldDelta.members } | ForEach-Object {
                    [PSCustomObject]@{
                        Message = "$_ has been added to the $($Group.GroupName) Role"
                        User    = $_
                        Role    = $Group.GroupName
                        Tenant  = $TenantFilter
                    }
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get get role changes for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertNewRole.ps1' 49
#Region './Public/Alerts/Get-CIPPAlertNoCAConfig.ps1' -1

function Get-CIPPAlertNoCAConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        # Only consider CA available when a SKU that grants it has enabled seats (> 0)
        $SubscribedSkus = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/subscribedSkus?`$select=prepaidUnits,servicePlans" -tenantid $TenantFilter -ErrorAction Stop
        $CAAvailable = foreach ($sku in $SubscribedSkus) {
            if ([int]$sku.prepaidUnits.enabled -gt 0) { $sku.servicePlans }
        }

        if (('AAD_PREMIUM' -in $CAAvailable.servicePlanName) -or ('AAD_PREMIUM_P2' -in $CAAvailable.servicePlanName)) {
            $CAPolicies = (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/identity/conditionalAccess/policies' -tenantid $TenantFilter)
            if (!$CAPolicies.id) {
                $AlertData = [PSCustomObject]@{
                    Message = 'Conditional Access is available, but no policies could be found.'
                    Tenant  = $TenantFilter
                }

                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Conditional Access Config Alert: Error occurred: $(Get-NormalizedError -message $_.Exception.message)"
    }

}
#EndRegion './Public/Alerts/Get-CIPPAlertNoCAConfig.ps1' 37
#Region './Public/Alerts/Get-CIPPAlertOnedriveQuota.ps1' -1

function Get-CIPPAlertOneDriveQuota {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $TenantFilter,
        [Alias('input')]
        [ValidateRange(0, 100)]
        [int]$InputValue = 90
    )

    try {
        $Usage = New-GraphGetRequest -tenantid $TenantFilter -uri "https://graph.microsoft.com/beta/reports/getOneDriveUsageAccountDetail(period='D7')?`$format=application/json&`$top=999" -AsApp $true
        if (!$Usage) {
            return
        }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-AlertMessage -tenant $($TenantFilter) -message "OneDrive quota Alert: Unable to get OneDrive usage: Error occurred: $ErrorMessage"
        return
    }

    #Check if the OneDrive quota is over the threshold
    $OverQuota = $Usage | ForEach-Object {
        if ($_.StorageUsedInBytes -eq 0 -or $_.storageAllocatedInBytes -eq 0) { return }
        try {
            $UsagePercent = [math]::Round(($_.storageUsedInBytes / $_.storageAllocatedInBytes) * 100)
        } catch { $UsagePercent = 100 }

        if ($UsagePercent -gt $InputValue) {
            $GBLeft = [math]::Round(($_.storageAllocatedInBytes - $_.storageUsedInBytes) / 1GB)
            [PSCustomObject]@{
                Details = @{
                    Message                 = "$($_.ownerPrincipalName): OneDrive is $UsagePercent% full. OneDrive has $($GBLeft)GB storage left"
                    Owner                   = $_.ownerPrincipalName
                    UsagePercent            = $UsagePercent
                    GBLeft                  = $GBLeft
                    StorageUsedInBytes      = $_.storageUsedInBytes
                    StorageAllocatedInBytes = $_.storageAllocatedInBytes
                    Tenant                  = $TenantFilter
                }
            }
        }

    }

    #If the quota is over the threshold, send an alert
    if ($OverQuota) {
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $OverQuota
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertOnedriveQuota.ps1' 55
#Region './Public/Alerts/Get-CIPPAlertOverusedLicenses.ps1' -1

function Get-CIPPAlertOverusedLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )


    try {
        $LicenseTable = Get-CIPPTable -TableName ExcludedLicenses
        $ExcludedSkuList = Get-CIPPAzDataTableEntity @LicenseTable
        $AlertData = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus' -tenantid $TenantFilter | ForEach-Object {
            $skuid = $_
            foreach ($sku in $skuid) {
                if ($sku.skuId -in $ExcludedSkuList.GUID) { continue }
                $PrettyName = Convert-SKUname -SkuID $sku.skuId
                if (!$PrettyName) { $PrettyName = $sku.skuPartNumber }
                if ($sku.prepaidUnits.enabled - $sku.consumedUnits -lt 0) {
                    [PSCustomObject]@{
                        Message       = "$PrettyName has Overused licenses. Using $($sku.consumedUnits) of $($sku.prepaidUnits.enabled)."
                        LicenseName   = $PrettyName
                        SkuId         = $sku.skuId
                        SkuPartNumber = $sku.skuPartNumber
                        ConsumedUnits = $sku.consumedUnits
                        EnabledUnits  = $sku.prepaidUnits.enabled
                        Tenant        = $TenantFilter
                    }
                }
            }
        }
        if ($AlertData) {
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }

    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Overused Licenses Alert Error occurred: $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertOverusedLicenses.ps1' 45
#Region './Public/Alerts/Get-CIPPAlertQuotaUsed.ps1' -1

function Get-CIPPAlertQuotaUsed {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $AlertData = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/reports/getMailboxUsageDetail(period='D7')?`$format=application/json" -tenantid $TenantFilter
    } catch {
        return
    }
    $OverQuota = $AlertData | ForEach-Object {
        if ([string]::IsNullOrEmpty($_.StorageUsedInBytes) -or [string]::IsNullOrEmpty($_.prohibitSendReceiveQuotaInBytes) -or $_.StorageUsedInBytes -eq 0 -or $_.prohibitSendReceiveQuotaInBytes -eq 0) { return }
        try {
            $PercentLeft = [math]::round(($_.storageUsedInBytes / $_.prohibitSendReceiveQuotaInBytes) * 100)
        } catch { $PercentLeft = 100 }
        try {
            if ([int]$InputValue -gt 0) {
                $Value = [int]$InputValue
            } else {
                $Value = 90
            }
        } catch {
            $Value = 90
        }
        if ($PercentLeft -gt $Value) {
            [PSCustomObject]@{
                Message                         = "$($_.userPrincipalName): Mailbox is more than $($value)% full. Mailbox is $PercentLeft% full"
                Owner                           = $_.userPrincipalName
                RecipientType                   = $_.recipientType
                UsagePercent                    = $PercentLeft
                StorageUsedInBytes              = $_.storageUsedInBytes
                ProhibitSendReceiveQuotaInBytes = $_.prohibitSendReceiveQuotaInBytes
                Tenant                          = $TenantFilter
            }
        }
    }
    Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $OverQuota
}
#EndRegion './Public/Alerts/Get-CIPPAlertQuotaUsed.ps1' 47
#Region './Public/Alerts/Get-CIPPAlertReportOnlyCA.ps1' -1

function Get-CIPPAlertReportOnlyCA {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        # Only consider CA available when a SKU that grants it has enabled seats (> 0)
        $SubscribedSkus = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/subscribedSkus?`$select=prepaidUnits,servicePlans" -tenantid $TenantFilter -ErrorAction Stop
        $CAAvailable = foreach ($sku in $SubscribedSkus) {
            if ([int]$sku.prepaidUnits.enabled -gt 0) { $sku.servicePlans }
        }

        if (('AAD_PREMIUM' -in $CAAvailable.servicePlanName) -or ('AAD_PREMIUM_P2' -in $CAAvailable.servicePlanName)) {
            $CAPolicies = (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/identity/conditionalAccess/policies?$top=999' -tenantid $TenantFilter -ErrorAction Stop)

            # Filter for policies in report-only mode
            $ReportOnlyPolicies = $CAPolicies | Where-Object { $_.state -eq 'enabledForReportingButNotEnforced' }

            if ($ReportOnlyPolicies) {
                $AlertData = foreach ($Policy in $ReportOnlyPolicies) {
                    [PSCustomObject]@{
                        PolicyNames = $Policy.displayName
                        State       = $Policy.state
                        Tenant      = $TenantFilter
                    }
                }
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Report-Only CA Alert: Error occurred: $(Get-NormalizedError -message $_.Exception.message)"
    }

}
#EndRegion './Public/Alerts/Get-CIPPAlertReportOnlyCA.ps1' 43
#Region './Public/Alerts/Get-CIPPAlertRestrictedUsers.ps1' -1

function Get-CIPPAlertRestrictedUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $BlockedUsers = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-BlockedSenderAddress'

        if ($BlockedUsers) {
            $AlertData = foreach ($User in $BlockedUsers) {
                # Parse the reason to make it more readable
                $ReasonParts = $User.Reason -split ';'
                $LimitType = ($ReasonParts | Where-Object { $_ -like 'ExceedingLimitType=*' }) -replace 'ExceedingLimitType=', ''
                $InternalCount = ($ReasonParts | Where-Object { $_ -like 'InternalRecipientCountToday=*' }) -replace 'InternalRecipientCountToday=', ''
                $ExternalCount = ($ReasonParts | Where-Object { $_ -like 'ExternalRecipientCountToday=*' }) -replace 'ExternalRecipientCountToday=', ''

                [PSCustomObject]@{
                    SenderAddress   = $User.SenderAddress
                    Message         = "User $($User.SenderAddress) is restricted from sending email. Block type: $($LimitType ?? 'Unknown'). Created: $($User.CreatedDatetime)"
                    BlockType       = if ($LimitType) { "$LimitType recipient limit exceeded" } else { 'Email sending limit exceeded' }
                    TemporaryBlock  = $User.TemporaryBlock
                    InternalCount   = $InternalCount
                    ExternalCount   = $ExternalCount
                    CreatedDatetime = $User.CreatedDatetime
                    Reason          = $User.Reason
                    Tenant          = $TenantFilter
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get restricted users for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertRestrictedUsers.ps1' 43
#Region './Public/Alerts/Get-CIPPAlertSecDefaultsUpsell.ps1' -1

function Get-CIPPAlertSecDefaultsUpsell {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        try {
            $SecDefaults = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -tenantid $TenantFilter)
            if ($SecDefaults.isEnabled -eq $false -and $SecDefaults.securityDefaultsUpsell.action -in @('autoEnable', 'autoEnabledNotify')) {
                $AlertData = [PSCustomObject]@{
                    Message        = ('Security Defaults will be automatically enabled on {0}' -f $SecDefaults.securityDefaultsUpsell.dueDateTime)
                    EnablementDate = $SecDefaults.securityDefaultsUpsell.dueDateTime
                    Action         = $SecDefaults.securityDefaultsUpsell.action
                    Tenant         = $TenantFilter
                }
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

            }
        } catch {}

    } catch {
        # Error handling
    }
}

#EndRegion './Public/Alerts/Get-CIPPAlertSecDefaultsUpsell.ps1' 34
#Region './Public/Alerts/Get-CIPPAlertSharepointQuota.ps1' -1

function Get-CIPPAlertSharepointQuota {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
        $extraHeaders = @{
            'Accept' = 'application/json'
        }
        $sharepointQuota = (New-GraphGetRequest -extraHeaders $extraHeaders -scope "$($SharePointInfo.AdminUrl)/.default" -tenantid $TenantFilter -uri "$($SharePointInfo.AdminUrl)/_api/StorageQuotas()?api-version=1.3.2")
    } catch {
        return
    }
    if ($sharepointQuota) {
        try {
            if ([int]$InputValue -gt 0) { $Value = [int]$InputValue } else { $Value = 90 }
        } catch {
            $Value = 90
        }
        $UsedStoragePercentage = [int](($sharepointQuota.GeoUsedStorageMB / $sharepointQuota.TenantStorageMB) * 100)
        if ($UsedStoragePercentage -gt $Value) {
            $AlertData = [PSCustomObject]@{
                UsedStoragePercentage = $UsedStoragePercentage
                StorageUsed           = ([math]::Round($sharepointQuota.GeoUsedStorageMB / 1024, 2))
                StorageQuota          = ([math]::Round($sharepointQuota.TenantStorageMB / 1024, 2))
                AlertQuotaThreshold   = $Value
                Tenant                = $TenantFilter
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
        }
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertSharepointQuota.ps1' 41
#Region './Public/Alerts/Get-CIPPAlertSmtpAuthSuccess.ps1' -1

function Get-CIPPAlertSmtpAuthSuccess {
    <#
    .FUNCTIONALITY
        Entrypoint  Check sign-in logs for SMTP AUTH with success status
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        # Graph API endpoint for sign-ins
        $uri = "https://graph.microsoft.com/v1.0/auditLogs/signIns?`$filter=clientAppUsed eq 'SMTP' and status/errorCode eq 0"

        # Call Graph API for the given tenant
        $SignIns = New-GraphGetRequest -uri $uri -tenantid $TenantFilter

        # Select only the properties you care about
        $AlertData = $SignIns.value | Select-Object userPrincipalName, createdDateTime, clientAppUsed, ipAddress, status, @{Name = 'Tenant'; Expression = { $TenantFilter } }

        # Write results into the alert pipeline
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        # Suppress errors if no data returned
        # Uncomment if you want explicit error logging
        # Write-AlertMessage -tenant $($TenantFilter) -message "Failed to query SMTP AUTH sign-ins for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertSmtpAuthSuccess.ps1' 33
#Region './Public/Alerts/Get-CIPPAlertSoftDeletedMailboxes.ps1' -1

function Get-CIPPAlertSoftDeletedMailboxes {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    $Select = 'ExchangeGuid,ArchiveGuid,WhenSoftDeleted,UserPrincipalName,IsInactiveMailbox'

    try {
        $SoftDeletedMailBoxes = New-ExoRequest -tenantid $TenantFilter -cmdlet 'get-mailbox' -cmdParams @{SoftDeletedMailbox = $true } -Select $Select |
            Select-Object ExchangeGuid, ArchiveGuid, WhenSoftDeleted, @{ Name = 'UPN'; Expression = { $_.'UserPrincipalName' } }, IsInactiveMailbox, @{ Name = 'Tenant'; Expression = { $TenantFilter } }

        # Filter out the mailboxes where IsInactiveMailbox is $true
        $AlertData = $SoftDeletedMailBoxes | Where-Object { $_.IsInactiveMailbox -ne $true }

        # Write the alert trace with the filtered data
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Failed to check for soft deleted mailboxes in $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertSoftDeletedMailboxes.ps1' 30
#Region './Public/Alerts/Get-CIPPAlertTERRL.ps1' -1

function Get-CIPPAlertTERRL {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        # Set threshold with fallback to 80%
        $Threshold = if ([string]::IsNullOrWhiteSpace($InputValue)) { 80 } else { [int]$InputValue }

        # Get TERRL status
        $TerrlStatus = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-LimitsEnforcementStatus'

        if ($TerrlStatus) {
            $UsagePercentage = [math]::Round(($TerrlStatus.ObservedValue / $TerrlStatus.Threshold) * 100, 2)

            if ($UsagePercentage -gt $Threshold) {
                $AlertData = [PSCustomObject]@{
                    UsagePercentage    = $UsagePercentage
                    CurrentVolume      = $TerrlStatus.ObservedValue
                    ThresholdLimit     = $TerrlStatus.Threshold
                    EnforcementEnabled = $TerrlStatus.EnforcementEnabled
                    Verdict            = $TerrlStatus.Verdict
                    Message            = 'Tenant is at {0}% of their TERRL limit (using {1} of {2} messages). Tenant Enforcement Status: {3}' -f $UsagePercentage, $TerrlStatus.ObservedValue, $TerrlStatus.Threshold, $TerrlStatus.Verdict
                    Tenant             = $TenantFilter
                }
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Could not get TERRL status for $($TenantFilter): $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertTERRL.ps1' 41
#Region './Public/Alerts/Get-CIPPAlertUnusedLicenses.ps1' -1

function Get-CIPPAlertUnusedLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $LicenseTable = Get-CIPPTable -TableName ExcludedLicenses
        $ExcludedSkuList = Get-CIPPAzDataTableEntity @LicenseTable
        $AlertData = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus' -tenantid $TenantFilter | ForEach-Object {
            $SkuId = $_
            foreach ($sku in $SkuId) {
                if ($sku.skuId -in $ExcludedSkuList.GUID) { continue }
                $PrettyName = Convert-SKUname -SkuID $sku.skuId
                if (!$PrettyName) { $PrettyName = $sku.skuPartNumber }
                if ($sku.prepaidUnits.enabled - $sku.consumedUnits -gt 0) {
                    [PSCustomObject]@{
                        Message       = "$PrettyName has unused licenses. Using $($sku.consumedUnits) of $($sku.prepaidUnits.enabled)."
                        LicenseName   = $PrettyName
                        SkuId         = $sku.skuId
                        SkuPartNumber = $sku.skuPartNumber
                        ConsumedUnits = $sku.consumedUnits
                        EnabledUnits  = $sku.prepaidUnits.enabled
                        Tenant        = $TenantFilter
                    }
                }
            }
        }
        Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
    } catch {
        Write-AlertMessage -tenant $($TenantFilter) -message "Unused Licenses Alert Error occurred: $(Get-NormalizedError -message $_.Exception.message)"
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertUnusedLicenses.ps1' 41
#Region './Public/Alerts/Get-CIPPAlertVppTokenExpiry.ps1' -1

function Get-CIPPAlertVppTokenExpiry {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )
    try {
        try {
            $VppTokens = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceAppManagement/vppTokens' -tenantid $TenantFilter
            $AlertData = foreach ($Vpp in $VppTokens) {
                if ($Vpp.state -ne 'valid') {
                    $Message = 'Apple Volume Purchase Program Token is not valid, new token required'
                    $Vpp | Select-Object -Property organizationName, appleId, vppTokenAccountType, @{Name = 'Message'; Expression = { $Message } }, @{Name = 'Tenant'; Expression = { $TenantFilter } }
                } elseif ($Vpp.expirationDateTime -lt (Get-Date).AddDays(30).ToUniversalTime() -and $Vpp.expirationDateTime -gt (Get-Date).AddDays(-7).ToUniversalTime()) {
                    $Message = 'Apple Volume Purchase Program token expiring on {0}' -f $Vpp.expirationDateTime
                    $Vpp | Select-Object -Property organizationName, appleId, vppTokenAccountType, @{Name = 'Message'; Expression = { $Message } }, @{Name = 'Tenant'; Expression = { $TenantFilter } }
                }
            }
            Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData

        } catch {}

    } catch {
        # Error handling
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertVppTokenExpiry.ps1' 33
#Region './Public/Alerts/Get-CIPPAlertVulnerabilities.ps1' -1

function Get-CIPPAlertVulnerabilities {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [Alias('input')]
        $InputValue,
        $TenantFilter
    )

    try {
        $VulnerabilityRequest = New-GraphGetRequest -tenantid $TenantFilter -uri "https://api.securitycenter.microsoft.com/api/machines/SoftwareVulnerabilitiesByMachine?`$top=999&`$filter=cveId ne null" -scope 'https://api.securitycenter.microsoft.com/.default'

        if ($VulnerabilityRequest) {
            $AlertData = [System.Collections.Generic.List[PSCustomObject]]::new()

            # Group by CVE ID and create objects for each vulnerability
            $VulnerabilityGroups = $VulnerabilityRequest | Where-Object { $_.cveId } | Group-Object cveId

            foreach ($Group in $VulnerabilityGroups) {
                $FirstVuln = $Group.Group | Sort-Object firstSeenTimestamp | Select-Object -First 1
                $HoursOld = [math]::Round(((Get-Date) - [datetime]$FirstVuln.firstSeenTimestamp).TotalHours)

                # Skip if vulnerability is not old enough
                if ($HoursOld -lt [int]$InputValue) {
                    continue
                }

                $DaysOld = [math]::Round(((Get-Date) - [datetime]$FirstVuln.firstSeenTimestamp).TotalDays)
                $AffectedDevices = ($Group.Group | Select-Object -ExpandProperty deviceName -Unique) -join ', '

                $VulnerabilityAlert = [PSCustomObject]@{
                    CVE                  = $Group.Name
                    Severity             = $FirstVuln.vulnerabilitySeverityLevel
                    FirstSeenTimestamp   = $FirstVuln.firstSeenTimestamp
                    LastSeenTimestamp    = $FirstVuln.lastSeenTimestamp
                    DaysOld              = $DaysOld
                    HoursOld             = $HoursOld
                    AffectedDeviceCount  = $Group.Count
                    AffectedDevices      = $AffectedDevices
                    SoftwareName         = $FirstVuln.softwareName
                    SoftwareVendor       = $FirstVuln.softwareVendor
                    SoftwareVersion      = $FirstVuln.softwareVersion
                    CVSSScore            = $FirstVuln.cvssScore
                    ExploitabilityLevel  = $FirstVuln.exploitabilityLevel
                    RecommendedUpdate    = $FirstVuln.recommendedSecurityUpdate
                    RecommendedUpdateId  = $FirstVuln.recommendedSecurityUpdateId
                    RecommendedUpdateUrl = $FirstVuln.recommendedSecurityUpdateUrl
                    Tenant               = $TenantFilter
                }
                $AlertData.Add($VulnerabilityAlert)
            }

            # Only send alert if we have vulnerabilities that meet the criteria
            if ($AlertData.Count -gt 0) {
                Write-AlertTrace -cmdletName $MyInvocation.MyCommand -tenantFilter $TenantFilter -data $AlertData
            }
        }
    } catch {
        Write-LogMessage -message "Failed to check vulnerabilities: $($_.exception.message)" -API 'Vulnerability Alerts' -tenant $TenantFilter -sev Error
    }
}
#EndRegion './Public/Alerts/Get-CIPPAlertVulnerabilities.ps1' 66
#Region './Public/Assert-CippVersion.ps1' -1

function Assert-CippVersion {
    <#
    .SYNOPSIS
    Compare the local version of CIPP with the latest version.

    .DESCRIPTION
    Retrieves the local version of CIPP and compares it with the latest version in GitHub.

    .PARAMETER CIPPVersion
    Local version of CIPP frontend

    #>
    Param($CIPPVersion)
    $APIVersion = (Get-Content 'version_latest.txt' -Raw).trim()

    $RemoteAPIVersion = (Invoke-RestMethod -Uri 'https://raw.githubusercontent.com/KelvinTegelaar/CIPP-API/master/version_latest.txt').trim()
    $RemoteCIPPVersion = (Invoke-RestMethod -Uri 'https://raw.githubusercontent.com/KelvinTegelaar/CIPP/main/public/version.json').version

    [PSCustomObject]@{
        LocalCIPPVersion     = $CIPPVersion
        RemoteCIPPVersion    = $RemoteCIPPVersion
        LocalCIPPAPIVersion  = $APIVersion
        RemoteCIPPAPIVersion = $RemoteAPIVersion
        OutOfDateCIPP        = ([semver]$RemoteCIPPVersion -gt [semver]$CIPPVersion)
        OutOfDateCIPPAPI     = ([semver]$RemoteAPIVersion -gt [semver]$APIVersion)
    }
}
#EndRegion './Public/Assert-CippVersion.ps1' 28
#Region './Public/AuditLogs/Get-CippAuditLogSearches.ps1' -1

function Get-CippAuditLogSearches {
    <#
    .SYNOPSIS
        Get the available audit log searches
    .DESCRIPTION
        Query the Graph API for available audit log searches.
    .PARAMETER TenantFilter
        The tenant to filter on.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter()]
        [switch]$ReadyToProcess
    )
    $AuditLogSearchesTable = Get-CippTable -TableName 'AuditLogSearches'
    if ($ReadyToProcess.IsPresent) {
        $15MinutesAgo = (Get-Date).AddMinutes(-15).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        $1DayAgo = (Get-Date).AddDays(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        $PendingQueries = Get-CIPPAzDataTableEntity @AuditLogSearchesTable -Filter "PartitionKey eq 'Search' and Tenant eq '$TenantFilter' and (CippStatus eq 'Pending' or (CippStatus eq 'Processing' and Timestamp le datetime'$15MinutesAgo')) and Timestamp ge datetime'$1DayAgo'" | Sort-Object Timestamp
    } else {
        $7DaysAgo = (Get-Date).AddDays(-7).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        $PendingQueries = Get-CIPPAzDataTableEntity @AuditLogSearchesTable -Filter "Tenant eq '$TenantFilter' and Timestamp ge datetime'$7DaysAgo'"
    }

    $BulkRequests = foreach ($PendingQuery in $PendingQueries) {
        @{
            id     = $PendingQuery.RowKey
            url    = 'security/auditLog/queries/' + $PendingQuery.RowKey
            method = 'GET'
        }
    }
    if ($BulkRequests.Count -eq 0) {
        return @()
    }
    $Queries = New-GraphBulkRequest -Requests @($BulkRequests) -AsApp $true -TenantId $TenantFilter | Select-Object -ExpandProperty body

    if ($ReadyToProcess.IsPresent) {
        $Queries = $Queries | Where-Object { $PendingQueries.RowKey -contains $_.id -and $_.status -eq 'succeeded' }
    }

    return $Queries
}
#EndRegion './Public/AuditLogs/Get-CippAuditLogSearches.ps1' 44
#Region './Public/AuditLogs/Get-CippAuditLogSearchResults.ps1' -1

function Get-CippAuditLogSearchResults {
    <#
    .SYNOPSIS
        Get the results of an audit log search
    .DESCRIPTION
        Get the results of an audit log search from the Graph API
    .PARAMETER TenantFilter
        The tenant to filter on.
    .PARAMETER QueryId
        The ID of the query to get the results for.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [Alias('id')]
        [string]$QueryId,
        [switch]$CountOnly
    )

    process {
        $GraphRequest = @{
            Uri      = ('https://graph.microsoft.com/beta/security/auditLog/queries/{0}/records?$top=999&$count=true' -f $QueryId)
            AsApp    = $true
            tenantid = $TenantFilter
        }
        if ($CountOnly.IsPresent) {
            $GraphRequest.CountOnly = $true
        }

        New-GraphGetRequest @GraphRequest -ErrorAction Stop | Sort-Object -Property createdDateTime -Descending
    }
}
#EndRegion './Public/AuditLogs/Get-CippAuditLogSearchResults.ps1' 34
#Region './Public/AuditLogs/Get-CippLastAuditLogSearch.ps1' -1

function Get-CippLastAuditLogSearch {
    <#
    .SYNOPSIS
        Get the last audit log search
    .DESCRIPTION
        Query the Graph API for the last audit log search.
    .PARAMETER TenantFilter
        The tenant to filter on.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter
    )

    $Table = Get-CIPPTable -TableName AuditLogSearches
    $LastHour = (Get-Date).AddHours(-1).ToString('yyyy-MM-ddTHH:mm:ssZ')
    $LastSearch = Get-AzDataTableEntity @Table -Filter "Tenant eq '$TenantFilter' and Timestamp ge datetime'$LastHour'" | Sort-Object Timestamp -Descending | Select-Object -First 1
    return $LastSearch
}
#EndRegion './Public/AuditLogs/Get-CippLastAuditLogSearch.ps1' 20
#Region './Public/AuditLogs/New-CippAuditLogSearch.ps1' -1

function New-CippAuditLogSearch {
    <#
    .SYNOPSIS
        Create a new audit log search
    .DESCRIPTION
        Create a new audit log search in Microsoft Graph Security API
    .PARAMETER DisplayName
        The display name of the audit log search. Default is 'CIPP Audit Search - ' + current date and time.
    .PARAMETER TenantFilter
        The tenant to filter on.
    .PARAMETER StartTime
        The start time to filter on.
    .PARAMETER EndTime
        The end time to filter on.
    .PARAMETER RecordTypeFilters
        The record types to filter on.
    .PARAMETER KeywordFilter
        The keyword to filter on.
    .PARAMETER ServiceFilter
        The service to filter on.
    .PARAMETER OperationsFilters
        The operations to filter on.
    .PARAMETER UserPrincipalNameFilters
        The user principal names to filter on.
    .PARAMETER IPAddressFilter
        The IP addresses to filter on.
    .PARAMETER ObjectIdFilters
        The object IDs to filter on.
    .PARAMETER AdministrativeUnitFilters
        The administrative units to filter on.
    .PARAMETER ProcessLogs
        Store the search in the CIPP AuditLogSearches table for alert processing.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter()]
        [string]$DisplayName = 'CIPP Audit Search - ' + (Get-Date).ToString('yyyy-MM-dd HH:mm:ss'),
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [datetime]$StartTime,
        [Parameter(Mandatory = $true)]
        [datetime]$EndTime,
        [Parameter()]
        [ValidateSet(
            'exchangeAdmin', 'exchangeItem', 'exchangeItemGroup', 'sharePoint', 'syntheticProbe', 'sharePointFileOperation',
            'oneDrive', 'azureActiveDirectory', 'azureActiveDirectoryAccountLogon', 'dataCenterSecurityCmdlet',
            'complianceDLPSharePoint', 'sway', 'complianceDLPExchange', 'sharePointSharingOperation',
            'azureActiveDirectoryStsLogon', 'skypeForBusinessPSTNUsage', 'skypeForBusinessUsersBlocked',
            'securityComplianceCenterEOPCmdlet', 'exchangeAggregatedOperation', 'powerBIAudit', 'crm', 'yammer',
            'skypeForBusinessCmdlets', 'discovery', 'microsoftTeams', 'threatIntelligence', 'mailSubmission',
            'microsoftFlow', 'aeD', 'microsoftStream', 'complianceDLPSharePointClassification', 'threatFinder',
            'project', 'sharePointListOperation', 'sharePointCommentOperation', 'dataGovernance', 'kaizala',
            'securityComplianceAlerts', 'threatIntelligenceUrl', 'securityComplianceInsights', 'mipLabel',
            'workplaceAnalytics', 'powerAppsApp', 'powerAppsPlan', 'threatIntelligenceAtpContent', 'labelContentExplorer',
            'teamsHealthcare', 'exchangeItemAggregated', 'hygieneEvent', 'dataInsightsRestApiAudit',
            'informationBarrierPolicyApplication', 'sharePointListItemOperation', 'sharePointContentTypeOperation',
            'sharePointFieldOperation', 'microsoftTeamsAdmin', 'hrSignal', 'microsoftTeamsDevice', 'microsoftTeamsAnalytics',
            'informationWorkerProtection', 'campaign', 'dlpEndpoint', 'airInvestigation', 'quarantine', 'microsoftForms',
            'applicationAudit', 'complianceSupervisionExchange', 'customerKeyServiceEncryption', 'officeNative',
            'mipAutoLabelSharePointItem', 'mipAutoLabelSharePointPolicyLocation', 'microsoftTeamsShifts', 'secureScore',
            'mipAutoLabelExchangeItem', 'cortanaBriefing', 'search', 'wdatpAlerts', 'powerPlatformAdminDlp',
            'powerPlatformAdminEnvironment', 'mdatpAudit', 'sensitivityLabelPolicyMatch', 'sensitivityLabelAction',
            'sensitivityLabeledFileAction', 'attackSim', 'airManualInvestigation', 'securityComplianceRBAC',
            'userTraining', 'airAdminActionInvestigation', 'mstic', 'physicalBadgingSignal', 'teamsEasyApprovals',
            'aipDiscover', 'aipSensitivityLabelAction', 'aipProtectionAction', 'aipFileDeleted', 'aipHeartBeat',
            'mcasAlerts', 'onPremisesFileShareScannerDlp', 'onPremisesSharePointScannerDlp', 'exchangeSearch',
            'sharePointSearch', 'privacyDataMinimization', 'labelAnalyticsAggregate', 'myAnalyticsSettings',
            'securityComplianceUserChange', 'complianceDLPExchangeClassification', 'complianceDLPEndpoint',
            'mipExactDataMatch', 'msdeResponseActions', 'msdeGeneralSettings', 'msdeIndicatorsSettings',
            'ms365DCustomDetection', 'msdeRolesSettings', 'mapgAlerts', 'mapgPolicy', 'mapgRemediation',
            'privacyRemediationAction', 'privacyDigestEmail', 'mipAutoLabelSimulationProgress',
            'mipAutoLabelSimulationCompletion', 'mipAutoLabelProgressFeedback', 'dlpSensitiveInformationType',
            'mipAutoLabelSimulationStatistics', 'largeContentMetadata', 'microsoft365Group', 'cdpMlInferencingResult',
            'filteringMailMetadata', 'cdpClassificationMailItem', 'cdpClassificationDocument', 'officeScriptsRunAction',
            'filteringPostMailDeliveryAction', 'cdpUnifiedFeedback', 'tenantAllowBlockList', 'consumptionResource',
            'healthcareSignal', 'dlpImportResult', 'cdpCompliancePolicyExecution', 'multiStageDisposition',
            'privacyDataMatch', 'filteringDocMetadata', 'filteringEmailFeatures', 'powerBIDlp', 'filteringUrlInfo',
            'filteringAttachmentInfo', 'coreReportingSettings', 'complianceConnector',
            'powerPlatformLockboxResourceAccessRequest', 'powerPlatformLockboxResourceCommand',
            'cdpPredictiveCodingLabel', 'cdpCompliancePolicyUserFeedback', 'webpageActivityEndpoint', 'omePortal',
            'cmImprovementActionChange', 'filteringUrlClick', 'mipLabelAnalyticsAuditRecord', 'filteringEntityEvent',
            'filteringRuleHits', 'filteringMailSubmission', 'labelExplorer', 'microsoftManagedServicePlatform',
            'powerPlatformServiceActivity', 'scorePlatformGenericAuditRecord', 'filteringTimeTravelDocMetadata', 'alert',
            'alertStatus', 'alertIncident', 'incidentStatus', 'case', 'caseInvestigation', 'recordsManagement',
            'privacyRemediation', 'dataShareOperation', 'cdpDlpSensitive', 'ehrConnector', 'filteringMailGradingResult',
            'publicFolder', 'privacyTenantAuditHistoryRecord', 'aipScannerDiscoverEvent', 'eduDataLakeDownloadOperation',
            'm365ComplianceConnector', 'microsoftGraphDataConnectOperation', 'microsoftPurview',
            'filteringEmailContentFeatures', 'powerPagesSite', 'powerAppsResource', 'plannerPlan', 'plannerCopyPlan',
            'plannerTask', 'plannerRoster', 'plannerPlanList', 'plannerTaskList', 'plannerTenantSettings',
            'projectForTheWebProject', 'projectForTheWebTask', 'projectForTheWebRoadmap', 'projectForTheWebRoadmapItem',
            'projectForTheWebProjectSettings', 'projectForTheWebRoadmapSettings', 'quarantineMetadata',
            'microsoftTodoAudit', 'timeTravelFilteringDocMetadata', 'teamsQuarantineMetadata',
            'sharePointAppPermissionOperation', 'microsoftTeamsSensitivityLabelAction', 'filteringTeamsMetadata',
            'filteringTeamsUrlInfo', 'filteringTeamsPostDeliveryAction', 'mdcAssessments',
            'mdcRegulatoryComplianceStandards', 'mdcRegulatoryComplianceControls', 'mdcRegulatoryComplianceAssessments',
            'mdcSecurityConnectors', 'mdaDataSecuritySignal', 'vivaGoals', 'filteringRuntimeInfo', 'attackSimAdmin',
            'microsoftGraphDataConnectConsent', 'filteringAtpDetonationInfo', 'privacyPortal', 'managedTenants',
            'unifiedSimulationMatchedItem', 'unifiedSimulationSummary', 'updateQuarantineMetadata', 'ms365DSuppressionRule',
            'purviewDataMapOperation', 'filteringUrlPostClickAction', 'irmUserDefinedDetectionSignal', 'teamsUpdates',
            'plannerRosterSensitivityLabel', 'ms365DIncident', 'filteringDelistingMetadata',
            'complianceDLPSharePointClassificationExtended', 'microsoftDefenderForIdentityAudit',
            'supervisoryReviewDayXInsight', 'defenderExpertsforXDRAdmin', 'cdpEdgeBlockedMessage', 'hostedRpa',
            'cdpContentExplorerAggregateRecord', 'cdpHygieneAttachmentInfo', 'cdpHygieneSummary',
            'cdpPostMailDeliveryAction', 'cdpEmailFeatures', 'cdpHygieneUrlInfo', 'cdpUrlClick',
            'cdpPackageManagerHygieneEvent', 'filteringDocScan', 'timeTravelFilteringDocScan', 'mapgOnboard'
        )]
        [string[]]$RecordTypeFilters,
        [Parameter()]
        [string]$KeywordFilters,
        [Parameter()]
        [string[]]$ServiceFilters,
        [Parameter()]
        [string[]]$OperationsFilters,
        [Parameter()]
        [string[]]$UserPrincipalNameFilters,
        [Parameter()]
        [string[]]$IPAddressFilters,
        [Parameter()]
        [string[]]$ObjectIdFilters,
        [Parameter()]
        [string[]]$AdministrativeUnitFilters,
        [Parameter()]
        [switch]$ProcessLogs
    )

    $SearchParams = @{
        displayName         = $DisplayName
        filterStartDateTime = $StartTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss')
        filterEndDateTime   = $EndTime.AddHours(1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss')
    }
    if ($OperationsFilters) {
        $SearchParams.operationsFilters = $OperationsFilters
    }
    if ($RecordTypeFilters) {
        $SearchParams.recordTypeFilters = @($RecordTypeFilters)
    }
    if ($KeywordFilters) {
        $SearchParams.keywordFilters = $KeywordFilters
    }
    if ($ServiceFilters) {
        $SearchParams.serviceFilters = $ServiceFilters
    }
    if ($UserPrincipalNameFilters) {
        $SearchParams.userPrincipalNameFilters = @($UserPrincipalNameFilters)
    }
    if ($IPAddressFilters) {
        $SearchParams.ipAddressFilters = @($IPAddressFilters)
    }
    if ($ObjectIdFilters) {
        $SearchParams.objectIdFilters = @($ObjectIdFilters)
    }
    if ($AdministrativeUnitFilters) {
        $SearchParams.administrativeUnitFilters = @($AdministrativeUnitFilters)
    }

    if ($PSCmdlet.ShouldProcess('Create a new audit log search for tenant ' + $TenantFilter)) {
        $Query = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/security/auditLog/queries' -body ($SearchParams | ConvertTo-Json -Compress) -tenantid $TenantFilter -AsApp $true


        if ($ProcessLogs.IsPresent -and $Query.id) {
            $CippStatus = 'Pending'
        } else {
            $CippStatus = 'N/A'
        }

        $Entity = [PSCustomObject]@{
            PartitionKey = [string]'Search'
            RowKey       = [string]$Query.id
            Tenant       = [string]$TenantFilter
            DisplayName  = [string]$DisplayName
            StartTime    = [datetime]$StartTime.ToUniversalTime()
            EndTime      = [datetime]$EndTime.ToUniversalTime()
            Query        = [string]($Query | ConvertTo-Json -Compress)
            CippStatus   = [string]$CippStatus
        }
        $Table = Get-CIPPTable -TableName 'AuditLogSearches'
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null

        return $Query
    }
}
#EndRegion './Public/AuditLogs/New-CippAuditLogSearch.ps1' 183
#Region './Public/AuditLogs/New-CIPPAuditLogSearchResultsCache.ps1' -1

function New-CIPPAuditLogSearchResultsCache {
    <#
    .SYNOPSIS
        Cache audit log search results for more efficient processing
    .DESCRIPTION
        Retrieves audit log searches for a tenant, processes them, and stores the results in a cache table.
        Also tracks performance metrics for download and processing times.
    .PARAMETER TenantFilter
        The tenant to filter on.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [string]$SearchId
    )
    try {
        $FailedDownloadsTable = Get-CippTable -TableName 'FailedAuditLogDownloads'
        $fourHoursAgo = (Get-Date).AddHours(-4).ToUniversalTime()
        $failedEntity = Get-CIPPAzDataTableEntity @FailedDownloadsTable -Filter "PartitionKey eq '$TenantFilter' and SearchId eq '$SearchId' and Timestamp ge datetime'$($fourHoursAgo.ToString('yyyy-MM-ddTHH:mm:ssZ'))'"

        if ($failedEntity) {
            $message = "Skipping search ID: $SearchId for tenant: $TenantFilter - Previous attempt failed within the last 4 hours"
            Write-LogMessage -API 'AuditLog' -tenant $TenantFilter -message $message -Sev 'Info'
            Write-Information $message
            exit 0
        }
    } catch {
        Write-Information "Error checking for failed downloads: $($_.Exception.Message)"
    }

    try {
        Write-Information "Starting audit log cache process for tenant: $TenantFilter"
        $CacheWebhooksTable = Get-CippTable -TableName 'CacheWebhooks'
        $CacheWebhookStatsTable = Get-CippTable -TableName 'CacheWebhookStats'
        # Check if we haven't already downloaded this search by checking the cache table
        $searchEntity = Get-CIPPAzDataTableEntity @CacheWebhooksTable -Filter "PartitionKey eq '$TenantFilter' and SearchId eq '$SearchId'"
        if ($searchEntity) {
            Write-Information "Search ID: $SearchId already cached for tenant: $TenantFilter"
            exit 0
        }

        # Record this attempt in the FailedAuditLogDownloads table BEFORE starting the download
        # This way, if the function is killed before completion, the record will remain
        try {
            $FailedDownloadsTable = Get-CippTable -TableName 'FailedAuditLogDownloads'
            $attemptId = [guid]::NewGuid().ToString()
            $failedEntity = @{
                RowKey       = $attemptId
                PartitionKey = $TenantFilter
                SearchId     = $SearchId
                ErrorMessage = 'Download attempt in progress'
            }
            Add-CIPPAzDataTableEntity @FailedDownloadsTable -Entity $failedEntity -Force
            Write-Information "Recorded download attempt for search ID: $SearchId, tenant: $TenantFilter"
        } catch {
            Write-Information "Failed to record download attempt: $($_.Exception.Message)"
        }

        $downloadStartTime = Get-Date
        try {
            Write-Information "Processing search ID: $($SearchId) for tenant: $TenantFilter"
            $searchResults = Get-CippAuditLogSearchResults -TenantFilter $TenantFilter -QueryId $SearchId
            foreach ($searchResult in $searchResults) {
                $cacheEntity = @{
                    RowKey       = $searchResult.id
                    PartitionKey = $TenantFilter
                    SearchId     = $SearchId
                    JSON         = [string]($searchResult | ConvertTo-Json -Depth 10)
                }
                Add-CIPPAzDataTableEntity @CacheWebhooksTable -Entity $cacheEntity -Force
            }
            Write-Information "Successfully cached search ID: $($SearchId) for tenant: $TenantFilter"
            try {
                $FailedDownloadsTable = Get-CippTable -TableName 'FailedAuditLogDownloads'
                $failedEntities = Get-CIPPAzDataTableEntity @FailedDownloadsTable -Filter "PartitionKey eq '$TenantFilter' and SearchId eq '$SearchId'"
                if ($failedEntities) {
                    Remove-AzDataTableEntity @FailedDownloadsTable -Entity $failedEntities -Force
                    Write-Information "Removed failed download records for search ID: $SearchId, tenant: $TenantFilter"
                }
            } catch {
                Write-Information "Failed to remove download attempt record: $($_.Exception.Message)"
            }
        } catch {
            throw $_
        }

        $downloadEndTime = Get-Date
        $downloadSeconds = ($downloadEndTime - $downloadStartTime).TotalSeconds

        $statsEntity = @{
            RowKey       = $TenantFilter
            PartitionKey = 'Stats'
            DownloadSecs = [string]$downloadSeconds
            SearchCount  = [string]($searchResults ? $searchResults.Count : 0)
        }
        Add-CIPPAzDataTableEntity @CacheWebhookStatsTable -Entity $statsEntity -Force
        Write-Information "Completed audit log cache process for tenant: $TenantFilter. Download time: $downloadSeconds seconds"
        return ($searchResults ? $searchResults.Count : 0)
    } catch {
        Write-Information "Error in New-CIPPAuditLogSearchResultsCache for tenant: $TenantFilter. Error: $($_.Exception.Message)"
        throw $_
    }
}
#EndRegion './Public/AuditLogs/New-CIPPAuditLogSearchResultsCache.ps1' 104
#Region './Public/AuditLogs/Remove-CippAuditLogSearch.ps1' -1

function Remove-CippAuditLogSearch {
    <#
    .SYNOPSIS
        Get the results of an audit log search
    .DESCRIPTION
        Get the results of an audit log search from the Graph API
    .PARAMETER TenantFilter
        The tenant to filter on.
    .PARAMETER QueryId
        The ID of the query to get the results for.
    #>
    param (
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [Alias('id')]
        [string]$QueryId
    )

    process {
        New-GraphPostRequest -type DELETE -body '{}' -uri ('https://graph.microsoft.com/beta/security/auditLog/queries/{0}' -f $QueryId) -AsApp $true -tenantid $TenantFilter
    }
}
#EndRegion './Public/AuditLogs/Remove-CippAuditLogSearch.ps1' 24
#Region './Public/Authentication/Get-CIPPAccessRole.ps1' -1

function Get-CIPPAccessRole {
    <#
    .SYNOPSIS
    Get the access role for the current user

    .DESCRIPTION
    Get the access role for the current user

    .PARAMETER TenantID
    The tenant ID to check the access role for

    .EXAMPLE
    Get-CippAccessRole -UserId $UserId

    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param($Request, $Headers)

    $Headers = $Request.Headers ?? $Headers

    $CacheAccessUserRoleTable = Get-CIPPTable -tablename 'cacheAccessUserRoles'

    $SwaCreds = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json)
    $SwaRoles = $SwaCreds.userRoles
    $Username = $SwaCreds.userDetails

    $CachedRoles = Get-CIPPAzDataTableEntity @CacheAccessUserRoleTable -Filter "PartitionKey eq 'AccessUser' and RowKey eq '$Username'" | Select-Object -ExpandProperty Role | ConvertFrom-Json

    Write-Information "SWA Roles: $($SwaRoles -join ', ')"
    Write-Information "Cached Roles: $($CachedRoles -join ', ')"

    # Combine SWA roles and cached roles into a single deduplicated list
    $AllRoles = [System.Collections.Generic.List[string]]::new()

    foreach ($Role in $SwaRoles) {
        if (-not $AllRoles.Contains($Role)) {
            $AllRoles.Add($Role)
        }
    }
    foreach ($Role in $CachedRoles) {
        if (-not $AllRoles.Contains($Role)) {
            $AllRoles.Add($Role)
        }
    }
    $CombinedRoles = $AllRoles | Select-Object -Unique

    # For debugging
    Write-Information "Combined Roles: $($CombinedRoles -join ', ')"
    return $CombinedRoles
}
#EndRegion './Public/Authentication/Get-CIPPAccessRole.ps1' 53
#Region './Public/Authentication/Get-CippAllowedPermissions.ps1' -1

function Get-CippAllowedPermissions {
    <#
    .SYNOPSIS
        Retrieves the allowed permissions for the current user.

    .DESCRIPTION
        This function retrieves the allowed permissions for the current user based on their role and the configured permissions in the CIPP system.
        For admin/superadmin users, permissions are computed from base role include/exclude rules.
        For editor/readonly users, permissions start from base role and are restricted by custom roles.

    .PARAMETER UserRoles
        Array of user roles to compute permissions for.

    .OUTPUTS
        Returns a list of allowed permissions for the current user.
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string[]]$UserRoles
    )

    # Get all available permissions and base roles configuration

    $CIPPCoreModuleRoot = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $CIPPRoot = (Get-Item $CIPPCoreModuleRoot).Parent.Parent
    $Version = (Get-Content -Path $CIPPRoot\version_latest.txt).trim()
    $BaseRoles = Get-Content -Path $CIPPRoot\Config\cipp-roles.json | ConvertFrom-Json
    $DefaultRoles = @('superadmin', 'admin', 'editor', 'readonly', 'anonymous', 'authenticated')

    $AllPermissionCacheTable = Get-CIPPTable -tablename 'cachehttppermissions'
    $AllPermissionsRow = Get-CIPPAzDataTableEntity @AllPermissionCacheTable -Filter "PartitionKey eq 'HttpFunctions' and RowKey eq 'HttpFunctions' and Version eq '$($Version)'"

    if (-not $AllPermissionsRow) {
        $AllPermissions = Get-CIPPHttpFunctions -ByRole | Select-Object -ExpandProperty Permission
        $Entity = @{
            PartitionKey = 'HttpFunctions'
            RowKey       = 'HttpFunctions'
            Version      = [string]$Version
            Permissions  = [string]($AllPermissions | ConvertTo-Json -Compress)
        }
        Add-CIPPAzDataTableEntity @AllPermissionCacheTable -Entity $Entity -Force
    } else {
        $AllPermissions = $AllPermissionsRow.Permissions | ConvertFrom-Json
    }

    $AllowedPermissions = [System.Collections.Generic.List[string]]::new()

    # Determine user's primary base role (highest priority first)
    $BaseRole = $null
    $PrimaryRole = $null

    if ($UserRoles -contains 'superadmin') {
        $PrimaryRole = 'superadmin'
    } elseif ($UserRoles -contains 'admin') {
        $PrimaryRole = 'admin'
    } elseif ($UserRoles -contains 'editor') {
        $PrimaryRole = 'editor'
    } elseif ($UserRoles -contains 'readonly') {
        $PrimaryRole = 'readonly'
    }

    if ($PrimaryRole) {
        $BaseRole = $BaseRoles.PSObject.Properties | Where-Object { $_.Name -eq $PrimaryRole } | Select-Object -First 1
    }

    # Get custom roles (non-default roles)
    $CustomRoles = $UserRoles | Where-Object { $DefaultRoles -notcontains $_ }

    # For admin and superadmin: Compute permissions from base role include/exclude rules
    if ($PrimaryRole -in @('admin', 'superadmin')) {

        if ($BaseRole) {
            # Start with all permissions and apply include/exclude rules
            $BasePermissions = [System.Collections.Generic.List[string]]::new()

            # Apply include rules
            foreach ($Include in $BaseRole.Value.include) {
                $MatchingPermissions = $AllPermissions | Where-Object { $_ -like $Include }
                foreach ($Permission in $MatchingPermissions) {
                    if ($BasePermissions -notcontains $Permission) {
                        $BasePermissions.Add($Permission)
                    }
                }
            }

            # Apply exclude rules
            foreach ($Exclude in $BaseRole.Value.exclude) {
                $ExcludedPermissions = $BasePermissions | Where-Object { $_ -like $Exclude }
                foreach ($Permission in $ExcludedPermissions) {
                    $BasePermissions.Remove($Permission) | Out-Null
                }
            }

            foreach ($Permission in $BasePermissions) {
                $AllowedPermissions.Add($Permission)
            }
        }
    }
    # For editor and readonly: Start with base role permissions and restrict with custom roles
    elseif ($PrimaryRole -in @('editor', 'readonly')) {
        Write-Information "Computing permissions for $PrimaryRole with custom role restrictions"

        if ($BaseRole) {
            # Get base role permissions first
            $BasePermissions = [System.Collections.Generic.List[string]]::new()

            # Apply include rules from base role
            foreach ($Include in $BaseRole.Value.include) {
                $MatchingPermissions = $AllPermissions | Where-Object { $_ -like $Include }
                foreach ($Permission in $MatchingPermissions) {
                    if ($BasePermissions -notcontains $Permission) {
                        $BasePermissions.Add($Permission)
                    }
                }
            }

            # Apply exclude rules from base role
            foreach ($Exclude in $BaseRole.Value.exclude) {
                $ExcludedPermissions = $BasePermissions | Where-Object { $_ -like $Exclude }
                foreach ($Permission in $ExcludedPermissions) {
                    $BasePermissions.Remove($Permission) | Out-Null
                }
            }

            # If custom roles exist, intersect with custom role permissions (restriction)
            if ($CustomRoles.Count -gt 0) {
                $CustomRolePermissions = [System.Collections.Generic.List[string]]::new()

                foreach ($CustomRole in $CustomRoles) {
                    try {
                        $RolePermissions = Get-CIPPRolePermissions -RoleName $CustomRole
                        foreach ($Permission in $RolePermissions.Permissions) {
                            if ($null -ne $Permission -and $Permission -is [string] -and $CustomRolePermissions -notcontains $Permission) {
                                $CustomRolePermissions.Add($Permission)
                            }
                        }
                    } catch {
                        Write-Warning "Failed to get permissions for custom role '$CustomRole': $($_.Exception.Message)"
                    }
                }

                # Restrict base permissions to only those allowed by custom roles
                # Include Read permissions when ReadWrite permissions are present
                $RestrictedPermissions = $BasePermissions | Where-Object {
                    $Permission = $_
                    if ($CustomRolePermissions -contains $Permission) {
                        $true
                    } elseif ($Permission -match 'Read$') {
                        # Check if there's a corresponding ReadWrite permission
                        $ReadWritePermission = $Permission -replace 'Read', 'ReadWrite'
                        $CustomRolePermissions -contains $ReadWritePermission
                    } else {
                        $false
                    }
                }
                foreach ($Permission in $RestrictedPermissions) {
                    if ($null -ne $Permission -and $Permission -is [string]) {
                        $AllowedPermissions.Add($Permission)
                    }
                }
            } else {
                # No custom roles, use base role permissions
                foreach ($Permission in $BasePermissions) {
                    if ($null -ne $Permission -and $Permission -is [string]) {
                        $AllowedPermissions.Add($Permission)
                    }
                }
            }
        }
    }
    # Handle users with only custom roles (no base role)
    elseif ($CustomRoles.Count -gt 0) {
        foreach ($CustomRole in $CustomRoles) {
            try {
                $RolePermissions = Get-CIPPRolePermissions -RoleName $CustomRole
                foreach ($Permission in $RolePermissions.Permissions) {
                    if ($null -ne $Permission -and $Permission -is [string] -and $AllowedPermissions -notcontains $Permission) {
                        $AllowedPermissions.Add($Permission)
                    }
                }
            } catch {
                Write-Warning "Failed to get permissions for custom role '$CustomRole': $($_.Exception.Message)"
            }
        }
    }

    # Return sorted unique permissions
    return ($AllowedPermissions | Where-Object { $_ -notmatch 'None$' } | Sort-Object -Unique)
}
#EndRegion './Public/Authentication/Get-CippAllowedPermissions.ps1' 192
#Region './Public/Authentication/Get-CippApiAuth.ps1' -1

function Get-CippApiAuth {
    param(
        [string]$RGName,
        [string]$FunctionAppName
    )

    if ($env:MSI_SECRET) {
        Disable-AzContextAutosave -Scope Process | Out-Null
        $null = Connect-AzAccount -Identity
        $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
        $Context = Set-AzContext -SubscriptionId $SubscriptionId
    } else {
        $Context = Get-AzContext
        $SubscriptionId = $Context.Subscription.Id
    }

    # Get auth settings
    $AuthSettings = Invoke-AzRestMethod -Uri "https://management.azure.com/subscriptions/$SubscriptionId/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($FunctionAppName)/config/authsettingsV2/list?api-version=2020-06-01" -ErrorAction Stop | Select-Object -ExpandProperty Content | ConvertFrom-Json

    if ($AuthSettings.properties) {
        [PSCustomObject]@{
            ApiUrl    = "https://$($env:WEBSITE_HOSTNAME)"
            TenantID  = $AuthSettings.properties.identityProviders.azureActiveDirectory.registration.openIdIssuer -replace 'https://sts.windows.net/', '' -replace '/v2.0', ''
            ClientIDs = $AuthSettings.properties.identityProviders.azureActiveDirectory.validation.defaultAuthorizationPolicy.allowedApplications
            Enabled   = $AuthSettings.properties.identityProviders.azureActiveDirectory.enabled
        }
    } else {
        throw 'No auth settings found'
    }
}
#EndRegion './Public/Authentication/Get-CippApiAuth.ps1' 31
#Region './Public/Authentication/Get-CippApiClient.ps1' -1

function Get-CippApiClient {
    <#
    .SYNOPSIS
        Get the API client details
    .DESCRIPTION
        This function retrieves the API client details
    .PARAMETER AppId
        The AppId of the API client
    .EXAMPLE
        Get-CippApiClient -AppId 'cipp-api'
    #>
    [CmdletBinding()]
    param (
        $AppId
    )

    $Table = Get-CIPPTable -TableName 'ApiClients'
    if ($AppId) {
        $Table.Filter = "RowKey eq '$AppId'"
    }
    $Apps = Get-CIPPAzDataTableEntity @Table | Where-Object { ![string]::IsNullOrEmpty($_.RowKey) }
    $Apps = foreach ($Client in $Apps) {
        $Client = $Client | Select-Object -Property @{Name = 'ClientId'; Expression = { $_.RowKey } }, AppName, Role, IPRange, Enabled

        if (!$Client.Role) {
            $Client.Role = $null
        }

        if ($Client.IPRange) {
            try {
                $IPRange = @($Client.IPRange | ConvertFrom-Json -ErrorAction Stop)
                if (($IPRange | Measure-Object).Count -eq 0) { @('Any') }
                $Client.IPRange = $IPRange
            } catch {
                $Client.IPRange = @('Any')
            }
        } else {
            $Client.IPRange = @('Any')
        }
        $Client
    }
    return $Apps
}
#EndRegion './Public/Authentication/Get-CippApiClient.ps1' 44
#Region './Public/Authentication/Get-CIPPHttpFunctions.ps1' -1

function Get-CIPPHttpFunctions {
    param(
        [switch]$ByRole,
        [switch]$ByRoleGroup
    )

    try {
        $Functions = Get-Command -Module CIPPCore | Where-Object { $_.Visibility -eq 'Public' -and $_.Name -match 'Invoke-*' }
        $Results = foreach ($Function in $Functions) {
            $Help = Get-Help $Function
            if ($Help.Functionality -notmatch 'Entrypoint') { continue }
            if ($Help.Role -eq 'Public') { continue }
            [PSCustomObject]@{
                Function    = $Function.Name
                Role        = $Help.Role
                Description = $Help.Description
            }
        }

        if ($ByRole.IsPresent -or $ByRoleGroup.IsPresent) {
            $Results = $Results | Group-Object -Property Role | Select-Object -Property @{l = 'Permission'; e = { $_.Name -eq '' ? 'None' : $_.Name } }, Count, @{l = 'Functions'; e = { $_.Group | Select-Object @{l = 'Name'; e = { $_.Function -replace 'Invoke-' } }, Description } } | Sort-Object -Property Permission
            if ($ByRoleGroup.IsPresent) {
                $RoleGroup = @{}
                foreach ($Permission in $Results) {
                    $PermSplit = $Permission.Permission -split '\.'
                    if ($PermSplit.Count -ne 3) { continue }
                    if ($null -eq $RoleGroup[$PermSplit[0]]) { $RoleGroup[$PermSplit[0]] = @{} }
                    if ($null -eq $RoleGroup[$PermSplit[0]][$PermSplit[1]]) { $RoleGroup[$PermSplit[0]][$PermSplit[1]] = @{} }
                    $RoleGroup[$PermSplit[0]][$PermSplit[1]][$PermSplit[2]] = @($Permission.Functions)
                }
                $Results = $RoleGroup
            }
        }
        $Results
    } catch {
        "Function Error $($_.Exception.Message): $($_.InvocationInfo.PositionMessage)"
    }
}
#EndRegion './Public/Authentication/Get-CIPPHttpFunctions.ps1' 39
#Region './Public/Authentication/Get-CIPPRolePermissions.ps1' -1

function Get-CIPPRolePermissions {
    <#
    .SYNOPSIS
        Get the permissions associated with a role.
    .PARAMETER RoleName
        The role to get the permissions for.
    .EXAMPLE
        Get-CIPPRolePermissions -RoleName 'mycustomrole'
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$RoleName
    )

    $Table = Get-CippTable -tablename 'CustomRoles'
    $Filter = "RowKey eq '$RoleName'"
    $Role = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    if ($Role) {
        $Permissions = $Role.Permissions | ConvertFrom-Json
        $AllowedTenants = if ($Role.AllowedTenants) { $Role.AllowedTenants | ConvertFrom-Json } else { @() }
        $BlockedTenants = if ($Role.BlockedTenants) { $Role.BlockedTenants | ConvertFrom-Json } else { @() }
        $BlockedEndpoints = if ($Role.BlockedEndpoints) { $Role.BlockedEndpoints | ConvertFrom-Json } else { @() }
        [PSCustomObject]@{
            Role             = $Role.RowKey
            Permissions      = $Permissions.PSObject.Properties.Value
            AllowedTenants   = @($AllowedTenants)
            BlockedTenants   = @($BlockedTenants)
            BlockedEndpoints = @($BlockedEndpoints)
        }
    } else {
        throw "Role $RoleName not found."
    }
}
#EndRegion './Public/Authentication/Get-CIPPRolePermissions.ps1' 35
#Region './Public/Authentication/New-CIPPAPIConfig.ps1' -1

function New-CIPPAPIConfig {

    [CmdletBinding(SupportsShouldProcess)]
    param (
        $APIName = 'CIPP API Config',
        $Headers,
        [switch]$ResetSecret,
        [string]$AppName,
        [string]$AppId
    )

    $Permissions = Get-GraphToken -tenantid $env:TenantID -scope 'https://graph.microsoft.com/.default' -AsApp $true -SkipCache $true -ReturnRefresh $true
    $Token = Read-JwtAccessDetails -Token $Permissions.access_token
    $Permissions = $Token.Roles | Where-Object { $_ -match 'Application.ReadWrite.All' -or $_ -match 'Directory.ReadWrite.All' }
    if (!$Permissions -or $Permissions.Count -lt 2) {
        Write-LogMessage -headers $Headers -API $APINAME -tenant 'None '-message 'Insufficient permissions to create API App' -Sev 'Error'
        throw 'Insufficient permissions to create API App. This integration requires the following Application permissions in the partner tenant. Application.ReadWrite.All, Directory.ReadWrite.All'
    }

    try {
        if ($AppId) {
            $APIApp = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications(appid='$($AppId)')" -NoAuthCheck $true
        } else {
            $CreateBody = @{
                api                    = @{
                    oauth2PermissionScopes = @(
                        @{
                            adminConsentDescription = 'Allow the application to access CIPP-API on behalf of the signed-in user.'
                            adminConsentDisplayName = 'Access CIPP-API'
                            id                      = 'ba7ffeff-96ea-4ac4-9822-1bcfee9adaa4'
                            isEnabled               = $true
                            type                    = 'User'
                            userConsentDescription  = 'Allow the application to access CIPP-API on your behalf.'
                            userConsentDisplayName  = 'Access CIPP-API'
                            value                   = 'user_impersonation'
                        }
                    )
                }
                displayName            = $AppName
                requiredResourceAccess = @(
                    @{
                        resourceAccess = @(
                            @{
                                id   = 'e1fe6dd8-ba31-4d61-89e7-88639da4683d'
                                type = 'Scope'
                            }
                        )
                        resourceAppId  = '00000003-0000-0000-c000-000000000000'
                    }
                )
                signInAudience         = 'AzureADMyOrg'
                web                    = @{
                    homePageUrl           = 'https://cipp.app'
                    implicitGrantSettings = @{
                        enableAccessTokenIssuance = $false
                        enableIdTokenIssuance     = $true
                    }
                    redirectUris          = @("https://$($env:WEBSITE_HOSTNAME)/.auth/login/aad/callback")
                }
            } | ConvertTo-Json -Depth 10 -Compress

            if ($PSCmdlet.ShouldProcess($AppName, 'Create API App')) {
                Write-Information 'Creating app'
                Write-Information $CreateBody
                $APIApp = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/applications' -AsApp $true -NoAuthCheck $true -type POST -body $CreateBody
                Write-Information 'Creating password'
                $APIPassword = New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/applications/$($APIApp.id)/addPassword" -AsApp $true -NoAuthCheck $true -type POST -body "{`"passwordCredential`":{`"displayName`":`"Generated by API Setup`"}}"
                Write-Information 'Adding App URL'
                $APIIdUrl = New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/applications/$($APIApp.id)" -AsApp $true -NoAuthCheck $true -type PATCH -body "{`"identifierUris`":[`"api://$($APIApp.appId)`"]}"
                Write-Information 'Adding serviceprincipal'
                $ServicePrincipal = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/serviceprincipals' -AsApp $true -NoAuthCheck $true -type POST -body "{`"accountEnabled`":true,`"appId`":`"$($APIApp.appId)`",`"displayName`":`"$AppName`",`"tags`":[`"WindowsAzureActiveDirectoryIntegratedApp`",`"AppServiceIntegratedApp`"]}"
                Write-LogMessage -headers $Headers -API $APINAME -tenant 'None '-message "Created CIPP-API App with name '$($APIApp.displayName)'." -Sev 'info'
            }
        }
        if ($ResetSecret.IsPresent -and $APIApp) {
            if ($PSCmdlet.ShouldProcess($APIApp.displayName, 'Reset API Secret')) {
                Write-Information 'Removing all old passwords'
                $Requests = @(
                    @{
                        id      = 'removeOldPasswords'
                        method  = 'PATCH'
                        url     = "applications/$($APIApp.id)/"
                        headers = @{
                            'Content-Type' = 'application/json'
                        }
                        body    = @{
                            passwordCredentials = @()
                        }
                    },
                    @{
                        id        = 'addNewPassword'
                        method    = 'POST'
                        url       = "applications/$($APIApp.id)/addPassword"
                        headers   = @{
                            'Content-Type' = 'application/json'
                        }
                        body      = @{
                            passwordCredential = @{
                                displayName = 'Generated by API Setup'
                            }
                        }
                        dependsOn = @('removeOldPasswords')
                    }
                )
                $BatchResponse = New-GraphBulkRequest -tenantid $env:TenantID -NoAuthCheck $true -asapp $true -Requests $Requests
                $APIPassword = $BatchResponse | Where-Object { $_.id -eq 'addNewPassword' } | Select-Object -ExpandProperty body
                Write-LogMessage -headers $Headers -API $APINAME -tenant 'None '-message "Reset CIPP-API Password for '$($APIApp.displayName)'." -Sev 'info'
            }
        }

        return @{
            AppName           = $APIApp.displayName
            ApplicationID     = $APIApp.appId
            ApplicationSecret = $APIPassword.secretText
            Results           = $Results
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Information ($ErrorMessage | ConvertTo-Json -Depth 10)
        Write-LogMessage -headers $Headers -API $APINAME -tenant 'None' -message "Failed to setup CIPP-API Access: $($ErrorMessage.NormalizedError) Linenumber: $($_.InvocationInfo.ScriptLineNumber)" -Sev 'Error' -LogData $ErrorMessage
        throw "Failed to setup CIPP-API Access: $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Authentication/New-CIPPAPIConfig.ps1' 125
#Region './Public/Authentication/Set-CIPPAccessRole.ps1' -1

function Set-CIPPAccessRole {
    <#
    .SYNOPSIS
    Set the access role mappings

    .DESCRIPTION
    Set the access role mappings for Entra groups

    .PARAMETER Role
    The role to set (e.g. 'superadmin','admin','editor','readonly','customrole')

    .PARAMETER Group
    The Entra group to set the role for

    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$Role,
        [Parameter(Mandatory = $true)]
        [string]$Group
    )

    $BlacklistedRoles = @('authenticated', 'anonymous')

    if ($BlacklistedRoles -contains $Role) {
        throw 'Role group cannot be set for authenticated or anonymous roles'
    }

    if (!$Group.id -or !$Group.displayName) {
        throw 'Group is not valid'
    }

    $Role = $Role.ToLower().Trim() -replace ' ', ''

    $Table = Get-CippTable -TableName AccessRoleGroups
    $AccessGroup = Get-CIPPAzDataTableEntity @Table -Filter "RowKey = '$Role'"

    $AccessGroup = [PSCustomObject]@{
        PartitionKey = [string]'AccessRole'
        RowKey       = [string]$Role
        GroupId      = [string]$Group.id
        GroupName    = [string]$Group.displayName
    }

    if ($PSCmdlet.ShouldProcess("Setting access role $Role for group $($Group.displayName)")) {
        Add-CIPPAzDataTableEntity -Table $Table -Entity $AccessGroup -Force
    }
}
#EndRegion './Public/Authentication/Set-CIPPAccessRole.ps1' 52
#Region './Public/Authentication/Set-CippApiAuth.ps1' -1

function Set-CippApiAuth {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [string]$RGName,
        [string]$FunctionAppName,
        [string]$TenantId,
        [string[]]$ClientIds
    )

    if ($env:MSI_SECRET) {
        Disable-AzContextAutosave -Scope Process | Out-Null
        $null = Connect-AzAccount -Identity
        $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
        $Context = Set-AzContext -SubscriptionId $SubscriptionId
    } else {
        $Context = Get-AzContext
        $SubscriptionId = $Context.Subscription.Id
    }

    # Get auth settings
    $AuthSettings = Invoke-AzRestMethod -Uri "https://management.azure.com/subscriptions/$SubscriptionId/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($FunctionAppName)/config/authsettingsV2/list?api-version=2020-06-01" | Select-Object -ExpandProperty Content | ConvertFrom-Json

    Write-Information "AuthSettings: $($AuthSettings | ConvertTo-Json -Depth 10)"

    # Set allowed audiences
    $AllowedAudiences = foreach ($ClientId in $ClientIds) {
        "api://$ClientId"
    }

    if (!$AllowedAudiences) { $AllowedAudiences = @() }
    if (!$ClientIds) { $ClientIds = @() }

    # Set auth settings

    if (($ClientIds | Measure-Object).Count -gt 0) {
        $AuthSettings.properties.identityProviders.azureActiveDirectory = @{
            enabled      = $true
            registration = @{
                clientId     = $ClientIds[0] ?? $ClientIds
                openIdIssuer = "https://sts.windows.net/$TenantID/v2.0"
            }
            validation   = @{
                allowedAudiences           = @($AllowedAudiences)
                defaultAuthorizationPolicy = @{
                    allowedApplications = @($ClientIds)
                }
            }
        }
    } else {
        $AuthSettings.properties.identityProviders.azureActiveDirectory = @{
            enabled      = $false
            registration = @{}
            validation   = @{}
        }
    }

    $AuthSettings.properties.globalValidation = @{
        unauthenticatedClientAction = 'Return401'
    }
    $AuthSettings.properties.login = @{
        tokenStore = @{
            enabled                    = $true
            tokenRefreshExtensionHours = 72
        }
    }

    if ($PSCmdlet.ShouldProcess('Update auth settings')) {
        # Update auth settings
        $null = Invoke-AzRestMethod -Uri "https://management.azure.com/subscriptions/$SubscriptionId/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($FunctionAppName)/config/authsettingsV2?api-version=2020-06-01" -Method PUT -Payload ($AuthSettings | ConvertTo-Json -Depth 10)
    }

    if ($PSCmdlet.ShouldProcess('Update allowed tenants')) {
        $null = Update-AzFunctionAppSetting -Name $FunctionAppName -ResourceGroupName $RGName -AppSetting @{ 'WEBSITE_AUTH_AAD_ALLOWED_TENANTS' = $TenantId }
    }
}
#EndRegion './Public/Authentication/Set-CippApiAuth.ps1' 76
#Region './Public/Authentication/Test-CIPPAccess.ps1' -1

function Test-CIPPAccess {
    param(
        $Request,
        [switch]$TenantList,
        [switch]$GroupList
    )
    if ($Request.Params.CIPPEndpoint -eq 'ExecSAMSetup') { return $true }

    # Get function help
    $FunctionName = 'Invoke-{0}' -f $Request.Params.CIPPEndpoint

    if ($FunctionName -ne 'Invoke-me') {
        try {
            $Help = Get-Help $FunctionName -ErrorAction Stop
        } catch {
            Write-Warning "Function '$FunctionName' not found"
        }
    }

    # Check help for role
    $APIRole = $Help.Role

    # Get default roles from config
    $CIPPCoreModuleRoot = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $CIPPRoot = (Get-Item $CIPPCoreModuleRoot).Parent.Parent
    $BaseRoles = Get-Content -Path $CIPPRoot\Config\cipp-roles.json | ConvertFrom-Json
    $DefaultRoles = @('superadmin', 'admin', 'editor', 'readonly', 'anonymous', 'authenticated')

    if ($APIRole -eq 'Public') {
        return $true
    }

    if ($Request.Headers.'x-ms-client-principal-idp' -eq 'aad' -and $Request.Headers.'x-ms-client-principal-name' -match '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$') {
        $Type = 'APIClient'
        # Direct API Access
        $ForwardedFor = $Request.Headers.'x-forwarded-for' -split ',' | Select-Object -First 1
        $IPRegex = '^(?<IP>(?:\d{1,3}(?:\.\d{1,3}){3}|\[[0-9a-fA-F:]+\]|[0-9a-fA-F:]+))(?::\d+)?$'
        $IPAddress = $ForwardedFor -replace $IPRegex, '$1' -replace '[\[\]]', ''

        $Client = Get-CippApiClient -AppId $Request.Headers.'x-ms-client-principal-name'
        if ($Client) {
            Write-Information "API Access: AppName=$($Client.AppName), AppId=$($Request.Headers.'x-ms-client-principal-name'), IP=$IPAddress"
            $IPMatched = $false
            if ($Client.IPRange -notcontains 'Any') {
                foreach ($Range in $Client.IPRange) {
                    if ($IPaddress -eq $Range -or (Test-IpInRange -IPAddress $IPAddress -Range $Range)) {
                        $IPMatched = $true
                        break
                    }
                }
            } else {
                $IPMatched = $true
            }

            if ($IPMatched) {
                if ($Client.Role) {
                    $CustomRoles = $Client.Role | ForEach-Object {
                        if ($DefaultRoles -notcontains $_) {
                            $_
                        }
                    }
                    $BaseRole = $null
                    foreach ($Role in $BaseRoles.PSObject.Properties) {
                        foreach ($ClientRole in $Client.Role) {
                            if ($Role.Name -eq $ClientRole) {
                                $BaseRole = $Role
                                break
                            }
                        }
                    }
                } else {
                    $CustomRoles = @('cipp-api')
                }
            } else {
                throw 'Access to this CIPP API endpoint is not allowed, the API Client does not have the required permission'
            }
        } else {
            $CustomRoles = @('cipp-api')
            Write-Information "API Access: AppId=$($Request.Headers.'x-ms-client-principal-name'), IP=$IPAddress"
        }
        if ($Request.Params.CIPPEndpoint -eq 'me') {
            $Permissions = Get-CippAllowedPermissions -UserRoles $CustomRoles
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = (
                        @{
                            'clientPrincipal' = @{
                                appId   = $Request.Headers.'x-ms-client-principal-name'
                                appRole = $CustomRoles
                            }
                            'permissions'     = $Permissions
                        } | ConvertTo-Json -Depth 5)
                })
        }

    } else {
        $Type = 'User'
        $User = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Request.Headers.'x-ms-client-principal')) | ConvertFrom-Json

        # Check for roles granted via group membership
        if (($User.userRoles | Measure-Object).Count -eq 2 -and $User.userRoles -contains 'authenticated' -and $User.userRoles -contains 'anonymous') {
            $User = Test-CIPPAccessUserRole -User $User
        }

        #Write-Information ($User | ConvertTo-Json -Depth 5)
        # Return user permissions
        if ($Request.Params.CIPPEndpoint -eq 'me') {

            if (!$User.userRoles) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = (
                            @{
                                'clientPrincipal' = $null
                                'permissions'     = @()
                            } | ConvertTo-Json -Depth 5)
                    })
            }

            $Permissions = Get-CippAllowedPermissions -UserRoles $User.userRoles
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = (
                        @{
                            'clientPrincipal' = $User
                            'permissions'     = $Permissions
                        } | ConvertTo-Json -Depth 5)
                })
        }

        if ($User.userRoles -contains 'admin' -or $User.userRoles -contains 'superadmin') {
            if ($TenantList.IsPresent) {
                return @('AllTenants')
            }
        }

        $CustomRoles = $User.userRoles | ForEach-Object {
            if ($DefaultRoles -notcontains $_) {
                $_
            }
        }

        $BaseRole = $null

        if ($User.userRoles -contains 'superadmin') {
            $User.userRoles = @('superadmin')
        } elseif ($User.userRoles -contains 'admin') {
            $User.userRoles = @('admin')
        }
        foreach ($Role in $BaseRoles.PSObject.Properties) {
            foreach ($UserRole in $User.userRoles) {
                if ($Role.Name -eq $UserRole) {
                    $BaseRole = $Role
                    break
                }
            }
        }

    }

    # Check base role permissions before continuing to custom roles
    if ($null -ne $BaseRole) {
        Write-Information "Base Role: $($BaseRole.Name)"
        $BaseRoleAllowed = $false
        foreach ($Include in $BaseRole.Value.include) {
            if ($APIRole -like $Include) {
                $BaseRoleAllowed = $true
                break
            }
        }
        foreach ($Exclude in $BaseRole.Value.exclude) {
            if ($APIRole -like $Exclude) {
                $BaseRoleAllowed = $false
                break
            }
        }
        if (!$BaseRoleAllowed) {
            throw "Access to this CIPP API endpoint is not allowed, the '$($BaseRole.Name)' base role does not have the required permission: $APIRole"
        }
    }

    # Check custom role permissions for limitations on api calls or tenants
    if ($null -eq $BaseRole.Name -and $Type -eq 'User' -and ($CustomRoles | Measure-Object).Count -eq 0) {
        Write-Information $BaseRole.Name
        throw 'Access to this CIPP API endpoint is not allowed, the user does not have the required permission'
    } elseif (($CustomRoles | Measure-Object).Count -gt 0) {
        if (@('admin', 'superadmin') -contains $BaseRole.Name) {
            return $true
        } else {
            $Tenants = Get-Tenants -IncludeErrors
            $PermissionsFound = $false
            $PermissionSet = foreach ($CustomRole in $CustomRoles) {
                try {
                    Get-CIPPRolePermissions -Role $CustomRole
                    $PermissionsFound = $true
                } catch {
                    Write-Information $_.Exception.Message
                    continue
                }
            }

            if ($PermissionsFound) {
                if ($TenantList.IsPresent) {
                    $LimitedTenantList = foreach ($Permission in $PermissionSet) {
                        if ((($Permission.AllowedTenants | Measure-Object).Count -eq 0 -or $Permission.AllowedTenants -contains 'AllTenants') -and (($Permission.BlockedTenants | Measure-Object).Count -eq 0)) {
                            @('AllTenants')
                        } else {
                            # Expand tenant groups to individual tenant IDs
                            $ExpandedAllowedTenants = foreach ($AllowedItem in $Permission.AllowedTenants) {
                                if ($AllowedItem -is [PSCustomObject] -and $AllowedItem.type -eq 'Group') {
                                    try {
                                        $GroupMembers = Expand-CIPPTenantGroups -TenantFilter @($AllowedItem)
                                        $GroupMembers | ForEach-Object { $_.addedFields.customerId }
                                    } catch {
                                        Write-Warning "Failed to expand tenant group '$($AllowedItem.label)': $($_.Exception.Message)"
                                        @()
                                    }
                                } else {
                                    $AllowedItem
                                }
                            }

                            $ExpandedBlockedTenants = foreach ($BlockedItem in $Permission.BlockedTenants) {
                                if ($BlockedItem -is [PSCustomObject] -and $BlockedItem.type -eq 'Group') {
                                    try {
                                        $GroupMembers = Expand-CIPPTenantGroups -TenantFilter @($BlockedItem)
                                        $GroupMembers | ForEach-Object { $_.addedFields.customerId }
                                    } catch {
                                        Write-Warning "Failed to expand blocked tenant group '$($BlockedItem.label)': $($_.Exception.Message)"
                                        @()
                                    }
                                } else {
                                    $BlockedItem
                                }
                            }

                            if ($ExpandedAllowedTenants -contains 'AllTenants') {
                                $ExpandedAllowedTenants = $Tenants.customerId
                            }
                            $ExpandedAllowedTenants | Where-Object { $ExpandedBlockedTenants -notcontains $_ }
                        }
                    }
                    return @($LimitedTenantList | Sort-Object -Unique)
                } elseif ($GroupList.IsPresent) {
                    Write-Information "Getting allowed groups for roles: $($CustomRoles -join ', ')"
                    $LimitedGroupList = foreach ($Permission in $PermissionSet) {
                        if ((($Permission.AllowedTenants | Measure-Object).Count -eq 0 -or $Permission.AllowedTenants -contains 'AllTenants') -and (($Permission.BlockedTenants | Measure-Object).Count -eq 0)) {
                            @('AllGroups')
                        } else {
                            foreach ($AllowedItem in $Permission.AllowedTenants) {
                                if ($AllowedItem -is [PSCustomObject] -and $AllowedItem.type -eq 'Group') {
                                    $AllowedItem.value
                                }
                            }
                        }
                    }
                    return @($LimitedGroupList | Sort-Object -Unique)
                }

                $TenantAllowed = $false
                $APIAllowed = $false
                foreach ($Role in $PermissionSet) {
                    foreach ($Perm in $Role.Permissions) {
                        if ($Perm -match $APIRole) {
                            if ($Role.BlockedEndpoints -contains $Request.Params.CIPPEndpoint) {
                                throw "Access to this CIPP API endpoint is not allowed, the custom role '$($Role.Role)' has blocked this endpoint: $($Request.Params.CIPPEndpoint)"
                            }
                            $APIAllowed = $true
                            break
                        }
                    }

                    if ($APIAllowed) {
                        $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter.value ?? $Request.Body.tenantFilter ?? $Request.Query.tenantId ?? $Request.Body.tenantId.value ?? $Request.Body.tenantId ?? $env:TenantID
                        # Check tenant level access
                        if (($Role.BlockedTenants | Measure-Object).Count -eq 0 -and $Role.AllowedTenants -contains 'AllTenants') {
                            $TenantAllowed = $true
                        } elseif ($TenantFilter -eq 'AllTenants' -and $ApiRole -match 'Write$') {
                            $TenantAllowed = $false
                        } elseif ($TenantFilter -eq 'AllTenants' -and $ApiRole -match 'Read$') {
                            $TenantAllowed = $true
                        } else {
                            $Tenant = ($Tenants | Where-Object { $TenantFilter -eq $_.customerId -or $TenantFilter -eq $_.defaultDomainName }).customerId

                            # Expand allowed tenant groups to individual tenant IDs
                            $ExpandedAllowedTenants = foreach ($AllowedItem in $Role.AllowedTenants) {
                                if ($AllowedItem -is [PSCustomObject] -and $AllowedItem.type -eq 'Group') {
                                    try {
                                        $GroupMembers = Expand-CIPPTenantGroups -TenantFilter @($AllowedItem)
                                        $GroupMembers | ForEach-Object { $_.addedFields.customerId }
                                    } catch {
                                        Write-Warning "Failed to expand allowed tenant group '$($AllowedItem.label)': $($_.Exception.Message)"
                                        @()
                                    }
                                } else {
                                    $AllowedItem
                                }
                            }

                            # Expand blocked tenant groups to individual tenant IDs
                            $ExpandedBlockedTenants = foreach ($BlockedItem in $Role.BlockedTenants) {
                                if ($BlockedItem -is [PSCustomObject] -and $BlockedItem.type -eq 'Group') {
                                    try {
                                        $GroupMembers = Expand-CIPPTenantGroups -TenantFilter @($BlockedItem)
                                        $GroupMembers | ForEach-Object { $_.addedFields.customerId }
                                    } catch {
                                        Write-Warning "Failed to expand blocked tenant group '$($BlockedItem.label)': $($_.Exception.Message)"
                                        @()
                                    }
                                } else {
                                    $BlockedItem
                                }
                            }

                            if ($ExpandedAllowedTenants -contains 'AllTenants') {
                                $AllowedTenants = $Tenants.customerId
                            } else {
                                $AllowedTenants = $ExpandedAllowedTenants
                            }

                            if ($Tenant) {
                                $TenantAllowed = $AllowedTenants -contains $Tenant -and $ExpandedBlockedTenants -notcontains $Tenant
                                if (!$TenantAllowed) { continue }
                                break
                            } else {
                                $TenantAllowed = $true
                                break
                            }
                        }
                    }
                }

                if (!$APIAllowed) {
                    throw "Access to this CIPP API endpoint is not allowed, you do not have the required permission: $APIRole"
                }
                if (!$TenantAllowed -and $Help.Functionality -notmatch 'AnyTenant') {
                    throw 'Access to this tenant is not allowed'
                } else {
                    return $true
                }
            } else {
                # No permissions found for any roles
                if ($TenantList.IsPresent) {
                    return @('AllTenants')
                }
                return $true
                if ($APIAllowed) {
                    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter.value ?? $Request.Body.tenantFilter ?? $Request.Query.tenantId ?? $Request.Body.tenantId.value ?? $Request.Body.tenantId ?? $env:TenantID
                    # Check tenant level access
                    if (($Role.BlockedTenants | Measure-Object).Count -eq 0 -and $Role.AllowedTenants -contains 'AllTenants') {
                        $TenantAllowed = $true
                    } elseif ($TenantFilter -eq 'AllTenants') {
                        $TenantAllowed = $false
                    } else {
                        $Tenant = ($Tenants | Where-Object { $TenantFilter -eq $_.customerId -or $TenantFilter -eq $_.defaultDomainName }).customerId

                        if ($Role.AllowedTenants -contains 'AllTenants') {
                            $AllowedTenants = $Tenants.customerId
                        } else {
                            $AllowedTenants = $Role.AllowedTenants
                        }
                        if ($Tenant) {
                            $TenantAllowed = $AllowedTenants -contains $Tenant -and $Role.BlockedTenants -notcontains $Tenant
                            if (!$TenantAllowed) { continue }
                            break
                        } else {
                            $TenantAllowed = $true
                            break
                        }
                    }
                }
            }

            if (!$TenantAllowed -and $Help.Functionality -notmatch 'AnyTenant') {

                if (!$APIAllowed) {
                    throw "Access to this CIPP API endpoint is not allowed, you do not have the required permission: $APIRole"
                }
                if (!$TenantAllowed -and $Help.Functionality -notmatch 'AnyTenant') {
                    Write-Information "Tenant not allowed: $TenantFilter"

                    throw 'Access to this tenant is not allowed'
                } else {
                    return $true
                }

            }
        } else {
            # No permissions found for any roles
            if ($TenantList.IsPresent) {
                return @('AllTenants')
            }
            return $true
        }
    }

    if ($TenantList.IsPresent) {
        return @('AllTenants')
    }
    return $true
}
#EndRegion './Public/Authentication/Test-CIPPAccess.ps1' 402
#Region './Public/Authentication/Test-CIPPAccessUserRole.ps1' -1

function Test-CIPPAccessUserRole {
    <#
    .SYNOPSIS
    Get the access role for the current user

    .DESCRIPTION
    Get the access role for the current user

    .PARAMETER TenantID
    The tenant ID to check the access role for

    .EXAMPLE
    Get-CippAccessRole -UserId $UserId

    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param(
        $User
    )
    $Roles = @()

    try {
        $Table = Get-CippTable -TableName cacheAccessUserRoles
        $Filter = "PartitionKey eq 'AccessUser' and RowKey eq '$($User.userDetails)' and Timestamp ge datetime'$((Get-Date).AddMinutes(-15).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffZ'))'"
        $UserRole = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    } catch {
        Write-Information "Could not access cached user roles table. $($_.Exception.Message)"
        $UserRole = $null
    }
    if ($UserRole) {
        Write-Information "Found cached user role for $($User.userDetails)"
        $Roles = $UserRole.Role | ConvertFrom-Json
    } else {
        try {
            $uri = "https://graph.microsoft.com/beta/users/$($User.userDetails)/transitiveMemberOf"
            $Memberships = New-GraphGetRequest -uri $uri -NoAuthCheck $true | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.group' }
            if ($Memberships) {
                Write-Information "Found group memberships for $($User.userDetails)"
            } else {
                Write-Information "No group memberships found for $($User.userDetails)"
            }
        } catch {
            Write-Information "Could not get user roles for $($User.userDetails). $($_.Exception.Message)"
            return $User
        }

        $AccessGroupsTable = Get-CippTable -TableName AccessRoleGroups
        $AccessGroups = Get-CIPPAzDataTableEntity @AccessGroupsTable -Filter "PartitionKey eq 'AccessRoleGroups'"
        $CustomRolesTable = Get-CippTable -TableName CustomRoles
        $CustomRoles = Get-CIPPAzDataTableEntity @CustomRolesTable -Filter "PartitionKey eq 'CustomRoles'"
        $BaseRoles = @('superadmin', 'admin', 'editor', 'readonly')

        $Roles = foreach ($AccessGroup in $AccessGroups) {
            if ($Memberships.id -contains $AccessGroup.GroupId -and ($CustomRoles.RowKey -contains $AccessGroup.RowKey -or $BaseRoles -contains $AccessGroup.RowKey)) {
                $AccessGroup.RowKey
            }
        }

        $Roles = @($Roles) + @($User.userRoles)

        if ($Roles) {
            Write-Information "Roles determined for $($User.userDetails): $($Roles -join ', ')"
        }

        if (($Roles | Measure-Object).Count -gt 2) {
            try {
                $UserRole = [PSCustomObject]@{
                    PartitionKey = 'AccessUser'
                    RowKey       = [string]$User.userDetails
                    Role         = [string](ConvertTo-Json -Compress -InputObject $Roles)
                }
                Add-CIPPAzDataTableEntity @Table -Entity $UserRole -Force
            } catch {
                Write-Information "Could not cache user roles for $($User.userDetails). $($_.Exception.Message)"
            }
        }
    }
    $User.userRoles = $Roles

    return $User
}
#EndRegion './Public/Authentication/Test-CIPPAccessUserRole.ps1' 84
#Region './Public/Authentication/Test-IpInRange.ps1' -1

function Test-IpInRange {
    <#
    .SYNOPSIS
    Test if an IP address is in a CIDR range
    .DESCRIPTION
    This function tests if an IP address is in a CIDR range
    .PARAMETER IPAddress
    The IP address to test
    .PARAMETER Range
    The CIDR range to test
    .EXAMPLE
    Test-IpInRange -IPAddress "1.1.1.1" -Range "1.1.1.1/24"
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$IPAddress,
        [Parameter(Mandatory = $true)]
        [string]$Range
    )

    function ConvertIpToBigInteger {
        param([System.Net.IPAddress]$ip)
        return [System.Numerics.BigInteger]::Parse(
            [BitConverter]::ToString($ip.GetAddressBytes()).Replace('-', ''),
            [System.Globalization.NumberStyles]::HexNumber
        )
    }

    try {
        $IP = [System.Net.IPAddress]::Parse($IPAddress)
        $rangeParts = $Range -split '/'
        $networkAddr = [System.Net.IPAddress]::Parse($rangeParts[0])
        $prefix = [int]$rangeParts[1]

        if ($networkAddr.AddressFamily -ne $IP.AddressFamily) {
            return $false
        }

        $ipBig = ConvertIpToBigInteger $IP
        $netBig = ConvertIpToBigInteger $networkAddr
        $maxBits = if ($networkAddr.AddressFamily -eq 'InterNetworkV6') { 128 } else { 32 }
        $shift = $maxBits - $prefix
        $mask = [System.Numerics.BigInteger]::Pow(2, $shift) - [System.Numerics.BigInteger]::One
        $invertedMask = [System.Numerics.BigInteger]::MinusOne -bxor $mask
        $ipMasked = $ipBig -band $invertedMask
        $netMasked = $netBig -band $invertedMask

        return $ipMasked -eq $netMasked
    } catch {
        return $false
    }
}
#EndRegion './Public/Authentication/Test-IpInRange.ps1' 54
#Region './Public/CippQueue/Invoke-ListCippQueue.ps1' -1

function Invoke-ListCippQueue {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    param($Request = $null, $TriggerMetadata = $null, $Reference = $null, $QueueId = $null)

    if ($Request) {
        $APIName = $Request.Params.CIPPEndpoint
        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Accessed this API' -Sev 'Debug'
    }

    $QueueId = $Request.Query.QueueId ?? $QueueId
    $Reference = $Request.Query.Reference ?? $Reference

    $CippQueue = Get-CippTable -TableName 'CippQueue'
    $CippQueueTasks = Get-CippTable -TableName 'CippQueueTasks'
    $3HoursAgo = (Get-Date).ToUniversalTime().AddHours(-3).ToString('yyyy-MM-ddTHH:mm:ssZ')

    if ($QueueId) {
        $Filter = "PartitionKey eq 'CippQueue' and RowKey eq '$QueueId'"
    } elseif ($Reference) {
        $Filter = "PartitionKey eq 'CippQueue' and Reference eq '$Reference' and Timestamp ge datetime'$3HoursAgo'"
    } else {
        $Filter = "PartitionKey eq 'CippQueue' and Timestamp ge datetime'$3HoursAgo'"
    }

    $CippQueueData = Get-CIPPAzDataTableEntity @CippQueue -Filter $Filter | Sort-Object -Property Timestamp -Descending

    $QueueData = foreach ($Queue in $CippQueueData) {
        $Tasks = Get-CIPPAzDataTableEntity @CippQueueTasks -Filter "PartitionKey eq 'Task' and QueueId eq '$($Queue.RowKey)'" | Where-Object { $_.Name } | Select-Object @{n = 'Timestamp'; exp = { $_.Timestamp } }, Name, Status
        $TaskStatus = @{}
        $Tasks | Group-Object -Property Status | ForEach-Object {
            $TaskStatus.$($_.Name) = $_.Count
        }

        if ($Tasks) {
            if ($Tasks.Status -notcontains 'Running' -and ($TaskStatus.Completed + $TaskStatus.Failed) -ge $Queue.TotalTasks) {
                if ($Tasks.Status -notcontains 'Failed') {
                    $Queue.Status = 'Completed'
                } else {
                    $Queue.Status = 'Completed (with errors)'
                }
            } else {
                $Queue.Status = 'Running'
            }
        }

        $TotalCompleted = $TaskStatus.Completed ?? 0
        $TotalFailed = $TaskStatus.Failed ?? 0
        $TotalRunning = $TaskStatus.Running ?? 0
        if ($Queue.TotalTasks -eq 0) { $Queue.TotalTasks = 1 }

        [PSCustomObject]@{
            PartitionKey    = $Queue.PartitionKey
            RowKey          = $Queue.RowKey
            Name            = $Queue.Name
            Link            = $Queue.Link
            Reference       = $Queue.Reference
            TotalTasks      = $Queue.TotalTasks
            CompletedTasks  = $TotalCompleted + $TotalFailed
            RunningTasks    = $TotalRunning
            FailedTasks     = $TotalFailed
            PercentComplete = [math]::Round(((($TotalCompleted + $TotalFailed) / $Queue.TotalTasks) * 100), 1)
            PercentFailed   = [math]::Round((($TotalFailed / $Queue.TotalTasks) * 100), 1)
            PercentRunning  = [math]::Round((($TotalRunning / $Queue.TotalTasks) * 100), 1)
            Tasks           = @($Tasks | Sort-Object -Descending Timestamp)
            Status          = $Queue.Status
            Timestamp       = $Queue.Timestamp
        }

    }

    if ($request) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($QueueData)
            })
    } else {
        return $QueueData
    }
}
#EndRegion './Public/CippQueue/Invoke-ListCippQueue.ps1' 85
#Region './Public/CippQueue/Invoke-RemoveCippQueue.ps1' -1

function Invoke-RemoveCippQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.ReadWrite
    #>
    param($Request, $TriggerMetadata)
    $CippQueue = Get-CippTable -TableName 'CippQueue'
    Clear-AzDataTable @CippQueue
    $CippQueueTasks = Get-CippTable -TableName 'CippQueueTasks'
    Clear-AzDataTable @CippQueueTasks

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @('History cleared') }
        })
}
#EndRegion './Public/CippQueue/Invoke-RemoveCippQueue.ps1' 19
#Region './Public/CippQueue/New-CippQueueEntry.ps1' -1

function New-CippQueueEntry {
    <#
    .FUNCTIONALITY
        Internal
    #>
    Param(
        [string]$Name,
        [string]$Link,
        [string]$Reference,
        [int]$TotalTasks = 1
    )

    $CippQueue = Get-CippTable -TableName CippQueue

    $QueueEntry = @{
        PartitionKey = 'CippQueue'
        RowKey       = (New-Guid).Guid.ToString()
        Name         = $Name
        Link         = $Link
        Reference    = $Reference
        Status       = 'Queued'
        TotalTasks   = $TotalTasks
    }
    $CippQueue.Entity = $QueueEntry

    Add-CIPPAzDataTableEntity @CippQueue

    $QueueEntry
}
#EndRegion './Public/CippQueue/New-CippQueueEntry.ps1' 30
#Region './Public/CippQueue/Set-CippQueueTask.ps1' -1

function Set-CippQueueTask {
    <#
    .FUNCTIONALITY
        Internal
    #>
    param(
        [string]$QueueId,
        [string]$TaskId = (New-Guid).Guid.ToString(),
        [string]$Name,
        [ValidateSet('Queued', 'Running', 'Completed', 'Failed')]
        [string]$Status = 'Queued',
        [string]$Message
    )

    $CippQueueTasks = Get-CippTable -TableName CippQueueTasks

    $QueueTaskEntry = @{
        PartitionKey = 'Task'
        RowKey       = $TaskId
        QueueId      = $QueueId
        Name         = $Name
        Status       = $Status
    }
    if ($Message) {
        $QueueTaskEntry.Message = $Message
    }
    $CippQueueTasks.Entity = $QueueTaskEntry

    Add-CIPPAzDataTableEntity @CippQueueTasks -Force
    return $QueueTaskEntry
}
#EndRegion './Public/CippQueue/Set-CippQueueTask.ps1' 32
#Region './Public/CippQueue/Update-CippQueueEntry.ps1' -1

function Update-CippQueueEntry {
    <#
    .FUNCTIONALITY
        Internal
    #>
    Param(
        [Parameter(Mandatory = $true)]
        $RowKey,
        $Status,
        $Name
    )

    $CippQueue = Get-CippTable -TableName CippQueue

    if ($RowKey) {
        $QueueEntry = Get-CIPPAzDataTableEntity @CippQueue -Filter ("RowKey eq '{0}'" -f $RowKey)

        if ($QueueEntry) {
            if ($Status) {
                $QueueEntry.Status = $Status
            }
            if ($Name) {
                $QueueEntry.Name = $Name
            }
            Add-CIPPAzDataTableEntity @CippQueue -Entity $QueueEntry -Force
            $QueueEntry
        } else {
            return $false
        }
    } else {
        return $false
    }
}
#EndRegion './Public/CippQueue/Update-CippQueueEntry.ps1' 34
#Region './Public/Clear-CippDurables.ps1' -1

function Clear-CippDurables {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    # Collect info
    $StorageContext = New-AzStorageContext -ConnectionString $env:AzureWebJobsStorage
    $FunctionName = $env:WEBSITE_SITE_NAME -replace '-', ''

    # Get orchestrators
    $InstancesTable = Get-CippTable -TableName ('{0}Instances' -f $FunctionName)
    $HistoryTable = Get-CippTable -TableName ('{0}History' -f $FunctionName)
    $QueueTable = Get-CippTable -TableName 'CippQueue'
    $CippQueueTasks = Get-CippTable -TableName 'CippQueueTasks'

    Remove-AzDataTable @InstancesTable
    Remove-AzDataTable @HistoryTable
    Remove-AzDataTable @QueueTable
    Remove-AzDataTable @CippQueueTasks

    $Queues = Get-AzStorageQueue -Context $StorageContext -Name ('{0}*' -f $FunctionName) | Select-Object -Property Name, ApproximateMessageCount, QueueClient

    $RunningQueues = $Queues | Where-Object { $_.ApproximateMessageCount -gt 0 }
    foreach ($Queue in $RunningQueues) {
        Write-Information "- Removing queue: $($Queue.Name), message count: $($Queue.ApproximateMessageCount)"
        if ($PSCmdlet.ShouldProcess($Queue.Name, 'Clear Queue')) {
            $Queue.QueueClient.ClearMessagesAsync()
        }
    }

    $BlobContainer = '{0}-largemessages' -f $FunctionName
    if (Get-AzStorageContainer -Name $BlobContainer -Context $StorageContext -ErrorAction SilentlyContinue) {
        Write-Information "- Removing blob container: $BlobContainer"
        if ($PSCmdlet.ShouldProcess($BlobContainer, 'Remove Blob Container')) {
            Remove-AzStorageContainer -Name $BlobContainer -Context $StorageContext -Confirm:$false -Force
        }
    }

    $null = Get-CippTable -TableName ('{0}History' -f $FunctionName)
    Write-Information 'Durable Orchestrators and Queues have been cleared'
    return $true
}
#EndRegion './Public/Clear-CippDurables.ps1' 41
#Region './Public/Clear-CIPPImmutableId.ps1' -1

function Clear-CIPPImmutableId {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $UserID,
        $Headers,
        $APIName = 'Clear Immutable ID'
    )

    try {
        try {
            $User = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$UserID" -tenantid $TenantFilter -ErrorAction SilentlyContinue
        } catch {
            $DeletedUser = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/directory/deletedItems/$UserID" -tenantid $TenantFilter
            if ($DeletedUser.id) {
                # Restore deleted user object
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/directory/deletedItems/$UserID/restore" -tenantid $TenantFilter -type POST
                Write-LogMessage -headers $Headers -API $APIName -message "Restored deleted user $UserID to clear immutable ID" -sev Info -tenant $TenantFilter
            }
        }

        $Body = [pscustomobject]@{ onPremisesImmutableId = $null }
        $Body = ConvertTo-Json -InputObject $Body -Depth 5 -Compress
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$UserID" -tenantid $TenantFilter -type PATCH -body $Body
        $Result = "Successfully cleared immutable ID for user $UserID"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -sev Info -tenant $TenantFilter
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to clear immutable ID for $($UserID). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Clear-CIPPImmutableId.ps1' 35
#Region './Public/Compare-CIPPIntuneObject.ps1' -1

function Compare-CIPPIntuneObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$ReferenceObject,

        [Parameter(Mandatory = $true)]
        [PSCustomObject]$DifferenceObject,

        [Parameter(Mandatory = $false)]
        [string[]]$ExcludeProperties = @(),
        [Parameter(Mandatory = $false)]
        [string[]]$CompareType = @()
    )
    if ($CompareType -ne 'Catalog') {
        $defaultExcludeProperties = @(
            'id',
            'createdDateTime',
            'lastModifiedDateTime',
            'supportsScopeTags',
            'modifiedDateTime',
            'version',
            'roleScopeTagIds',
            'settingCount',
            'creationSource',
            'priorityMetaData'
            'featureUpdatesWillBeRolledBack',
            'qualityUpdatesWillBeRolledBack',
            'qualityUpdatesPauseStartDate',
            'featureUpdatesPauseStartDate'
            'wslDistributions',
            'lastSuccessfulSyncDateTime'
        )

        $excludeProps = $defaultExcludeProperties + $ExcludeProperties
        $result = [System.Collections.Generic.List[PSObject]]::new()

        function ShouldSkipProperty {
            param (
                [string]$PropertyName
            )
            return ($PropertyName -like '*@OData*' -or
                $PropertyName -like '#microsoft.graph*' -or
                $excludeProps -contains $PropertyName)
        }

        function Compare-ObjectsRecursively {
            param (
                [Parameter(Mandatory = $true)]
                $Object1,

                [Parameter(Mandatory = $true)]
                $Object2,

                [Parameter(Mandatory = $false)]
                [string]$PropertyPath = '',
                [int]$Depth = 0,
                [int]$MaxDepth = 20
            )

            if ($Depth -ge $MaxDepth) {
                $result.Add([PSCustomObject]@{
                        Property      = $PropertyPath
                        ExpectedValue = '[MaxDepthExceeded]'
                        ReceivedValue = '[MaxDepthExceeded]'
                    })
                return
            }

            if (($null -eq $Object1 -or $Object1 -eq '') -and ($null -eq $Object2 -or $Object2 -eq '')) {
                return
            }

            if (($null -eq $Object1 -or $Object1 -eq '') -xor ($null -eq $Object2 -or $Object2 -eq '')) {
                $result.Add([PSCustomObject]@{
                        Property      = $PropertyPath
                        ExpectedValue = if ($null -eq $Object1) { '' } else { $Object1 }
                        ReceivedValue = if ($null -eq $Object2) { '' } else { $Object2 }
                    })
                return
            }

            if ($Object1.GetType() -ne $Object2.GetType()) {
                $result.Add([PSCustomObject]@{
                        Property      = $PropertyPath
                        ExpectedValue = $Object1
                        ReceivedValue = $Object2
                    })
                return
            }

            # Short-circuit recursion for primitive types
            $primitiveTypes = @([double], [decimal], [datetime], [timespan], [guid] )
            foreach ($type in $primitiveTypes) {
                if ($Object1 -is $type -and $Object2 -is $type) {
                    if ($Object1 -ne $Object2) {
                        $result.Add([PSCustomObject]@{
                                Property      = $PropertyPath
                                ExpectedValue = $Object1
                                ReceivedValue = $Object2
                            })
                    }
                    return
                }
            }

            if ($Object1 -is [System.Collections.IDictionary]) {
                $allKeys = @($Object1.Keys) + @($Object2.Keys) | Select-Object -Unique

                foreach ($key in $allKeys) {
                    if (ShouldSkipProperty -PropertyName $key) { continue }

                    $newPath = if ($PropertyPath) { "$PropertyPath.$key" } else { $key }

                    if ($Object1.ContainsKey($key) -and $Object2.ContainsKey($key)) {
                        if ($Object1[$key] -and $Object2[$key]) {
                            Compare-ObjectsRecursively -Object1 $Object1[$key] -Object2 $Object2[$key] -PropertyPath $newPath -Depth ($Depth + 1) -MaxDepth $MaxDepth
                        }
                    } elseif ($Object1.ContainsKey($key)) {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = $Object1[$key]
                                ReceivedValue = ''
                            })
                    } else {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = ''
                                ReceivedValue = $Object2[$key]
                            })
                    }
                }
            } elseif ($Object1 -is [Array] -or $Object1 -is [System.Collections.IList]) {
                $maxLength = [Math]::Max($Object1.Count, $Object2.Count)

                for ($i = 0; $i -lt $maxLength; $i++) {
                    $newPath = "$PropertyPath.$i"

                    if ($i -lt $Object1.Count -and $i -lt $Object2.Count) {
                        Compare-ObjectsRecursively -Object1 $Object1[$i] -Object2 $Object2[$i] -PropertyPath $newPath -Depth ($Depth + 1) -MaxDepth $MaxDepth
                    } elseif ($i -lt $Object1.Count) {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = $Object1[$i]
                                ReceivedValue = ''
                            })
                    } else {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = ''
                                ReceivedValue = $Object2[$i]
                            })
                    }
                }
            } elseif ($Object1 -is [PSCustomObject] -or $Object1.PSObject.Properties.Count -gt 0) {
                $allPropertyNames = @(
                    $Object1.PSObject.Properties | Select-Object -ExpandProperty Name
                    $Object2.PSObject.Properties | Select-Object -ExpandProperty Name
                ) | Select-Object -Unique

                foreach ($propName in $allPropertyNames) {
                    if (ShouldSkipProperty -PropertyName $propName) { continue }

                    $newPath = if ($PropertyPath) { "$PropertyPath.$propName" } else { $propName }
                    $prop1Exists = $Object1.PSObject.Properties.Name -contains $propName
                    $prop2Exists = $Object2.PSObject.Properties.Name -contains $propName

                    if ($prop1Exists -and $prop2Exists) {
                        if ($Object1.$propName -and $Object2.$propName) {
                            Compare-ObjectsRecursively -Object1 $Object1.$propName -Object2 $Object2.$propName -PropertyPath $newPath -Depth ($Depth + 1) -MaxDepth $MaxDepth
                        }
                    } elseif ($prop1Exists) {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = $Object1.$propName
                                ReceivedValue = ''
                            })
                    } else {
                        $result.Add([PSCustomObject]@{
                                Property      = $newPath
                                ExpectedValue = ''
                                ReceivedValue = $Object2.$propName
                            })
                    }
                }
            } else {
                $val1 = $Object1.ToString()
                $val2 = $Object2.ToString()

                if ($val1 -ne $val2) {
                    $result.Add([PSCustomObject]@{
                            Property      = $PropertyPath
                            ExpectedValue = $val1
                            ReceivedValue = $val2
                        })
                }
            }
        }

        $obj1 = if ($ReferenceObject -is [string]) {
            $ReferenceObject | ConvertFrom-Json -AsHashtable -Depth 100
        } else {
            $ReferenceObject
        }

        $obj2 = if ($DifferenceObject -is [string]) {
            $DifferenceObject | ConvertFrom-Json -AsHashtable -Depth 100
        } else {
            $DifferenceObject
        }

        if ($obj1 -and $obj2) {
            Compare-ObjectsRecursively -Object1 $obj1 -Object2 $obj2
        }

        if ($result.Count -eq 0) {
            return $null
        }
    } else {
        $intuneCollection = Get-Content .\intuneCollection.json | ConvertFrom-Json -ErrorAction SilentlyContinue

        # Recursive function to process group setting collections at any depth
        function Process-GroupSettingChildren {
            param(
                [Parameter(Mandatory = $true)]
                $Children,
                [Parameter(Mandatory = $true)]
                [string]$Source,
                [Parameter(Mandatory = $true)]
                $IntuneCollection
            )

            $results = [System.Collections.Generic.List[PSCustomObject]]::new()

            foreach ($child in $Children) {
                $childIntuneObj = $IntuneCollection | Where-Object { $_.id -eq $child.settingDefinitionId }
                $childLabel = if ($childIntuneObj?.displayName) {
                    $childIntuneObj.displayName
                } else {
                    $child.settingDefinitionId
                }

                switch ($child.'@odata.type') {
                    '#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance' {
                        if ($child.groupSettingCollectionValue) {
                            foreach ($groupValue in $child.groupSettingCollectionValue) {
                                if ($groupValue.children) {
                                    $nestedResults = Process-GroupSettingChildren -Children $groupValue.children -Source $Source -IntuneCollection $IntuneCollection
                                    $results.AddRange($nestedResults)
                                }
                            }
                        }
                    }
                    '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' {
                        $childValue = $null
                        if ($child.choiceSettingValue?.value) {
                            $option = $childIntuneObj.options | Where-Object {
                                $_.id -eq $child.choiceSettingValue.value
                            }
                            $childValue = if ($option?.displayName) {
                                $option.displayName
                            } else {
                                $child.choiceSettingValue.value
                            }
                        }

                        $results.Add([PSCustomObject]@{
                            Key    = "GroupChild-$($child.settingDefinitionId)"
                            Label  = $childLabel
                            Value  = $childValue
                            Source = $Source
                        })
                    }
                    '#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance' {
                        $childValue = $null
                        if ($null -ne $child.simpleSettingValue -and $null -ne $child.simpleSettingValue.value) {
                            $childValue = $child.simpleSettingValue.value
                        }

                        $results.Add([PSCustomObject]@{
                            Key    = "GroupChild-$($child.settingDefinitionId)"
                            Label  = $childLabel
                            Value  = $childValue
                            Source = $Source
                        })
                    }
                    '#microsoft.graph.deviceManagementConfigurationChoiceSettingCollectionInstance' {
                        if ($child.choiceSettingCollectionValue) {
                            $values = [System.Collections.Generic.List[string]]::new()
                            foreach ($choiceValue in $child.choiceSettingCollectionValue) {
                                $option = $childIntuneObj.options | Where-Object {
                                    $_.id -eq $choiceValue.value
                                }
                                $displayValue = if ($option?.displayName) {
                                    $option.displayName
                                } else {
                                    $choiceValue.value
                                }
                                $values.Add($displayValue)
                            }
                            $childValue = $values -join ', '

                            $results.Add([PSCustomObject]@{
                                Key    = "GroupChild-$($child.settingDefinitionId)"
                                Label  = $childLabel
                                Value  = $childValue
                                Source = $Source
                            })
                        }
                    }
                    '#microsoft.graph.deviceManagementConfigurationSimpleSettingCollectionInstance' {
                        if ($child.simpleSettingCollectionValue) {
                            $values = [System.Collections.Generic.List[object]]::new()
                            foreach ($simpleValue in $child.simpleSettingCollectionValue) {
                                $values.Add($simpleValue.value)
                            }
                            $childValue = $values -join ', '

                            $results.Add([PSCustomObject]@{
                                Key    = "GroupChild-$($child.settingDefinitionId)"
                                Label  = $childLabel
                                Value  = $childValue
                                Source = $Source
                            })
                        }
                    }
                    default {
                        # Unknown setting type - could add logging here if needed
                    }
                }

                # Also process any children within choice setting values
                if ($child.choiceSettingValue?.children) {
                    $nestedResults = Process-GroupSettingChildren -Children $child.choiceSettingValue.children -Source $Source -IntuneCollection $IntuneCollection
                    $results.AddRange($nestedResults)
                }
            }

            return $results
        }

        # Process reference object settings
        $referenceItems = $ReferenceObject.settings | ForEach-Object {
            $settingInstance = $_.settingInstance
            $intuneObj = $intuneCollection | Where-Object { $_.id -eq $settingInstance.settingDefinitionId }
            $tempOutput = switch ($settingInstance.'@odata.type') {
                '#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance' {
                    if ($null -ne $settingInstance.groupSettingCollectionValue) {
                        $groupResults = [System.Collections.Generic.List[PSCustomObject]]::new()
                        foreach ($groupValue in $settingInstance.groupSettingCollectionValue) {
                            if ($groupValue.children -is [System.Array]) {
                                $childResults = Process-GroupSettingChildren -Children $groupValue.children -Source 'Reference' -IntuneCollection $intuneCollection
                                $groupResults.AddRange($childResults)
                            }
                        }
                        # Return the results from the recursive processing
                        $groupResults
                    }
                }
                default {
                    if ($settingInstance.simpleSettingValue?.value) {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }
                        $value = $settingInstance.simpleSettingValue.value
                        [PSCustomObject]@{
                            Key    = "Simple-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = $value
                            Source = 'Reference'
                        }
                    } elseif ($settingInstance.choiceSettingValue?.value) {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }

                        $option = $intuneObj.options | Where-Object {
                            $_.id -eq $settingInstance.choiceSettingValue.value
                        }
                        $value = if ($option?.displayName) {
                            $option.displayName
                        } else {
                            $settingInstance.choiceSettingValue.value
                        }

                        [PSCustomObject]@{
                            Key    = "Choice-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = $value
                            Source = 'Reference'
                        }
                    } else {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }
                        [PSCustomObject]@{
                            Key    = "Unknown-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = 'This setting could not be resolved'
                            Source = 'Reference'
                        }
                    }
                }
            }
            $tempOutput
        }

        # Process difference object settings
        $differenceItems = $DifferenceObject.settings | ForEach-Object {
            $settingInstance = $_.settingInstance
            $intuneObj = $intuneCollection | Where-Object { $_.id -eq $settingInstance.settingDefinitionId }
            $tempOutput = switch ($settingInstance.'@odata.type') {
                '#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance' {
                    if ($null -ne $settingInstance.groupSettingCollectionValue) {
                        $groupResults = [System.Collections.Generic.List[PSCustomObject]]::new()
                        foreach ($groupValue in $settingInstance.groupSettingCollectionValue) {
                            if ($groupValue.children -is [System.Array]) {
                                $childResults = Process-GroupSettingChildren -Children $groupValue.children -Source 'Difference' -IntuneCollection $intuneCollection
                                $groupResults.AddRange($childResults)
                            }
                        }
                        # Return the results from the recursive processing
                        $groupResults
                    }
                }
                default {
                    if ($settingInstance.simpleSettingValue?.value) {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }
                        $value = $settingInstance.simpleSettingValue.value
                        [PSCustomObject]@{
                            Key    = "Simple-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = $value
                            Source = 'Difference'
                        }
                    } elseif ($settingInstance.choiceSettingValue?.value) {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }

                        $option = $intuneObj.options | Where-Object {
                            $_.id -eq $settingInstance.choiceSettingValue.value
                        }
                        $value = if ($option?.displayName) {
                            $option.displayName
                        } else {
                            $settingInstance.choiceSettingValue.value
                        }

                        [PSCustomObject]@{
                            Key    = "Choice-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = $value
                            Source = 'Difference'
                        }
                    } else {
                        $label = if ($intuneObj?.displayName) {
                            $intuneObj.displayName
                        } else {
                            $settingInstance.settingDefinitionId
                        }
                        [PSCustomObject]@{
                            Key    = "Unknown-$($settingInstance.settingDefinitionId)"
                            Label  = $label
                            Value  = 'This setting could not be resolved'
                            Source = 'Difference'
                        }
                    }
                }
            }
            $tempOutput
        }

        $result = [System.Collections.Generic.List[PSObject]]::new()

        $allKeys = @($referenceItems | Select-Object -ExpandProperty Key) + @($differenceItems | Select-Object -ExpandProperty Key) | Sort-Object -Unique

        foreach ($key in $allKeys) {
            $refItem = $referenceItems | Where-Object { $_.Key -eq $key } | Select-Object -First 1
            $diffItem = $differenceItems | Where-Object { $_.Key -eq $key } | Select-Object -First 1

            $settingId = $key
            if ($key -like 'Simple-*') {
                $settingId = $key.Substring(7)
            } elseif ($key -like 'Choice-*') {
                $settingId = $key.Substring(7)
            } elseif ($key -like 'GroupChild-*') {
                $settingId = $key.Substring(11)
            } elseif ($key -like 'Unknown-*') {
                $settingId = $key.Substring(8)
            }

            $settingDefinition = $intuneCollection | Where-Object { $_.id -eq $settingId }

            $refRawValue = if ($refItem) { $refItem.Value } else { $null }
            $diffRawValue = if ($diffItem) { $diffItem.Value } else { $null }

            $refValue = $refRawValue
            $diffValue = $diffRawValue

            if ($null -ne $settingDefinition -and $null -ne $settingDefinition.options) {
                if ($null -ne $refRawValue -and $refRawValue -match '_\d+$') {
                    $option = $settingDefinition.options | Where-Object { $_.id -eq $refRawValue }
                    if ($null -ne $option -and $null -ne $option.displayName) {
                        $refValue = $option.displayName
                    }
                }

                if ($null -ne $diffRawValue -and $diffRawValue -match '_\d+$') {
                    $option = $settingDefinition.options | Where-Object { $_.id -eq $diffRawValue }
                    if ($null -ne $option -and $null -ne $option.displayName) {
                        $diffValue = $option.displayName
                    }
                }
            }

            $label = if ($null -ne $settingDefinition -and $null -ne $settingDefinition.displayName) {
                $settingDefinition.displayName
            } elseif ($refItem) {
                $refItem.Label
            } elseif ($diffItem) {
                $diffItem.Label
            } else {
                $key
            }

            if ($refRawValue -ne $diffRawValue -or $null -eq $refRawValue -or $null -eq $diffRawValue) {
                $result.Add([PSCustomObject]@{
                        Property      = $label
                        ExpectedValue = $refValue
                        ReceivedValue = $diffValue
                    })
            }
        }

        return $result
    }
    return $result
}
#EndRegion './Public/Compare-CIPPIntuneObject.ps1' 552
#Region './Public/CustomData/Invoke-CustomDataSync.ps1' -1

function Invoke-CustomDataSync {
    param(
        $TenantFilter
    )

    $Table = Get-CIPPTable -TableName CustomDataMappings
    $CustomData = Get-CIPPAzDataTableEntity @Table

    $Mappings = $CustomData | ForEach-Object {
        $Mapping = $_.JSON | ConvertFrom-Json
        $Mapping
    }

    Write-Information "Found $($Mappings.Count) Custom Data mappings"
    $Mappings = $Mappings | Where-Object { $_.sourceType.value -eq 'extensionSync' -and $_.tenantFilter.value -contains $TenantFilter -or $_.tenantFilter.value -contains 'AllTenants' }

    if ($Mappings.Count -eq 0) {
        Write-Warning "No Custom Data mappings found for tenant $TenantFilter"
        return
    }

    Write-Information "Getting cached data for tenant $TenantFilter"
    $Cache = Get-ExtensionCacheData -TenantFilter $TenantFilter
    $BulkRequests = [System.Collections.Generic.List[object]]::new()
    $DirectoryObjectQueries = [System.Collections.Generic.List[object]]::new()
    $SyncConfigs = foreach ($Mapping in $Mappings) {
        $SyncConfig = [PSCustomObject]@{
            Dataset                   = $Mapping.extensionSyncDataset.value
            DatasetConfig             = $Mapping.extensionSyncDataset.addedFields
            DirectoryObjectType       = $Mapping.directoryObjectType.value
            ExtensionSyncProperty     = $Mapping.extensionSyncProperty.value
            CustomDataAttribute       = $Mapping.customDataAttribute.value
            CustomDataAttributeConfig = $Mapping.customDataAttribute.addedFields
        }

        switch ($SyncConfig.DirectoryObjectType) {
            'user' {
                $Query = @{
                    id     = 'user'
                    url    = 'users?$select=id,userPrincipalName,displayName,mailNickname&$count=true&$top=999'
                    method = 'GET'
                }
            }
        }
        $SyncConfig
        if ($DirectoryObjectQueries | Where-Object { $_.id -eq $Query.id }) {
            continue
        } else {
            $DirectoryObjectQueries.Add($Query)
        }
    }

    Write-Information "Getting directory objects for tenant $TenantFilter"
    #Write-Information ($DirectoryObjectQueries | ConvertTo-Json -Depth 10)
    $AllDirectoryObjects = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($DirectoryObjectQueries)
    Write-Information "Retrieved $($AllDirectoryObjects.Count) result sets"
    #Write-Information ($AllDirectoryObjects | ConvertTo-Json -Depth 10)

    $PatchObjects = @{}

    foreach ($SyncConfig in $SyncConfigs) {
        Write-Warning "Processing Custom Data mapping for $($SyncConfig.Dataset)"
        Write-Information ($SyncConfig | ConvertTo-Json -Depth 10)
        $Rows = $Cache.$($SyncConfig.Dataset)
        if (!$Rows) {
            Write-Warning "No data found for dataset $($SyncConfig.Dataset)"
            continue
        }
        $SourceMatchProperty = $SyncConfig.DatasetConfig.sourceMatchProperty
        $DestinationMatchProperty = $SyncConfig.DatasetConfig.destinationMatchProperty
        $CustomDataAttribute = $SyncConfig.CustomDataAttribute
        $ExtensionSyncProperty = $SyncConfig.ExtensionSyncProperty
        $DatasetConfig = $SyncConfig.DatasetConfig

        $DirectoryObjects = ($AllDirectoryObjects | Where-Object { $_.id -eq $SyncConfig.DirectoryObjectType }).body.value

        switch ($SyncConfig.DirectoryObjectType) {
            'user' {
                $url = 'users'
            }
        }

        foreach ($Row in $Rows) {
            #Write-Warning 'Processing row'
            #Write-Information ($Row | ConvertTo-Json -Depth 10)
            Write-Host "Comparing $SourceMatchProperty $($Row.$SourceMatchProperty) to $($DirectoryObjects.Count) directory objects on $DestinationMatchProperty"
            if ($DestinationMatchProperty.Count -gt 1) {
                foreach ($Prop in $DestinationMatchProperty) {
                    $DirectoryObject = $DirectoryObjects | Where-Object { $_.$Prop -eq $Row.$SourceMatchProperty }
                    if ($DirectoryObject) {
                        break
                    }
                }
            } else {
                $DirectoryObject = $DirectoryObjects | Where-Object { $_.$DestinationMatchProperty -eq $Row.$SourceMatchProperty }
            }

            if (!$DirectoryObject) {
                Write-Warning "No directory object found for $($Row.$SourceMatchProperty)"
            }
            if ($DirectoryObject) {
                $ObjectUrl = "$($url)/$($DirectoryObject.id)"

                # check if key in patch objects already exists otherwise create one with object url
                if (!$PatchObjects.ContainsKey($ObjectUrl)) {
                    Write-Host "Creating new object for $($ObjectUrl)"
                    $PatchObjects[$ObjectUrl] = @{}
                }

                if ($DatasetConfig.type -eq 'object') {
                    if ($CustomDataAttribute -match '\.') {
                        $Props = @($CustomDataAttribute -split '\.')
                        if (!$PatchObjects[$ObjectUrl].ContainsKey($Props[0])) {
                            Write-Host "Creating new object for $($Props[0])"
                            $PatchObjects[$ObjectUrl][$Props[0]] = @{}
                        }
                        if (!$PatchObjects[$ObjectUrl][$Props[0]].ContainsKey($Props[1])) {
                            Write-Host "Creating new object for $($Props[1])"
                            $PatchObjects[$ObjectUrl][$Props[0]][$Props[1]] = $Row.$ExtensionSyncProperty
                        }
                    } else {
                        $PatchObjects[$ObjectUrl][$CustomDataAttribute] = $Row.$ExtensionSyncProperty
                    }
                } elseif ($DatasetConfig.type -eq 'array') {
                    Write-Warning "Processing array data for $($CustomDataAttribute) on $($DirectoryObject.id) - found $($Row.Count) entries"
                    #Write-Information ($Row | ConvertTo-Json -Depth 10)
                    if ($DatasetConfig.select) {
                        $Row = $Row | Select-Object -Property ($DatasetConfig.select -split ',')
                    }

                    if (!$PatchObjects[$ObjectUrl].ContainsKey($CustomDataAttribute)) {
                        $PatchObjects[$ObjectUrl][$CustomDataAttribute] = [System.Collections.Generic.List[string]]::new()
                    }

                    $Data = if ($DatasetConfig.storeAs -eq 'json') {
                        $Row | ConvertTo-Json -Depth 5 -Compress
                    } else {
                        $Row
                    }

                    $PatchObjects[$ObjectUrl][$CustomDataAttribute].Add($Data)
                }
            }
        }
    }

    foreach ($ObjectUrl in $PatchObjects.Keys) {
        $PatchObject = $PatchObjects[$ObjectUrl]
        $BulkRequests.Add([PSCustomObject]@{
                id      = ($ObjectUrl -split '/' | Select-Object -Last 1)
                url     = $ObjectUrl
                method  = 'PATCH'
                body    = $PatchObject
                headers = @{
                    'Content-Type' = 'application/json'
                }
            })
    }

    Write-Host ($BulkRequests | ConvertTo-Json -Depth 10)
    if ($BulkRequests.Count -gt 0) {
        Write-Information "Sending $($BulkRequests.Count) requests to Graph API"
        $Responses = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($BulkRequests)
        if ($Responses | Where-Object { $_.statusCode -ne 204 }) {
            Write-Warning 'Some requests failed'
            Write-Information ($Responses | Where-Object { $_.status -ne 204 } | ConvertTo-Json -Depth 10)
        }
    }
}
#EndRegion './Public/CustomData/Invoke-CustomDataSync.ps1' 170
#Region './Public/DeltaQueries/Get-DeltaQueryResults.ps1' -1

function Get-DeltaQueryResults {
    <#
    .SYNOPSIS
        Retrieves results for Delta Queries
    .DESCRIPTION
        This helper function modifies the results from Delta Query triggers based on specified properties.
    .PARAMETER Data
        The data containing Delta Query results. Use %triggerdata% from the scheduler to pass in the data.
    .PARAMETER Properties
        A comma-separated list of properties to include in the output. If not specified, all properties are returned.
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $Data,
        [string]$Properties,
        [string]$TenantFilter,
        $Headers
    )

    $Properties = $Properties -split ',' | ForEach-Object { $_.Trim() }
    if (!$Properties -or $Properties.Count -eq 0) {
        Write-Information 'No specific properties requested, returning all data.'
        Write-Information ($Data | ConvertTo-Json -Depth 10)
        return $Data
    }

    $Data = $Data | Select-Object -Property $Properties
}
#EndRegion './Public/DeltaQueries/Get-DeltaQueryResults.ps1' 31
#Region './Public/DeltaQueries/Get-DeltaQueryUrl.ps1' -1

function Get-DeltaQueryUrl {
    <#
    .SYNOPSIS
        Retrieves the URL for Delta Queries
    .DESCRIPTION
        This helper function constructs the URL for Delta Query requests based on the resource and parameters.
    .PARAMETER TenantFilter
        The tenant to filter the query on.
    .PARAMETER PartitionKey
        The partition key for the delta query.
    #>

    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $TenantFilter,
        [Parameter(Mandatory = $true)]
        $PartitionKey
    )

    $Table = Get-CIPPTable -TableName 'DeltaQueries'
    $DeltaQueryEntity = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$PartitionKey' and RowKey eq '$TenantFilter'"

    if ($DeltaQueryEntity) {
        return $DeltaQueryEntity.DeltaUrl
    } else {
        throw "Delta Query not found for Tenant '$TenantFilter' and PartitionKey '$PartitionKey'."
    }
}
#EndRegion './Public/DeltaQueries/Get-DeltaQueryUrl.ps1' 30
#Region './Public/DeltaQueries/New-GraphDeltaQuery.ps1' -1

function New-GraphDeltaQuery {
    <#
    .SYNOPSIS
        Creates a new Graph Delta Query.
    .DESCRIPTION
        This function creates a new Graph Delta Query to track changes in a specified resource.
        Always returns the full response including the deltaLink for future incremental queries.
    .PARAMETER Resource
        The resource to track changes for (e.g., 'users', 'groups').
    .PARAMETER TenantFilter
        The tenant to filter the query on.
    .PARAMETER Parameters
        Additional query parameters (e.g., $select, $filter, $top).
    .PARAMETER DeltaUrl
        Use this parameter to continue a delta query with a specific delta or next link.
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding(DefaultParameterSetName = 'NewDeltaQuery')]
    param(
        [Parameter(Mandatory = $true, ParameterSetName = 'NewDeltaQuery')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DeltaUrl')]
        $TenantFilter,

        [Parameter(ParameterSetName = 'NewDeltaQuery', Mandatory = $true)]
        [ValidateSet('users', 'groups', 'contacts', 'orgContact', 'devices', 'applications', 'servicePrincipals', 'directoryObjects', 'directoryRole', 'administrativeUnits', 'oAuth2PermissionGrant')]
        [string]$Resource,

        [Parameter(ParameterSetName = 'NewDeltaQuery', Mandatory = $false)]
        [hashtable]$Parameters = @{},

        [Parameter(ParameterSetName = 'DeltaUrl', Mandatory = $true)]
        [string]$DeltaUrl,

        [Parameter(Mandatory = $false, ParameterSetName = 'NewDeltaQuery')]
        [Parameter(Mandatory = $true, ParameterSetName = 'DeltaUrl')]
        [string]$PartitionKey
    )

    if ($TenantFilter -eq 'AllTenants' -or $TenantFilter.type -eq 'Group') {
        Write-Information 'Creating delta query for all tenants or tenant group.'
        if ($TenantFilter.type -eq 'group') {
            $Tenants = Expand-CIPPTenantGroups -TenantFilter $TenantFilter
        } else {
            $Tenants = Get-Tenants -IncludeErrors
        }

        if (!$PartitionKey) {
            $ParamJson = $Parameters | ConvertTo-Json -Depth 5 -Compress
            $PartitionKey = Get-StringHash -String ($Resource + $ParamJson)
        }
        # Prepare batch processing for all tenants
        $TenantBatch = $Tenants | ForEach-Object {
            [PSCustomObject]@{
                FunctionName = 'GraphDeltaQuery'
                TenantFilter = $_.defaultDomainName ?? $_.value
                Resource     = $Resource
                Parameters   = $Parameters
                PartitionKey = $PartitionKey
            }
        }

        $InputObject = @{
            Batch            = @($TenantBatch)
            OrchestratorName = 'ProcessDeltaQueries'
            SkipLog          = $true
        }
        Write-Information "Starting delta query orchestration for $($Tenants.Count) tenants."
        Write-Information "Orchestration Input: $($InputObject | ConvertTo-Json -Compress -Depth 5)"
        $Orchestration = Start-NewOrchestration -FunctionName CIPPOrchestrator -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)

    } else {
        $Table = Get-CIPPTable -TableName 'DeltaQueries'

        if ($Parameters -and $Resource) {
            $ParamJson = $Parameters | ConvertTo-Json -Depth 5
            $ResourceHash = Get-StringHash -String ($Resource + $ParamJson)

            $DeltaQuery = @{
                PartitionKey = $PartitionKey ?? $ResourceHash
                RowKey       = $TenantFilter
                Resource     = $Resource
                Parameters   = [string]($Parameters | ConvertTo-Json -Depth 5 -Compress)
                DeltaUrl     = $DeltaUrl
            }
        } elseif ($PartitionKey) {
            $DeltaQuery = Get-AzDataTableEntity @Table -Filter "PartitionKey eq '$PartitionKey' and RowKey eq '$TenantFilter'"
        }

        try {
            if ($DeltaUrl) {
                $GraphQuery = [System.UriBuilder]$DeltaUrl
            } else {
                $GraphQuery = [System.UriBuilder]('https://graph.microsoft.com/beta/{0}/delta' -f $Resource)
                $QueryParams = @{
                    '$deltaToken' = 'latest'
                }
                $ParamCollection = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)

                foreach ($key in $QueryParams.Keys) {
                    if ($QueryParams[$key]) {
                        $ParamCollection.Add($key, $QueryParams[$key])
                    }
                }

                foreach ($Item in ($Parameters.GetEnumerator() | Sort-Object -CaseSensitive -Property Key)) {
                    if ($Item.Value -is [System.Boolean]) {
                        $Item.Value = $Item.Value.ToString().ToLower()
                    }
                    if ($Item.Value) {
                        $ParamCollection.Add($Item.Key, $Item.Value)
                    }
                }
                $GraphQuery.Query = $ParamCollection.ToString()
            }

            $allResults = [System.Collections.ArrayList]::new()
            $nextUrl = $GraphQuery.ToString()
            $deltaLink = $null

            $DeltaError = $false
            do {
                try {
                    $response = New-GraphGetRequest -tenantid $TenantFilter -uri $nextUrl -ReturnRawResponse -extraHeaders @{ Prefer = 'return=minimal' } -ErrorAction Stop
                    if ($response.Content) {
                        $content = $response.Content
                        if ($content -is [string]) {
                            $content = $content | ConvertFrom-Json
                        }

                        # Add results from this page
                        if ($content.value) {
                            $allResults.AddRange($content.value)
                        }

                        # Check for next page or delta link
                        $nextUrl = $content.'@odata.nextLink'
                        $deltaLink = $content.'@odata.deltaLink'
                    }
                } catch {
                    Write-Error "Error during Graph Delta Query request for tenant '$TenantFilter': $(Get-NormalizedError -Message $_.Exception.message)"
                    $DeltaError = $true
                }
            } while ($nextUrl -and -not $deltaLink -and -not $DeltaError)

            if ($DeltaError) {
                throw "Delta Query failed for tenant '$TenantFilter'."
            }
            $DeltaQuery.RowKey = $TenantFilter
            $DeltaQuery.DeltaUrl = $deltaLink

            # Return results with delta link for future queries
            $result = @{
                value              = $allResults.ToArray()
                '@odata.deltaLink' = $deltaLink
                PartitionKey       = $PartitionKey
            }
            # Save link to table
            Add-CIPPAzDataTableEntity @Table -Entity $DeltaQuery -Force

            Write-Information "Delta Query created for $($DeltaQuery.Resource). Total items: $($allResults.Count)"

            # Always return full response with deltaLink
            return $result
        } catch {
            Write-Error "Failed to create Delta Query: $(Get-NormalizedError -Message $_.Exception.message)"
            Write-Warning $_.InvocationInfo.PositionMessage
        }
    }
}
#EndRegion './Public/DeltaQueries/New-GraphDeltaQuery.ps1' 171
#Region './Public/DeltaQueries/Push-GraphDeltaQuery.ps1' -1

function Push-GraphDeltaQuery {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param (
        $Item
    )

    $Item = $Item | Select-Object -ExcludeProperty FunctionName | ConvertTo-Json -Depth 5 | ConvertFrom-Json -AsHashtable
    try {
        New-GraphDeltaQuery @Item
    } catch {
        Write-Error "Failed to create Delta Query: $(Get-NormalizedError -Message $_.Exception.message)"
        Write-Warning $_.InvocationInfo.PositionMessage
    }

}
#EndRegion './Public/DeltaQueries/Push-GraphDeltaQuery.ps1' 20
#Region './Public/DeltaQueries/Test-DeltaQueryConditions.ps1' -1

function Test-DeltaQueryConditions {
    <#
    .SYNOPSIS
        Tests if the conditions for a Delta Query trigger are met.
    .DESCRIPTION
        This function evaluates whether the specified conditions for a Delta Query trigger are satisfied based on the provided data.
    .PARAMETER Query
        The result of the delta query to evaluate.
    .PARAMETER Trigger
        The trigger configuration containing conditions to test against.
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $Query,
        [Parameter(Mandatory = $true)]
        $Trigger,
        [Parameter(Mandatory = $true)]
        $TenantFilter,
        [Parameter(Mandatory = $true)]
        $LastTrigger
    )

    $ConditionsMet = $false
    $MatchedData = @()

    $Data = $Query.value
    $EventType = $Trigger.EventType.value ?? $Trigger.EventType

    # Filter data based on delta query change type according to Microsoft Graph specification
    switch ($EventType) {
        'deleted' {
            Write-Information "data to process for deleted: $($Data | ConvertTo-Json -Depth 5)"
            # Removed instances are represented by their id and an @removed object
            $Data = $Data | Where-Object {
                $_.PSObject.Properties.Name -contains '@removed' -and $_.'@removed'.reason -eq 'changed'
            }

            # For directory objects, fetch full details of deleted items
            Write-Information 'Fetching full details for deleted directory objects.'

            $Requests = foreach ($item in $Data) {
                [PSCustomObject]@{
                    'id'     = $item.id
                    'url'    = "directory/deletedItems/$($item.id)"
                    'method' = 'GET'
                }
            }
            try {
                $DeletedItems = New-GraphBulkRequest -Requests @($Requests) -tenantid $TenantFilter
                if ($DeletedItems.status -eq 200) {
                    Write-Information 'Retrieved full details for deleted items.'
                    Write-Information "Deleted items response: $($DeletedItems | ConvertTo-Json -Depth 5)"
                    $EnrichedData = [System.Collections.Generic.List[object]]::new()
                    foreach ($Row in $Data) {
                        $fullItem = ($DeletedItems | Where-Object { $_.id -eq $Row.id -and $_.status -eq 200 }).body
                        if ($fullItem) {
                            $EnrichedData.Add($fullItem)
                        } else {
                            $EnrichedData.Add($Row)
                        }
                    }
                    $Data = $EnrichedData
                }
            } catch {
                Write-Warning "Failed to retrieve full details for deleted items: $($_.Exception.Message)"
            }

            Write-Information "Found $($Data.Count) deleted items."
        }
        'created' {
            # Newly created instances use standard representation without @removed
            # These will have their full standard representation, not minimal response
            $Data = $Data | Where-Object { $_.createdDateTime -ge $LastTrigger }
            Write-Information "Found $($Data.Count) created items."
        }
        'updated' {
            # Updated instances have at least updated properties but no @removed object
            $Data = $Data | Where-Object {
                $_.PSObject.Properties.Name -notcontains '@removed' -and
                (!$_.createdDateTime -or $_.createdDateTime -lt $LastTrigger)
            }
            Write-Information "Found $($Data.Count) updated items."
        }
    }

    # Check if we have any data after event type filtering
    if (($Data | Measure-Object).Count -eq 0) {
        Write-Information "No data matches the event type filter '$EventType'. Conditions not met."
        return @{
            ConditionsMet     = $false
            MatchedData       = @()
            TotalItems        = ($Query.value | Measure-Object).Count
            FilteredItems     = 0
            MatchedItems      = 0
            EventTypeFilter   = $EventType
            ChangeTypeSummary = @()
        }
    }

    if ($Trigger.UseConditions -eq $true -and $Trigger.Conditions) {
        try {
            # Parse conditions from JSON (similar to audit log processing)
            $conditions = $Trigger.Conditions | ConvertFrom-Json | Where-Object { $_.Input.value -ne '' -and $_.Input.value -ne $null }

            if ($conditions) {
                # Initialize collections for condition strings
                $conditionStrings = [System.Collections.Generic.List[string]]::new()
                $CIPPClause = [System.Collections.Generic.List[string]]::new()

                foreach ($condition in $conditions) {
                    # Handle array vs single values
                    $value = if ($condition.Input.value -is [array]) {
                        $arrayAsString = $condition.Input.value | ForEach-Object {
                            "'$_'"
                        }
                        "@($($arrayAsString -join ', '))"
                    } else {
                        "'$($condition.Input.value)'"
                    }

                    # Build PowerShell condition string
                    $conditionStrings.Add("`$(`$_.$($condition.Property.label)) -$($condition.Operator.value) $value")
                    $CIPPClause.Add("$($condition.Property.label) is $($condition.Operator.label) $value")
                }

                # Join all conditions with AND
                $finalCondition = $conditionStrings -join ' -AND '

                Write-Information "Testing delta query conditions: $finalCondition"
                Write-Information "Human readable: $($CIPPClause -join ' and ')"

                # Apply conditions to filter the data using a script block instead of Invoke-Expression
                $scriptBlock = [scriptblock]::Create("param(`$_) $finalCondition")
                $MatchedData = $Data | Where-Object $scriptBlock
            } else {
                Write-Information 'No valid conditions found in trigger configuration.'
                $MatchedData = $Data
            }
        } catch {
            Write-Warning "Error processing delta query conditions: $($_.Exception.Message)"
            Write-Information $_.InvocationInfo.PositionMessage
            $MatchedData = @()
        }
    } else {
        # No conditions specified, consider all data as matching
        $MatchedData = $Data
    }

    # Determine if conditions are met based on final matched data count
    $ConditionsMet = ($MatchedData | Measure-Object).Count -gt 0

    # Return results with matched data and change type summary
    $changeTypeSummary = $MatchedData | Group-Object CIPPChangeType | ForEach-Object {
        @{
            ChangeType = $_.Name
            Count      = $_.Count
        }
    }

    return @{
        ConditionsMet     = $ConditionsMet
        MatchedData       = $MatchedData
        TotalItems        = ($Query.value | Measure-Object).Count
        FilteredItems     = ($Data | Measure-Object).Count
        MatchedItems      = ($MatchedData | Measure-Object).Count
        EventTypeFilter   = $EventType
        ChangeTypeSummary = $changeTypeSummary
    }

}
#EndRegion './Public/DeltaQueries/Test-DeltaQueryConditions.ps1' 174
#Region './Public/Entrypoints/Activity Triggers/Applications/Push-GetApplicationQueue.ps1' -1

function Push-GetApplicationQueue {
    param()
    $Table = Get-CippTable -tablename 'apps'
    Get-CIPPAzDataTableEntity @Table | Select-Object @{Name = 'Name'; Expression = { $_.RowKey } }, @{Name = 'FunctionName'; Expression = { 'UploadApplication' } }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Applications/Push-GetApplicationQueue.ps1' 6
#Region './Public/Entrypoints/Activity Triggers/Applications/Push-UploadApplication.ps1' -1

function Push-UploadApplication {
    <#
        .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)

    try {
        $Table = Get-CippTable -tablename 'apps'
        $Filter = "PartitionKey eq 'apps' and RowKey eq '$($Item.Name)'"

        $ModuleRoot = (Get-Module CIPPCore).ModuleBase
        $CippRoot = (Get-Item $ModuleRoot).Parent.Parent
        Set-Location $CippRoot

        $ChocoApp = (Get-CIPPAzDataTableEntity @Table -filter $Filter).JSON | ConvertFrom-Json
        $intuneBody = $ChocoApp.IntuneBody
        $tenants = if ($ChocoApp.tenant -eq 'AllTenants') {
            (Get-Tenants -IncludeErrors).defaultDomainName
        } else {
            $ChocoApp.tenant
        }
        if ($ChocoApp.type -eq 'MSPApp') {
            [xml]$Intunexml = Get-Content "AddMSPApp\$($ChocoApp.MSPAppName).app.xml"
            $intunewinFilesize = (Get-Item "AddMSPApp\$($ChocoApp.MSPAppName).intunewin")
            $Infile = "AddMSPApp\$($ChocoApp.MSPAppName).intunewin"
        } else {
            [xml]$Intunexml = Get-Content 'AddChocoApp\Choco.App.xml'
            $intunewinFilesize = (Get-Item 'AddChocoApp\IntunePackage.intunewin')
            $Infile = "AddChocoApp\$($intunexml.ApplicationInfo.FileName)"
        }
        $assignTo = $ChocoApp.assignTo
        $AssignToIntent = $ChocoApp.InstallationIntent
        $Baseuri = 'https://graph.microsoft.com/beta/deviceAppManagement/mobileApps'
        $ContentBody = ConvertTo-Json @{
            name          = $intunexml.ApplicationInfo.FileName
            size          = [int64]$intunexml.ApplicationInfo.UnencryptedContentSize
            sizeEncrypted = [int64]($intunewinFilesize).length
        }
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter
        $RemoveCacheFile = if ($ChocoApp.tenant -ne 'AllTenants') {
            Remove-AzDataTableEntity -Force @Table -Entity $clearRow
        } else {
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$($ChocoApp | ConvertTo-Json)"
                RowKey       = "$($ClearRow.RowKey)"
                PartitionKey = 'apps'
                status       = 'Deployed'
            }
        }
        $EncBody = @{
            fileEncryptionInfo = @{
                encryptionKey        = $intunexml.ApplicationInfo.EncryptionInfo.EncryptionKey
                macKey               = $intunexml.ApplicationInfo.EncryptionInfo.MacKey
                initializationVector = $intunexml.ApplicationInfo.EncryptionInfo.InitializationVector
                mac                  = $intunexml.ApplicationInfo.EncryptionInfo.Mac
                profileIdentifier    = $intunexml.ApplicationInfo.EncryptionInfo.ProfileIdentifier
                fileDigest           = $intunexml.ApplicationInfo.EncryptionInfo.FileDigest
                fileDigestAlgorithm  = $intunexml.ApplicationInfo.EncryptionInfo.FileDigestAlgorithm
            }
        } | ConvertTo-Json

        foreach ($tenant in $tenants) {
            try {
                $ApplicationList = New-GraphGetRequest -Uri $baseuri -tenantid $tenant | Where-Object { $_.DisplayName -eq $ChocoApp.Applicationname -and ($_.'@odata.type' -eq '#microsoft.graph.win32LobApp' -or $_.'@odata.type' -eq '#microsoft.graph.winGetApp') }
                if ($ApplicationList.displayname.count -ge 1) {
                    Write-LogMessage -api 'AppUpload' -tenant $tenant -message "$($ChocoApp.Applicationname) exists. Skipping this application" -Sev 'Info'
                    continue
                }
                if ($ChocoApp.type -eq 'WinGet') {
                    Write-Host 'Winget!'
                    Write-Host ($intuneBody | ConvertTo-Json -Compress)
                    $NewApp = New-GraphPostRequest -Uri $baseuri -Body ($intuneBody | ConvertTo-Json -Compress) -Type POST -tenantid $tenant
                    Start-Sleep -Milliseconds 200
                    Write-LogMessage -api 'AppUpload' -tenant $tenant -message "$($ChocoApp.Applicationname) uploaded as WinGet app." -Sev 'Info'
                    if ($AssignTo -ne 'On') {
                        $intent = if ($AssignToIntent) { 'Uninstall' } else { 'Required' }
                        Set-CIPPAssignedApplication -ApplicationId $NewApp.Id -Intent $intent -TenantFilter $tenant -groupName "$AssignTo" -AppType 'WinGet'
                    }
                    Write-LogMessage -api 'AppUpload' -tenant $tenant -message "$($ChocoApp.Applicationname) Successfully created" -Sev 'Info'
                    continue
                } else {
                    $NewApp = New-GraphPostRequest -Uri $baseuri -Body ($intuneBody | ConvertTo-Json) -Type POST -tenantid $tenant

                }
                $ContentReq = New-GraphPostRequest -Uri "$($BaseURI)/$($NewApp.id)/microsoft.graph.win32lobapp/contentVersions/1/files/" -Body $ContentBody -Type POST -tenantid $tenant
                do {
                    $AzFileUri = New-graphGetRequest -Uri "$($BaseURI)/$($NewApp.id)/microsoft.graph.win32lobapp/contentVersions/1/files/$($ContentReq.id)" -tenantid $tenant
                    if ($AZfileuri.uploadState -like '*fail*') { break }
                    Start-Sleep -Milliseconds 300
                } while ($AzFileUri.AzureStorageUri -eq $null)
                Write-Host "Uploading file to $($AzFileUri.azureStorageUri)"
                Write-Host "Complete AZ file uri data: $($AzFileUri | ConvertTo-Json -Depth 10)"
                $chunkSizeInBytes = 4mb
                [byte[]]$bytes = [System.IO.File]::ReadAllBytes($($intunewinFilesize.fullname))
                $chunks = [Math]::Ceiling($bytes.Length / $chunkSizeInBytes)
                $id = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($chunks.ToString('0000')))
                #For anyone that reads this, The maximum chunk size is 100MB for blob storage, so we can upload it as one part and just give it the single ID. Easy :)
                $Upload = Invoke-RestMethod -Uri "$($AzFileUri.azureStorageUri)&comp=block&blockid=$id" -Method Put -Headers @{'x-ms-blob-type' = 'BlockBlob' } -InFile $inFile -ContentType 'application/octet-stream'
                Write-Host "Upload data: $($Upload | ConvertTo-Json -Depth 10)"
                $ConfirmUpload = Invoke-RestMethod -Uri "$($AzFileUri.azureStorageUri)&comp=blocklist" -Method Put -Body "<?xml version=`"1.0`" encoding=`"utf-8`"?><BlockList><Latest>$id</Latest></BlockList>" -ContentType 'application/xml'
                Write-Host "Confirm Upload data: $($ConfirmUpload | ConvertTo-Json -Depth 10)"
                $CommitReq = New-graphPostRequest -Uri "$($BaseURI)/$($NewApp.id)/microsoft.graph.win32lobapp/contentVersions/1/files/$($ContentReq.id)/commit" -Body $EncBody -Type POST -tenantid $tenant
                Write-Host "Commit Request: $($CommitReq | ConvertTo-Json -Depth 10)"

                do {
                    $CommitStateReq = New-graphGetRequest -Uri "$($BaseURI)/$($NewApp.id)/microsoft.graph.win32lobapp/contentVersions/1/files/$($ContentReq.id)" -tenantid $tenant
                    Write-Host "Commit State Request: $($CommitStateReq | ConvertTo-Json -Depth 10)"
                    if ($CommitStateReq.uploadState -like '*fail*') {
                        Write-LogMessage -api 'AppUpload' -tenant $tenant -message "$($ChocoApp.Applicationname) Commit failed. Please check if app uploaded succesful" -Sev 'Warning'
                        break
                    }
                    Start-Sleep -Milliseconds 300
                } while ($CommitStateReq.uploadState -eq 'commitFilePending')
                $CommitFinalizeReq = New-graphPostRequest -Uri "$($BaseURI)/$($NewApp.id)" -tenantid $tenant -Body '{"@odata.type":"#microsoft.graph.win32lobapp","committedContentVersion":"1"}' -type PATCH
                Write-Host "Commit Finalize Request: $($CommitFinalizeReq | ConvertTo-Json -Depth 10)"
                Write-LogMessage -api 'AppUpload' -tenant $tenant -message "Added Application $($ChocoApp.Applicationname)" -Sev 'Info'
                if ($AssignTo -ne 'On') {
                    $intent = if ($AssignToIntent) { 'Uninstall' } else { 'Required' }
                    Set-CIPPAssignedApplication -ApplicationId $NewApp.Id -Intent $intent -TenantFilter $tenant -groupName "$AssignTo" -AppType 'Win32Lob'

                }
                Write-LogMessage -api 'AppUpload' -tenant $tenant -message 'Successfully added Application' -Sev 'Info'
            } catch {
                "Failed to add Application for $($Tenant): $($_.Exception.Message)"
                Write-LogMessage -api 'AppUpload' -tenant $tenant -message "Failed adding Application $($ChocoApp.Applicationname). Error: $($_.Exception.Message)" -LogData (Get-CippException -Exception $_) -Sev 'Error'
                continue
            }
        }
    } catch {
        Write-Host "Error pushing application: $($_.Exception.Message)"
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Applications/Push-UploadApplication.ps1' 136
#Region './Public/Entrypoints/Activity Triggers/BEC/Push-BECRun.ps1' -1

function Push-BECRun {
    <#
        .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $TenantFilter = $Item.TenantFilter
    $SuspectUser = $Item.UserID
    $UserName = $Item.userName

    if (!$TenantFilter -or !$SuspectUser) {
        Write-Information 'BEC: No user or tenant specified'
        return
    }
    $Table = Get-CippTable -tablename 'cachebec'

    Write-Information "Working on $UserName"
    try {
        $startDate = (Get-Date).AddDays(-7).ToUniversalTime()
        $endDate = (Get-Date)
        Write-Information 'Getting audit logs'
        $auditLog = (New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-AdminAuditLogConfig').UnifiedAuditLogIngestionEnabled
        $7dayslog = if ($auditLog -eq $false) {
            $ExtractResult = 'AuditLog is disabled. Cannot perform full analysis'
        } else {
            $sessionid = Get-Random -Minimum 10000 -Maximum 99999
            $operations = @(
                'Remove-MailboxPermission',
                'Add-MailboxPermission',
                'UpdateCalendarDelegation',
                'AddFolderPermissions',
                'MailboxLogin',
                'UserLoggedIn'
            )
            $startDate = (Get-Date).AddDays(-7)
            $endDate = (Get-Date)
            $SearchParam = @{
                SessionCommand = 'ReturnLargeSet'
                Operations     = $operations
                sessionid      = $sessionid
                startDate      = $startDate
                endDate        = $endDate
            }
            do {
                New-ExoRequest -tenantid $TenantFilter -cmdlet 'Search-unifiedAuditLog' -cmdParams $SearchParam -Anchor $Username
                Write-Information "Retrieved $($logsTenant.count) logs"
                $logsTenant
            } while ($LogsTenant.count % 5000 -eq 0 -and $LogsTenant.count -ne 0)
            $ExtractResult = 'Successfully extracted logs from auditlog'
        }
        Write-Information 'Getting last sign-in'
        try {
            $URI = "https://graph.microsoft.com/beta/auditLogs/signIns?`$filter=(userId eq '$SuspectUser')&`$top=1&`$orderby=createdDateTime desc"
            $LastSignIn = New-GraphGetRequest -uri $URI -tenantid $TenantFilter -noPagination $true -verbose | Select-Object @{ Name = 'CreatedDateTime'; Expression = { $(($_.createdDateTime | Out-String) -replace '\r\n') } },
            id,
            @{ Name = 'AppDisplayName'; Expression = { $_.resourceDisplayName } },
            @{ Name = 'Status'; Expression = { if (($_.conditionalAccessStatus -eq 'Success' -or 'Not Applied') -and $_.status.errorCode -eq 0) { 'Success' } else { 'Failed' } } },
            @{ Name = 'IPAddress'; Expression = { $_.ipAddress } }
        } catch {
            $LastSignIn = [PSCustomObject]@{
                AppDisplayName  = 'Unknown - could not retrieve information. No access to sign-in logs'
                CreatedDateTime = 'Unknown'
                Id              = '0'
                Status          = 'Could not retrieve additional details'
            }
        }
        Write-Information 'Getting user devices'
        #List all users devices
        $Bytes = [System.Text.Encoding]::UTF8.GetBytes($SuspectUser)
        $base64IdentityParam = [Convert]::ToBase64String($Bytes)
        try {
            $Devices = New-GraphGetRequest -uri "https://outlook.office365.com:443/adminapi/beta/$($TenantFilter)/mailbox('$($base64IdentityParam)')/MobileDevice/Exchange.GetMobileDeviceStatistics()/?IsEncoded=True" -Tenantid $TenantFilter -scope ExchangeOnline
        } catch {
            $Devices = $null
        }

        try {
            $PermissionsLog = ($7dayslog | Where-Object -Property Operations -In 'Remove-MailboxPermission', 'Add-MailboxPermission', 'UpdateCalendarDelegation', 'AddFolderPermissions' ).AuditData | ConvertFrom-Json -ErrorAction Stop | ForEach-Object {
                $perms = if ($_.Parameters) {
                    $_.Parameters | ForEach-Object { if ($_.Name -eq 'AccessRights') { $_.Value } }
                } else
                { $_.item.ParentFolder.MemberRights }
                $objectID = if ($_.ObjectID) { $_.ObjectID } else { $($_.MailboxOwnerUPN) + $_.item.ParentFolder.Path }
                [pscustomobject]@{
                    Operation   = $_.Operation
                    UserKey     = $_.UserKey
                    ObjectId    = $objectId
                    Permissions = $perms
                }
            }
        } catch {
            $PermissionsLog = @()
        }

        Write-Information 'Getting rules'

        try {
            $RulesLog = New-ExoRequest -cmdlet 'Get-InboxRule' -tenantid $TenantFilter -cmdParams @{ Mailbox = $Username; IncludeHidden = $true } -Anchor $Username |
                Where-Object { $_.Name -ne 'Junk E-Mail Rule' -and $_.Name -notlike 'Microsoft.Exchange.OOF.*' }
        } catch {
            Write-Host 'Failed to get rules: ' + $_.Exception.Message
            $RulesLog = @()
        }

        Write-Information 'Getting last 50 logons'
        try {
            $Last50Logons = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/auditLogs/signIns?`$filter=userDisplayName ne 'On-Premises Directory Synchronization Service Account'&`$top=50&`$orderby=createdDateTime desc" -tenantid $TenantFilter -noPagination $true | Select-Object @{ Name = 'CreatedDateTime'; Expression = { $(($_.createdDateTime | Out-String) -replace '\r\n') } },
            id,
            @{ Name = 'AppDisplayName'; Expression = { $_.resourceDisplayName } },
            @{ Name = 'Status'; Expression = { if (($_.conditionalAccessStatus -eq 'Success' -or 'Not Applied') -and $_.status.errorCode -eq 0) { 'Success' } else { 'Failed' } } },
            @{ Name = 'IPAddress'; Expression = { $_.ipAddress } }, UserPrincipalName, UserDisplayName
        } catch {
            $Last50Logons = @(
                [PSCustomObject]@{
                    AppDisplayName  = 'Unknown - could not retrieve information. No access to sign-in logs'
                    CreatedDateTime = 'Unknown'
                    Id              = '0'
                    Status          = 'Could not retrieve additional details'
                    Exception       = $_.Exception.Message
                }
            )
        }

        $Requests = @(
            @{
                id     = 'Users'
                url    = "users?`$select=id,displayName,userPrincipalName,createdDateTime,lastPasswordChangeDateTime"
                method = 'GET'
            }
            @{
                id     = 'MFADevices'
                url    = "users/$($SuspectUser)/authentication/methods"
                method = 'GET'
            }
            @{
                id     = 'NewSPs'
                url    = "servicePrincipals?`$select=displayName,createdDateTime,appId,appDisplayName,publisher&`$filter=createdDateTime ge $($startDate.ToString('yyyy-MM-ddTHH:mm:ssZ'))"
                method = 'GET'
            }
        )

        Write-Information 'Getting bulk requests'
        $GraphResults = New-GraphBulkRequest -Requests $Requests -tenantid $TenantFilter -asapp $true

        $PasswordChanges = (($GraphResults | Where-Object { $_.id -eq 'Users' }).body.value | Where-Object { $_.lastPasswordChangeDateTime -ge $startDate }) ?? @()
        $NewUsers = (($GraphResults | Where-Object { $_.id -eq 'Users' }).body.value | Where-Object { $_.createdDateTime -ge $startDate }) ?? @()
        $MFADevices = ($GraphResults | Where-Object { $_.id -eq 'MFADevices' }).body.value ?? @()
        $NewSPs = ($GraphResults | Where-Object { $_.id -eq 'NewSPs' }).body.value ?? @()


        $Results = [PSCustomObject]@{
            AddedApps                = @($NewSPs)
            SuspectUserMailboxLogons = @($Last50Logons)
            LastSuspectUserLogon     = @($LastSignIn)
            SuspectUserDevices       = @($Devices)
            NewRules                 = @($RulesLog)
            MailboxPermissionChanges = @($PermissionsLog)
            NewUsers                 = @($NewUsers)
            MFADevices               = @($MFADevices)
            ChangedPasswords         = @($PasswordChanges)
            ExtractedAt              = (Get-Date)
            ExtractResult            = $ExtractResult
        }

        $Entity = @{
            UserId       = $SuspectUser
            Results      = [string]($Results | ConvertTo-Json -Depth 10 -Compress)
            RowKey       = $SuspectUser
            PartitionKey = 'bec'
            Status       = 'Completed'
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
        Write-LogMessage -API 'BECRun' -message "BEC Check run for $UserName" -tenant $TenantFilter -sev 'Info'
    } catch {
        $errMessage = Get-NormalizedError -message $_.Exception.Message
        $CippError = Get-CippException -Exception $_
        $results = [pscustomobject]@{'Results' = "$errMessage"; Exception = $CippError }
        Write-LogMessage -API 'BECRun' -message "Error Running BEC for $($UserName): $errMessage" -tenant $TenantFilter -sev 'Error' -LogData $CIPPError
        $Entity = @{
            UserId       = $SuspectUser
            Results      = [string]($Results | ConvertTo-Json -Depth 10 -Compress)
            RowKey       = $SuspectUser
            PartitionKey = 'bec'
            Status       = 'Error'
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/BEC/Push-BECRun.ps1' 190
#Region './Public/Entrypoints/Activity Triggers/BPA/Push-BPACollectData.ps1' -1

function Push-BPACollectData {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    param($Item)

    $TenantName = Get-Tenants | Where-Object -Property defaultDomainName -EQ $Item.Tenant
    $BPATemplateTable = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'BPATemplate'"
    $TemplatesLoc = (Get-CIPPAzDataTableEntity @BPATemplateTable -Filter $Filter).JSON | ConvertFrom-Json

    $Templates = $TemplatesLoc | ForEach-Object {
        $Template = $_
        [PSCustomObject]@{
            Data  = $Template
            Name  = $Template.Name
            Style = $Template.Style
        }
    }
    $Table = Get-CippTable -tablename 'cachebpav2'

    $Rerun = Test-CIPPRerun -Type 'BPA' -Tenant $Item.Tenant -API $Item.Template
    if ($Rerun) {
        Write-Host 'Detected rerun for BPA. Exiting cleanly'
        exit 0
    }
    Write-Host "Working on BPA for $($TenantName.defaultDomainName) with GUID $($TenantName.customerId) - Report ID $($Item.Template)"
    $Template = $Templates | Where-Object -Property Name -EQ -Value $Item.Template
    # Build up the result object that will be stored in tables
    $Result = @{
        Tenant       = "$($TenantName.displayName)"
        GUID         = "$($TenantName.customerId)"
        RowKey       = "$($Template.Name)"
        PartitionKey = "$($TenantName.customerId)"
        LastRefresh  = [string]$(Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
    }
    foreach ($field in $Template.Data.Fields) {
        if ($field.UseExistingInfo) { continue }
        if ($Field.Where) { $filterscript = [scriptblock]::Create($Field.Where) } else { $filterscript = { $true } }
        try {
            switch ($field.API) {
                'Graph' {
                    $paramsField = @{
                        uri      = $field.URL
                        tenantid = $TenantName.defaultDomainName
                    }
                    if ($Field.Parameters.PSObject.properties.name) {
                        $field.Parameters | ForEach-Object {
                            $paramsField[$_.PSObject.properties.name] = $_.PSObject.properties.value
                        }
                    }
                    $FieldInfo = New-GraphGetRequest @paramsField | Where-Object $filterscript | Select-Object $field.ExtractFields
                }
                'Exchange' {
                    Write-Host "Trying to execute $($field.Command) for $($TenantName.displayName) with GUID $($TenantName.customerId)"
                    if ($field.Command -notlike 'get-*') {
                        Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message 'The BPA only supports get- exchange commands. A set or update command was used.' -sev Error
                        break
                    } else {
                        $paramsField = @{
                            tenantid = $TenantName.defaultDomainName
                            cmdlet   = $field.Command
                        }
                        if ($Field.Parameters) { $paramsField.'cmdParams' = $field.parameters }
                        $FieldInfo = New-ExoRequest @paramsField | Where-Object $filterscript | Select-Object $field.ExtractFields
                    }
                }
                'CIPPFunction' {
                    if ($field.Command -notlike 'get-CIPP*') {
                        Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message 'The BPA only supports get-CIPP commands. A set or update command was used, or a command that is not allowed.' -sev Error
                        break
                    }
                    $paramsField = @{
                        TenantFilter = $TenantName.defaultDomainName
                    }
                    if ($field.Parameters.PSObject.properties.name) {
                        $field.Parameters | ForEach-Object {
                            $paramsField[$_.PSObject.properties.name] = $_.PSObject.properties.value
                        }
                    }
                    $FieldInfo = & $field.Command @paramsField | Where-Object $filterscript | Select-Object $field.ExtractFields
                }
            }
        } catch {
            Write-Information "Error getting $($field.Name) in $($field.api) for $($TenantName.displayName) with GUID $($TenantName.customerId). Error: $($_.Exception.Message)"
            Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message "Error getting $($field.Name) for $($TenantName.displayName) with GUID $($TenantName.customerId). Error: $($_.Exception.Message)" -sev Error -LogData (Get-CippException -Exception $_)
            $FieldInfo = 'FAILED'
            $field.StoreAs = 'string'
        }
        try {
            switch -Wildcard ($field.StoreAs) {
                '*bool' {
                    if ($field.ExtractFields.Count -gt 1) {
                        Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message "The BPA only supports 1 field for a bool. $($field.ExtractFields.Count) fields were specified." -sev Error
                        break
                    }
                    if ($null -eq $FieldInfo.$($field.ExtractFields)) { $FieldInfo = $false }

                    $Result.Add($field.Name, [bool]$FieldInfo.$($field.ExtractFields))
                }
                'JSON' {
                    if ($null -eq $FieldInfo) { $JsonString = '{}' } else { $JsonString = (ConvertTo-Json -Depth 15 -InputObject $FieldInfo -Compress) }
                    Write-Host "Adding $($field.Name) to table with value $JsonString"
                    $Result.Add($field.Name, $JSONString)
                }
                'string' {
                    $Result.Add($field.Name, [string]$FieldInfo)
                }
                'percentage' {

                }
            }
        } catch {
            Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message "Error storing $($field.Name) for $($TenantName.displayName) with GUID $($TenantName.customerId). Error: $($_.Exception.Message)" -sev Error -LogData (Get-CippException -Exception $_)
            $Result.Add($field.Name, 'FAILED')
        }

    }

    if ($Result) {
        try {
            Add-CIPPAzDataTableEntity @Table -Entity $Result -Force
        } catch {
            Write-LogMessage -API 'BPA' -tenant $TenantName.defaultDomainName -message "Error getting saving data for $($template.Name) - $($TenantName.customerId). Error: $($_.Exception.Message)" -LogData (Get-CippException -Exception $_) -sev Error
        }
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/BPA/Push-BPACollectData.ps1' 129
#Region './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-DomainAnalyserDomain.ps1' -1

function Push-DomainAnalyserDomain {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)
    $DomainTable = Get-CippTable -tablename 'Domains'
    $Filter = "PartitionKey eq 'TenantDomains' and RowKey eq '{0}'" -f $Item.RowKey
    $DomainObject = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter | Select-Object * -ExcludeProperty table

    try {
        $ConfigTable = Get-CippTable -tablename Config
        $Filter = "PartitionKey eq 'Domains' and RowKey eq 'Domains'"
        $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter $Filter

        $ValidResolvers = @('Google', 'CloudFlare', 'Quad9')
        if ($ValidResolvers -contains $Config.Resolver) {
            $Resolver = $Config.Resolver
        } else {
            $Resolver = 'Google'
            $Config = @{
                PartitionKey = 'Domains'
                RowKey       = 'Domains'
                Resolver     = $Resolver
            }
            Add-CIPPAzDataTableEntity @ConfigTable -Entity $Config -Force
        }
    } catch {
        $Resolver = 'Google'
    }
    Set-DnsResolver -Resolver $Resolver

    $Domain = $DomainObject.RowKey

    try {
        $Tenant = $DomainObject.TenantDetails | ConvertFrom-Json -ErrorAction Stop
    } catch {
        $Tenant = @{ Tenant = 'None' }
    }

    $Result = [PSCustomObject]@{
        Tenant               = $Tenant.Tenant
        TenantID             = $Tenant.TenantGUID
        GUID                 = $($Domain.Replace('.', ''))
        LastRefresh          = $(Get-Date (Get-Date).ToUniversalTime() -UFormat '+%Y-%m-%dT%H:%M:%S.000Z')
        Domain               = $Domain
        NSRecords            = (Read-NSRecord -Domain $Domain).Records
        ExpectedSPFRecord    = ''
        ActualSPFRecord      = ''
        SPFPassAll           = ''
        ActualMXRecords      = ''
        MXPassTest           = ''
        DMARCPresent         = ''
        DMARCFullPolicy      = ''
        DMARCActionPolicy    = ''
        DMARCReportingActive = ''
        DMARCPercentagePass  = ''
        DNSSECPresent        = ''
        MailProvider         = ''
        DKIMEnabled          = ''
        DKIMRecords          = ''
        MSCNAMEDKIMSelectors = ''
        Score                = ''
        MaximumScore         = 160
        ScorePercentage      = ''
        ScoreExplanation     = ''
    }

    $Scores = [PSCustomObject]@{
        SPFPresent           = 10
        SPFCorrectAll        = 20
        MXRecommended        = 10
        DMARCPresent         = 10
        DMARCSetQuarantine   = 20
        DMARCSetReject       = 30
        DMARCReportingActive = 20
        DMARCPercentageGood  = 20
        DNSSECPresent        = 20
        DKIMActiveAndWorking = 20
    }

    $ScoreDomain = 0
    # Setup Score Explanation
    $ScoreExplanation = [System.Collections.Generic.List[string]]::new()

    #Region MX Check
    $MXRecord = Read-MXRecord -Domain $Domain -ErrorAction Stop

    $Result.ExpectedSPFRecord = $MXRecord.ExpectedInclude
    $Result.MXPassTest = $false
    $Result.ActualMXRecords = $MXRecord.Records

    # Check fail counts to ensure all tests pass
    #$MXWarnCount = $MXRecord.ValidationWarns | Measure-Object | Select-Object -ExpandProperty Count
    $MXFailCount = $MXRecord.ValidationFails | Measure-Object | Select-Object -ExpandProperty Count

    if ($MXFailCount -eq 0) {
        $Result.MXPassTest = $true
        $ScoreDomain += $Scores.MXRecommended
    } else {
        $ScoreExplanation.Add('MX record did not pass validation') | Out-Null
    }

    if ([string]::IsNullOrEmpty($MXRecord.MailProvider)) {
        $Result.MailProvider = 'Unknown'
    } else {
        $Result.MailProvider = $MXRecord.MailProvider.Name
    }
    #EndRegion MX Check

    #Region SPF Check
    try {
        $SPFRecord = Read-SpfRecord -Domain $Domain -ErrorAction Stop
        if ($SPFRecord.RecordCount -gt 0) {
            $Result.ActualSPFRecord = $SPFRecord.Record
            if ($SPFRecord.RecordCount -eq 1) {
                $ScoreDomain += $Scores.SPFPresent
            } else {
                $ScoreExplanation.Add('Multiple SPF records detected') | Out-Null
            }
        } else {
            $Result.ActualSPFRecord = 'No SPF Record'
            $ScoreExplanation.Add('No SPF Record Found') | Out-Null
        }
    } catch {
        $Message = 'SPF Error'
        Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message $Message -LogData (Get-CippException -Exception $_) -sev Error
    }


    # Check warning + fail counts to ensure all tests pass
    #$SPFWarnCount = $SPFRecord.ValidationWarns | Measure-Object | Select-Object -ExpandProperty Count
    $SPFFailCount = $SPFRecord.ValidationFails | Measure-Object | Select-Object -ExpandProperty Count
    $Result.SPFPassAll = $false

    if ($SPFFailCount -eq 0) {
        $ScoreDomain += $Scores.SPFCorrectAll
        $Result.SPFPassAll = $true
    } else {
        $ScoreExplanation.Add('SPF record did not pass validation') | Out-Null
    }
    #EndRegion SPF Check

    #Region DMARC Check
    try {
        $DMARCPolicy = Read-DmarcPolicy -Domain $Domain -ErrorAction Stop

        if ([string]::IsNullOrEmpty($DMARCPolicy.Record)) {
            $Result.DMARCPresent = $false
            $ScoreExplanation.Add('No DMARC Records Found') | Out-Null
        } else {
            $Result.DMARCPresent = $true
            $ScoreDomain += $Scores.DMARCPresent

            $Result.DMARCFullPolicy = $DMARCPolicy.Record
            if ($DMARCPolicy.Policy -eq 'reject' -and $DMARCPolicy.SubdomainPolicy -eq 'reject') {
                $Result.DMARCActionPolicy = 'Reject'
                $ScoreDomain += $Scores.DMARCSetReject
            }
            if ($DMARCPolicy.Policy -eq 'none') {
                $Result.DMARCActionPolicy = 'None'
                $ScoreExplanation.Add('DMARC is not being enforced') | Out-Null
            }
            if ($DMARCPolicy.Policy -eq 'quarantine') {
                $Result.DMARCActionPolicy = 'Quarantine'
                $ScoreDomain += $Scores.DMARCSetQuarantine
                $ScoreExplanation.Add('DMARC Partially Enforced with quarantine') | Out-Null
            }

            $ReportEmailCount = $DMARCPolicy.ReportingEmails | Measure-Object | Select-Object -ExpandProperty Count
            if ($ReportEmailCount -gt 0) {
                $Result.DMARCReportingActive = $true
                $ScoreDomain += $Scores.DMARCReportingActive
            } else {
                $Result.DMARCReportingActive = $False
                $ScoreExplanation.Add('DMARC Reporting not Configured') | Out-Null
            }

            if ($DMARCPolicy.Percent -eq 100) {
                $Result.DMARCPercentagePass = $true
                $ScoreDomain += $Scores.DMARCPercentageGood
            } else {
                $Result.DMARCPercentagePass = $false
                $ScoreExplanation.Add('DMARC Not Checking All Messages') | Out-Null
            }
        }
    } catch {
        $Message = 'DMARC Error'
        Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message $Message -LogData (Get-CippException -Exception $_) -sev Error
        #return $Message
    }
    #EndRegion DMARC Check

    #Region DNS Sec Check
    try {
        $DNSSECResult = Test-DNSSEC -Domain $Domain -ErrorAction Stop
        $DNSSECFailCount = $DNSSECResult.ValidationFails | Measure-Object | Select-Object -ExpandProperty Count
        $DNSSECWarnCount = $DNSSECResult.ValidationFails | Measure-Object | Select-Object -ExpandProperty Count
        if (($DNSSECFailCount + $DNSSECWarnCount) -eq 0) {
            $Result.DNSSECPresent = $true
            $ScoreDomain += $Scores.DNSSECPresent
        } else {
            $Result.DNSSECPresent = $false
            $ScoreExplanation.Add('DNSSEC Not Configured or Enabled') | Out-Null
        }
    } catch {
        $Message = 'DNSSEC Error'
        Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message $Message -LogData (Get-CippException -Exception $_) -sev Error
        #return $Message
    }
    #EndRegion DNS Sec Check

    #Region DKIM Check
    try {
        $DkimParams = @{
            Domain                       = $Domain
            FallbackToMicrosoftSelectors = $true
        }
        if (![string]::IsNullOrEmpty($DomainObject.DkimSelectors)) {
            $DkimParams.Selectors = $DomainObject.DkimSelectors | ConvertFrom-Json
        }
        # Check if its a onmicrosoft.com domain and add special selectors for these
        if ($Domain -match 'onmicrosoft.com' -and $Domain -notmatch 'mail.onmicrosoft.com') {
            $DKIMSelector1Value = "selector1-$($Domain -replace '\.', '-' )"
            $DKIMSelector2Value = "selector2-$($Domain -replace '\.', '-' )"
            $DkimParams.Add('Selectors', @("$DKIMSelector1Value", "$DKIMSelector2Value"))
        }

        $DkimRecord = Read-DkimRecord @DkimParams -ErrorAction Stop

        $DkimRecordCount = $DkimRecord.Records | Measure-Object | Select-Object -ExpandProperty Count
        $DkimFailCount = $DkimRecord.ValidationFails | Measure-Object | Select-Object -ExpandProperty Count
        #$DkimWarnCount = $DkimRecord.ValidationWarns | Measure-Object | Select-Object -ExpandProperty Count
        if ($DkimRecordCount -gt 0 -and $DkimFailCount -eq 0) {
            $Result.DKIMEnabled = $true
            $ScoreDomain += $Scores.DKIMActiveAndWorking
            $Result.DKIMRecords = $DkimRecord.Records | Select-Object Selector, Record
        } else {
            $Result.DKIMEnabled = $false
            $ScoreExplanation.Add('DKIM Not Configured') | Out-Null
        }
    } catch {
        $Message = 'DKIM Exception'
        Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message $Message -LogData (Get-CippException -Exception $_) -sev Error
        #return $Message
    }
    #EndRegion DKIM Check

    #Region MSCNAME DKIM Records
    # Get Microsoft DKIM CNAME selector Records
    # Ugly, but i needed to create a scope/loop i could break out of without breaking the rest of the function
    foreach ($d in $Domain) {
        try {
            # Test if DKIM is enabled, skip domain if it is
            if ($Result.DKIMEnabled -eq $true) {
                continue
            }
            # Test if its a onmicrosoft.com domain, skip domain if it is
            if ($Domain -match 'onmicrosoft.com') {
                continue
            }
            # Test if there are already MSCNAME values set, skip domain if there is
            if ($null -ne $DomainObject.DomainAnalyser) {
                $CurrentMSCNAMEInfo = ConvertFrom-Json $DomainObject.DomainAnalyser -Depth 10
                if (![string]::IsNullOrWhiteSpace($CurrentMSCNAMEInfo.MSCNAMEDKIMSelectors.selector1.Value) -and
                    ![string]::IsNullOrWhiteSpace($CurrentMSCNAMEInfo.MSCNAMEDKIMSelectors.selector2.Value)) {
                    $Result.MSCNAMEDKIMSelectors = $CurrentMSCNAMEInfo.MSCNAMEDKIMSelectors
                    continue
                }
            }

            # Get the DKIM record from EXO. This is the only way to get the correct values for the MSCNAME records since the new format was introduced in May 2025.
            $DKIM = (New-ExoRequest -tenantid $Tenant.Tenant -cmdlet 'Get-DkimSigningConfig' -Select 'Domain,Selector1CNAME,Selector2CNAME') | Where-Object { $_.Domain -eq $Domain }

            # If no DKIM signing record is found, create a new disabled one
            if ($null -eq $DKIM) {
                Write-Information 'No DKIM record found in EXO - Creating new signing'
                $NewDKIMSigningRequest = New-ExoRequest -tenantid $Tenant.Tenant -cmdlet 'New-DkimSigningConfig' -cmdParams @{  KeySize = 2048; DomainName = $Domain; Enabled = $false }
                $Selector1Value = $NewDKIMSigningRequest.Selector1CNAME
                $Selector2Value = $NewDKIMSigningRequest.Selector2CNAME
            } else {
                $Selector1Value = $DKIM.Selector1CNAME
                $Selector2Value = $DKIM.Selector2CNAME
            }


            # Create the MSCNAME object
            $MSCNAMERecords = [PSCustomObject]@{
                Domain    = $Domain
                selector1 = @{
                    Hostname = 'selector1._domainkey'
                    Value    = $Selector1Value
                }
                selector2 = @{
                    Hostname = 'selector2._domainkey'
                    Value    = $Selector2Value
                }
            }
            $Result.MSCNAMEDKIMSelectors = $MSCNAMERecords
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message "MS CNAME DKIM error: $($ErrorMessage.NormalizedError)" -LogData $ErrorMessage -sev Error
        }
    }
    #EndRegion MSCNAME DKIM Records
    # Final Score
    $Result.Score = $ScoreDomain
    $Result.ScorePercentage = [int](($Result.Score / $Result.MaximumScore) * 100)
    $Result.ScoreExplanation = ($ScoreExplanation) -join ', '

    $Json = (ConvertTo-Json -InputObject $Result -Depth 5 -Compress).ToString()

    if ($DomainObject.PSObject.Properties.Name -notcontains 'DomainAnalyser') {
        $DomainObject | Add-Member -MemberType NoteProperty -Name DomainAnalyser -Value $Json
    } else {
        $DomainObject.DomainAnalyser = $Json
    }

    try {
        $DomainTable.Entity = $DomainObject
        $DomainTable.Force = $true
        Add-CIPPAzDataTableEntity @DomainTable -Entity $DomainObject -Force
    } catch {
        Write-LogMessage -API 'DomainAnalyser' -tenant $DomainObject.TenantId -message "Error saving domain $Domain to table " -sev Error -LogData (Get-CippException -Exception $_)
    }
    return $Result
}
#EndRegion './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-DomainAnalyserDomain.ps1' 328
#Region './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-DomainAnalyserTenant.ps1' -1

function Push-DomainAnalyserTenant {
    <#
        .FUNCTIONALITY
            Entrypoint
        #>
    param($Item)

    $Tenant = Get-Tenants -IncludeAll | Where-Object { $_.customerId -eq $Item.customerId } | Select-Object -First 1
    $DomainTable = Get-CippTable -tablename 'Domains'

    if ($Tenant.Excluded -eq $true) {
        $Filter = "PartitionKey eq 'TenantDomains' and TenantId eq '{0}'" -f $Tenant.defaultDomainName
        $CleanupRows = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter
        $CleanupCount = ($CleanupRows | Measure-Object).Count
        if ($CleanupCount -gt 0) {
            Write-LogMessage -API 'DomainAnalyser' -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -message "Cleaning up $CleanupCount domain(s) for excluded tenant" -sev Info
            Remove-AzDataTableEntity -Force @DomainTable -Entity $CleanupRows
        }
    } elseif ($Tenant.GraphErrorCount -gt 50) {
        return
    } else {
        try {
            # Remove domains that are not wanted, and used for cloud signature services. Same exclusions also found in Invoke-CIPPStandardAddDKIM
            $ExclusionDomains = @(
                '*.microsoftonline.com'
                '*.mail.onmicrosoft.com'
                '*.exclaimer.cloud'
                '*.excl.cloud'
                '*.codetwo.online'
                '*.call2teams.com'
                '*.signature365.net'
                '*.myteamsconnect.io'
                '*.teams.dstny.com'
                '*.msteams.8x8.com'
                '*.ucconnect.co.uk'
                '*.teams-sbc.dk'
            )
            $Domains = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/domains' -tenantid $Tenant.customerId | Where-Object { $_.isVerified -eq $true } | ForEach-Object {
                $Domain = $_
                foreach ($ExclusionDomain in $ExclusionDomains) {
                    if ($Domain.id -like $ExclusionDomain) {
                        $Domain = $null
                    }
                }
                $Domain
            } | Where-Object { $_ -ne $null }

            $TenantDomains = foreach ($d in $Domains) {
                [PSCustomObject]@{
                    Tenant             = $Tenant.defaultDomainName
                    TenantGUID         = $Tenant.customerId
                    InitialDomainName  = $Tenant.initialDomainName
                    Domain             = $d.id
                    AuthenticationType = $d.authenticationType
                    IsAdminManaged     = $d.isAdminManaged
                    IsDefault          = $d.isDefault
                    IsInitial          = $d.isInitial
                    IsRoot             = $d.isRoot
                    IsVerified         = $d.isVerified
                    SupportedServices  = $d.supportedServices
                }
            }

            $DomainCount = ($TenantDomains | Measure-Object).Count
            if ($DomainCount -gt 0) {
                Write-Host "############# $DomainCount tenant Domains"
                $TenantDomainObjects = [System.Collections.Generic.List[object]]::new()
                try {
                    foreach ($TenantDomain in $TenantDomains) {
                        $TenantDetails = ($TenantDomain | ConvertTo-Json -Compress).ToString()
                        $Filter = "PartitionKey eq '{0}' and RowKey eq '{1}'" -f $TenantDomain.Tenant, $TenantDomain.Domain
                        $OldDomain = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter

                        if ($OldDomain) {
                            Remove-AzDataTableEntity -Force @DomainTable -Entity $OldDomain | Out-Null
                        }

                        $Filter = "PartitionKey eq 'TenantDomains' and RowKey eq '{0}'" -f $TenantDomain.Domain
                        $Domain = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter

                        if (!$Domain -or $null -eq $TenantDomain.TenantGUID) {
                            $Domain = [pscustomobject]@{
                                DomainAnalyser = ''
                                TenantDetails  = $TenantDetails
                                TenantId       = $TenantDomain.Tenant
                                TenantGUID     = $TenantDomain.TenantGUID
                                DkimSelectors  = ''
                                MailProviders  = ''
                                RowKey         = $TenantDomain.Domain
                                PartitionKey   = 'TenantDomains'
                            }

                            if ($OldDomain) {
                                $DomainObject.DkimSelectors = $OldDomain.DkimSelectors
                                $DomainObject.MailProviders = $OldDomain.MailProviders
                            }
                        } else {
                            $Domain.TenantDetails = $TenantDetails
                            if ($OldDomain) {
                                $Domain.DkimSelectors = $OldDomain.DkimSelectors
                                $Domain.MailProviders = $OldDomain.MailProviders
                            }
                            # Fix tenant info in the event of a default domain name change in a tenant
                            $Domain | Add-Member -MemberType NoteProperty -Name 'TenantId' -Value $TenantDomain.Tenant -Force
                            $Domain | Add-Member -MemberType NoteProperty -Name 'TenantGUID' -Value $TenantDomain.TenantGUID -Force
                        }
                        # Return domain object to list
                        $TenantDomainObjects.Add($Domain)
                    }

                    # Batch insert tenant domains
                    try {
                        Add-CIPPAzDataTableEntity @DomainTable -Entity $TenantDomainObjects -Force
                        $InputObject = [PSCustomObject]@{
                            QueueFunction    = @{
                                FunctionName = 'GetTenantDomains'
                                TenantGUID   = $Tenant.customerId
                            }
                            OrchestratorName = "DomainAnalyser_$($Tenant.defaultDomainName)"
                            PostExecution    = @{
                                FunctionName = 'GetDomainAnalyserResults'
                                Parameters   = @{
                                    Tenant = $Tenant
                                }
                            }
                        }
                        Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
                        Write-Host "Started analysis for $DomainCount tenant domains in $($Tenant.defaultDomainName)"
                        Write-LogMessage -Tenant $Tenant.defaultDomainName -TenantId $Tenant.customerId -API 'DomainAnalyser' -message "Started analysis for $DomainCount tenant domains" -sev Info
                    } catch {
                        Write-LogMessage -Tenant $Tenant.defaultDomainName -TenantId $Tenant.customerId -API 'DomainAnalyser' -message 'Domain Analyser GetTenantDomains error' -sev 'Error' -LogData (Get-CippException -Exception $_)
                    }
                } catch {
                    Write-LogMessage -Tenant $Tenant.defaultDomainName -TenantId $Tenant.customerId -API 'DomainAnalyser' -message 'GetTenantDomains loop error' -sev 'Error' -LogData (Get-CippException -Exception $_)
                }
            }
        } catch {
            #Write-Host (Get-CippException -Exception $_ | ConvertTo-Json)
            Write-LogMessage -Tenant $Tenant.defaultDomainName -TenantId $Tenant.customerId -API 'DomainAnalyser' -message 'DNS Analyser GraphGetRequest' -LogData (Get-CippException -Exception $_) -sev Error
        }
    }
    return $null
}
#EndRegion './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-DomainAnalyserTenant.ps1' 144
#Region './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-GetDomainAnalyserResults.ps1' -1

function Push-GetDomainAnalyserResults {
    [CmdletBinding()]
    param (
        $Item
    )

    $Tenant = $Item.Parameters.Tenant
    Write-LogMessage -API 'DomainAnalyser' -Tenant $Tenant.defaultDomainName -TenantId $Tenant.customerId -message "Domain Analyser completed for tenant $($Tenant.defaultDomainName)" -sev Info -LogData ($Item.Results | Select-Object Domain, @{Name = 'Score'; Expression = { "$($_.Score)/$($_.MaximumScore)" } })
    return
}
#EndRegion './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-GetDomainAnalyserResults.ps1' 11
#Region './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-GetTenantDomains.ps1' -1

function Push-GetTenantDomains {
    Param($Item)
    $DomainTable = Get-CippTable -tablename 'Domains'
    $Filter = "PartitionKey eq 'TenantDomains' and TenantGUID eq '{0}'" -f $Item.TenantGUID
    $Domains = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter -Property PartitionKey, RowKey | Select-Object RowKey, @{n = 'FunctionName'; exp = { 'DomainAnalyserDomain' } }
    return @($Domains)
}
#EndRegion './Public/Entrypoints/Activity Triggers/Domain Analyser/Push-GetTenantDomains.ps1' 8
#Region './Public/Entrypoints/Activity Triggers/Graph Requests/Push-ListGraphRequestQueue.ps1' -1

function Push-ListGraphRequestQueue {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    param($Item)

    Write-Information "PowerShell durable function processed work item: $($Item.Endpoint) - $($Item.TenantFilter)"

    try {
        $ParamCollection = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)

        $Parameters = $Item.Parameters | ConvertTo-Json -Depth 5 | ConvertFrom-Json -AsHashtable
        foreach ($Param in ($Parameters.GetEnumerator() | Sort-Object -CaseSensitive -Property Key)) {
            $ParamCollection.Add($Param.Key, $Param.Value)
        }

        $PartitionKey = $Item.PartitionKey

        $TableName = ('cache{0}' -f ($Item.Endpoint -replace '[^A-Za-z0-9]'))[0..62] -join ''
        Write-Information "Queue Table: $TableName"
        $Table = Get-CIPPTable -TableName $TableName

        $Filter = "PartitionKey eq '{0}' and (RowKey eq '{1}' or OriginalEntityId eq '{1}')" -f $PartitionKey, $Item.TenantFilter
        Write-Information "Filter: $Filter"
        $Existing = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey, OriginalEntityId
        if ($Existing) {
            $null = Remove-AzDataTableEntity -Force @Table -Entity $Existing
        }
        $GraphRequestParams = @{
            TenantFilter                = $Item.TenantFilter
            Endpoint                    = $Item.Endpoint
            Parameters                  = $Parameters
            NoPagination                = $Item.NoPagination
            ReverseTenantLookupProperty = $Item.ReverseTenantLookupProperty
            ReverseTenantLookup         = $Item.ReverseTenantLookup
            AsApp                       = $Item.AsApp ?? $false
            Caller                      = 'Push-ListGraphRequestQueue'
            SkipCache                   = $true
        }

        $RawGraphRequest = try {
            $Results = Get-GraphRequestList @GraphRequestParams
            if ($Results[-1].PSObject.Properties.Name -contains 'nextLink') {
                $Results | Select-Object -First ($Results.Count - 1)
            } else {
                $Results
            }
        } catch {
            $CippException = Get-CippException -Exception $_.Exception
            [PSCustomObject]@{
                Tenant        = $Item.TenantFilter
                CippStatus    = "Could not connect to tenant. $($CippException.NormalizedMessage)"
                CippException = [string]($CippException | ConvertTo-Json -Depth 10 -Compress)
            }
        }
        $Json = ConvertTo-Json -Depth 10 -Compress -InputObject $RawGraphRequest
        $GraphResults = [PSCustomObject]@{
            PartitionKey = [string]$PartitionKey
            RowKey       = [string]$Item.TenantFilter
            QueueId      = [string]$Item.QueueId
            QueueType    = [string]$Item.QueueType
            Data         = [string]$Json
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphResults -Force | Out-Null
        return $true
    } catch {
        Write-Warning "Queue Error: $($_.Exception.Message)"
        #Write-Information ($GraphResults | ConvertTo-Json -Depth 10 -Compress)
        throw $_
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Graph Requests/Push-ListGraphRequestQueue.ps1' 73
#Region './Public/Entrypoints/Activity Triggers/Maintenance/Push-TableCleanupTask.ps1' -1

function Push-TableCleanupTask {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        [Parameter(Mandatory = $true)]
        $Item
    )

    $Type = $Item.Type
    Write-Information "#### Starting $($Type) task..."
    if ($PSCmdlet.ShouldProcess('Start-TableCleanup', 'Starting Table Cleanup')) {
        if ($Type -eq 'DeleteTable') {
            $DeleteTables = $Item.Tables
            foreach ($Table in $DeleteTables) {
                try {
                    $Table = Get-CIPPTable -tablename $Table
                    if ($Table) {
                        Write-Information "Deleting table $($Table.Context.TableName)"
                        try {
                            Remove-AzDataTable -Context $Table.Context -Force
                        } catch {
                            #Write-LogMessage -API 'TableCleanup' -message "Failed to delete table $($Table.Context.TableName)" -sev Error -LogData (Get-CippException -Exception $_)
                        }
                    }
                } catch {
                    Write-Information "Table $Table not found"
                }
            }
            Write-Information "#### $($Type) task complete for $($Item.TableName)"
        } elseif ($Type -eq 'CleanupRule') {
            if ($Item.Where) {
                $Where = [scriptblock]::Create($Item.Where)
            } else {
                $Where = { $true }
            }

            $DataTableProps = $Item.DataTableProps | ConvertTo-Json | ConvertFrom-Json -AsHashtable
            $Table = Get-CIPPTable -tablename $Item.TableName
            $CleanupCompleted = $false

            $RowsRemoved = 0
            do {
                Write-Information "Fetching entities from $($Item.TableName) with filter: $($DataTableProps.Filter)"
                try {
                    $Entities = Get-AzDataTableEntity @Table @DataTableProps | Where-Object $Where
                    if ($Entities) {
                        Write-Information "Removing $($Entities.Count) entities from $($Item.TableName)"
                        try {
                            Remove-AzDataTableEntity @Table -Entity $Entities -Force
                            $RowsRemoved += $Entities.Count
                            if ($DataTableProps.First -and $Entities.Count -lt $DataTableProps.First) {
                                $CleanupCompleted = $true
                            }
                        } catch {
                            Write-LogMessage -API 'TableCleanup' -message "Failed to remove entities from $($Item.TableName)" -sev Error -LogData (Get-CippException -Exception $_)
                            $CleanupCompleted = $true
                        }
                    } else {
                        Write-Information "No entities found for cleanup in $($Item.TableName)"
                        $CleanupCompleted = $true
                    }
                } catch {
                    Write-Warning "Failed to fetch entities from $($Item.TableName): $($_.Exception.Message)"
                    $CleanupCompleted = $true
                }
            } while (!$CleanupCompleted)
            Write-Information "#### $($Type) task complete for $($Item.TableName). Rows removed: $RowsRemoved"
        } else {
            Write-Warning "Unknown task type: $Type"
        }
    }

}
#EndRegion './Public/Entrypoints/Activity Triggers/Maintenance/Push-TableCleanupTask.ps1' 73
#Region './Public/Entrypoints/Activity Triggers/Push-CIPPAccessTenantTest.ps1' -1

function Push-CIPPAccessTenantTest {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    Param($Item)

    Test-CIPPAccessTenant -Tenant $Item.customerId -Headers 'CIPP'
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-CIPPAccessTenantTest.ps1' 10
#Region './Public/Entrypoints/Activity Triggers/Push-ExecAddMultiTenantApp.ps1' -1

function Push-ExecAddMultiTenantApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)
    try {
        $Item = $Item | ConvertTo-Json -Depth 10 | ConvertFrom-Json
        Write-Host "$($Item | ConvertTo-Json -Depth 10)"
        $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -tenantid $Item.Tenant
        if ($Item.AppId -Notin $ServicePrincipalList.appId) {
            $PostResults = New-GraphPostRequest 'https://graph.microsoft.com/beta/servicePrincipals' -type POST -tenantid $Item.tenant -body "{ `"appId`": `"$($Item.appId)`" }"
            Write-LogMessage -message "Added $($Item.AppId) to tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Info
        } else {
            Write-LogMessage -message "This app already exists in tenant $($Item.Tenant). We're adding the required permissions." -tenant $Item.Tenant -API 'Add Multitenant App' -sev Info
        }
        Add-CIPPApplicationPermission -RequiredResourceAccess ($Item.applicationResourceAccess) -ApplicationId $Item.AppId -Tenantfilter $Item.Tenant
        Add-CIPPDelegatedPermission -RequiredResourceAccess ($Item.DelegateResourceAccess) -ApplicationId $Item.AppId -Tenantfilter $Item.Tenant
    } catch {
        Write-LogMessage -message "Error adding application to tenant $($Item.Tenant) - $($_.Exception.Message)" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecAddMultiTenantApp.ps1' 24
#Region './Public/Entrypoints/Activity Triggers/Push-ExecAlertsListAllTenants.ps1' -1

function Push-ExecAlertsListAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName 'cachealertsandincidents'

    try {
        $Alerts = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/security/alerts' -tenantid $domainName
        foreach ($Alert in $Alerts) {
            $GUID = (New-Guid).Guid
            $alertJson = $Alert | ConvertTo-Json
            $GraphRequest = @{
                Alert        = [string]$alertJson
                RowKey       = [string]$GUID
                Tenant       = $domainName
                PartitionKey = 'alert'
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
        }

    } catch {
        $GUID = (New-Guid).Guid
        $AlertText = ConvertTo-Json -InputObject @{
            Title             = "Could not connect to tenant to retrieve data: $($_.Exception.Message)"
            Id                = ''
            Category          = ''
            EventDateTime     = ''
            Severity          = ''
            Status            = ''
            userStates        = @('None')
            vendorInformation = @{
                vendor   = 'CIPP'
                provider = 'CIPP'
            }
        }
        $GraphRequest = @{
            Alert        = [string]$AlertText
            RowKey       = [string]$GUID
            PartitionKey = 'alert'
            Tenant       = $domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecAlertsListAllTenants.ps1' 51
#Region './Public/Entrypoints/Activity Triggers/Push-ExecAppApprovalTemplate.ps1' -1

function Push-ExecAppApprovalTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    try {
        $Item = $Item | ConvertTo-Json -Depth 10 | ConvertFrom-Json
        $TemplateId = $Item.templateId
        if (!$TemplateId) {
            Write-LogMessage -message 'No template specified' -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
            return $false
        }

        # Get the template data to determine if it's a Gallery Template or Enterprise App
        $Table = Get-CIPPTable -TableName 'templates'
        $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$TemplateId'"

        if (!$Template) {
            Write-LogMessage -message "Template $TemplateId not found" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
            return $false
        }

        $TemplateData = $Template.JSON | ConvertFrom-Json
        # Default to EnterpriseApp for backward compatibility with older templates
        $AppType = $TemplateData.AppType
        if (-not $AppType) {
            $AppType = 'EnterpriseApp'
        }

        # Handle Gallery Templates
        if ($AppType -eq 'GalleryTemplate') {
            Write-Information "Deploying Gallery Template $($TemplateData.AppName) to tenant $($Item.Tenant)."

            # Use the Gallery Template instantiation API
            $GalleryTemplateId = $TemplateData.GalleryTemplateId
            if (!$GalleryTemplateId) {
                Write-LogMessage -message 'Gallery Template ID not found in template data' -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
                return $false
            }

            # Check if the app already exists in the tenant
            $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -tenantid $Item.Tenant
            if ($TemplateData.GalleryTemplateId -in $ServicePrincipalList.applicationTemplateId) {
                Write-LogMessage -message "Gallery Template app $($TemplateData.AppName) already exists in tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add Gallery App' -sev Info
                return $true
            }

            # Instantiate the gallery template
            $InstantiateBody = @{
                displayName = $TemplateData.AppName
            } | ConvertTo-Json -Depth 10

            $InstantiateResult = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/applicationTemplates/$GalleryTemplateId/instantiate" -type POST -tenantid $Item.tenant -body $InstantiateBody

            if ($InstantiateResult.application.appId) {
                Write-LogMessage -message "Successfully deployed Gallery Template $($TemplateData.AppName) to tenant $($Item.Tenant). Application ID: $($InstantiateResult.application.appId)" -tenant $Item.Tenant -API 'Add Gallery App' -sev Info
                # Get application registration
                $App = $InstantiateResult.application.appId
                $Application = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications(appId='$App')" -tenantid $Item.tenant -AsApp $true
                if ($Application.requiredResourceAccess) {
                    Add-CIPPDelegatedPermission -RequiredResourceAccess $Application.requiredResourceAccess -ApplicationId $App -Tenantfilter $Item.Tenant
                    Add-CIPPApplicationPermission -RequiredResourceAccess $Application.requiredResourceAccess -ApplicationId $App -Tenantfilter $Item.Tenant
                }
            } else {
                Write-LogMessage -message "Gallery Template deployment completed but application ID not returned for $($TemplateData.AppName) in tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add Gallery App' -sev Warning
            }

        } elseif ($AppType -eq 'ApplicationManifest') {
            Write-Information "Deploying Application Manifest $($TemplateData.AppName) to tenant $($Item.Tenant)."

            # Get the application manifest from template data
            $ApplicationManifest = $TemplateData.ApplicationManifest
            if (!$ApplicationManifest) {
                Write-LogMessage -message 'Application Manifest not found in template data' -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
                return $false
            }

            # Check for existing application by display name
            $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -tenantid $Item.Tenant
            $ExistingApp = $ServicePrincipalList | Where-Object { $_.displayName -eq $TemplateData.AppName }
            if ($ExistingApp) {
                Write-LogMessage -message "Application with name '$($TemplateData.AppName)' already exists in tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add App Manifest' -sev Info

                # get existing application
                $App = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications(appId='$($ExistingApp.appId)')" -tenantid $Item.Tenant

                # compare permissions
                $ExistingPermissions = $App.requiredResourceAccess | ConvertTo-Json -Depth 10
                $NewPermissions = $ApplicationManifest.requiredResourceAccess | ConvertTo-Json -Depth 10
                if ($ExistingPermissions -ne $NewPermissions) {
                    Write-LogMessage -message "Updating permissions for existing application '$($TemplateData.AppName)' in tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add App Manifest' -sev Info

                    # Update permissions for existing application
                    $UpdateBody = @{
                        requiredResourceAccess = $ApplicationManifest.requiredResourceAccess
                    } | ConvertTo-Json -Depth 10
                    $null = New-GraphPostRequest -type PATCH -uri "https://graph.microsoft.com/beta/applications(appId='$($ExistingApp.appId)')" -tenantid $Item.Tenant -body $UpdateBody

                    # consent new permissions
                    Add-CIPPDelegatedPermission -RequiredResourceAccess $ApplicationManifest.requiredResourceAccess -ApplicationId $ExistingApp.appId -Tenantfilter $Item.Tenant
                    Add-CIPPApplicationPermission -RequiredResourceAccess $ApplicationManifest.requiredResourceAccess -ApplicationId $ExistingApp.appId -Tenantfilter $Item.Tenant
                }

                return $true
            }

            $PropertiesToRemove = @('appId', 'id', 'createdDateTime', 'publisherDomain', 'servicePrincipalLockConfiguration', 'identifierUris', 'applicationIdUris')

            # Strip tenant-specific data that might cause conflicts
            $CleanManifest = $ApplicationManifest | ConvertTo-Json -Depth 10 | ConvertFrom-Json
            foreach ($Property in $PropertiesToRemove) {
                $CleanManifest.PSObject.Properties.Remove($Property)
            }

            # Create the application from manifest
            try {
                $CreateBody = $CleanManifest | ConvertTo-Json -Depth 10
                $CreatedApp = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/applications' -type POST -tenantid $Item.tenant -body $CreateBody

                if ($CreatedApp.appId) {
                    # Create service principal for the application
                    $ServicePrincipalBody = @{
                        appId = $CreatedApp.appId
                    } | ConvertTo-Json

                    $null = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/servicePrincipals' -type POST -tenantid $Item.tenant -body $ServicePrincipalBody

                    Write-LogMessage -message "Successfully deployed Application Manifest $($TemplateData.AppName) to tenant $($Item.Tenant). Application ID: $($CreatedApp.appId)" -tenant $Item.Tenant -API 'Add App Manifest' -sev Info

                    if ($CreatedApp.requiredResourceAccess) {
                        Add-CIPPDelegatedPermission -RequiredResourceAccess $CreatedApp.requiredResourceAccess -ApplicationId $CreatedApp.appId -Tenantfilter $Item.Tenant
                        Add-CIPPApplicationPermission -RequiredResourceAccess $CreatedApp.requiredResourceAccess -ApplicationId $CreatedApp.appId -Tenantfilter $Item.Tenant
                    }
                } else {
                    Write-LogMessage -message "Application Manifest deployment failed - no application ID returned for $($TemplateData.AppName) in tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add App Manifest' -sev Error
                }
            } catch {
                Write-LogMessage -message "Error creating application from manifest in tenant $($Item.Tenant) - $($_.Exception.Message)" -tenant $Item.Tenant -API 'Add App Manifest' -sev Error
                throw $_.Exception.Message
            }

        } else {
            # Handle Enterprise Apps (existing logic)
            $ServicePrincipalList = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=AppId,id,displayName&`$top=999" -tenantid $Item.Tenant
            if ($Item.AppId -notin $ServicePrincipalList.appId) {
                Write-Information "Adding $($Item.AppId) to tenant $($Item.Tenant)."
                $PostResults = New-GraphPostRequest 'https://graph.microsoft.com/beta/servicePrincipals' -type POST -tenantid $Item.tenant -body "{ `"appId`": `"$($Item.appId)`" }"
                Write-LogMessage -message "Added $($Item.AppId) to tenant $($Item.Tenant)" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Info
            } else {
                Write-LogMessage -message "This app already exists in tenant $($Item.Tenant). We're adding the required permissions." -tenant $Item.Tenant -API 'Add Multitenant App' -sev Info
            }
            Add-CIPPApplicationPermission -TemplateId $TemplateId -Tenantfilter $Item.Tenant
            Add-CIPPDelegatedPermission -TemplateId $TemplateId -Tenantfilter $Item.Tenant
        }
    } catch {
        Write-LogMessage -message "Error adding application to tenant $($Item.Tenant) - $($_.Exception.Message)" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
        Write-Error $_.Exception.Message
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecAppApprovalTemplate.ps1' 162
#Region './Public/Entrypoints/Activity Triggers/Push-ExecApplicationCopy.ps1' -1

function Push-ExecApplicationCopy {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)
    try {
        Write-Host "$($Item | ConvertTo-Json -Depth 10)"
        New-CIPPApplicationCopy -App $Item.AppId -Tenant $Item.Tenant
    } catch {
        Write-LogMessage -message "Error adding application to tenant $($Item.Tenant) - $($_.Exception.Message)" -tenant $Item.Tenant -API 'Add Multitenant App' -sev Error
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecApplicationCopy.ps1' 15
#Region './Public/Entrypoints/Activity Triggers/Push-ExecGDAPInviteQueue.ps1' -1

function Push-ExecGDAPInviteQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    # Write out the queue message and metadata to the information log.
    Write-Host "PowerShell queue trigger function processed work item: $($Item.customer.displayName)"

    Set-CIPPGDAPInviteGroups -Relationship $Item
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecGDAPInviteQueue.ps1' 13
#Region './Public/Entrypoints/Activity Triggers/Push-ExecIncidentsListAllTenants.ps1' -1

function Push-ExecIncidentsListAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName 'cachealertsandincidents'

    try {
        $incidents = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/security/incidents' -tenantid $domainName -AsApp $true
        $GraphRequest = foreach ($incident in $incidents) {
            $GUID = (New-Guid).Guid
            $GraphRequest = @{
                Incident     = [string]($incident | ConvertTo-Json -Depth 10)
                RowKey       = [string]$GUID
                PartitionKey = 'Incident'
                Tenant       = [string]$domainName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
        }

    } catch {
        $GUID = (New-Guid).Guid
        $AlertText = ConvertTo-Json -InputObject @{
            Tenant         = $domainName
            displayName    = "Could not connect to Tenant: $($_.Exception.Message)"
            comments       = @{
                createdDateTime      = (Get-Date).ToString('s')
                createdbyDisplayName = 'CIPP'
                comment              = 'Could not connect'
            }
            classification = 'Unknown'
            determination  = 'Unknown'
            severity       = 'CIPP'
        }
        $GraphRequest = @{
            Incident     = [string]$AlertText
            RowKey       = [string]$GUID
            PartitionKey = 'Incident'
            Tenant       = [string]$domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
    }
}

#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecIncidentsListAllTenants.ps1' 49
#Region './Public/Entrypoints/Activity Triggers/Push-ExecJITAdminListAllTenants.ps1' -1

function Push-ExecJITAdminListAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $DomainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName CacheJITAdmin

    try {
        # Get schema extensions
        $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1

        # Query users with JIT Admin enabled
        $Query = @{
            TenantFilter = $DomainName # Use $DomainName for the current tenant
            Endpoint     = 'users'
            Parameters   = @{
                '$count'  = 'true'
                '$select' = "id,accountEnabled,displayName,userPrincipalName,$($Schema.id)"
                '$filter' = "$($Schema.id)/jitAdminEnabled eq true or $($Schema.id)/jitAdminEnabled eq false" # Fetches both states to cache current status
            }
        }
        $Users = Get-GraphRequestList @Query | Where-Object { $_.id }

        if ($Users) {
            # Get role memberships
            $BulkRequests = $Users | ForEach-Object { @(
                    @{
                        id     = $_.id
                        method = 'GET'
                        url    = "users/$($_.id)/memberOf/microsoft.graph.directoryRole/?`$select=id,displayName"
                    }
                )
            }
            # Ensure $BulkRequests is not empty or null before making the bulk request
            if ($BulkRequests -and $BulkRequests.Count -gt 0) {
                $RoleResults = New-GraphBulkRequest -tenantid $DomainName -Requests @($BulkRequests)

                # Format the data
                $Results = $Users | ForEach-Object {
                    $currentUser = $_ # Capture current user in the loop
                    $MemberOf = @() # Initialize as empty array
                    if ($RoleResults) {
                        $userRoleResult = $RoleResults | Where-Object -Property id -EQ $currentUser.id
                        if ($userRoleResult -and $userRoleResult.body -and $userRoleResult.body.value) {
                            $MemberOf = $userRoleResult.body.value | Select-Object displayName, id
                        }
                    }

                    $jitAdminData = $currentUser.($Schema.id)
                    $jitAdminEnabled = if ($jitAdminData -and $jitAdminData.PSObject.Properties['jitAdminEnabled']) { $jitAdminData.jitAdminEnabled } else { $false }
                    $jitAdminExpiration = if ($jitAdminData -and $jitAdminData.PSObject.Properties['jitAdminExpiration']) { $jitAdminData.jitAdminExpiration } else { $null }

                    [PSCustomObject]@{
                        id                 = $currentUser.id
                        displayName        = $currentUser.displayName
                        userPrincipalName  = $currentUser.userPrincipalName
                        accountEnabled     = $currentUser.accountEnabled
                        jitAdminEnabled    = $jitAdminEnabled
                        jitAdminExpiration = $jitAdminExpiration
                        memberOf           = ($MemberOf | ConvertTo-Json -Depth 5 -Compress)
                    }
                }

                # Add to Azure Table
                foreach ($result in $Results) {
                    $GUID = (New-Guid).Guid
                    Write-Host ($result | ConvertTo-Json -Depth 10 -Compress)
                    $GraphRequest = @{
                        JITAdminUser = [string]($result | ConvertTo-Json -Depth 10 -Compress)
                        RowKey       = [string]$GUID
                        PartitionKey = 'JITAdminUser'
                        Tenant       = [string]$DomainName
                        UserId       = [string]$result.id # Add UserId for easier querying if needed
                        UserUPN      = [string]$result.userPrincipalName # Add UserUPN for easier querying
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
                }
            } else {
                # No users with JIT Admin attributes found, or no users at all
                Write-Host "No JIT Admin users or no users found to process for tenant $DomainName."
            }
        } else {
            Write-Host "No users found for tenant $DomainName."
        }

    } catch {
        $GUID = (New-Guid).Guid
        $ErrorMessage = "Could not process JIT Admin users for Tenant: $($DomainName). Error: $($_.Exception.Message)"
        if ($_.ScriptStackTrace) {
            $ErrorMessage += " StackTrace: $($_.ScriptStackTrace)"
        }
        $ErrorJson = ConvertTo-Json -InputObject @{
            Tenant    = $DomainName
            Error     = $ErrorMessage
            Exception = ($_.Exception.Message | ConvertTo-Json -Depth 3 -Compress)
            Timestamp = (Get-Date).ToString('s')
        }
        $GraphRequest = @{
            JITAdminUser = [string]$ErrorJson
            RowKey       = [string]$GUID
            PartitionKey = 'JITAdminUser'
            Tenant       = [string]$DomainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
        Write-Error ('Error processing JIT Admin for {0}: {1}' -f $DomainName, $_.Exception.Message)
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecJITAdminListAllTenants.ps1' 112
#Region './Public/Entrypoints/Activity Triggers/Push-ExecMdoAlertsListAllTenants.ps1' -1

function Push-ExecMdoAlertsListAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName 'cachealertsandincidents'

    try {
        # Get MDO alerts using the specific endpoint and filter
        $Alerts = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/security/alerts_v2?`$filter=serviceSource eq 'microsoftDefenderForOffice365'" -tenantid $domainName

        foreach ($Alert in $Alerts) {
            $GUID = (New-Guid).Guid
            $GraphRequest = @{
                MdoAlert     = [string]($Alert | ConvertTo-Json -Depth 10)
                RowKey       = [string]$GUID
                PartitionKey = 'MdoAlert'
                Tenant       = [string]$domainName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
        }

    } catch {
        $GUID = (New-Guid).Guid
        $AlertText = ConvertTo-Json -InputObject @{
            Tenant          = $domainName
            displayName     = "Could not connect to Tenant: $($_.Exception.Message)"
            id              = ''
            severity        = 'CIPP'
            status          = 'Failed'
            createdDateTime = (Get-Date).ToString('s')
            category        = 'Unknown'
            description     = 'Could not connect'
            serviceSource   = 'microsoftDefenderForOffice365'
        }
        $GraphRequest = @{
            MdoAlert     = [string]$AlertText
            RowKey       = [string]$GUID
            PartitionKey = 'MdoAlert'
            Tenant       = [string]$domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecMdoAlertsListAllTenants.ps1' 49
#Region './Public/Entrypoints/Activity Triggers/Push-ExecOffboardingMailboxPermissions.ps1' -1

function Push-ExecOffboardingMailboxPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param(
        $Item
    )

    Remove-CIPPMailboxPermissions -PermissionsLevel @('FullAccess', 'SendAs', 'SendOnBehalf') -userid 'AllUsers' -AccessUser $Item.User -TenantFilter $Item.TenantFilter -APIName $Item.APINAME -Headers $Item.Headers
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecOffboardingMailboxPermissions.ps1' 12
#Region './Public/Entrypoints/Activity Triggers/Push-ExecOnboardTenantQueue.ps1' -1

function Push-ExecOnboardTenantQueue {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding()]
    param($Item)
    try {
        $Id = $Item.id
        $Start = Get-Date
        $Logs = [System.Collections.Generic.List[object]]::new()
        $OnboardTable = Get-CIPPTable -TableName 'TenantOnboarding'
        $TenantOnboarding = Get-CIPPAzDataTableEntity @OnboardTable -Filter "RowKey eq '$Id'"

        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = "Starting onboarding for relationship $Id" })
        $OnboardingSteps = $TenantOnboarding.OnboardingSteps | ConvertFrom-Json
        $OnboardingSteps.Step1.Status = 'running'
        $OnboardingSteps.Step1.Message = 'Checking GDAP invite status'
        $OnboardingSteps.Step2.Status = 'pending'
        $OnboardingSteps.Step2.Message = 'Waiting for Step 1'
        $OnboardingSteps.Step3.Status = 'pending'
        $OnboardingSteps.Step3.Message = 'Waiting for Step 2'
        $OnboardingSteps.Step4.Status = 'pending'
        $OnboardingSteps.Step4.Message = 'Waiting for Step 3'
        $OnboardingSteps.Step5.Status = 'pending'
        $OnboardingSteps.Step5.Message = 'Waiting for Step 4'
        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
        $TenantOnboarding.Status = 'running'
        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress -AsArray)
        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

        try {
            $Relationship = $TenantOnboarding.Relationship | ConvertFrom-Json -ErrorAction Stop
        } catch {
            $Relationship = ''
        }

        $ExpectedRoles = @(
            @{ Name = 'Application Administrator'; Id = '9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3' },
            @{ Name = 'User Administrator'; Id = 'fe930be7-5e62-47db-91af-98c3a49a38b1' },
            @{ Name = 'Intune Administrator'; Id = '3a2c62db-5318-420d-8d74-23affee5d9d5' },
            @{ Name = 'Exchange Administrator'; Id = '29232cdf-9323-42fd-ade2-1d097af3e4de' },
            @{ Name = 'Security Administrator'; Id = '194ae4cb-b126-40b2-bd5b-6091b380977d' },
            @{ Name = 'Cloud App Security Administrator'; Id = '892c5842-a9a6-463a-8041-72aa08ca3cf6' },
            @{ Name = 'Cloud Device Administrator'; Id = '7698a772-787b-4ac8-901f-60d6b08affd2' },
            @{ Name = 'Teams Administrator'; Id = '69091246-20e8-4a56-aa4d-066075b2a7a8' },
            @{ Name = 'SharePoint Administrator'; Id = 'f28a1f50-f6e7-4571-818b-6a12f2af6b6c' },
            @{ Name = 'Authentication Policy Administrator'; Id = '0526716b-113d-4c15-b2c8-68e3c22b9f80' },
            @{ Name = 'Privileged Role Administrator'; Id = 'e8611ab8-c189-46e8-94e1-60213ab1f814' },
            @{ Name = 'Privileged Authentication Administrator'; Id = '7be44c8a-adaf-4e2a-84d6-ab2649e08a13' }
        )

        if ($OnboardingSteps.Step1.Status -ne 'succeeded') {
            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Checking relationship status' })
            $x = 0
            do {
                $Relationship = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$Id"
                $x++
                Start-Sleep -Seconds 30
            } while ($Relationship.status -ne 'active' -and $x -lt 6)

            if ($Relationship.status -eq 'active') {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'GDAP Invite Accepted' })
                $OnboardingSteps.Step1.Status = 'succeeded'
                $OnboardingSteps.Step1.Message = "GDAP Invite accepted for $($Relationship.customer.displayName)"
                $TenantOnboarding.CustomerId = $Relationship.customer.tenantId
            } else {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'GDAP Invite Failed' })
                $OnboardingSteps.Step1.Status = 'failed'
                $OnboardingSteps.Step1.Message = 'GDAP Invite timeout, retry onboarding after accepting the invite with a GA account in the customer tenant.'
                $TenantOnboarding.Status = 'failed'
            }
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Relationship = [string](ConvertTo-Json -InputObject $Relationship -Compress -Depth 10)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
        }

        if ($OnboardingSteps.Step1.Status -eq 'succeeded') {
            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Starting role check' })
            $OnboardingSteps.Step2.Status = 'running'
            $OnboardingSteps.Step2.Message = 'Checking role mapping'
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

            $MissingRoles = [System.Collections.Generic.List[string]]::new()
            foreach ($Role in $ExpectedRoles) {
                $RoleFound = $false
                foreach ($AvailableRole in $Relationship.accessDetails.unifiedRoles) {
                    if ($AvailableRole.roleDefinitionId -eq $Role.Id) {
                        $RoleFound = $true
                        break
                    }
                }
                if (!$RoleFound) {
                    $MissingRoles.Add($Role.Name)
                }
            }
            if (($MissingRoles | Measure-Object).Count -gt 0) {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Missing roles for relationship' })
                if ($Item.IgnoreMissingRoles -ne $true) {
                    $TenantOnboarding.Status = 'failed'
                    $OnboardingSteps.Step2.Status = 'failed'
                    $OnboardingSteps.Step2.Message = "Your GDAP relationship is missing the following roles: $($MissingRoles -join ', ')"
                } else {
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Ignoring missing roles' })
                    $OnboardingSteps.Step2.Status = 'succeeded'
                    $OnboardingSteps.Step2.Message = 'Your GDAP relationship is missing some roles, but the onboarding will continue'
                }
            } else {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Required roles found' })
                $OnboardingSteps.Step2.Status = 'succeeded'
                $OnboardingSteps.Step2.Message = 'Your GDAP relationship has the required roles'
            }
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
        }

        if ($OnboardingSteps.Step2.Status -eq 'succeeded') {
            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Checking group mapping' })
            $AccessAssignments = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments"
            if ($AccessAssignments.id -and $Item.AutoMapRoles -ne $true) {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Groups mapped' })
                $OnboardingSteps.Step3.Status = 'succeeded'
                $OnboardingSteps.Step3.Message = 'Your GDAP relationship already has mapped security groups'
            } else {
                $GroupSuccess = $false
                $OnboardingSteps.Step3.Status = 'running'
                $OnboardingSteps.Step3.Message = 'Mapping security groups'
                $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

                $InviteTable = Get-CIPPTable -TableName 'GDAPInvites'
                $Invite = Get-CIPPAzDataTableEntity @InviteTable -Filter "RowKey eq '$Id'"

                if ($AccessAssignments.id -and !$Invite) {
                    $MissingRoles = [System.Collections.Generic.List[object]]::new()
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Relationship has existing access assignments, checking for missing mappings' })

                    if ($Item.Roles -and $Item.AutoMapRoles -eq $true) {
                        foreach ($Role in $Item.Roles) {
                            if ($AccessAssignments.accessContainer.accessContainerid -notcontains $Role.GroupId -and $Relationship.accessDetails.unifiedRoles.roleDefinitionId -contains $Role.roleDefinitionId) {
                                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = "Adding missing group to relationship: $($Role.GroupName)" })
                                $MissingRoles.Add([PSCustomObject]$Role)
                            }
                        }

                        if (($MissingRoles | Measure-Object).Count -gt 0) {
                            $Invite = [PSCustomObject]@{
                                'PartitionKey' = 'invite'
                                'RowKey'       = $Id
                                'InviteUrl'    = 'https://admin.microsoft.com/AdminPortal/Home#/partners/invitation/granularAdminRelationships/{0}' -f $Id
                                'RoleMappings' = [string](@($MissingRoles) | ConvertTo-Json -Depth 10 -Compress)
                            }
                            Add-CIPPAzDataTableEntity @InviteTable -Entity $Invite
                        } else {
                            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'All roles have been mapped to the M365 GDAP security groups' })
                            $OnboardingSteps.Step3.Status = 'succeeded'
                            $OnboardingSteps.Step3.Message = 'Groups mapped successfully'
                            $GroupSuccess = $true
                        }
                    }
                }

                if (!$AccessAssignments.id -and $Item.Roles) {
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'No access assignments found, using defined role mapping.' })
                    $MatchingRoles = [System.Collections.Generic.List[object]]::new()
                    foreach ($Role in $Item.Roles) {
                        if ($Relationship.accessDetails.unifiedRoles.roleDefinitionId -contains $Role.roleDefinitionId) {
                            $MatchingRoles.Add([PSCustomObject]$Role)
                        }
                    }

                    if (($MatchingRoles | Measure-Object).Count -gt 0 -and $Item.AutoMapRoles -eq $true) {
                        $Invite = [PSCustomObject]@{
                            'PartitionKey' = 'invite'
                            'RowKey'       = $Id
                            'InviteUrl'    = 'https://admin.microsoft.com/AdminPortal/Home#/partners/invitation/granularAdminRelationships/{0}' -f $Id
                            'RoleMappings' = [string](@($MatchingRoles) | ConvertTo-Json -Depth 10 -Compress)
                        }
                        Add-CIPPAzDataTableEntity @InviteTable -Entity $Invite -Force
                        $GroupSuccess = $true
                    } else {
                        $TenantOnboarding.Status = 'failed'
                        $OnboardingSteps.Step3.Status = 'failed'
                        $OnboardingSteps.Step3.Message = 'No matching roles found, check the relationship and try again.'
                        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                        return
                    }
                }

                if ($Invite) {
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'GDAP invite found, starting group/role mapping' })
                    $GroupMapStatus = Set-CIPPGDAPInviteGroups -Relationship $Relationship
                    if ($GroupMapStatus) {
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Groups mapped successfully' })
                        $OnboardingSteps.Step3.Message = 'Groups mapped successfully, checking access assignment status'
                        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

                    } else {
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Group mapping failed' })
                        $TenantOnboarding.Status = 'failed'
                        $OnboardingSteps.Step3.Status = 'failed'
                        $OnboardingSteps.Step3.Message = 'Group mapping failed, check the log book for details.'
                        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                        return
                    }
                } elseif (!$GroupSuccess) {
                    $TenantOnboarding.Status = 'failed'
                    $OnboardingSteps.Step3.Status = 'failed'
                    $OnboardingSteps.Step3.Message = 'Failed to map security groups, no pending invite available'
                }
            }

            do {
                $AccessAssignments = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments"
                Start-Sleep -Seconds 15
            } while ($AccessAssignments.status -contains 'pending' -and (Get-Date) -lt $Start.AddMinutes(8))

            if ($AccessAssignments.status -notcontains 'pending') {
                $OnboardingSteps.Step3.Message = 'Group check: Access assignments are mapped and active'
                $OnboardingSteps.Step3.Status = 'succeeded'

                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Checking for missing groups for SAM user' })
                $SamUserId = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/me?`$select=id" -NoAuthCheck $true).id
                $CurrentMemberships = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/me/transitiveMemberOf?`$select=id,displayName" -NoAuthCheck $true
                $ExpectedCippRoles = $Item.Roles | Where-Object { $_.roleDefinitionId -in $ExpectedRoles.roleDefinitionId }
                foreach ($Role in $ExpectedCippRoles) {
                    if ($CurrentMemberships.id -notcontains $Role.GroupId) {
                        $PostBody = @{
                            '@odata.id' = 'https://graph.microsoft.com/v1.0/directoryObjects/{0}' -f $SamUserId
                        } | ConvertTo-Json -Compress
                        try {
                            New-GraphPostRequest -uri "https://graph.microsoft.com/beta/groups/$($Role.GroupId)/members/`$ref" -body $PostBody -AsApp $true -NoAuthCheck $true
                            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = "Added SAM user to $($Role.GroupName)" })
                        } catch {
                            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = "Failed to add SAM user to $($Role.GroupName) - $($_.Exception.Message)" })
                        }
                    }
                }
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'SAM user group check completed' })
            } else {
                $OnboardingSteps.Step3.Message = 'Group check: Access assignments are still pending, try again later'
                $OnboardingSteps.Step3.Status = 'failed'
                $TenantOnboarding.Status = 'failed'
                Write-LogMessage -API 'Onboarding' -message "Tenant onboarding failed at group mapping step for $($Relationship.customer.displayName)" -Sev 'Error'
            }

            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
        }

        if ($OnboardingSteps.Step3.Status -eq 'succeeded') {
            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Setting up CPV consent' })
            $OnboardingSteps.Step4.Status = 'running'
            $OnboardingSteps.Step4.Message = 'Setting up CPV consent'
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

            $ExcludedTenant = Get-Tenants -SkipList | Where-Object { $_.customerId -eq $Relationship.customer.tenantId }
            $IsExcluded = ($ExcludedTenant | Measure-Object).Count -gt 0
            if ($IsExcluded) {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = ('Tenant is excluded from CIPP, onboarding cannot continue. Remove the exclusion from "{0}" ({1})' -f $ExcludedTenant.displayName, $ExcludedTenant.customerId) })
                $TenantOnboarding.Status = 'failed'
                $OnboardingSteps.Step4.Status = 'failed'
                $OnboardingSteps.Step4.Message = 'Tenant excluded from CIPP, remove the exclusion and retry onboarding.'
            } else {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Clearing tenant cache' })
                $y = 0
                do {
                    $Tenant = Get-Tenants -TriggerRefresh -TenantFilter $Relationship.customer.tenantId | Select-Object -First 1
                    $y++
                    Start-Sleep -Seconds 20
                } while (!$Tenant -and $y -le 10)

                if ($Tenant) {
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Tenant found in customer list' })
                    try {
                        $CPVConsentParams = @{
                            TenantFilter = $Relationship.customer.tenantId
                        }
                        $Consent = Set-CIPPCPVConsent @CPVConsentParams
                        if ($Consent -match 'Could not add our Service Principal to the client tenant') {
                            throw
                        }
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Added initial CPV consent permissions' })
                    } catch {
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = ('CPV Consent Failed, error: {0}' -f $Consent) })
                        $TenantOnboarding.Status = 'failed'
                        $OnboardingSteps.Step4.Status = 'failed'
                        $OnboardingSteps.Step4.Message = 'CPV Consent failed, check the logs for more details.'
                        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                        Write-LogMessage -API 'Onboarding' -message "Tenant onboarding failed at CPV step for $($Relationship.customer.displayName)" -Sev 'Error'
                        return
                    }
                    $Refreshing = $true
                    $CPVSuccess = $false
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Refreshing CPV permissions' })
                    $OnboardingSteps.Step4.Message = 'Refreshing CPV permissions'
                    $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                    $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                    Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                    $LastCPVError = ''
                    do {
                        try {
                            Add-CIPPApplicationPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -TenantFilter $Relationship.customer.tenantId
                            Add-CIPPDelegatedPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -TenantFilter $Relationship.customer.tenantId
                            $CPVSuccess = $true
                            $Refreshing = $false
                        } catch {
                            $LastCPVError = $_.Exception.Message
                            Start-Sleep -Seconds 30
                        }
                    } while ($Refreshing -and (Get-Date) -lt $Start.AddMinutes(8))

                    if ($CPVSuccess) {
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'CPV permissions refreshed' })
                        $OnboardingSteps.Step4.Status = 'succeeded'
                        $OnboardingSteps.Step4.Message = 'CPV permissions refreshed'
                        if ($Tenant.defaultDomainName -match 'Domain Error') {
                            $Tenant = Get-Tenants -TriggerRefresh -IncludeAll | Where-Object { $_.customerId -eq $Relationship.customer.tenantId } | Select-Object -First 1
                        }
                    } else {
                        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'CPV permissions failed to refresh. {0}' -f $LastCPVError })
                        $TenantOnboarding.Status = 'failed'
                        $OnboardingSteps.Step4.Status = 'failed'
                        $OnboardingSteps.Step4.Message = 'CPV permissions failed to refresh, check the logs for more details.'
                    }
                } else {
                    $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Tenant not found' })
                    $TenantOnboarding.Status = 'failed'
                    $OnboardingSteps.Step4.Status = 'failed'
                    $OnboardingSteps.Step4.Message = 'Tenant not found in customer list, try again later'
                }
            }
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
        }

        if ($OnboardingSteps.Step4.Status -eq 'succeeded') {
            if ($Item.StandardsExcludeAllTenants -eq $true) {
                $AddExclusionObj = [PSCustomObject]@{
                    label       = '{0} ({1})' -f $Tenant.displayName, $Tenant.defaultDomainName
                    value       = $Tenant.defaultDomainName
                    addedFields = @{
                        customerId        = $Tenant.customerId
                        defaultDomainName = $Tenant.defaultDomainName
                    }
                }
                $Table = Get-CIPPTable -tablename 'templates'
                $ExistingTemplates = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'StandardsTemplateV2'" | Where-Object { $_.JSON -match 'AllTenants' }
                foreach ($AllTenantsTemplate in $ExistingTemplates) {
                    $object = $AllTenantsTemplate.JSON | ConvertFrom-Json
                    $NewExcludedTenants = [System.Collections.Generic.List[object]]::new()
                    if (!$object.excludedTenants) {
                        $object | Add-Member -MemberType NoteProperty -Name 'excludedTenants' -Value @() -Force
                    }
                    foreach ($ExcludedStandardsTenant in $object.excludedTenants) {
                        $NewExcludedTenants.Add($ExcludedStandardsTenant)
                    }
                    $NewExcludedTenants.Add($AddExclusionObj)
                    $object.excludedTenants = $NewExcludedTenants
                    $JSON = ConvertTo-Json -InputObject $object -Compress -Depth 10
                    $Table.Force = $true
                    Add-CIPPAzDataTableEntity @Table -Entity @{
                        JSON         = "$JSON"
                        RowKey       = $AllTenantsTemplate.RowKey
                        GUID         = $AllTenantsTemplate.GUID
                        PartitionKey = 'StandardsTemplateV2'
                    }
                }

                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Set All Tenant Standards Exclusion' })
            }
            $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = "Testing API access for $($Tenant.defaultDomainName)" })
            $OnboardingSteps.Step5.Status = 'running'
            $OnboardingSteps.Step5.Message = 'Testing API access'
            $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
            $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
            Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

            try {
                #Write-Host ($Tenant | ConvertTo-Json)
                $UserCount = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$count=true&`$top=1" -ComplexFilter -tenantid $Tenant.defaultDomainName -CountOnly
            } catch {
                $UserCount = 0
                $ApiError = $_.Exception.Message
                $ApiException = $_
            }

            if ($UserCount -gt 0) {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'API test successful' })
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Onboarding complete' })
                $OnboardingSteps.Step5.Status = 'succeeded'
                $OnboardingSteps.Step5.Message = 'API Test Successful: {0} users found' -f $UserCount
                $TenantOnboarding.Status = 'succeeded'
                $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                Write-LogMessage -API 'Onboarding' -message "Tenant onboarding succeeded for $($Relationship.customer.displayName)" -Sev 'Info'
            } else {
                $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'API Test failed: {0}' -f $ApiError })
                $OnboardingSteps.Step5.Status = 'failed'
                $OnboardingSteps.Step5.Message = 'API Test failed: {0}' -f $ApiError
                $TenantOnboarding.Status = 'succeeded'
                $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
                Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
                Write-LogMessage -API 'Onboarding' -message "Tenant onboarding API test failed for $($Relationship.customer.displayName)" -Sev 'Error' -LogData (Get-CippException -Exception $ApiException)
            }
        }
    } catch {
        $Logs.Add([PSCustomObject]@{ Date = (Get-Date).ToUniversalTime(); Log = 'Onboarding failed. Exception: {0}' -f $_.Exception.Message })
        $TenantOnboarding.Status = 'failed'
        $TenantOnboarding.Exception = [string]('{0} - Line {1} - {2}' -f $_.Exception.Message, $_.InvocationInfo.ScriptLineNumber, $_.InvocationInfo.ScriptName)
        $TenantOnboarding.OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
        $TenantOnboarding.Logs = [string](ConvertTo-Json -InputObject @($Logs) -Compress)
        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop
        Write-LogMessage -API 'Onboarding' -message "Tenant onboarding failed for $Id" -Sev 'Error' -LogData (Get-CippException -Exception $_)
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecOnboardTenantQueue.ps1' 436
#Region './Public/Entrypoints/Activity Triggers/Push-ExecScheduledCommand.ps1' -1

function Push-ExecScheduledCommand {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)
    $item = $Item | ConvertTo-Json -Depth 100 | ConvertFrom-Json
    Write-Information "We are going to be running a scheduled task: $($Item.TaskInfo | ConvertTo-Json -Depth 10)"

    # Initialize AsyncLocal storage for thread-safe per-invocation context
    if (-not $script:CippScheduledTaskIdStorage) {
        $script:CippScheduledTaskIdStorage = [System.Threading.AsyncLocal[string]]::new()
    }
    $script:CippScheduledTaskIdStorage.Value = $Item.TaskInfo.RowKey

    $Table = Get-CippTable -tablename 'ScheduledTasks'
    $task = $Item.TaskInfo
    $commandParameters = $Item.Parameters | ConvertTo-Json -Depth 10 | ConvertFrom-Json -AsHashtable

    # Handle tenant resolution - support both direct tenant and group-expanded tenants
    $Tenant = $Item.Parameters.TenantFilter ?? $Item.TaskInfo.Tenant

    # For tenant group tasks, the tenant will be the expanded tenant from the orchestrator
    # We don't need to expand groups here as that's handled in the orchestrator
    $TenantInfo = Get-Tenants -TenantFilter $Tenant

    $CurrentTask = Get-AzDataTableEntity @Table -Filter "PartitionKey eq '$($task.PartitionKey)' and RowKey eq '$($task.RowKey)'"
    if (!$CurrentTask) {
        Write-Information "The task $($task.Name) for tenant $($task.Tenant) does not exist in the ScheduledTasks table. Exiting."
        Remove-Variable -Name ScheduledTaskId -Scope Script -ErrorAction SilentlyContinue
        return
    }
    if ($CurrentTask.TaskState -eq 'Completed') {
        Write-Information "The task $($task.Name) for tenant $($task.Tenant) is already completed. Skipping execution."
        Remove-Variable -Name ScheduledTaskId -Scope Script -ErrorAction SilentlyContinue
        return
    }

    if ($task.Trigger) {
        # Extract trigger data from the task and process
        $Trigger = if (Test-Json -Json $task.Trigger) { $task.Trigger | ConvertFrom-Json } else { $task.Trigger }
        $TriggerType = $Trigger.Type.value ?? $Trigger.Type
        if ($TriggerType -eq 'DeltaQuery') {
            $IsTriggerTask = $true
            $DeltaUrl = Get-DeltaQueryUrl -TenantFilter $Tenant -PartitionKey $task.RowKey
            $DeltaQuery = @{
                DeltaUrl     = $DeltaUrl
                TenantFilter = $Tenant
                PartitionKey = $task.RowKey
            }
            $Query = New-GraphDeltaQuery @DeltaQuery

            $secondsToAdd = switch -Regex ($task.Recurrence) {
                '(\d+)m$' { [int64]$matches[1] * 60 }
                '(\d+)h$' { [int64]$matches[1] * 3600 }
                '(\d+)d$' { [int64]$matches[1] * 86400 }
                default { 0 }
            }

            $Minutes = [int]($secondsToAdd / 60)

            $DeltaQueryConditions = @{
                Query        = $Query
                Trigger      = $Trigger
                TenantFilter = $Tenant
                LastTrigger  = [datetime]::UtcNow.AddMinutes(-$Minutes)
            }
            $DeltaResults = Test-DeltaQueryConditions @DeltaQueryConditions

            if (-not $DeltaResults.ConditionsMet) {
                Write-Information "Delta query conditions not met for tenant $Tenant. Skipping execution."
                # update interval
                $nextRunUnixTime = [int64]$task.ScheduledTime + [int64]$secondsToAdd
                $null = Update-AzDataTableEntity -Force @Table -Entity @{
                    PartitionKey  = $task.PartitionKey
                    RowKey        = $task.RowKey
                    TaskState     = 'Planned'
                    ScheduledTime = [string]$nextRunUnixTime
                }
                Remove-Variable -Name ScheduledTaskId -Scope Script -ErrorAction SilentlyContinue
                return
            }
        }
    } else {
        $IsTriggerTask = $false
    }

    $null = Update-AzDataTableEntity -Force @Table -Entity @{
        PartitionKey = $task.PartitionKey
        RowKey       = $task.RowKey
        TaskState    = 'Running'
    }

    $Function = Get-Command -Name $Item.Command
    if ($null -eq $Function) {
        $Results = "Task Failed: The command $($Item.Command) does not exist."
        $State = 'Failed'
        Update-AzDataTableEntity -Force @Table -Entity @{
            PartitionKey = $task.PartitionKey
            RowKey       = $task.RowKey
            Results      = "$Results"
            TaskState    = $State
        }

        Write-LogMessage -API 'Scheduler_UserTasks' -tenant $Tenant -tenantid $TenantInfo.customerId -message "Failed to execute task $($task.Name): The command $($Item.Command) does not exist." -sev Error
        Remove-Variable -Name ScheduledTaskId -Scope Script -ErrorAction SilentlyContinue
        return
    }

    try {
        $PossibleParams = $Function.Parameters.Keys
        $keysToRemove = [System.Collections.Generic.List[string]]@()
        foreach ($key in $commandParameters.Keys) {
            if (-not ($PossibleParams -contains $key)) {
                $keysToRemove.Add($key)
            }
        }
        foreach ($key in $keysToRemove) {
            $commandParameters.Remove($key)
        }
    } catch {
        Write-Information "Failed to remove parameters: $($_.Exception.Message)"
    }

    if ($IsTriggerTask -eq $true -and $Trigger.ExecutePerResource -ne $true) {
        # iterate through paramters looking for %variables% and replace them with matched data from the delta query
        # examples would be %id% to be the id of the result
        # if %triggerdata% is found, pass the entire matched data object
        try {
            foreach ($key in $commandParameters.Keys) {
                if ($commandParameters[$key] -is [string]) {
                    if ($commandParameters[$key] -match '^%(.*)%$') {
                        $variableName = $matches[1]
                        if ($variableName -eq 'triggerdata') {
                            Write-Information "Replacing parameter $key with full matched data object."
                            $commandParameters[$key] = $DeltaResults.MatchedData
                        } else {
                            # Replace with array of matched property values
                            Write-Information "Replacing parameter $key with matched data property '$variableName'."
                            $commandParameters[$key] = $DeltaResults.MatchedData | Select-Object -ExpandProperty $variableName
                        }
                    }
                }
            }
        } catch {
            Write-Information "Failed to process trigger data parameters: $($_.Exception.Message)"
        }
    } elseif ($IsTriggerTask -eq $true -and $Trigger.ExecutePerResource -eq $true) {
        Write-Information 'This is a trigger task with ExecutePerResource set to true. Iterating through matched data to execute command per resource.'
        $results = foreach ($dataItem in $DeltaResults.MatchedData) {
            $individualCommandParameters = $commandParameters.Clone()
            try {
                foreach ($key in $individualCommandParameters.Keys) {
                    if ($individualCommandParameters[$key] -is [string]) {
                        if ($individualCommandParameters[$key] -match '^%(.*)%$') {
                            if ($matches[1] -eq 'triggerdata') {
                                Write-Information "Replacing parameter $key with full matched data object for individual execution."
                                $individualCommandParameters[$key] = $dataItem
                            } else {
                                $variableName = $matches[1]
                                Write-Information "Replacing parameter $key with matched data property '$variableName' for individual execution."
                                $individualCommandParameters[$key] = $dataItem.$variableName
                            }
                        }
                    }
                }
            } catch {
                Write-Information "Failed to process trigger data parameters for individual execution: $($_.Exception.Message)"
            }
            try {
                Write-Information "Executing command $($Item.Command) for individual matched data item with parameters: $($individualCommandParameters | ConvertTo-Json -Depth 10)"
                & $Item.Command @individualCommandParameters
                Write-Information "Results for individual execution: $($results | ConvertTo-Json -Depth 10)"
            } catch {
                Write-Information "Failed to execute command for individual matched data item: $($_.Exception.Message)"
            }
        }
    }

    try {
        if (-not $Trigger.ExecutePerResource) {
            try {
                Write-Information "Starting task: $($Item.Command) for tenant: $Tenant with parameters: $($commandParameters | ConvertTo-Json)"
                $results = & $Item.Command @commandParameters
            } catch {
                $results = "Task Failed: $($_.Exception.Message)"
                $State = 'Failed'
            }
            Write-Information 'Ran the command. Processing results'
        }
        Write-Information "Results: $($results | ConvertTo-Json -Depth 10)"
        if ($item.command -like 'Get-CIPPAlert*') {
            Write-Information 'This is an alert task. Processing results as alerts.'
            $results = @($results)
            $TaskType = 'Alert'
        } else {
            Write-Information 'This is a scheduled task. Processing results as scheduled task.'
            $TaskType = 'Scheduled Task'

            if (!$results) {
                $results = 'Task completed successfully'
            }

            if ($results -is [String]) {
                $results = @{ Results = $results }
            } elseif ($results -is [array] -and $results[0] -is [string] -or $results[0].resultText -is [string]) {
                $results = $results | Where-Object { $_ -is [string] -or $_.resultText -is [string] }
                $results = $results | ForEach-Object {
                    $Message = $_.resultText ?? $_
                    @{ Results = $Message }
                }
            }
            Write-Information "Results after processing: $($results | ConvertTo-Json -Depth 10)"
            Write-Information 'Moving onto storing results'
            if ($results -is [string]) {
                $StoredResults = $results
            } else {
                $results = $results | Select-Object * -ExcludeProperty RowKey, PartitionKey
                $StoredResults = $results | ConvertTo-Json -Compress -Depth 20 | Out-String
            }
        }
        Write-Information "Results: $($results | ConvertTo-Json -Depth 10)"
        if ($StoredResults.Length -gt 64000 -or $task.Tenant -eq 'AllTenants' -or $task.TenantGroup) {
            $TaskResultsTable = Get-CippTable -tablename 'ScheduledTaskResults'
            $TaskResults = @{
                PartitionKey = $task.RowKey
                RowKey       = $Tenant
                Results      = [string](ConvertTo-Json -Compress -Depth 20 $results)
            }
            $null = Add-CIPPAzDataTableEntity @TaskResultsTable -Entity $TaskResults -Force
            $StoredResults = @{ Results = 'Completed, details are available in the More Info pane' } | ConvertTo-Json -Compress
        }
    } catch {
        Write-Information "Failed to run task: $($_.Exception.Message)"
        $errorMessage = $_.Exception.Message
        #if recurrence is just a number, add it in days.
        if ($task.Recurrence -match '^\d+$') {
            $task.Recurrence = $task.Recurrence + 'd'
        }
        $secondsToAdd = switch -Regex ($task.Recurrence) {
            '(\d+)m$' { [int64]$matches[1] * 60 }
            '(\d+)h$' { [int64]$matches[1] * 3600 }
            '(\d+)d$' { [int64]$matches[1] * 86400 }
            default { 0 }
        }

        if ($secondsToAdd -gt 0) {
            $unixtimeNow = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
            if ([int64]$task.ScheduledTime -lt ($unixtimeNow - $secondsToAdd)) {
                $task.ScheduledTime = $unixtimeNow
            }
        }

        $nextRunUnixTime = [int64]$task.ScheduledTime + [int64]$secondsToAdd
        if ($task.Recurrence -ne 0) { $State = 'Failed - Planned' } else { $State = 'Failed' }
        Write-Information "The job is recurring, but failed. It was scheduled for $($task.ScheduledTime). The next runtime should be $nextRunUnixTime"
        Update-AzDataTableEntity -Force @Table -Entity @{
            PartitionKey  = $task.PartitionKey
            RowKey        = $task.RowKey
            Results       = "$errorMessage"
            ScheduledTime = "$nextRunUnixTime"
            TaskState     = $State
        }
        Write-LogMessage -API 'Scheduler_UserTasks' -tenant $Tenant -tenantid $TenantInfo.customerId -message "Failed to execute task $($task.Name): $errorMessage" -sev Error -LogData (Get-CippExceptionData -Exception $_.Exception)
    }
    Write-Information 'Sending task results to target. Updating the task state.'

    if ($Results) {
        $TableDesign = '<style>table.adaptiveTable{border:1px solid currentColor;background-color:transparent;width:100%;text-align:left;border-collapse:collapse;opacity:0.9}table.adaptiveTable td,table.adaptiveTable th{border:1px solid currentColor;padding:8px 6px;opacity:0.8}table.adaptiveTable tbody td{font-size:13px}table.adaptiveTable tr:nth-child(even){background-color:rgba(128,128,128,0.1)}table.adaptiveTable thead{background-color:rgba(128,128,128,0.2);border-bottom:2px solid currentColor}table.adaptiveTable thead th{font-size:15px;font-weight:700;border-left:1px solid currentColor}table.adaptiveTable thead th:first-child{border-left:none}table.adaptiveTable tfoot{font-size:14px;font-weight:700;background-color:rgba(128,128,128,0.1);border-top:2px solid currentColor}table.adaptiveTable tfoot td{font-size:14px}@media (prefers-color-scheme: dark){table.adaptiveTable{opacity:0.95}table.adaptiveTable tr:nth-child(even){background-color:rgba(255,255,255,0.05)}table.adaptiveTable thead{background-color:rgba(255,255,255,0.1)}table.adaptiveTable tfoot{background-color:rgba(255,255,255,0.05)}}</style>'
        $FinalResults = if ($results -is [array] -and $results[0] -is [string]) { $Results | ConvertTo-Html -Fragment -Property @{ l = 'Text'; e = { $_ } } } else { $Results | ConvertTo-Html -Fragment }
        $HTML = $FinalResults -replace '<table>', "This alert is for tenant $Tenant. <br /><br /> $TableDesign<table class=adaptiveTable>" | Out-String

        # Add alert comment if available
        if ($task.AlertComment) {
            $HTML += "<div style='background-color: #f8f9fa; border-left: 4px solid #007bff; padding: 15px; margin: 15px 0;'><h4 style='margin-top: 0; color: #007bff;'>Alert Information</h4><p style='margin-bottom: 0;'>$($task.AlertComment)</p></div>"
        }

        $title = "$TaskType - $Tenant - $($task.Name)"
        Write-Information 'Scheduler: Sending the results to the target.'
        Write-Information "The content of results is: $Results"
        switch -wildcard ($task.PostExecution) {
            '*psa*' { Send-CIPPAlert -Type 'psa' -Title $title -HTMLContent $HTML -TenantFilter $Tenant }
            '*email*' { Send-CIPPAlert -Type 'email' -Title $title -HTMLContent $HTML -TenantFilter $Tenant }
            '*webhook*' {
                $Webhook = [PSCustomObject]@{
                    'tenantId'     = $TenantInfo.customerId
                    'Tenant'       = $Tenant
                    'TaskInfo'     = $Item.TaskInfo
                    'Results'      = $Results
                    'AlertComment' = $task.AlertComment
                }
                Send-CIPPAlert -Type 'webhook' -Title $title -TenantFilter $Tenant -JSONContent $($Webhook | ConvertTo-Json -Depth 20)
            }
        }
    }
    Write-Information 'Sent the results to the target. Updating the task state.'

    try {
        if ($task.Recurrence -eq '0' -or [string]::IsNullOrEmpty($task.Recurrence) -or $Trigger.ExecutionMode.value -eq 'once' -or $Trigger.ExecutionMode -eq 'once') {
            Write-Information 'Recurrence empty or 0. Task is not recurring. Setting task state to completed.'
            Update-AzDataTableEntity -Force @Table -Entity @{
                PartitionKey = $task.PartitionKey
                RowKey       = $task.RowKey
                Results      = "$StoredResults"
                TaskState    = 'Completed'
            }
        } else {
            #if recurrence is just a number, add it in days.
            if ($task.Recurrence -match '^\d+$') {
                $task.Recurrence = $task.Recurrence + 'd'
            }
            $secondsToAdd = switch -Regex ($task.Recurrence) {
                '(\d+)m$' { [int64]$matches[1] * 60 }
                '(\d+)h$' { [int64]$matches[1] * 3600 }
                '(\d+)d$' { [int64]$matches[1] * 86400 }
                default { 0 }
            }

            if ($secondsToAdd -gt 0) {
                $unixtimeNow = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
                if ([int64]$task.ScheduledTime -lt ($unixtimeNow - $secondsToAdd)) {
                    $task.ScheduledTime = $unixtimeNow
                }
            }

            $nextRunUnixTime = [int64]$task.ScheduledTime + [int64]$secondsToAdd
            Write-Information "The job is recurring. It was scheduled for $($task.ScheduledTime). The next runtime should be $nextRunUnixTime"
            Update-AzDataTableEntity -Force @Table -Entity @{
                PartitionKey  = $task.PartitionKey
                RowKey        = $task.RowKey
                Results       = "$StoredResults"
                TaskState     = 'Planned'
                ScheduledTime = "$nextRunUnixTime"
            }
        }
    } catch {
        Write-Warning "Failed to update task state: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }
    if ($TaskType -ne 'Alert') {
        Write-LogMessage -API 'Scheduler_UserTasks' -tenant $Tenant -tenantid $TenantInfo.customerId -message "Successfully executed task: $($task.Name)" -sev Info
    }
    Remove-Variable -Name ScheduledTaskId -Scope Script -ErrorAction SilentlyContinue
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ExecScheduledCommand.ps1' 345
#Region './Public/Entrypoints/Activity Triggers/Push-GetPendingWebhooks.ps1' -1

function Push-GetPendingWebhooks {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    Param($Item)
    $Table = Get-CIPPTable -TableName WebhookIncoming
    $Webhooks = Get-CIPPAzDataTableEntity @Table -Property PartitionKey, RowKey, FunctionName -First 10000
    $WebhookCount = ($Webhooks | Measure-Object).Count
    $Message = 'Processing {0} webhooks' -f $WebhookCount
    Write-LogMessage -API 'Webhooks' -message $Message -sev Info
    return $Webhooks
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-GetPendingWebhooks.ps1' 14
#Region './Public/Entrypoints/Activity Triggers/Push-GetTenants.ps1' -1

function Push-GetTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    Param($Item)

    $Params = $Item.TenantParams | ConvertTo-Json | ConvertFrom-Json -AsHashtable
    try {
        if ($Item.QueueId) {
            Get-Tenants @Params | Select-Object customerId, @{n = 'FunctionName'; e = { $Item.DurableName } }, @{n = 'QueueId'; e = { $Item.QueueId } }, @{n = 'QueueName'; e = { $_.defaultDomainName } }
        } else {
            Get-Tenants @Params | Select-Object customerId, @{n = 'FunctionName'; e = { $Item.DurableName } }
        }
    } catch {
        Write-Host "GetTenants Exception $($_.Exception.Message)"
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-GetTenants.ps1' 19
#Region './Public/Entrypoints/Activity Triggers/Push-ListBasicAuthAllTenants.ps1' -1

Function Push-ListBasicAuthAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)

    $domainName = $Item.defaultDomainName

    # XXX; This function seems to be unused in the frontend. -Bobby

    $currentTime = Get-Date -Format 'yyyy-MM-ddTHH:MM:ss'
    $ts = (Get-Date).AddDays(-30)
    $endTime = $ts.ToString('yyyy-MM-ddTHH:MM:ss')
    $filters = "createdDateTime ge $($endTime)Z and createdDateTime lt $($currentTime)Z and (clientAppUsed eq 'AutoDiscover' or clientAppUsed eq 'Exchange ActiveSync' or clientAppUsed eq 'Exchange Online PowerShell' or clientAppUsed eq 'Exchange Web Services' or clientAppUsed eq 'IMAP4' or clientAppUsed eq 'MAPI Over HTTP' or clientAppUsed eq 'Offline Address Book' or clientAppUsed eq 'Outlook Anywhere (RPC over HTTP)' or clientAppUsed eq 'Other clients' or clientAppUsed eq 'POP3' or clientAppUsed eq 'Reporting Web Services' or clientAppUsed eq 'Authenticated SMTP' or clientAppUsed eq 'Outlook Service')"
    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/auditLogs/signIns?api-version=beta&filter=$($filters)" -tenantid $domainName -ErrorAction stop | Sort-Object -Unique -Property clientAppUsed | ForEach-Object {
            @{
                Tenant            = $domainName
                clientAppUsed     = $_.clientAppUsed
                userPrincipalName = $_.UserPrincipalName
                RowKey            = "$($_.UserPrincipalName)-$($_.clientAppUsed)"
                PartitionKey      = 'basicauth'
            }
        }
    } catch {
        $GraphRequest = @{
            Tenant            = $domainName
            clientAppUsed     = "Could not connect to Tenant: $($_.Exception.message)"
            userPrincipalName = $domainName
            RowKey            = $domainName
            PartitionKey      = 'basicauth'
        }
    }
    $Table = Get-CIPPTable -TableName cachebasicauth
    Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null

}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListBasicAuthAllTenants.ps1' 40
#Region './Public/Entrypoints/Activity Triggers/Push-ListConditionalAccessPoliciesAllTenants.ps1' -1

function Push-ListConditionalAccessPoliciesAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    #Region Helper functions
    function Get-LocationNameFromId {
        param ($ID, $Locations)
        if ($id -eq 'All') { return 'All' }
        $DisplayName = $Locations | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) { return $ID } else { return $DisplayName }
    }

    function Get-RoleNameFromId {
        param ($ID, $RoleDefinitions)
        if ($id -eq 'All') { return 'All' }
        $DisplayName = $RoleDefinitions | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) { return $ID } else { return $DisplayName }
    }

    function Get-UserNameFromId {
        param ($ID, $Users)
        if ($id -eq 'All') { return 'All' }
        $DisplayName = $Users | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) { return $ID } else { return $DisplayName }
    }

    function Get-GroupNameFromId {
        param ($ID, $Groups)
        if ($id -eq 'All') { return 'All' }
        $DisplayName = $Groups | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) { return 'No Data' } else { return $DisplayName }
    }

    function Get-ApplicationNameFromId {
        param ($ID, $Applications, $ServicePrincipals)
        if ($id -eq 'All') { return 'All' }
        $return = $ServicePrincipals | Where-Object { $_.appId -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($return)) {
            $return = $Applications | Where-Object { $_.Appid -eq $ID } | Select-Object -ExpandProperty DisplayName
        }
        if ([string]::IsNullOrEmpty($return)) {
            $return = $Applications | Where-Object { $_.ID -eq $ID } | Select-Object -ExpandProperty DisplayName
        }
        if ([string]::IsNullOrEmpty($return)) { $return = '' }
        return $return
    }
    #EndRegion Helper functions

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName 'cacheCAPolicies'

    try {
        $Requests = @(
            @{
                id     = 'policies'
                url    = 'identity/conditionalAccess/policies'
                method = 'GET'
            }
            @{
                id     = 'namedLocations'
                url    = 'identity/conditionalAccess/namedLocations'
                method = 'GET'
            }
            @{
                id     = 'applications'
                url    = 'applications?$top=999&$select=appId,displayName'
                method = 'GET'
            }
            @{
                id     = 'roleDefinitions'
                url    = 'roleManagement/directory/roleDefinitions?$select=id,displayName'
                method = 'GET'
            }
            @{
                id     = 'groups'
                url    = 'groups?$top=999&$select=id,displayName'
                method = 'GET'
            }
            @{
                id     = 'users'
                url    = 'users?$top=999&$select=id,displayName,userPrincipalName'
                method = 'GET'
            }
            @{
                id     = 'servicePrincipals'
                url    = 'servicePrincipals?$top=999&$select=appId,displayName'
                method = 'GET'
            }
        )

        $BulkResults = New-GraphBulkRequest -Requests $Requests -tenantid $domainName -asapp $true

        $ConditionalAccessPolicyOutput = ($BulkResults | Where-Object { $_.id -eq 'policies' }).body.value
        $AllNamedLocations = ($BulkResults | Where-Object { $_.id -eq 'namedLocations' }).body.value
        $AllApplications = ($BulkResults | Where-Object { $_.id -eq 'applications' } ).body.value
        $AllRoleDefinitions = ($BulkResults | Where-Object { $_.id -eq 'roleDefinitions' }).body.value
        $GroupListOutput = ($BulkResults | Where-Object { $_.id -eq 'groups' }).body.value
        $UserListOutput = ($BulkResults | Where-Object { $_.id -eq 'users' }).body.value
        $AllServicePrincipals = ($BulkResults | Where-Object { $_.id -eq 'servicePrincipals' }).body.value

        foreach ($cap in $ConditionalAccessPolicyOutput) {
            $GUID = (New-Guid).Guid
            $PolicyData = @{
                id                                          = $cap.id
                displayName                                 = $cap.displayName
                customer                                    = $cap.Customer
                Tenant                                      = $domainName
                createdDateTime                             = $(if (![string]::IsNullOrEmpty($cap.createdDateTime)) { [datetime]$cap.createdDateTime } else { '' })
                modifiedDateTime                            = $(if (![string]::IsNullOrEmpty($cap.modifiedDateTime)) { [datetime]$cap.modifiedDateTime } else { '' })
                state                                       = $cap.state
                clientAppTypes                              = ($cap.conditions.clientAppTypes) -join ','
                includePlatforms                            = ($cap.conditions.platforms.includePlatforms) -join ','
                excludePlatforms                            = ($cap.conditions.platforms.excludePlatforms) -join ','
                includeLocations                            = (Get-LocationNameFromId -Locations $AllNamedLocations -id $cap.conditions.locations.includeLocations) -join ','
                excludeLocations                            = (Get-LocationNameFromId -Locations $AllNamedLocations -id $cap.conditions.locations.excludeLocations) -join ','
                includeApplications                         = ($cap.conditions.applications.includeApplications | ForEach-Object { Get-ApplicationNameFromId -Applications $AllApplications -ServicePrincipals $AllServicePrincipals -id $_ }) -join ','
                excludeApplications                         = ($cap.conditions.applications.excludeApplications | ForEach-Object { Get-ApplicationNameFromId -Applications $AllApplications -ServicePrincipals $AllServicePrincipals -id $_ }) -join ','
                includeUserActions                          = ($cap.conditions.applications.includeUserActions | Out-String)
                includeAuthenticationContextClassReferences = ($cap.conditions.applications.includeAuthenticationContextClassReferences | Out-String)
                includeUsers                                = ($cap.conditions.users.includeUsers | ForEach-Object { Get-UserNameFromId -Users $UserListOutput -id $_ }) | Out-String
                excludeUsers                                = ($cap.conditions.users.excludeUsers | ForEach-Object { Get-UserNameFromId -Users $UserListOutput -id $_ }) | Out-String
                includeGroups                               = ($cap.conditions.users.includeGroups | ForEach-Object { Get-GroupNameFromId -Groups $GroupListOutput -id $_ }) | Out-String
                excludeGroups                               = ($cap.conditions.users.excludeGroups | ForEach-Object { Get-GroupNameFromId -Groups $GroupListOutput -id $_ }) | Out-String
                includeRoles                                = ($cap.conditions.users.includeRoles | ForEach-Object { Get-RoleNameFromId -RoleDefinitions $AllRoleDefinitions -id $_ }) | Out-String
                excludeRoles                                = ($cap.conditions.users.excludeRoles | ForEach-Object { Get-RoleNameFromId -RoleDefinitions $AllRoleDefinitions -id $_ }) | Out-String
                grantControlsOperator                       = ($cap.grantControls.operator) -join ','
                builtInControls                             = ($cap.grantControls.builtInControls) -join ','
                customAuthenticationFactors                 = ($cap.grantControls.customAuthenticationFactors) -join ','
                termsOfUse                                  = ($cap.grantControls.termsOfUse) -join ','
                rawjson                                     = ($cap | ConvertTo-Json -Depth 100)
            }

            $Entity = @{
                Policy       = [string]($PolicyData | ConvertTo-Json -Depth 10 -Compress)
                RowKey       = [string]$GUID
                PartitionKey = 'CAPolicy'
                Tenant       = [string]$domainName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null
        }

    } catch {
        $GUID = (New-Guid).Guid
        $ErrorPolicy = ConvertTo-Json -InputObject @{
            Tenant           = $domainName
            displayName      = "Could not connect to Tenant: $($_.Exception.Message)"
            state            = 'Error'
            createdDateTime  = (Get-Date).ToString('s')
            modifiedDateTime = (Get-Date).ToString('s')
            id               = 'Error'
            clientAppTypes   = 'CIPP'
        } -Compress
        $Entity = @{
            Policy       = [string]$ErrorPolicy
            RowKey       = [string]$GUID
            PartitionKey = 'CAPolicy'
            Tenant       = [string]$domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListConditionalAccessPoliciesAllTenants.ps1' 166
#Region './Public/Entrypoints/Activity Triggers/Push-ListLicensesQueue.ps1' -1

function Push-ListLicensesQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    # Write out the queue message and metadata to the information log.
    Write-Host "PowerShell queue trigger function processed work item: $($Item.defaultDomainName)"

    $domainName = $Item.defaultDomainName
    try {
        Write-Host "Processing $domainName"
        $Overview = Get-CIPPLicenseOverview -TenantFilter $domainName
    } catch {
        $Overview = [pscustomobject]@{
            Tenant         = [string]$domainName
            License        = "Could not connect to client: $($_.Exception.Message)"
            'PartitionKey' = 'License'
            'RowKey'       = "$($domainName)-$((New-Guid).Guid)"
        }
    } finally {
        $Table = Get-CIPPTable -TableName cachelicenses
        Add-CIPPAzDataTableEntity @Table -Entity $Overview -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListLicensesQueue.ps1' 27
#Region './Public/Entrypoints/Activity Triggers/Push-ListMailboxRulesQueue.ps1' -1

function Push-ListMailboxRulesQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    # Write out the queue message and metadata to the information log.
    Write-Host "PowerShell queue trigger function processed work item: $($Item.defaultDomainName)"

    $domainName = $Item.defaultDomainName

    $Table = Get-CIPPTable -TableName cachembxrules
    try {
        $Mailboxes = New-ExoRequest -tenantid $domainName -cmdlet 'Get-Mailbox' -Select 'userPrincipalName,GUID'
        $Request = $Mailboxes | ForEach-Object {
            @{
                OperationGuid = $_.UserPrincipalName
                CmdletInput   = @{
                    CmdletName = 'Get-InboxRule'
                    Parameters = @{
                        Mailbox = $_.UserPrincipalName
                    }
                }
            }
        }

        $Rules = New-ExoBulkRequest -tenantid $domainName -cmdletArray @($Request) | Where-Object { $_.Identity }
        if (($Rules | Measure-Object).Count -gt 0) {
            $GraphRequest = foreach ($Rule in $Rules) {
                [PSCustomObject]@{
                    Rules        = [string]($Rule | ConvertTo-Json)
                    RowKey       = [string](New-Guid).guid
                    Tenant       = [string]$domainName
                    PartitionKey = 'MailboxRules'
                }

            }
        } else {
            $Rules = @(@{
                    Name = 'No rules found'
                }) | ConvertTo-Json
            $GraphRequest = [PSCustomObject]@{
                Rules        = [string]$Rules
                RowKey       = [string]$domainName
                Tenant       = [string]$domainName
                PartitionKey = 'MailboxRules'
            }
        }
    } catch {
        $Rules = @{
            Name = "Could not connect to tenant $($_.Exception.message)"
        } | ConvertTo-Json
        $GraphRequest = [PSCustomObject]@{
            Rules        = [string]$Rules
            RowKey       = [string]$domainName
            Tenant       = [string]$domainName
            PartitionKey = 'MailboxRules'
        }
    }
    Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListMailboxRulesQueue.ps1' 63
#Region './Public/Entrypoints/Activity Triggers/Push-ListMailQuarantineAllTenants.ps1' -1

function Push-ListMailQuarantineAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName cacheQuarantineMessages
    Write-Host "PowerShell queue trigger function processed work item: $($Tenant.defaultDomainName)"

    try {
        $quarantineMessages = New-ExoRequest -tenantid $domainName -cmdlet 'Get-QuarantineMessage' -cmdParams @{ 'PageSize' = 1000 } | Select-Object -ExcludeProperty *data.type*
        $GraphRequest = foreach ($message in $quarantineMessages) {
            $messageData = @{
                QuarantineMessage = [string]($message | ConvertTo-Json -Depth 10 -Compress)
                RowKey            = [string](New-Guid).Guid
                PartitionKey      = 'QuarantineMessage'
                Tenant            = [string]$domainName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $messageData -Force | Out-Null
        }
    } catch {
        $errorData = ConvertTo-Json -InputObject @{
            Identity         = $null
            ReceivedTime     = (Get-Date).ToString('s')
            SenderAddress    = 'CIPP Error'
            RecipientAddress = 'N/A'
            Subject          = "Could not connect to Tenant: $($_.Exception.Message)"
            Size             = 0
            Type             = 'Error'
            QuarantineReason = 'ConnectionError'
        }
        $messageData = @{
            QuarantineMessage = [string]$errorData
            RowKey            = [string]$domainName
            PartitionKey      = 'QuarantineMessage'
            Tenant            = [string]$domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $messageData -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListMailQuarantineAllTenants.ps1' 44
#Region './Public/Entrypoints/Activity Triggers/Push-ListMFAUsersQueue.ps1' -1

function Push-ListMFAUsersQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    # Write out the queue message and metadata to the information log.
    Write-Host "PowerShell queue trigger function processed work item: $($Item.defaultDomainName)"

    try {
        #Update-CippQueueEntry -RowKey $Item.QueueId -Status 'Running' -Name $Item.displayName
        $domainName = $Item.defaultDomainName
        $Table = Get-CIPPTable -TableName cachemfa
        Try {
            $GraphRequest = Get-CIPPMFAState -TenantFilter $domainName -ErrorAction Stop
        } catch {
            $GraphRequest = $null
        }
        if (!$GraphRequest) {
            $GraphRequest = @{
                Tenant          = [string]$domainName
                UPN             = [string]$domainName
                AccountEnabled  = 'none'
                PerUser         = [string]'Could not connect to tenant'
                MFARegistration = 'none'
                CoveredByCA     = [string]'Could not connect to tenant'
                CoveredBySD     = 'none'
                RowKey          = [string]"$domainName"
                PartitionKey    = 'users'
            }
        } else {
            $GraphRequest = foreach ($Request in $GraphRequest) {
                $Request.CAPolicies = try { [string](@($Request.CAPolicies) | ConvertTo-Json -Compress -Depth 5) } catch { [string]$Request.CAPolicies }
                $Request.MFAMethods = try { [string](@($Request.MFAMethods) | ConvertTo-Json -Compress -Depth 5) } catch { [string]$Request.MFAMethods }
                $Request
            }
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null

    } catch {
        $Table = Get-CIPPTable -TableName cachemfa
        $GraphRequest = @{
            Tenant          = [string]$domainName
            UPN             = [string]$domainName
            AccountEnabled  = 'none'
            PerUser         = [string]'Could not connect to tenant'
            MFARegistration = 'none'
            CoveredByCA     = [string]'Could not connect to tenant'
            CoveredBySD     = 'none'
            RowKey          = [string]"$domainName"
            PartitionKey    = 'users'
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force | Out-Null
    } finally {
        #Update-CippQueueEntry -RowKey $QueueItem -Status 'Completed'
    }

}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListMFAUsersQueue.ps1' 60
#Region './Public/Entrypoints/Activity Triggers/Push-ListTenantAllowBlockListAllTenants.ps1' -1

function Push-ListTenantAllowBlockListAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding()]
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $domainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName 'cacheTenantAllowBlockList'
    $ListTypes = 'Sender', 'Url', 'FileHash', 'IP'

    try {
        foreach ($ListType in $ListTypes) {
            $Entries = New-ExoRequest -tenantid $domainName -cmdlet 'Get-TenantAllowBlockListItems' -cmdParams @{ ListType = $ListType }
            foreach ($Entry in $Entries) {
                $CleanEntry = $Entry | Select-Object -ExcludeProperty *'@data.type'*, *'(DateTime])'*
                $CleanEntry | Add-Member -MemberType NoteProperty -Name Tenant -Value $domainName -Force
                $CleanEntry | Add-Member -MemberType NoteProperty -Name ListType -Value $ListType -Force
                $Entity = @{
                    Entry        = [string]($CleanEntry | ConvertTo-Json -Depth 10 -Compress)
                    RowKey       = [string](New-Guid).Guid
                    PartitionKey = 'TenantAllowBlockList'
                    Tenant       = [string]$domainName
                }
                Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null
            }
        }
    } catch {
        $ErrorEntry = [pscustomobject]@{
            Tenant      = $domainName
            ListType    = 'Error'
            Identity    = 'Error'
            DisplayName = "Could not retrieve tenant allow/block list: $($_.Exception.Message)"
            Timestamp   = (Get-Date).ToString('s')
        }
        $Entity = @{
            Entry        = [string]($ErrorEntry | ConvertTo-Json -Depth 10 -Compress)
            RowKey       = [string](New-Guid).Guid
            PartitionKey = 'TenantAllowBlockList'
            Tenant       = [string]$domainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListTenantAllowBlockListAllTenants.ps1' 47
#Region './Public/Entrypoints/Activity Triggers/Push-ListTransportRulesAllTenants.ps1' -1

function Push-ListTransportRulesAllTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Tenant = Get-Tenants -TenantFilter $Item.customerId
    $DomainName = $Tenant.defaultDomainName
    $Table = Get-CIPPTable -TableName CacheTransportRules

    try {
        $TransportRules = New-ExoRequest -tenantid $DomainName -cmdlet 'Get-TransportRule'
        $Results = foreach ($rule in $TransportRules) {
            $GUID = (New-Guid).Guid
            $Results = @{
                TransportRule = [string]($rule | ConvertTo-Json -Depth 10)
                RowKey        = [string]$GUID
                PartitionKey  = 'TransportRule'
                Tenant        = [string]$DomainName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Results -Force | Out-Null
        }

    } catch {
        $GUID = (New-Guid).Guid
        $ErrorText = ConvertTo-Json -InputObject @{
            Tenant      = $DomainName
            Name        = "Could not connect to Tenant: $($_.Exception.Message)"
            State       = 'Error'
            Priority    = 0
            Description = "Error retrieving transport rules: $($_.Exception.Message)"
        }
        $Results = @{
            TransportRule = [string]$ErrorText
            RowKey        = [string]$GUID
            PartitionKey  = 'TransportRule'
            Tenant        = [string]$DomainName
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Results -Force | Out-Null
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-ListTransportRulesAllTenants.ps1' 43
#Region './Public/Entrypoints/Activity Triggers/Push-SchedulerCIPPNotifications.ps1' -1

function Push-SchedulerCIPPNotifications {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param (
        $QueueItem, $TriggerMetadata
    )
    #Add new alert engine.
    $Table = Get-CIPPTable -TableName SchedulerConfig
    $Filter = "RowKey eq 'CippNotifications' and PartitionKey eq 'CippNotifications'"
    $Config = [pscustomobject](Get-CIPPAzDataTableEntity @Table -Filter $Filter)

    $Settings = [System.Collections.Generic.List[string]]@('Alerts')
    $Config.psobject.properties.name | ForEach-Object { if ($Config.$_ -eq $true) { $Settings.Add($_) } }
    Write-Information "Our APIs are: $($Settings -join ',')"

    $severity = $Config.Severity -split ','
    if (!$severity) {
        $severity = [System.Collections.ArrayList]@('Info', 'Error', 'Warning', 'Critical', 'Alert')
    }
    Write-Information "Our Severity table is: $severity"

    $Table = Get-CIPPTable
    $PartitionKey = Get-Date -UFormat '%Y%m%d'
    $Filter = "PartitionKey eq '{0}'" -f $PartitionKey
    $Currentlog = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object {
        $_.API -in $Settings -and $_.sentAsAlert -ne $true -and $_.Severity -in $severity
    }
    $StandardsTable = Get-CIPPTable -tablename CippStandardsAlerts
    $CurrentStandardsLogs = Get-CIPPAzDataTableEntity @StandardsTable -Filter $Filter | Where-Object {
        $_.sentAsAlert -ne $true
    }
    Write-Information "Alerts: $($Currentlog.count) found"
    Write-Information "Standards: $($CurrentStandardsLogs.count) found"

    # Get the CIPP URL
    $CippConfigTable = Get-CippTable -tablename Config
    $CippConfig = Get-CIPPAzDataTableEntity @CippConfigTable -Filter "PartitionKey eq 'InstanceProperties' and RowKey eq 'CIPPURL'"
    $CIPPURL = 'https://{0}' -f $CippConfig.Value

    #email try
    try {
        if ($Config.email -like '*@*') {
            #Normal logs
            if ($Currentlog) {
                if ($config.onePerTenant) {
                    foreach ($tenant in ($CurrentLog.Tenant | Sort-Object -Unique)) {
                        $Data = ($CurrentLog | Select-Object Message, API, Tenant, Username, Severity | Where-Object -Property tenant -EQ $tenant)
                        $Subject = "$($Tenant): CIPP Alert: Alerts found starting at $((Get-Date).AddMinutes(-15))"
                        $HTMLContent = New-CIPPAlertTemplate -Data $Data -Format 'html' -InputObject 'table' -CIPPURL $CIPPURL
                        Send-CIPPAlert -Type 'email' -Title $Subject -HTMLContent $HTMLContent.htmlcontent -TenantFilter $tenant -APIName 'Alerts'
                        $UpdateLogs = $CurrentLog | ForEach-Object {
                            if ($_.PSObject.Properties.Name -contains 'sentAsAlert') {
                                $_.sentAsAlert = $true
                            } else {
                                $_ | Add-Member -MemberType NoteProperty -Name sentAsAlert -Value $true -Force
                            }
                            $_
                        }
                        if ($UpdateLogs) {
                            Add-CIPPAzDataTableEntity @Table -Entity $UpdateLogs -Force
                        }
                    }
                } else {
                    $Data = ($CurrentLog | Select-Object Message, API, Tenant, Username, Severity)
                    $Subject = "CIPP Alert: Alerts found starting at $((Get-Date).AddMinutes(-15))"
                    $HTMLContent = New-CIPPAlertTemplate -Data $Data -Format 'html' -InputObject 'table' -CIPPURL $CIPPURL
                    Send-CIPPAlert -Type 'email' -Title $Subject -HTMLContent $HTMLContent.htmlcontent -TenantFilter $tenant -APIName 'Alerts'
                    $UpdateLogs = $CurrentLog | ForEach-Object {
                        if ($_.PSObject.Properties.Name -contains 'sentAsAlert') {
                            $_.sentAsAlert = $true
                        } else {
                            $_ | Add-Member -MemberType NoteProperty -Name sentAsAlert -Value $true -Force
                        }
                        $_
                    }
                    if ($UpdateLogs) {
                        Add-CIPPAzDataTableEntity @Table -Entity $UpdateLogs -Force
                    }
                }
            }
            if ($CurrentStandardsLogs) {
                foreach ($tenant in ($CurrentStandardsLogs.Tenant | Sort-Object -Unique)) {
                    $Data = ($CurrentStandardsLogs | Where-Object -Property tenant -EQ $tenant)
                    $Subject = "$($Tenant): Standards are out of sync for $tenant"
                    $HTMLContent = New-CIPPAlertTemplate -Data $Data -Format 'html' -InputObject 'standards' -CIPPURL $CIPPURL
                    Send-CIPPAlert -Type 'email' -Title $Subject -HTMLContent $HTMLContent.htmlcontent -TenantFilter $tenant -APIName 'Alerts'
                    $updateStandards = $CurrentStandardsLogs | ForEach-Object {
                        if ($_.PSObject.Properties.Name -contains 'sentAsAlert') {
                            $_.sentAsAlert = $true
                        } else {
                            $_ | Add-Member -MemberType NoteProperty -Name sentAsAlert -Value $true -Force
                        }
                        $_
                    }
                    if ($updateStandards) { Add-CIPPAzDataTableEntity @StandardsTable -Entity $updateStandards -Force }
                }
            }
        }
    } catch {
        Write-Information "Could not send alerts to email: $($_.Exception.message)"
        Write-LogMessage -API 'Alerts' -message "Could not send alert emails: $($_.Exception.message)" -sev error -LogData (Get-CippException -Exception $_)
    }

    try {
        Write-Information $($config | ConvertTo-Json)
        Write-Information $config.webhook
        if (![string]::IsNullOrEmpty($config.webhook)) {
            if ($Currentlog) {
                $JSONContent = $Currentlog | ConvertTo-Json -Compress
                Send-CIPPAlert -Type 'webhook' -JSONContent $JSONContent -TenantFilter $Tenant -APIName 'Alerts'
                $UpdateLogs = $CurrentLog | ForEach-Object { $_.sentAsAlert = $true; $_ }
                if ($UpdateLogs) { Add-CIPPAzDataTableEntity @Table -Entity $UpdateLogs -Force }
            }

            if ($CurrentStandardsLogs) {
                $JSONContent = New-CIPPAlertTemplate -Data $Data -Format 'json' -InputObject 'table' -CIPPURL $CIPPURL
                $CurrentStandardsLogs | ConvertTo-Json -Compress
                Send-CIPPAlert -Type 'webhook' -JSONContent $JSONContent -TenantFilter $Tenant -APIName 'Alerts'
                $updateStandards = $CurrentStandardsLogs | ForEach-Object {
                    if ($_.PSObject.Properties.Name -contains 'sentAsAlert') {
                        $_.sentAsAlert = $true
                    } else {
                        $_ | Add-Member -MemberType NoteProperty -Name sentAsAlert -Value $true -Force
                    }
                    $_
                }
            }

        }
    } catch {
        Write-Information "Could not send alerts to webhook $($config.webhook): $($_.Exception.message)"
        Write-LogMessage -API 'Alerts' -message "Could not send alerts to webhook $($config.webhook): $($_.Exception.message)" -tenant $Tenant -sev error -LogData (Get-CippException -Exception $_)
    }

    if ($config.sendtoIntegration) {
        try {
            foreach ($tenant in ($CurrentLog.Tenant | Sort-Object -Unique)) {
                $Data = ($CurrentLog | Select-Object Message, API, Tenant, Username, Severity | Where-Object -Property tenant -EQ $tenant)
                $HTMLContent = New-CIPPAlertTemplate -Data $Data -Format 'html' -InputObject 'table' -CIPPURL $CIPPURL
                $Title = "$tenant CIPP Alert: Alerts found starting at $((Get-Date).AddMinutes(-15))"
                Send-CIPPAlert -Type 'psa' -Title $Title -HTMLContent $HTMLContent.htmlcontent -TenantFilter $tenant -APIName 'Alerts'
                $UpdateLogs = $CurrentLog | ForEach-Object { $_.SentAsAlert = $true; $_ }
                if ($UpdateLogs) { Add-CIPPAzDataTableEntity @Table -Entity $UpdateLogs -Force }
            }
            foreach ($standardsTenant in ($CurrentStandardsLogs.Tenant | Sort-Object -Unique)) {
                $Data = ($CurrentStandardsLogs | Where-Object -Property tenant -EQ $standardsTenant)
                $Subject = "$($standardsTenant): Standards are out of sync for $standardsTenant"
                $HTMLContent = New-CIPPAlertTemplate -Data $Data -Format 'html' -InputObject 'standards' -CIPPURL $CIPPURL
                Send-CIPPAlert -Type 'psa' -Title $Subject -HTMLContent $HTMLContent.htmlcontent -TenantFilter $standardsTenant -APIName 'Alerts'
                $updateStandards = $CurrentStandardsLogs | ForEach-Object {
                    if ($_.PSObject.Properties.Name -contains 'sentAsAlert') {
                        $_.sentAsAlert = $true
                    } else {
                        $_ | Add-Member -MemberType NoteProperty -Name sentAsAlert -Value $true -Force
                    }
                    $_
                }
            }
        } catch {
            Write-Information "Could not send alerts to ticketing system: $($_.Exception.message)"
            Write-LogMessage -API 'Alerts' -tenant $Tenant -message "Could not send alerts to ticketing system: $($_.Exception.message)" -sev Error
        }
    }

}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-SchedulerCIPPNotifications.ps1' 168
#Region './Public/Entrypoints/Activity Triggers/Push-UpdatePermissionsQueue.ps1' -1

function Push-UpdatePermissionsQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    try {
        $DomainRefreshRequired = $false

        if (!$Item.defaultDomainName) {
            $DomainRefreshRequired = $true
        }

        Write-Information "Applying permissions for $($Item.displayName)"
        $Table = Get-CIPPTable -TableName cpvtenants
        $CPVRows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Tenant -EQ $Item.customerId

        $Tenant = Get-Tenants -TenantFilter $Item.customerId -IncludeErrors

        if ((!$CPVRows -or $env:ApplicationID -notin $CPVRows.applicationId) -and $Tenant.delegatedPrivilegeStatus -ne 'directTenant') {
            Write-LogMessage -tenant $Item.defaultDomainName -tenantId $Item.customerId -message 'A New tenant has been added, or a new CIPP-SAM Application is in use' -Sev 'Warn' -API 'NewTenant'
            Write-Information 'Adding CPV permissions'
            Set-CIPPCPVConsent -Tenantfilter $Item.customerId
            $DomainRefreshRequired = $true
        }
        Write-Information 'Updating permissions'
        Add-CIPPApplicationPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -tenantfilter $Item.customerId
        Add-CIPPDelegatedPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -tenantfilter $Item.customerId
        Write-LogMessage -tenant $Item.defaultDomainName -tenantId $Item.customerId -message "Updated permissions for $($Item.displayName)" -Sev 'Info' -API 'UpdatePermissionsQueue'

        if ($Item.defaultDomainName -ne 'PartnerTenant') {
            Write-Information 'Pushing CIPP-SAM admin roles'
            Set-CIPPSAMAdminRoles -TenantFilter $Item.customerId
        }

        $Table = Get-CIPPTable -TableName cpvtenants
        $unixtime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
        $GraphRequest = @{
            LastApply     = "$unixtime"
            applicationId = "$($env:ApplicationID)"
            Tenant        = "$($Item.customerId)"
            PartitionKey  = 'Tenant'
            RowKey        = "$($Item.customerId)"
        }
        Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force

        if ($DomainRefreshRequired) {
            $UpdatedTenant = Get-Tenants -TenantFilter $Item.customerId -TriggerRefresh
            if ($UpdatedTenant.defaultDomainName) {
                Write-Information "Updated tenant domains $($UpdatedTenant.defaultDomainName)"
            }
        }
    } catch {
        Write-Information "Error updating permissions for $($Item.displayName)"
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-UpdatePermissionsQueue.ps1' 58
#Region './Public/Entrypoints/Activity Triggers/Push-UpdateTenants.ps1' -1

function Push-UpdateTenants {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    Param($Item)
    $QueueReference = 'UpdateTenants'
    $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -ne 'Completed' -and $_.Status -ne 'Failed' }

    $Queue = New-CippQueueEntry -Name 'Update Tenants' -Reference $QueueReference -TotalTasks 1
    try {
        $QueueTask = @{
            QueueId = $Queue.RowKey
            Name    = 'Get tenant list'
            Status  = 'Running'
        }
        $TaskStatus = Set-CippQueueTask @QueueTask
        $QueueTask.TaskId = $TaskStatus.RowKey
        Update-CippQueueEntry -RowKey $Queue.RowKey -Status 'Running'
        Get-Tenants -IncludeAll -TriggerRefresh | Out-Null
        Update-CippQueueEntry -RowKey $Queue.RowKey -Status 'Completed'
        $QueueTask.Status = 'Completed'
        Set-CippQueueTask @QueueTask
    } catch {
        Write-Host "Queue Error: $($_.Exception.Message)"
        Update-CippQueueEntry -RowKey $Queue.RowKey -Status 'Failed'
        $QueueTask.Status = 'Failed'
        Set-CippQueueTask @QueueTask
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-UpdateTenants.ps1' 31
#Region './Public/Entrypoints/Activity Triggers/Push-Z_CIPPQueueTrigger.ps1' -1

function Push-Z_CIPPQueueTrigger {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    Param($QueueItem, $TriggerMetadata)
    $APIName = $QueueItem.FunctionName

    $FunctionName = 'Push-{0}' -f $APIName
    if (Get-Command -Name $FunctionName -ErrorAction SilentlyContinue) {
        & $FunctionName -QueueItem $QueueItem -TriggerMetadata $TriggerMetadata
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Push-Z_CIPPQueueTrigger.ps1' 14
#Region './Public/Entrypoints/Activity Triggers/Standards/Push-CIPPDriftManagement.ps1' -1

function Push-CippDriftManagement {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param (
        $Item
    )

    Write-Information "Received drift standard item for $($Item.Tenant)"

    try {
        $Drift = Get-CIPPDrift -TenantFilter $Item.Tenant
        if ($Drift.newDeviationsCount -gt 0) {
            $Settings = $Drift.driftSettings
            $email = $Settings.driftAlertEmail
            $webhook = $Settings.driftAlertWebhook
            $CippConfigTable = Get-CippTable -tablename Config
            $CippConfig = Get-CIPPAzDataTableEntity @CippConfigTable -Filter "PartitionKey eq 'InstanceProperties' and RowKey eq 'CIPPURL'"
            $CIPPURL = 'https://{0}' -f $CippConfig.Value

            # Process deviations more efficiently with foreach instead of ForEach-Object
            $Data = foreach ($deviation in $Drift.currentDeviations) {
                $currentValue = if ($deviation.receivedValue -and $deviation.receivedValue.Length -gt 200) {
                    $deviation.receivedValue.Substring(0, 200) + '...'
                } else {
                    $deviation.receivedValue
                }
                [PSCustomObject]@{
                    Standard         = $deviation.standardDisplayName ? $deviation.standardDisplayName : $deviation.standardName
                    'Expected Value' = $deviation.expectedValue
                    'Current Value'  = $currentValue
                    Status           = $deviation.status
                }
            }

            $GenerateEmail = New-CIPPAlertTemplate -format 'html' -data $Data -CIPPURL $CIPPURL -Tenant $Item.Tenant -InputObject 'driftStandard' -AuditLogLink $drift.standardId

            # Send email alert if configured
            $CIPPAlert = @{
                Type         = 'email'
                Title        = $GenerateEmail.title
                HTMLContent  = $GenerateEmail.htmlcontent
                TenantFilter = $Item.Tenant
            }
            Write-Information "Sending email alert for tenant $($Item.Tenant)"
            Send-CIPPAlert @CIPPAlert -altEmail $email
            # Send webhook alert if configured
            $WebhookData = @{
                Title      = $GenerateEmail.title
                ActionUrl  = $GenerateEmail.ButtonUrl
                ActionText = $GenerateEmail.ButtonText
                AlertData  = $Data
                Tenant     = $Item.Tenant
            } | ConvertTo-Json -Depth 5 -Compress
            $CippAlert = @{
                Type         = 'webhook'
                Title        = $GenerateEmail.title
                JSONContent  = $WebhookData
                TenantFilter = $Item.Tenant
            }
            Write-Information "Sending webhook alert for tenant $($Item.Tenant)"
            Send-CIPPAlert @CippAlert -altWebhook $webhook
            # Always send PSA alert
            $CIPPAlert = @{
                Type         = 'psa'
                Title        = $GenerateEmail.title
                HTMLContent  = $GenerateEmail.htmlcontent
                TenantFilter = $Item.Tenant
            }
            Send-CIPPAlert @CIPPAlert
            return $true
        } else {
            Write-LogMessage -API 'DriftStandards' -tenant $Item.Tenant -message "No new drift deviations found for tenant $($Item.Tenant)" -sev Info
            return $true
        }
        Write-Information "Drift management completed for tenant $($Item.Tenant)"
    } catch {
        Write-LogMessage -API 'DriftStandards' -tenant $Item.Tenant -message "Error running Drift Check for tenant $($Item.Tenant) - $($_.Exception.Message)" -sev Error -LogData (Get-CippException -Exception $_)
        Write-Warning "Error running drift standards for tenant $($Item.Tenant) - $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        throw $_.Exception.Message
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Standards/Push-CIPPDriftManagement.ps1' 85
#Region './Public/Entrypoints/Activity Triggers/Standards/Push-CIPPStandard.ps1' -1

function Push-CIPPStandard {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param (
        $Item
    )

    Write-Information "Received queue item for $($Item.Tenant) and standard $($Item.Standard)."
    $Tenant = $Item.Tenant
    $Standard = $Item.Standard
    $FunctionName = 'Invoke-CIPPStandard{0}' -f $Standard
    Write-Information "We'll be running $FunctionName"

    if ($Standard -in @('IntuneTemplate', 'ConditionalAccessTemplate')) {
        $API = "$($Standard)_$($Item.templateId)_$($Item.Settings.TemplateList.value)"
    } else {
        $API = "$($Standard)_$($Item.templateId)"
    }

    $Rerun = Test-CIPPRerun -Type Standard -Tenant $Tenant -API $API
    if ($Rerun) {
        Write-Information 'Detected rerun. Exiting cleanly'
        exit 0
    } else {
        Write-Information "Rerun is set to false. We'll be running $FunctionName"
    }

    $StandardInfo = @{
        Standard           = $Standard
        StandardTemplateId = $Item.templateId
    }
    if ($Standard -eq 'IntuneTemplate') {
        $StandardInfo.IntuneTemplateId = $Item.Settings.TemplateList.value
    }
    if ($Standard -eq 'ConditionalAccessTemplate') {
        $StandardInfo.ConditionalAccessTemplateId = $Item.Settings.TemplateList.value
    }

    # Initialize AsyncLocal storage for thread-safe per-invocation context
    if (-not $script:CippStandardInfoStorage) {
        $script:CippStandardInfoStorage = [System.Threading.AsyncLocal[object]]::new()
    }
    $script:CippStandardInfoStorage.Value = $StandardInfo

    try {
        # Convert settings to JSON, replace %variables%, then convert back to object
        $SettingsJSON = $Item.Settings | ConvertTo-Json -Depth 10 -Compress
        if ($SettingsJSON -match '%') {
            $Settings = Get-CIPPTextReplacement -TenantFilter $Item.Tenant -Text $SettingsJSON | ConvertFrom-Json
        } else {
            $Settings = $Item.Settings
        }

        # Prepare telemetry metadata for standard execution
        $metadata = @{
            Standard     = $Standard
            Tenant       = $Tenant
            TemplateId   = $Item.templateId
            FunctionName = $FunctionName
            TriggerType  = 'Standard'
        }

        # Add template-specific metadata
        if ($Standard -eq 'IntuneTemplate' -and $Item.Settings.TemplateList.value) {
            $metadata['IntuneTemplateId'] = $Item.Settings.TemplateList.value
        }
        if ($Standard -eq 'ConditionalAccessTemplate' -and $Item.Settings.TemplateList.value) {
            $metadata['CATemplateId'] = $Item.Settings.TemplateList.value
        }

        # Wrap the standard execution with telemetry
        Measure-CippTask -TaskName $Standard -EventName 'CIPP.StandardCompleted' -Metadata $metadata -Script {
            & $FunctionName -Tenant $Item.Tenant -Settings $Settings -ErrorAction Stop
        }

        Write-Information "Standard $($Standard) completed for tenant $($Tenant)"
    } catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Error running standard $($Standard) for tenant $($Tenant) - $($_.Exception.Message)" -sev Error -LogData (Get-CippException -Exception $_)
        Write-Warning "Error running standard $($Standard) for tenant $($Tenant) - $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        throw $_.Exception.Message
    } finally {
        if ($script:CippStandardInfoStorage) {
            $script:CippStandardInfoStorage.Value = $null
        }
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Standards/Push-CIPPStandard.ps1' 90
#Region './Public/Entrypoints/Activity Triggers/Standards/Push-GetStandards.ps1' -1

function Push-GetStandards {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    Param($Item)

    $Params = $Item.StandardParams | ConvertTo-Json | ConvertFrom-Json -AsHashtable
    Write-Host "My params are $($Params | ConvertTo-Json -Depth 5 -Compress)"
    try {
        $AllTasks = Get-CIPPStandards @Params
        Write-Host "AllTasks: $($AllTasks | ConvertTo-Json -Depth 5 -Compress)"
        foreach ($task in $AllTasks) {
            [PSCustomObject]@{
                Tenant       = $task.Tenant
                Standard     = $task.Standard
                Settings     = $task.Settings
                QueueId      = $Item.QueueId
                templateId   = $task.templateId
                QueueName    = '{0} - {1}' -f $task.Standard, $Task.Tenant
                FunctionName = 'CIPPStandard'
            }
        }
    } catch {
        Write-Host "GetStandards Exception $($_.Exception.Message)"
    }

}
#EndRegion './Public/Entrypoints/Activity Triggers/Standards/Push-GetStandards.ps1' 29
#Region './Public/Entrypoints/Activity Triggers/Tenant Groups/Push-UpdateDynamicTenantGroup.ps1' -1

function Push-UpdateDynamicTenantGroup {
    <#
    .SYNOPSIS
    Push an update to a Dynamic Tenant Group
    .FUNCTIONALITY
    Entrypoint
    #>

    [CmdletBinding()]
    param ($Item)

    Write-Information "Pushing update to Dynamic Tenant Group: $($Item.Name) (ID: $($Item.Id))"
    Update-CIPPDynamicTenantGroups -GroupId $Item.Id
}
#EndRegion './Public/Entrypoints/Activity Triggers/Tenant Groups/Push-UpdateDynamicTenantGroup.ps1' 15
#Region './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogSearchCreation.ps1' -1

function Push-AuditLogSearchCreation {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param($Item)

    # Get params from batch item
    $Tenant = $Item.Tenant
    $StartTime = $Item.StartTime
    $EndTime = $Item.EndTime
    $ServiceFilters = @($Item.ServiceFilters)

    try {
        $LogSearch = @{
            StartTime         = $StartTime
            EndTime           = $EndTime
            ServiceFilters    = $ServiceFilters
            TenantFilter      = $Tenant.defaultDomainName
            ProcessLogs       = $true
            RecordTypeFilters = @(
                'exchangeAdmin', 'azureActiveDirectory', 'azureActiveDirectoryAccountLogon', 'dataCenterSecurityCmdlet',
                'complianceDLPSharePoint', 'complianceDLPExchange', 'azureActiveDirectoryStsLogon', 'skypeForBusinessPSTNUsage',
                'skypeForBusinessUsersBlocked', 'securityComplianceCenterEOPCmdlet', 'microsoftFlow', 'aeD', 'microsoftStream',
                'threatFinder', 'project', 'dataGovernance', 'securityComplianceAlerts', 'threatIntelligenceUrl',
                'securityComplianceInsights', 'mipLabel', 'workplaceAnalytics', 'powerAppsApp', 'powerAppsPlan',
                'threatIntelligenceAtpContent', 'labelContentExplorer', 'hygieneEvent',
                'dataInsightsRestApiAudit', 'informationBarrierPolicyApplication', 'microsoftTeamsAdmin', 'hrSignal',
                'informationWorkerProtection', 'campaign', 'dlpEndpoint', 'airInvestigation', 'quarantine', 'microsoftForms',
                'applicationAudit', 'complianceSupervisionExchange', 'customerKeyServiceEncryption', 'officeNative',
                'mipAutoLabelSharePointItem', 'mipAutoLabelSharePointPolicyLocation', 'secureScore',
                'mipAutoLabelExchangeItem', 'cortanaBriefing', 'search', 'wdatpAlerts', 'powerPlatformAdminDlp',
                'powerPlatformAdminEnvironment', 'mdatpAudit', 'sensitivityLabelPolicyMatch', 'sensitivityLabelAction',
                'sensitivityLabeledFileAction', 'attackSim', 'airManualInvestigation', 'securityComplianceRBAC', 'userTraining',
                'airAdminActionInvestigation', 'mstic', 'physicalBadgingSignal', 'aipDiscover', 'aipSensitivityLabelAction',
                'aipProtectionAction', 'aipFileDeleted', 'aipHeartBeat', 'mcasAlerts', 'onPremisesFileShareScannerDlp',
                'onPremisesSharePointScannerDlp', 'exchangeSearch', 'privacyDataMinimization', 'labelAnalyticsAggregate',
                'myAnalyticsSettings', 'securityComplianceUserChange', 'complianceDLPExchangeClassification',
                'complianceDLPEndpoint', 'mipExactDataMatch', 'msdeResponseActions', 'msdeGeneralSettings', 'msdeIndicatorsSettings',
                'ms365DCustomDetection', 'msdeRolesSettings', 'mapgAlerts', 'mapgPolicy', 'mapgRemediation',
                'privacyRemediationAction', 'privacyDigestEmail', 'mipAutoLabelSimulationProgress', 'mipAutoLabelSimulationCompletion',
                'mipAutoLabelProgressFeedback', 'dlpSensitiveInformationType', 'mipAutoLabelSimulationStatistics',
                'largeContentMetadata', 'microsoft365Group', 'cdpMlInferencingResult', 'filteringMailMetadata',
                'cdpClassificationMailItem', 'cdpClassificationDocument', 'officeScriptsRunAction', 'filteringPostMailDeliveryAction',
                'cdpUnifiedFeedback', 'tenantAllowBlockList', 'consumptionResource', 'healthcareSignal', 'dlpImportResult',
                'cdpCompliancePolicyExecution', 'multiStageDisposition', 'privacyDataMatch', 'filteringDocMetadata',
                'filteringEmailFeatures', 'powerBIDlp', 'filteringUrlInfo', 'filteringAttachmentInfo', 'coreReportingSettings',
                'complianceConnector', 'powerPlatformLockboxResourceAccessRequest', 'powerPlatformLockboxResourceCommand',
                'cdpPredictiveCodingLabel', 'cdpCompliancePolicyUserFeedback', 'webpageActivityEndpoint', 'omePortal',
                'cmImprovementActionChange', 'filteringUrlClick', 'mipLabelAnalyticsAuditRecord', 'filteringEntityEvent',
                'filteringRuleHits', 'filteringMailSubmission', 'labelExplorer', 'microsoftManagedServicePlatform',
                'powerPlatformServiceActivity', 'scorePlatformGenericAuditRecord', 'filteringTimeTravelDocMetadata', 'alert',
                'alertStatus', 'alertIncident', 'incidentStatus', 'case', 'caseInvestigation', 'recordsManagement',
                'privacyRemediation', 'dataShareOperation', 'cdpDlpSensitive', 'ehrConnector', 'filteringMailGradingResult',
                'microsoftTodoAudit', 'timeTravelFilteringDocMetadata', 'microsoftDefenderForIdentityAudit',
                'supervisoryReviewDayXInsight', 'defenderExpertsforXDRAdmin', 'cdpEdgeBlockedMessage', 'hostedRpa',
                'cdpContentExplorerAggregateRecord', 'cdpHygieneAttachmentInfo', 'cdpHygieneSummary', 'cdpPostMailDeliveryAction',
                'cdpEmailFeatures', 'cdpHygieneUrlInfo', 'cdpUrlClick', 'cdpPackageManagerHygieneEvent', 'filteringDocScan',
                'timeTravelFilteringDocScan', 'mapgOnboard'
            )
        }
        if ($PSCmdlet.ShouldProcess('Push-AuditLogSearchCreation', 'Creating Audit Log Search')) {
            $NewSearch = New-CippAuditLogSearch @LogSearch
            Write-Information "Created audit log search $($Tenant.defaultDomainName) - $($NewSearch.displayName)"
        }
    } catch {
        Write-Information "Error creating audit log search $($Tenant.defaultDomainName) - $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }
    return $true
}
#EndRegion './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogSearchCreation.ps1' 73
#Region './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogTenantDownload.ps1' -1

function Push-AuditLogTenantDownload {
    param($Item)
    $TenantFilter = $Item.TenantFilter

    try {
        Write-Information "Audit Logs: Downloading $($TenantFilter)"
        # Get CIPP Url, cleanup legacy tasks
        $SchedulerConfig = Get-CippTable -TableName 'SchedulerConfig'
        $LegacyWebhookTasks = Get-CIPPAzDataTableEntity @SchedulerConfig -Filter "PartitionKey eq 'webhookcreation'"
        $LegacyUrl = $LegacyWebhookTasks | Select-Object -First 1 -ExpandProperty CIPPURL
        $CippConfigTable = Get-CippTable -tablename Config
        $CippConfig = Get-CIPPAzDataTableEntity @CippConfigTable -Filter "PartitionKey eq 'InstanceProperties' and RowKey eq 'CIPPURL'"
        if ($LegacyUrl) {
            if (!$CippConfig) {
                $Entity = @{
                    PartitionKey = 'InstanceProperties'
                    RowKey       = 'CIPPURL'
                    Value        = [string]([System.Uri]$LegacyUrl).Host
                }
                Add-CIPPAzDataTableEntity @CippConfigTable -Entity $Entity -Force
            }
            # remove legacy webhooks
            foreach ($Task in $LegacyWebhookTasks) {
                Remove-AzDataTableEntity -Force @SchedulerConfig -Entity $Task
            }
            $CIPPURL = $LegacyUrl
        } else {
            if (!$CippConfig) {
                $CippConfig = @{
                    PartitionKey = 'InstanceProperties'
                    RowKey       = 'CIPPURL'
                    Value        = [string]([System.Uri]$Request.Headers.'x-ms-original-url').Host
                }
                Add-AzDataTableEntity @CippConfigTable -Entity $CippConfig -Force
                $CIPPURL = 'https://{0}' -f $CippConfig.Value
            } else { $CIPPURL = 'https://{0}' -f $CippConfig.Value }
        }

        $LogSearchesTable = Get-CippTable -TableName 'AuditLogSearches'

        try {
            $LogSearches = Get-CippAuditLogSearches -TenantFilter $TenantFilter -ReadyToProcess | Select-Object -First 10
            Write-Information ('Audit Logs: Found {0} searches, begin downloading' -f $LogSearches.Count)
            foreach ($Search in $LogSearches) {
                $SearchEntity = Get-CIPPAzDataTableEntity @LogSearchesTable -Filter "Tenant eq '$($TenantFilter)' and RowKey eq '$($Search.id)'"
                $SearchEntity.CippStatus = 'Processing'
                Add-CIPPAzDataTableEntity @LogSearchesTable -Entity $SearchEntity -Force
                try {
                    Write-Information "Audit Log search: Processing search ID: $($Search.id) for tenant: $TenantFilter"
                    $Downloads = New-CIPPAuditLogSearchResultsCache -TenantFilter $TenantFilter -searchId $Search.id
                    $SearchEntity.CippStatus = 'Downloaded'
                } catch {
                    if ($_.Exception.Message -match 'Request rate is large. More Request Units may be needed, so no changes were made. Please retry this request later.') {
                        $SearchEntity.CippStatus = 'Pending'
                        Write-Information "Audit Log search: Rate limit hit for $($SearchEntity.RowKey)."
                        if ($SearchEntity.PSObject.Properties.Name -contains 'RetryCount') {
                            $SearchEntity.RetryCount++
                        } else {
                            $SearchEntity | Add-Member -MemberType NoteProperty -Name RetryCount -Value 1
                        }
                    } else {
                        $Exception = [string](ConvertTo-Json -Compress -InputObject (Get-CippException -Exception $_))
                        $SearchEntity | Add-Member -MemberType NoteProperty -Name Error -Value $Exception
                        $SearchEntity.CippStatus = 'Failed'
                        Write-Information "Error processing audit log rules: $($_.Exception.Message)"
                    }

                }
                Add-CIPPAzDataTableEntity @LogSearchesTable -Entity $SearchEntity -Force
            }
        } catch {
            Write-Information ('Audit Log search: Error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
            exit 0
        }

    } catch {
        Write-Information ('Push-AuditLogTenant: Error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
        exit 0
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogTenantDownload.ps1' 81
#Region './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogTenantProcess.ps1' -1

function Push-AuditLogTenantProcess {
    param($Item)
    $TenantFilter = $Item.TenantFilter
    $RowIds = $Item.RowIds

    try {
        Write-Information "Audit Logs: Processing $($TenantFilter) with $($RowIds.Count) row IDs. We're processing id $($RowIds[0]) to $($RowIds[-1])"

        # Get the CacheWebhooks table
        $CacheWebhooksTable = Get-CippTable -TableName 'CacheWebhooks'
        # we do it this way because the rows can grow extremely large, if we get them all it might just hang for minutes at a time.
        $Rows = foreach ($RowId in $RowIds) {
            $CacheEntity = Get-CIPPAzDataTableEntity @CacheWebhooksTable -Filter "PartitionKey eq '$TenantFilter' and RowKey eq '$RowId'"
            if ($CacheEntity) {
                $AuditData = $CacheEntity.JSON | ConvertFrom-Json -ErrorAction SilentlyContinue
                $AuditData
            }
        }

        if ($Rows.Count -gt 0) {
            Write-Information "Retrieved $($Rows.Count) rows from cache for processing"
            Test-CIPPAuditLogRules -TenantFilter $TenantFilter -Rows $Rows
            return $true
        } else {
            Write-Information 'No rows found in cache for the provided row IDs'
            return $false
        }
    } catch {
        Write-Information ('Push-AuditLogTenant: Error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
        return $false
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Webhooks/Push-AuditLogTenantProcess.ps1' 33
#Region './Public/Entrypoints/Activity Triggers/Webhooks/Push-PublicWebhookProcess.ps1' -1

function Push-PublicWebhookProcess {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param($Item)

    $Table = Get-CIPPTable -TableName WebhookIncoming
    $Webhook = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Item.RowKey)'"
    try {
        if ($Webhook.Type -eq 'GraphSubscription') {
            Invoke-CippGraphWebhookProcessing -Data ($Webhook.Data | ConvertFrom-Json) -CIPPID $Webhook.CIPPID -WebhookInfo ($Webhook.Webhookinfo | ConvertFrom-Json)
        } elseif ($Webhook.Type -eq 'AuditLog') {
            Invoke-CippWebhookProcessing -TenantFilter $Webhook.TenantFilter -Data ($Webhook.Data | ConvertFrom-Json) -CIPPURL $Webhook.CIPPURL
        } elseif ($Webhook.Type -eq 'PartnerCenter') {
            Invoke-CippPartnerWebhookProcessing -Data ($Webhook.Data | ConvertFrom-Json)
        }
    } catch {
        Write-Host "Webhook Exception: $($_.Exception.Message)"
    } finally {
        $Entity = $Webhook | Select-Object -Property RowKey, PartitionKey
        Remove-AzDataTableEntity -Force @Table -Entity $Entity
    }
}
#EndRegion './Public/Entrypoints/Activity Triggers/Webhooks/Push-PublicWebhookProcess.ps1' 25
#Region './Public/Entrypoints/Activity Triggers/Webhooks/Push-Schedulerwebhookcreation.ps1' -1

function Push-Schedulerwebhookcreation {
    <#
    .FUNCTIONALITY
        Entrypoint
    #>
    param (
        $item
    )
    <#$Table = Get-CIPPTable -TableName 'SchedulerConfig'
    $WebhookTable = Get-CIPPTable -TableName 'webhookTable'
    $Tenant = $Item.Tenant
    $Row = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($item.SchedulerRow)'"
    if (!$Row) {
        Write-Information "No row found for $($item.SchedulerRow). Full received item was $($item | ConvertTo-Json)"
        return
    } else {
        Write-Information "Working on $Tenant - $($Item.Tenantid)"
        #use the queueitem to see if we already have a webhook for this tenant + webhooktype. If we do, delete this row from SchedulerConfig.
        $Webhook = Get-CIPPAzDataTableEntity @WebhookTable -Filter "PartitionKey eq '$Tenant' and Version eq '3' and Resource eq '$($Row.webhookType)'"
        if ($Webhook) {
            Write-Information "Found existing webhook for $Tenant - $($Row.webhookType)"
            if ($Row.tenantid -ne 'AllTenants') {
                Remove-AzDataTableEntity -Force @Table -Entity $Row
            }
            if (($Webhook | Measure-Object).Count -gt 1) {
                $Webhook = $Webhook | Select-Object -First 1
                $WebhooksToRemove = $ExistingWebhooks | Where-Object { $_.RowKey -ne $Webhook.RowKey }
                foreach ($RemoveWebhook in $WebhooksToRemove) {
                    Remove-AzDataTableEntity -Force @WebhookTable -Entity $RemoveWebhook
                }
            }
        } else {
            Write-Information "No existing webhook for $Tenant - $($Row.webhookType) - Time to create."
            try {
                $NewSub = New-CIPPGraphSubscription -TenantFilter $Tenant -EventType $Row.webhookType -auditLogAPI $true
                if ($NewSub.Success -and $Row.tenantid -ne 'AllTenants') {
                    Remove-AzDataTableEntity -Force @Table -Entity $Row
                } else {
                    Write-Information "Failed to create webhook for $Tenant - $($Row.webhookType) - $($_.Exception.Message)"
                }
            } catch {
                Write-Information "Failed to create webhook for $Tenant - $($Row.webhookType): $($_.Exception.Message)"
            }
        }
    }#>

}
#EndRegion './Public/Entrypoints/Activity Triggers/Webhooks/Push-Schedulerwebhookcreation.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAddAlert.ps1' -1

function Invoke-ExecAddAlert {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $Severity = 'Alert'

    $Result = if ($Request.Body.sendEmailNow -or $Request.Body.sendWebhookNow -eq $true -or $Request.Body.writeLog -eq $true -or $Request.Body.sendPsaNow -eq $true) {
        $sev = ([pscustomobject]$Request.body.Severity).value -join (',')
        if ($Request.body.email -or $Request.body.webhook) {
            Write-Host 'found config, setting'
            $config = @{
                email             = $Request.body.email
                webhook           = $Request.body.webhook
                onepertenant      = $Request.body.onePerTenant
                logsToInclude     = $Request.body.logsToInclude
                sendtoIntegration = $true
                sev               = $sev
            }
            Write-Host "setting notification config to $($config | ConvertTo-Json)"
            $Results = Set-cippNotificationConfig @Config
            Write-Host $Results
        }
        $Title = 'CIPP Notification Test'
        if ($Request.Body.sendEmailNow -eq $true) {
            $CIPPAlert = @{
                Type        = 'email'
                Title       = $Title
                HTMLContent = $Request.Body.text
            }
            Send-CIPPAlert @CIPPAlert
        }
        if ($Request.Body.sendWebhookNow -eq $true) {
            $JSONContent = @{
                Title = $Title
                Text  = $Request.Body.text
            } | ConvertTo-Json -Compress
            $CIPPAlert = @{
                Type        = 'webhook'
                Title       = $Title
                JSONContent = $JSONContent
            }
            Send-CIPPAlert @CIPPAlert
        }
        if ($Request.Body.sendPsaNow -eq $true) {
            $CIPPAlert = @{
                Type        = 'psa'
                Title       = $Title
                HTMLContent = $Request.Body.text
            }
            Send-CIPPAlert @CIPPAlert
        }

        if ($Request.Body.writeLog -eq $true) {
            Write-LogMessage -headers $Headers -API 'Alerts' -message $Request.Body.text -Sev $Severity
            'Successfully generated alert.'
        }
    } else {
        Write-LogMessage -headers $Headers -API 'Alerts' -message $Request.Body.text -Sev $Severity
        'Successfully generated alert.'
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Result
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAddAlert.ps1' 74
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAppInsightsQuery.ps1' -1

function Invoke-ExecAppInsightsQuery {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.Read
    #>
    [CmdletBinding()]
    param (
        $Request,
        $TriggerMetadata
    )

    $Query = $Request.Body.query ?? $Request.Query.query
    if (-not $Query) {
        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = @{
                Results = 'No query provided in request body.'
            }
        }
    }

    try {
        $LogData = Get-ApplicationInsightsQuery -Query $Query

        $Body = @{
            Results  = @($LogData)
            Metadata = @{
                Query = $Query
            }
        } | ConvertTo-Json -Depth 10 -Compress

        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        }

    } catch {
        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::InternalServerError
            Body       = @{
                Results  = "$($_.Exception.Message)"
                Metadata = @{
                    Query     = $Query
                    Exception = Get-CippException -Exception $_
                }
            }
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAppInsightsQuery.ps1' 52
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAzBobbyTables.ps1' -1


function Invoke-ExecAzBobbyTables {
    <#
    .SYNOPSIS
        Execute a AzBobbyTables function
    .DESCRIPTION
        This function is used to interact with Azure Tables. This is advanced functionality used for external integrations or SuperAdmin functionality.
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $AllowList = @(
        'Add-AzDataTableEntity'
        'Add-CIPPAzDataTableEntity'
        'Update-AzDataTableEntity'
        'Get-AzDataTableEntity'
        'Get-CIPPAzDataTableEntity'
        'Get-AzDataTable'
        'New-AzDataTable'
        'Remove-AzDataTableEntity'
        'Remove-AzDataTable'
    )

    $Function = $Request.Body.FunctionName
    $Params = if ($Request.Body.Parameters) {
        $Request.Body.Parameters | ConvertTo-Json -Compress -ErrorAction Stop | ConvertFrom-Json -AsHashtable
    } else {
        @{}
    }

    if ($Function -in $AllowList) {
        if ($Function -eq 'Get-AzDataTable') {
            $Context = New-AzDataTableContext -ConnectionString $env:AzureWebJobsStorage
        } else {
            $Context = New-AzDataTableContext -ConnectionString $env:AzureWebJobsStorage -TableName $Request.Body.TableName
        }
        try {
            $Results = & $Function -Context $Context @Params
            if (!$Results) {
                $Results = "Function $Function executed successfully"
            }
            $StatusCode = [HttpStatusCode]::OK
        } catch {
            $Results = $_.Exception.Message
            $StatusCode = [HttpStatusCode]::InternalServerError
        }
    } else {
        $Results = "Function $Function not found or not allowed"
        $StatusCode = [HttpStatusCode]::NotFound
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecAzBobbyTables.ps1' 60
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCippFunction.ps1' -1

function Invoke-ExecCippFunction {
    <#
    .SYNOPSIS
        Execute a CIPPCore function
    .DESCRIPTION
        This function is used to execute a CIPPCore function from an HTTP request. This is advanced functionality used for external integrations or SuperAdmin functionality.
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $BlockList = @(
        'Get-GraphToken'
        'Get-GraphTokenFromCert'
        'Get-ClassicAPIToken'
    )

    $Function = $Request.Body.FunctionName
    $Params = if ($Request.Body.Parameters) {
        $Request.Body.Parameters | ConvertTo-Json -Compress -ErrorAction Stop | ConvertFrom-Json -AsHashtable
    } else {
        @{}
    }

    if (Get-Command -Module CIPPCore -Name $Function -and $BlockList -notcontains $Function) {
        try {
            $Results = & $Function @Params
            if (!$Results) {
                $Results = "Function $Function executed successfully"
            }
            $StatusCode = [HttpStatusCode]::OK
        } catch {
            $Results = $_.Exception.Message
            $StatusCode = [HttpStatusCode]::InternalServerError
        }
    } else {
        $Results = "Function $Function not found or not allowed"
        $StatusCode = [HttpStatusCode]::NotFound
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCippFunction.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCloneTemplate.ps1' -1

function Invoke-ExecCloneTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.ReadWrite
    #>
    param(
        $Request,
        $TriggerMetadata
    )

    $GUID = $Request.Query.GUID ?? $Request.Body.GUID
    $Type = $Request.Query.Type ?? $Request.Body.Type

    if ($GUID -and $Type) {
        $Table = Get-CIPPTable -tablename templates
        $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$Type' and RowKey eq '$GUID'"

        if ($Template) {
            $NewGuid = [guid]::NewGuid().ToString()
            $Template.RowKey = $NewGuid
            $Template.JSON = $Template.JSON -replace $GUID, $NewGuid
            $Template.Package = $null
            $Template.SHA = $null
            try {
                Add-CIPPAzDataTableEntity @Table -Entity $Template
                $body = @{
                    Results = @{
                        state      = 'success'
                        resultText = 'Template cloned successfully'
                    }
                }
            } catch {
                $body = @{
                    Results = @{
                        state      = 'error'
                        resultText = 'Failed to clone template'
                        details    = Get-CIPPException -Exception $_
                    }
                }
            }
        } else {
            $body = @{
                Results = @{
                    state      = 'error'
                    resultText = 'Template not found'
                }
            }
        }
    } else {
        $body = @{
            Results = @{
                state      = 'error'
                resultText = 'GUID or Type not provided'
            }
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCloneTemplate.ps1' 64
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCPVRefresh.ps1' -1

function Invoke-ExecCPVRefresh {
    <#
    .SYNOPSIS
    This endpoint is used to trigger a refresh of CPV for all tenants

    .FUNCTIONALITY
    Entrypoint

    .ROLE
    CIPP.Core.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $InstanceId = Start-UpdatePermissionsOrchestrator

    return @{
        StatusCode = [System.Net.HttpStatusCode]::OK
        Body       = @{
            Results    = 'CPV Refresh has been triggered'
            InstanceId = $InstanceId
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecCPVRefresh.ps1' 24
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecDiagnosticsPresets.ps1' -1

function Invoke-ExecDiagnosticsPresets {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param (
        $Request,
        $TriggerMetadata
    )

    try {
        $Table = Get-CIPPTable -TableName 'DiagnosticsPresets'
        $Action = $Request.Body.action
        $GUID = $Request.Body.GUID

        if ($Action -eq 'delete') {
            if (-not $GUID) {
                return [HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::BadRequest
                    Body       = @{
                        Results = 'GUID is required for delete action'
                    }
                }
            }

            Remove-AzDataTableEntity @Table -Entity @{
                PartitionKey = 'Preset'
                RowKey       = $GUID
            }

            return [HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{
                    Results = 'Preset deleted successfully'
                }
            }
        } else {
            # Save or update preset
            $Name = $Request.Body.name
            $Query = $Request.Body.query

            if (-not $Name -or -not $Query) {
                return [HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::BadRequest
                    Body       = @{
                        Results = 'Name and query are required'
                    }
                }
            }

            # Use provided GUID or generate new one
            if (-not $GUID) {
                $GUID = (New-Guid).Guid
            }

            # Convert query to compressed JSON for storage
            $QueryJson = ConvertTo-Json -InputObject @{ query = $Query } -Compress

            $Entity = @{
                PartitionKey = 'Preset'
                RowKey       = [string]$GUID
                name         = [string]$Name
                data         = [string]$QueryJson
            }

            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

            return [HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{
                    Results  = 'Preset saved successfully'
                    Metadata = @{
                        GUID = $GUID
                    }
                }
            }
        }
    } catch {
        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::InternalServerError
            Body       = @{
                Error = "Failed to manage diagnostics preset: $($_.Exception.Message)"
            }
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecDiagnosticsPresets.ps1' 90
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecDurableFunctions.ps1' -1

function Invoke-ExecDurableFunctions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param($Request, $TriggerMetadata)
    # Collect info
    $StorageContext = New-AzStorageContext -ConnectionString $env:AzureWebJobsStorage
    $FunctionName = $env:WEBSITE_SITE_NAME

    # Get orchestrators
    $InstancesTable = Get-CippTable -TableName ('{0}Instances' -f $FunctionName)
    $Yesterday = (Get-Date).AddDays(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
    $Filter = "CreatedTime ge datetime'$Yesterday' or RuntimeStatus eq 'Pending' or RuntimeStatus eq 'Running'"
    $Instances = Get-CippAzDataTableEntity @InstancesTable -Filter $Filter

    switch ($Request.Query.Action) {
        'ListOrchestrators' {
            $Orchestrators = foreach ($Instance in $Instances) {
                $Json = $Instance.Input -replace '^"(.+)"$', '$1' -replace '\\"', '"'

                if ($Json -notmatch '^http' -and ![string]::IsNullOrEmpty($Json)) {
                    if (Test-Json -Json $Json -ErrorAction SilentlyContinue) {
                        $Instance.Input = $Json | ConvertFrom-Json
                        if (![string]::IsNullOrEmpty($Instance.Input.OrchestratorName)) {
                            $Instance.Name = $Instance.Input.OrchestratorName
                        }
                    } else {
                        #Write-Host $Instance.Input
                        if ($Json -match '\"OrchestratorName\":\"(.+?)\"') {
                            $Instance.Name = $Matches[1]
                        }
                        $Instance.Input = 'Invalid JSON'
                    }
                }
                $Instance
            }

            $Body = [PSCustomObject]@{
                Orchestrators = @($Orchestrators)
            }
        }
        'ListOrchestratorHistory' {
            if ($Request.Query.PartitionKey) {
                $HistoryTable = Get-CippTable -TableName ('{0}History' -f $FunctionName)
                $Filter = "PartitionKey eq '{0}'" -f $Request.Query.PartitionKey
                $History = Get-CippAzDataTableEntity @HistoryTable -Filter $Filter -Property PartitionKey, RowKey, Timestamp, EventType, Name, IsPlayed, OrchestrationStatus | Select-Object * -ExcludeProperty ETag

                $Body = [PSCustomObject]@{
                    Results = @($History)
                }
            } else {
                $Body = [PSCustomObject]@{
                    Results = @('PartitionKey is required')
                }
            }
        }
        'ListStats' {
            $OrchestratorsByStatus = $Instances | Group-Object -Property RuntimeStatus

            if ($OrchestratorsByStatus.Name -contains 'Pending') {
                $PendingOrchestrators = $OrchestratorsByStatus | Where-Object -Property Name -EQ 'Pending' | Select-Object -ExpandProperty Group
                $Pending30MinCount = $PendingOrchestrators | Where-Object { $_.CreatedTime -lt (Get-Date).AddMinutes(-30).ToUniversalTime() } | Measure-Object | Select-Object -ExpandProperty Count
            }

            $Queues = Get-AzStorageQueue -Context $StorageContext -Name ('{0}*' -f $FunctionName) | Select-Object -Property Name, ApproximateMessageCount

            $Body = [PSCustomObject]@{
                Orchestrators     = @($OrchestratorsByStatus | Select-Object Count, Name)
                Pending30MinCount = $Pending30MinCount ?? 0
                Queues            = @($Queues)
            }
        }
        'ResetDurables' {
            try {
                $Queues = Get-AzStorageQueue -Context $StorageContext -Name ('{0}*' -f $FunctionName) | Select-Object -Property Name, ApproximateMessageCount, QueueClient

                $RunningQueues = $Queues | Where-Object { $_.ApproximateMessageCount -gt 0 }
                foreach ($Queue in $RunningQueues) {
                    Write-Information "- Removing queue: $($Queue.Name), message count: $($Queue.ApproximateMessageCount)"
                    if ($PSCmdlet.ShouldProcess($Queue.Name, 'Clear Queue')) {
                        $Queue.QueueClient.ClearMessagesAsync()
                    }
                }

                $RunningInstances = $Instances | Where-Object { $_.RuntimeStatus -eq 'Running' -or $_.RuntimeStatus -eq 'Pending' }
                if (($RunningInstances | Measure-Object).Count -gt 0) {
                    if ($PSCmdlet.ShouldProcess('Orchestrators', 'Mark Failed')) {
                        foreach ($Instance in $RunningInstances) {
                            $Instance.RuntimeStatus = 'Failed'
                            Update-AzDataTableEntity -Force @InstancesTable -Entity $Instance
                        }
                    }
                }

                $QueueTable = Get-CippTable -TableName 'CippQueue'
                $CippQueue = Invoke-ListCippQueue
                $QueueEntities = foreach ($Queue in $CippQueue) {
                    if ($Queue.Status -eq 'Running') {
                        $Queue.TotalTasks = $Queue.CompletedTasks
                        $Queue | Select-Object -Property PartitionKey, RowKey, TotalTasks
                    }
                }
                if (($QueueEntities | Measure-Object).Count -gt 0) {
                    if ($PSCmdlet.ShouldProcess('Queues', 'Mark Failed')) {
                        Update-AzDataTableEntity -Force @QueueTable -Entity $QueueEntities
                    }
                }

                $CippQueueTasks = Get-CippTable -TableName 'CippQueueTasks'
                $RunningTasks = Get-CIPPAzDataTableEntity @CippQueueTasks -Filter "PartitionKey eq 'Task' and Status eq 'Running'" -Property RowKey, PartitionKey, Status
                if (($RunningTasks | Measure-Object).Count -gt 0) {
                    if ($PSCmdlet.ShouldProcess('Tasks', 'Mark Failed')) {
                        $UpdatedTasks = foreach ($Task in $RunningTasks) {
                            $Task.Status = 'Failed'
                            $Task
                        }
                        Update-AzDataTableEntity -Force @CippQueueTasks -Entity $UpdatedTasks
                    }
                }

                $Body = [PSCustomObject]@{
                    Message = 'Durable Queues reset successfully'
                }

            } catch {
                $Body = [PSCustomObject]@{
                    Message   = "Error resetting durables: $($_.Exception.Message)"
                    Exception = Get-CippException -Exception $_
                }
            }
        }
        'PurgeOrchestrators' {
            $HistoryTable = Get-CippTable -TableName ('{0}History' -f $FunctionName)
            if ($Request.Query.PartitionKey) {
                $HistoryEntities = Get-CIPPAzDataTableEntity @HistoryTable -Filter "PartitionKey eq '$($Request.Query.PartitionKey)'" -Property RowKey, PartitionKey
                if ($HistoryEntities) {
                    Remove-AzDataTableEntity -Force @HistoryTable -Entity $HistoryEntities
                }
                $Instance = Get-CIPPAzDataTableEntity @InstancesTable -Filter "PartitionKey eq '$($Request.Query.PartitionKey)'" -Property RowKey, PartitionKey
                if ($Instance) {
                    Remove-AzDataTableEntity -Force @InstancesTable -Entity $Instance
                }
                $Body = [PSCustomObject]@{
                    Results = 'Orchestrator {0} purged successfully' -f $Request.Query.PartitionKey
                }
            } else {
                Remove-AzDataTable @InstancesTable
                Remove-AzDataTable @HistoryTable
                $BlobContainer = '{0}-largemessages' -f $Function.Name
                if (Get-AzStorageContainer -Name $BlobContainer -Context $StorageContext -ErrorAction SilentlyContinue) {
                    Write-Information "- Removing blob container: $BlobContainer"
                    if ($PSCmdlet.ShouldProcess($BlobContainer, 'Remove Blob Container')) {
                        Remove-AzStorageContainer -Name $BlobContainer -Context $StorageContext -Confirm:$false -Force
                    }
                }
                $null = Get-CippTable -TableName ('{0}History' -f $FunctionName)
                $Body = [PSCustomObject]@{
                    Message = 'Orchestrators purged successfully'
                }
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecDurableFunctions.ps1' 173
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecEditTemplate.ps1' -1

function Invoke-ExecEditTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {
        $Table = Get-CippTable -tablename 'templates'
        $guid = $request.Body.id ? $request.Body.id : $request.Body.GUID
        $JSON = ConvertTo-Json -Compress -Depth 100 -InputObject ($request.Body | Select-Object * -ExcludeProperty GUID)
        $Type = $request.Query.Type ?? $Request.Body.Type

        if ($Type -eq 'IntuneTemplate') {
            Write-Host 'Intune Template'
            $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'IntuneTemplate' and RowKey eq '$GUID'"
            $OriginalJSON = $Template.JSON

            $TemplateData = $Template.JSON | ConvertFrom-Json
            $TemplateType = $TemplateData.Type

            if ($Template.SHA) {
                $NewGuid = [guid]::NewGuid().ToString()
            } else {
                $NewGuid = $GUID
            }
            if ($Request.Body.parsedRAWJson) {
                $RawJSON = ConvertTo-Json -Compress -Depth 100 -InputObject $Request.Body.parsedRAWJson
            } else {
                $RawJSON = $OriginalJSON
            }

            $IntuneTemplate = @{
                GUID         = $NewGuid
                RawJson      = $RawJSON
                DisplayName  = $Request.Body.displayName
                Description  = $Request.Body.description
                templateType = $TemplateType
                Package      = $Template.Package
                Headers      = $Request.Headers
            }
            Set-CIPPIntuneTemplate @IntuneTemplate
        } else {
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$JSON"
                RowKey       = "$GUID"
                PartitionKey = "$Type"
                GUID         = "$GUID"
            }
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Edited template $($Request.Body.name) with GUID $GUID" -Sev 'Debug'
        }
        $body = [pscustomobject]@{ 'Results' = 'Successfully saved the template' }

    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Failed to edit template: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Editing template failed: $($_.Exception.Message)" }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecEditTemplate.ps1' 71
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecGeoIPLookup.ps1' -1

Function Invoke-ExecGeoIPLookup {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $IP = $Request.Query.IP ?? $Request.Body.IP

    if (-not $IP) {
        $ErrorMessage = Get-NormalizedError -Message 'IP address is required'
        $LocationInfo = $ErrorMessage
    } else {
        $locationInfo = Get-CIPPGeoIPLocation -IP $IP
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $LocationInfo
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecGeoIPLookup.ps1' 25
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecListBackup.ps1' -1

function Invoke-ExecListBackup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Backup.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Type = $Request.Query.Type
    $TenantFilter = $Request.Query.tenantFilter
    $NameOnly = $Request.Query.NameOnly
    $BackupName = $Request.Query.BackupName

    $CippBackupParams = @{}
    if ($Type) { $CippBackupParams.Type = $Type }
    if ($TenantFilter) { $CippBackupParams.TenantFilter = $TenantFilter }
    if ($BackupName) { $CippBackupParams.Name = $BackupName }

    $Result = Get-CIPPBackup @CippBackupParams

    if ($NameOnly) {
        $Processed = foreach ($item in $Result) {
            $properties = $item.PSObject.Properties | Where-Object { $_.Name -notin @('TenantFilter', 'ETag', 'PartitionKey', 'RowKey', 'Timestamp') -and $_.Value }
            [PSCustomObject]@{
                BackupName = $item.RowKey
                Timestamp  = $item.Timestamp
                Items      = $properties.Name
            }
        }
        $Result = $Processed | Sort-Object Timestamp -Descending
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Result)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecListBackup.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecPartnerWebhook.ps1' -1

function Invoke-ExecPartnerWebhook {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    param($Request, $TriggerMetadata)
    switch ($Request.Query.Action) {
        'ListEventTypes' {
            $Uri = 'https://api.partnercenter.microsoft.com/webhooks/v1/registration/events'
            $Results = New-GraphGetRequest -uri $Uri -tenantid $env:TenantID -NoAuthCheck $true -scope 'https://api.partnercenter.microsoft.com/.default'
        }
        'ListSubscription' {
            try {
                $Uri = 'https://api.partnercenter.microsoft.com/webhooks/v1/registration'
                $Results = New-GraphGetRequest -uri $Uri -tenantid $env:TenantID -NoAuthCheck $true -scope 'https://api.partnercenter.microsoft.com/.default'

                $ConfigTable = Get-CIPPTable -TableName Config
                $WebhookConfig = Get-CIPPAzDataTableEntity @ConfigTable -Filter "RowKey eq 'PartnerWebhookOnboarding'"
                if ($WebhookConfig.StandardsExcludeAllTenants -eq $true) {
                    $Results | Add-Member -MemberType NoteProperty -Name 'standardsExcludeAllTenants' -Value $true -Force
                }
            } catch {}
            if (!$Results) {
                $Results = [PSCustomObject]@{
                    webhoookUrl           = 'None'
                    lastModifiedTimestamp = 'Never'
                    webhookEvents         = @()
                }
            }
        }
        'CreateSubscription' {
            if ($Request.Body.EventType.value) {
                $Request.Body.EventType = $Request.Body.EventType.value
            }

            $BaseURL = ([System.Uri]$Request.Headers.'x-ms-original-url').Host
            $Webhook = @{
                TenantFilter  = $env:TenantID
                PartnerCenter = $true
                BaseURL       = $BaseURL
                EventType     = $Request.Body.EventType
                Headers       = $Request.Headers.'x-ms-client-principal'
            }

            $Results = New-CIPPGraphSubscription @Webhook

            $ConfigTable = Get-CIPPTable -TableName Config
            $PartnerWebhookOnboarding = [PSCustomObject]@{
                PartitionKey               = 'Config'
                RowKey                     = 'PartnerWebhookOnboarding'
                StandardsExcludeAllTenants = $Request.Body.standardsExcludeAllTenants
            }
            Add-CIPPAzDataTableEntity @ConfigTable -Entity $PartnerWebhookOnboarding -Force | Out-Null
        }
        'SendTest' {
            $Results = New-GraphPOSTRequest -uri 'https://api.partnercenter.microsoft.com/webhooks/v1/registration/validationEvents' -tenantid $env:TenantID -NoAuthCheck $true -scope 'https://api.partnercenter.microsoft.com/.default'
        }
        'ValidateTest' {
            $Results = New-GraphGetRequest -uri "https://api.partnercenter.microsoft.com/webhooks/v1/registration/validationEvents/$($Request.Query.CorrelationId)" -tenantid $env:TenantID -NoAuthCheck $true -scope 'https://api.partnercenter.microsoft.com/.default'
        }
        default {
            $Results = 'Invalid Action'
        }
    }

    $Body = [PSCustomObject]@{
        Results  = $Results
        Metadata = [PSCustomObject]@{
            Action = $Request.Query.Action
        }
    }

    return [HttpResponseContext]@{
        StatusCode = [System.Net.HttpStatusCode]::OK
        Body       = $Body
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecPartnerWebhook.ps1' 80
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecServicePrincipals.ps1' -1

function Invoke-ExecServicePrincipals {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $env:TenantID

    $Success = $true

    $Action = $Request.Query.Action ?? 'Default'
    try {
        switch ($Request.Query.Action) {
            'Create' {
                $BlockList = @(
                    'e9a7fea1-1cc0-4cd9-a31b-9137ca5deedd', # eM Client
                    'ff8d92dc-3d82-41d6-bcbd-b9174d163620', # PerfectData Software
                    'a245e8c0-b53c-4b67-9b45-751d1dff8e6b', # Newsletter Software Supermailer
                    'b15665d9-eda6-4092-8539-0eec376afd59', # rclone
                    'a43e5392-f48b-46a4-a0f1-098b5eeb4757', # CloudSponge
                    'caffae8c-0882-4c81-9a27-d1803af53a40'  # SigParser
                )
                $Action = 'Create'

                if ($Request.Query.AppId -match '^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$') {

                    if ($BlockList -contains $Request.Query.AppId) {
                        $Results = 'Service Principal creation is blocked for this AppId'
                        $Success = $false
                    } else {
                        $Body = @{
                            'appId' = $Request.Query.AppId
                        } | ConvertTo-Json -Compress
                        try {
                            $ServicePrincipal = New-GraphPostRequest -Uri 'https://graph.microsoft.com/beta/servicePrincipals' -tenantid $TenantFilter -type POST -body $Body -NoAuthCheck $true
                            $Results = "Created service principal for $($ServicePrincipal.displayName) ($($ServicePrincipal.appId))"
                        } catch {
                            $Results = "Unable to create service principal: $($_.Exception.Message)"
                            $Success = $false
                        }
                    }
                } else {
                    $Results = 'Invalid AppId'
                    $Success = $false
                }
            }
            default {
                if ($Request.Query.AppId) {
                    $Action = 'Get'
                    $Results = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/servicePrincipals(appId='$($Request.Query.AppId)')" -tenantid $TenantFilter -NoAuthCheck $true
                } elseif ($Request.Query.Id) {
                    $Action = 'Get'
                    $Results = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/servicePrincipals/$($Request.Query.Id)" -tenantid $TenantFilter -NoAuthCheck $true
                } else {
                    $Action = 'List'
                    $Uri = 'https://graph.microsoft.com/beta/servicePrincipals?$top=999&$orderby=displayName&$count=true'
                    if ($Request.Query.Select) {
                        $Uri = '{0}&$select={1}' -f $Uri, $Request.Query.Select
                    }

                    $Results = New-GraphGetRequest -Uri $Uri -ComplexFilter -tenantid $TenantFilter -NoAuthCheck $true
                }
            }
        }
    } catch {
        $Results = $_.Exception.Message
        $Success = $false
    }

    $Metadata = @{
        'Action'  = $Action
        'Success' = $Success
    }

    if ($ServicePrincipal) {
        $Metadata.ServicePrincipal = $ServicePrincipal
    }

    if ($Request.Query.AppId) {
        $Metadata.AppId = $Request.Query.AppId
    }

    $Body = @{
        'Results'  = $Results
        'Metadata' = $Metadata
    }

    $Json = $Body | ConvertTo-Json -Depth 10 -Compress
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Json
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecServicePrincipals.ps1' 97
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecSetCIPPAutoBackup.ps1' -1

function Invoke-ExecSetCIPPAutoBackup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Backup.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $unixtime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
    if ($Request.Body.Enabled -eq $true) {
        $Table = Get-CIPPTable -TableName 'ScheduledTasks'
        $AutomatedCIPPBackupTask = Get-AzDataTableEntity @table -Filter "Name eq 'Automated CIPP Backup'"
        $task = @{
            RowKey       = $AutomatedCIPPBackupTask.RowKey
            PartitionKey = 'ScheduledTask'
        }
        Remove-AzDataTableEntity -Force @Table -Entity $task | Out-Null

        $TaskBody = [pscustomobject]@{
            TenantFilter  = 'PartnerTenant'
            Name          = 'Automated CIPP Backup'
            Command       = @{
                value = 'New-CIPPBackup'
                label = 'New-CIPPBackup'
            }
            Parameters    = [pscustomobject]@{ backupType = 'CIPP' }
            ScheduledTime = $unixtime
            Recurrence    = '1d'
        }
        Add-CIPPScheduledTask -Task $TaskBody -hidden $false
        $Result = @{ 'Results' = 'Scheduled Task Successfully created' }
    }
    Write-LogMessage -headers $Request.Headers -API $Request.Params.CIPPEndpoint -message 'Scheduled automatic CIPP backups' -Sev 'Info'
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Result
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecSetCIPPAutoBackup.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecSetPackageTag.ps1' -1

function Invoke-ExecSetPackageTag {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $Table = Get-CippTable -tablename 'templates'

    try {
        $GUIDS = $Request.body.GUID
        $Remove = $Request.body.Remove

        if ($Remove -eq $true) {
            # Remove package tag by setting it to null/empty
            $PackageValue = $null
            $LogMessage = 'Successfully removed package tag from template with GUID'
            $SuccessMessage = 'Successfully removed package tag from template(s)'
        } else {
            # Add package tag (existing logic)
            $PackageValue = [string]($Request.body.Package | Select-Object -First 1)
            $LogMessage = 'Successfully updated template with GUID'
            $SuccessMessage = "Successfully updated template(s) with package tag: $PackageValue"
        }

        foreach ($GUID in $GUIDS) {
            $Filter = "RowKey eq '$GUID'"
            $Template = Get-CIPPAzDataTableEntity @Table -Filter $Filter
            $Entity = @{
                JSON         = $Template.JSON
                RowKey       = "$GUID"
                PartitionKey = $Template.PartitionKey
                GUID         = "$GUID"
                Package      = $PackageValue
                SHA          = $Template.SHA ?? $null
            }


            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

            if ($Remove -eq $true) {
                Write-LogMessage -headers $Headers -API $APIName -message "$LogMessage $GUID" -Sev 'Info'
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "$LogMessage $GUID with package tag: $PackageValue" -Sev 'Info'
            }
        }

        $body = [pscustomobject]@{ 'Results' = $SuccessMessage }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        if ($Remove -eq $true) {
            Write-LogMessage -headers $Headers -API $APIName -message "Failed to remove package tag: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
            $body = [pscustomobject]@{'Results' = "Failed to remove package tag: $($ErrorMessage.NormalizedError)" }
        } else {
            Write-LogMessage -headers $Headers -API $APIName -message "Failed to set package tag: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
            $body = [pscustomobject]@{'Results' = "Failed to set package tag: $($ErrorMessage.NormalizedError)" }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ExecSetPackageTag.ps1' 72
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-GetCippAlerts.ps1' -1

function Invoke-GetCippAlerts {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Alerts = [System.Collections.Generic.List[object]]::new()
    $Table = Get-CippTable -tablename CippAlerts
    $PartitionKey = Get-Date -UFormat '%Y%m%d'
    $Filter = "PartitionKey eq '{0}'" -f $PartitionKey
    $Rows = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Sort-Object TableTimestamp -Descending | Select-Object -First 10
    $Role = Get-CippAccessRole -Request $Request

    $CIPPVersion = $Request.Query.localversion
    $Version = Assert-CippVersion -CIPPVersion $CIPPVersion
    if ($Version.OutOfDateCIPP) {
        $Alerts.Add(@{
                title = 'CIPP Frontend Out of Date'
                Alert = 'Your CIPP Frontend is out of date. Please update to the latest version. Find more on the following '
                link  = 'https://docs.cipp.app/setup/self-hosting-guide/updating'
                type  = 'warning'
            })
        Write-LogMessage -message 'Your CIPP Frontend is out of date. Please update to the latest version' -API 'Updates' -tenant 'All Tenants' -sev Alert

    }
    if ($Version.OutOfDateCIPPAPI) {
        $Alerts.Add(@{
                title = 'CIPP API Out of Date'
                Alert = 'Your CIPP API is out of date. Please update to the latest version. Find more on the following'
                link  = 'https://docs.cipp.app/setup/self-hosting-guide/updating'
                type  = 'warning'
            })
        Write-LogMessage -message 'Your CIPP API is out of date. Please update to the latest version' -API 'Updates' -tenant 'All Tenants' -sev Alert
    }

    if ($env:ApplicationID -eq 'LongApplicationID' -or $null -eq $env:ApplicationID) {
        $Alerts.Add(@{
                title          = 'SAM Setup Incomplete'
                Alert          = 'You have not yet completed your setup. Please go to the Setup Wizard in Application Settings to connect CIPP to your tenants.'
                link           = '/cipp/setup'
                type           = 'warning'
                setupCompleted = $false
            })
    }
    if ($role -like '*superadmin*') {
        $Alerts.Add(@{
                title = 'Superadmin Account Warning'
                Alert = 'You are logged in under a superadmin account. This account should not be used for normal usage.'
                link  = 'https://docs.cipp.app/setup/installation/owntenant'
                type  = 'error'
            })
    }
    if (!(![string]::IsNullOrEmpty($env:WEBSITE_RUN_FROM_PACKAGE) -or ![string]::IsNullOrEmpty($env:DEPLOYMENT_STORAGE_CONNECTION_STRING)) -and $env:AzureWebJobsStorage -ne 'UseDevelopmentStorage=true' -and $env:NonLocalHostAzurite -ne 'true') {
        $Alerts.Add(
            @{
                title = 'Function App in Write Mode'
                Alert = 'Your Function App is running in write mode. This will cause performance issues and increase cost. Please check this '
                link  = 'https://docs.cipp.app/setup/installation/runfrompackage'
                type  = 'warning'
            })
    }
    if ($Rows) { $Rows | ForEach-Object { $Alerts.Add($_) } }
    $Alerts = @($Alerts)

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Alerts
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-GetCippAlerts.ps1' 74
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-GetVersion.ps1' -1

Function Invoke-GetVersion {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $CIPPVersion = $request.query.LocalVersion

    $Version = Assert-CippVersion -CIPPVersion $CIPPVersion

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Version
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-GetVersion.ps1' 20
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListAdminPortalLicenses.ps1' -1

function Invoke-ListAdminPortalLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $TenantFilter = $Request.Query.tenantFilter

    try {
        $AdminPortalLicenses = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $TenantFilter -Uri 'https://admin.microsoft.com/admin/api/tenant/accountSkus'
    } catch {
        Write-Warning 'Failed to get Admin Portal Licenses'
        $AdminPortalLicenses = @()
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($AdminPortalLicenses)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListAdminPortalLicenses.ps1' 25
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListApiTest.ps1' -1

function Invoke-ListApiTest {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Response = @{}
    $Response.Request = $Request
    $Response.TriggerMetadata = $TriggerMetadata
    if ($env:DEBUG_ENV_VARS -eq 'true') {
        $BlockedKeys = @('ApplicationSecret', 'RefreshToken', 'AzureWebJobsStorage', 'DEPLOYMENT_STORAGE_CONNECTION_STRING')
        $EnvironmentVariables = [PSCustomObject]@{}
        Get-ChildItem env: | Where-Object { $BlockedKeys -notcontains $_.Name } | ForEach-Object {
            $EnvironmentVariables | Add-Member -NotePropertyName $_.Name -NotePropertyValue $_.Value
        }
        $Response.EnvironmentVariables = $EnvironmentVariables
    }
    $Response.AllowedTenants = $script:CippAllowedTenantsStorage.Value
    $Response.AllowedGroups = $script:CippAllowedGroupsStorage.Value

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Response
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListApiTest.ps1' 30
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListCustomDataMappings.ps1' -1

function Invoke-ListCustomDataMappings {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $CustomDataMappingsTable = Get-CippTable -TableName 'CustomDataMappings'
    $TenantFilter = $Request.Query.tenantFilter
    $SourceTypeFilter = $Request.Query.sourceType
    $DirectoryObjectFilter = $Request.Query.directoryObject

    Write-Information "Listing custom data mappings with filters - sourceType: $SourceTypeFilter, directoryObject: $DirectoryObjectFilter, tenant: $TenantFilter"

    try {
        $Mappings = Get-CIPPAzDataTableEntity @CustomDataMappingsTable | ForEach-Object {
            $Mapping = $_.JSON | ConvertFrom-Json -AsHashtable

            # Filter by tenant
            $TenantList = Expand-CIPPTenantGroups -TenantFilter $Mapping.tenantFilter
            if ($TenantFilter -and ($TenantList -contains $TenantFilter -or $TenantList -eq 'AllTenants')) {
                return
            }

            $MappingObject = [PSCustomObject]@{
                id                    = $_.RowKey
                tenant                = $Mapping.tenantFilter.label
                dataset               = $Mapping.extensionSyncDataset.label
                sourceType            = $Mapping.sourceType.label
                directoryObject       = $Mapping.directoryObjectType.label
                syncProperty          = $Mapping.extensionSyncProperty.label ?? @($Mapping.extensionSyncDataset.addedFields.select -split ',')
                customDataAttribute   = $Mapping.customDataAttribute
                manualEntryFieldLabel = $Mapping.manualEntryFieldLabel
            }

            # Apply safe filtering
            $Include = $true
            if ($SourceTypeFilter -and $MappingObject.sourceType -ne $SourceTypeFilter) {
                $Include = $false
            }
            if ($DirectoryObjectFilter -and $MappingObject.directoryObject -ne $DirectoryObjectFilter) {
                $Include = $false
            }

            if ($Include) {
                return $MappingObject
            }
        } | Where-Object { $_ -ne $null }

        $Body = @{
            Results = @($Mappings)
        }
    } catch {
        $Body = @{
            Results = @(
                @{
                    state      = 'error'
                    resultText = "Failed to retrieve mappings: $($_.Exception.Message)"
                }
            )
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListCustomDataMappings.ps1' 72
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListDiagnosticsPresets.ps1' -1

function Invoke-ListDiagnosticsPresets {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.Read
    #>
    [CmdletBinding()]
    param (
        $Request,
        $TriggerMetadata
    )

    try {
        $Table = Get-CIPPTable -TableName 'DiagnosticsPresets'
        $Presets = Get-CIPPAzDataTableEntity @Table | ForEach-Object {
            $Data = $_.data | ConvertFrom-Json
            [PSCustomObject]@{
                GUID  = $_.RowKey
                name  = $_.name
                query = $Data.query
            }
        }

        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Presets)
        }
    } catch {
        return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::InternalServerError
            Body       = @{
                Error = "Failed to list diagnostics presets: $($_.Exception.Message)"
            }
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListDiagnosticsPresets.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListDirectoryObjects.ps1' -1

function Invoke-ListDirectoryObjects {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Body.partnerLookup ? $env:TenantID : $Request.Body.tenantFilter
    $AsApp = $Request.Body.asApp
    $Ids = $Request.Body.ids

    $BaseUri = 'https://graph.microsoft.com/beta/directoryObjects/getByIds'
    if ($Request.Body.'$select') {
        $Uri = '{0}?$select={1}' -f $BaseUri, $Request.Body.'$select'
    } else {
        $Uri = $BaseUri
    }

    $Body = @{
        ids = $Ids
    } | ConvertTo-Json -Depth 10

    try {
        $Results = New-GraphPOSTRequest -tenantid $TenantFilter -uri $Uri -body $Body -AsApp $AsApp -NoAuthCheck $true
        $StatusCode = [System.Net.HttpStatusCode]::OK
    } catch {
        $StatusCode = [System.Net.HttpStatusCode]::BadRequest
        $Results = $_.Exception.Message
        Write-Warning "Error retrieving directory objects: $Results"
        Write-Information $_.InvocationInfo.PositionMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListDirectoryObjects.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/invoke-ListEmptyResults.ps1' -1

#using namespace System.Net

Function invoke-ListEmptyResults {
    <#
    .SYNOPSIS
     - Purposely lists an empty result
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @()
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/invoke-ListEmptyResults.ps1' 20
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListExtensionCacheData.ps1' -1

function Invoke-ListExtensionCacheData {
    <#
    .SYNOPSIS
        List Extension Cache Data
    .DESCRIPTION
        This function is used to list the extension cache data.
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $DataTypes = $Request.Query.dataTypes -split ',' ?? $Request.Body.dataTypes ?? 'All'

    $Data = Get-ExtensionCacheData -TenantFilter $TenantFilter

    if ($DataTypes -ne 'All') {
        $Data = $Data | Select-Object $DataTypes
    }

    if (!$Data) {
        $Results = @{}
    }

    $Body = @{
        Results = $Data
    }

    $StatusCode = [HttpStatusCode]::OK

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body | ConvertTo-Json -Compress -Depth 100
            Headers    = @{
                'Content-Type' = 'application/json'
            }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListExtensionCacheData.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListGraphBulkRequest.ps1' -1

function Invoke-ListGraphBulkRequest {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Body.tenantFilter
    $AsApp = $Request.Body.asApp
    $Requests = $Request.Body.requests
    $NoPaginateIds = $Request.Body.noPaginateIds

    $GraphRequestParams = @{
        tenantid      = $TenantFilter
        Requests      = @()
        NoPaginateIds = $NoPaginateIds ?? @()
    }

    if ($AsApp) {
        $GraphRequestParams.asapp = $AsApp
    }

    $BulkRequests = foreach ($GraphRequest in $Requests) {
        if ($GraphRequest.method -eq 'GET') {
            @{
                id     = $GraphRequest.id
                url    = $GraphRequest.url
                method = $GraphRequest.method
            }
        }
    }

    if ($BulkRequests) {
        $GraphRequestParams.Requests = @($BulkRequests)
        try {
            $Body = New-GraphBulkRequest @GraphRequestParams
            $Results = @{
                StatusCode = [System.Net.HttpStatusCode]::OK
                Body       = $Body
            }
        } catch {
            $Results = @{
                StatusCode = [System.Net.HttpStatusCode]::BadRequest
                Body       = $_.Exception.Message
            }
        }
    } else {
        $Results = @{
            StatusCode = [System.Net.HttpStatusCode]::BadRequest
            Body       = 'No requests found in the body'
        }
    }

    return [HttpResponseContext]$Results
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListGraphBulkRequest.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListGraphRequest.ps1' -1


function Invoke-ListGraphRequest {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $Message = 'Accessed this API | Endpoint: {0}' -f $Request.Query.Endpoint
    Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Debug'

    $CippLink = ([System.Uri]$TriggerMetadata.Headers.Referer).PathAndQuery

    $Parameters = @{}
    if ($Request.Query.'$filter') {
        $Parameters.'$filter' = $Request.Query.'$filter'
    }

    if (!$Request.Query.'$filter' -and $Request.Query.graphFilter) {
        $Parameters.'$filter' = $Request.Query.graphFilter
    }

    if ($Request.Query.'$select') {
        $Parameters.'$select' = $Request.Query.'$select'
    }

    if ($Request.Query.'$expand') {
        $Parameters.'$expand' = $Request.Query.'$expand'
    }

    if ($Request.Query.expand) {
        $Parameters.'expand' = $Request.Query.expand
    }

    if ($Request.Query.'$top') {
        $Parameters.'$top' = $Request.Query.'$top'
    }

    if ($Request.Query.'$count') {
        $Parameters.'$count' = ([string]([System.Boolean]$Request.Query.'$count')).ToLower()
    }


    if ($Request.Query.'$orderby') {
        $Parameters.'$orderby' = $Request.Query.'$orderby'
    }

    if ($Request.Query.'$search') {
        $Parameters.'$search' = $Request.Query.'$search'
    }

    if ($Request.Query.'$format') {
        $Parameters.'$format' = $Request.Query.'$format'
    }

    $GraphRequestParams = @{
        Endpoint   = $Request.Query.Endpoint
        Parameters = $Parameters
        CippLink   = $CippLink
    }

    if ($Request.Query.TenantFilter) {
        $GraphRequestParams.TenantFilter = $Request.Query.TenantFilter
    }

    if ($Request.Query.QueueId) {
        $GraphRequestParams.QueueId = $Request.Query.QueueId
    }

    if ($Request.Query.Version) {
        $GraphRequestParams.Version = $Request.Query.Version
    }

    if ($Request.Query.NoPagination) {
        $GraphRequestParams.NoPagination = [System.Boolean]$Request.Query.NoPagination
    }

    if ($Request.Query.manualPagination) {
        $GraphRequestParams.ManualPagination = [System.Boolean]$Request.Query.manualPagination
    }

    if ($Request.Query.nextLink) {
        $GraphRequestParams.nextLink = $Request.Query.nextLink
    }

    if ($Request.Query.CountOnly) {
        $GraphRequestParams.CountOnly = [System.Boolean]$Request.Query.CountOnly
    }

    if ($Request.Query.QueueNameOverride) {
        $GraphRequestParams.QueueNameOverride = [string]$Request.Query.QueueNameOverride
    }

    if ($Request.Query.ReverseTenantLookup) {
        $GraphRequestParams.ReverseTenantLookup = [System.Boolean]$Request.Query.ReverseTenantLookup
    }

    if ($Request.Query.ReverseTenantLookupProperty) {
        $GraphRequestParams.ReverseTenantLookupProperty = $Request.Query.ReverseTenantLookupProperty
    }

    if ($Request.Query.SkipCache) {
        $GraphRequestParams.SkipCache = [System.Boolean]$Request.Query.SkipCache
    }

    if ($Request.Query.ListProperties) {
        $GraphRequestParams.NoPagination = $true
        $GraphRequestParams.Parameters.'$select' = ''
        if ($Request.Query.TenantFilter -eq 'AllTenants') {
            $GraphRequestParams.TenantFilter = (Get-Tenants | Select-Object -First 1).customerId
        }
    }

    if ($Request.Query.AsApp) {
        $GraphRequestParams.AsApp = $true
    }

    $Metadata = $GraphRequestParams

    try {
        $Results = Get-GraphRequestList @GraphRequestParams

        if ($script:LastGraphResponseHeaders) {
            $Metadata.GraphHeaders = $script:LastGraphResponseHeaders
        }

        if ($Results | Where-Object { $_.PSObject.Properties.Name -contains 'nextLink' }) {
            if (![string]::IsNullOrEmpty($Results.nextLink) -and $Request.Query.TenantFilter -ne 'AllTenants') {
                Write-Host "NextLink: $($Results.nextLink | Where-Object { $_ } | Select-Object -Last 1)"
                $Metadata['nextLink'] = $Results.nextLink | Where-Object { $_ } | Select-Object -Last 1
            }
            # Remove nextLink trailing object only if its the last item
            $Results = $Results | Where-Object { $_.PSObject.Properties.Name -notcontains 'nextLink' }
        }
        if ($Request.Query.ListProperties) {
            $Columns = ($Results | Select-Object -First 1).PSObject.Properties.Name
            $Results = $Columns | Where-Object { @('Tenant', 'CippStatus') -notcontains $_ }
        } else {
            if ($Results.Queued -eq $true) {
                $Metadata.Queued = $Results.Queued
                $Metadata.QueueMessage = $Results.QueueMessage
                $Metadata.QueueId = $Results.QueueId
                $Results = @()
            }
        }

        if ($Request.Headers.'x-ms-coldstart' -eq 1) {
            $Metadata.ColdStart = $true
        }

        $GraphRequestData = [PSCustomObject]@{
            Results  = @($Results)
            Metadata = $Metadata
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $GraphRequestData = "Graph Error: $(Get-NormalizedError $_.Exception.Message) - Endpoint: $($Request.Query.Endpoint)"
        if ($Request.Query.IgnoreErrors) { $StatusCode = [HttpStatusCode]::OK }
        else { $StatusCode = [HttpStatusCode]::BadRequest }
    }

    if ($request.Query.Sort) {
        $GraphRequestData.Results = $GraphRequestData.Results | Sort-Object -Property $request.Query.Sort
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $GraphRequestData
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-ListGraphRequest.ps1' 176
#Region './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-PublicPing.ps1' -1

function Invoke-PublicPing {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Public
    #>
    [CmdletBinding()]
    Param(
        $Request,
        $TriggerMetadata
    )

    $KeepaliveTable = Get-CippTable -tablename 'CippKeepAlive'
    $LastKeepalive = Get-CippAzDataTableEntity @KeepaliveTable -Filter "PartitionKey eq 'Ping' and RowKey eq 'Ping'"

    if ($LastKeepalive.Timestamp) {
        $LastKeepalive = $LastKeepalive.Timestamp.DateTime.ToUniversalTime()
    } else {
        $LastKeepalive = (Get-Date).AddSeconds(-600).ToUniversalTime()
    }
    $KeepaliveInterval = -300
    $NextKeepAlive = (Get-Date).AddSeconds($KeepaliveInterval).ToUniversalTime()

    $IsColdStart = $Request.Headers.'x-ms-coldstart' -eq 1

    if ($LastKeepalive -le $NextKeepAlive -or $IsColdStart) {
        $Keepalive = @{
            PartitionKey = 'Ping'
            RowKey       = 'Ping'
        }
        Add-AzDataTableEntity @KeepaliveTable -Entity $Keepalive -Force

        if ($IsColdStart) {
            $Milliseconds = 500
        } else {
            $Milliseconds = 150
        }

        Start-Sleep -Milliseconds $Milliseconds
    }

    $Body = @{
        Results = @{
            Message   = 'Pong'
            ColdStart = $IsColdStart
            Timestamp = (Get-Date).ToUniversalTime()
            RequestId = $TriggerMetadata.InvocationId
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ($Body | ConvertTo-Json -Depth 5)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Core/Invoke-PublicPing.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionMapping.ps1' -1

Function Invoke-ExecExtensionMapping {
  <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.ReadWrite
    #>
  [CmdletBinding()]
  param($Request, $TriggerMetadata)

  $APIName = $Request.Params.CIPPEndpoint
  $Headers = $Request.Headers


  $Table = Get-CIPPTable -TableName CippMapping

  if ($Request.Query.List) {
    switch ($Request.Query.List) {
      'HaloPSA' {
        $Result = Get-HaloMapping -CIPPMapping $Table
      }
      'NinjaOne' {
        $Result = Get-NinjaOneOrgMapping -CIPPMapping $Table
      }
      'NinjaOneFields' {
        $Result = Get-NinjaOneFieldMapping -CIPPMapping $Table
      }
      'Hudu' {
        $Result = Get-HuduMapping -CIPPMapping $Table
      }
      'HuduFields' {
        $Result = Get-HuduFieldMapping -CIPPMapping $Table
      }
      'Sherweb' {
        $Result = Get-SherwebMapping -CIPPMapping $Table
      }
      'HaloPSAFields' {
        $TicketTypes = Get-HaloTicketType
        $Outcomes = Get-HaloTicketOutcome
        $Result = @{
          'TicketTypes' = $TicketTypes
          'Outcomes'    = $Outcomes
        }
      }
      'PWPushFields' {
        $Accounts = Get-PwPushAccount
        $Result = @{
          'Accounts' = $Accounts
        }
      }
    }
  }

  try {
    if ($Request.Query.AddMapping) {
      switch ($Request.Query.AddMapping) {
        'Sherweb' {
          $Result = Set-SherwebMapping -CIPPMapping $Table -APIName $APIName -Request $Request
        }
        'HaloPSA' {
          $Result = Set-HaloMapping -CIPPMapping $Table -APIName $APIName -Request $Request
        }
        'NinjaOne' {
          $Result = Set-NinjaOneOrgMapping -CIPPMapping $Table -APIName $APIName -Request $Request
          Register-CIPPExtensionScheduledTasks
        }
        'NinjaOneFields' {
          $Result = Set-NinjaOneFieldMapping -CIPPMapping $Table -APIName $APIName -Request $Request -TriggerMetadata $TriggerMetadata
          Register-CIPPExtensionScheduledTasks
        }
        'Hudu' {
          $Result = Set-HuduMapping -CIPPMapping $Table -APIName $APIName -Request $Request
          Register-CIPPExtensionScheduledTasks
        }
        'HuduFields' {
          $Result = Set-ExtensionFieldMapping -CIPPMapping $Table -APIName $APIName -Request $Request -Extension 'Hudu'
          Register-CIPPExtensionScheduledTasks
        }
      }
    }
    $StatusCode = [HttpStatusCode]::OK
  }
  catch {
    $ErrorMessage = Get-CippException -Exception $_
    $Result = "Mapping API failed. $($ErrorMessage.NormalizedError)"
    Write-LogMessage -API $APIName -headers $Headers -message $Result -Sev 'Error' -LogData $ErrorMessage
    $StatusCode = [HttpStatusCode]::InternalServerError
  }

  try {
    if ($Request.Query.AutoMapping) {
      switch ($Request.Query.AutoMapping) {
        'NinjaOne' {
          $Batch = [PSCustomObject]@{
            'NinjaAction'  = 'StartAutoMapping'
            'FunctionName' = 'NinjaOneQueue'
          }
          $InputObject = [PSCustomObject]@{
            OrchestratorName = 'NinjaOneOrchestrator'
            Batch            = @($Batch)
          }
          #Write-Host ($InputObject | ConvertTo-Json)
          $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
          Write-Host "Started permissions orchestration with ID = '$InstanceId'"
          $Result = 'AutoMapping Request has been queued. Exact name matches will appear first and matches on device names and serials will take longer. Please check the CIPP Logbook and refresh the page once complete.'
        }

      }
    }
    $StatusCode = [HttpStatusCode]::OK
  }
  catch {
    $ErrorMessage = Get-CippException -Exception $_
    $Result = "Mapping API failed. $($ErrorMessage.NormalizedError)"
    Write-LogMessage -API $APIName -headers $Headers -message $Result -Sev 'Error' -LogData $ErrorMessage
    $StatusCode = [HttpStatusCode]::InternalServerError
  }

  return ([HttpResponseContext]@{
      StatusCode = $StatusCode
      Body       = $Result
    })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionMapping.ps1' 125
#Region './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionsConfig.ps1' -1

function Invoke-ExecExtensionsConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $Body = [PSCustomObject]$Request.Body
    $Results = try {
        # Check if NinjaOne URL is set correctly and the instance has at least version 5.6
        if ($Body.NinjaOne.Enabled -eq $true) {
            $AllowedNinjaHostnames = @(
                'app.ninjarmm.com',
                'eu.ninjarmm.com',
                'oc.ninjarmm.com',
                'ca.ninjarmm.com',
                'us2.ninjarmm.com'
            )
            $SetNinjaHostname = $Body.NinjaOne.Instance -replace '/ws', '' -replace 'https://', ''
            if ($AllowedNinjaHostnames -notcontains $SetNinjaHostname) {
                "Error: NinjaOne URL is not allowed. Allowed hostnames are: $($AllowedNinjaHostnames -join ', ')"
            }
        }

        if ($Body.Hudu.NextSync) {
            #parse unixtime for addedtext
            $Timestamp = [datetime]::UnixEpoch.AddSeconds([int]$Body.Hudu.NextSync).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            Register-CIPPExtensionScheduledTasks -Reschedule -NextSync $Body.Hudu.NextSync -Extensions 'Hudu'
            $AddedText = " Next sync will be at $Timestamp."
            $Body.Hudu.NextSync = ''
        }

        $Table = Get-CIPPTable -TableName Extensionsconfig
        foreach ($APIKey in $Body.PSObject.Properties.Name) {
            Write-Information "Working on $apikey"
            if ($Body.$APIKey.APIKey -eq 'SentToKeyVault' -or $Body.$APIKey.APIKey -eq '') {
                Write-Information 'Not sending to keyvault. Key previously set or left blank.'
            } else {
                Write-Information 'writing API Key to keyvault, and clearing.'
                Write-Information "$env:WEBSITE_DEPLOYMENT_ID"
                if ($Body.$APIKey.APIKey) {
                    Set-ExtensionAPIKey -Extension $APIKey -APIKey $Body.$APIKey.APIKey
                }
                if ($Body.$APIKey.PSObject.Properties.Name -notcontains 'APIKey') {
                    $Body.$APIKey | Add-Member -MemberType NoteProperty -Name APIKey -Value 'SentToKeyVault'
                } else {
                    $Body.$APIKey.APIKey = 'SentToKeyVault'
                }
            }
            $Body.$APIKey = $Body.$APIKey | Select-Object * -ExcludeProperty ResetPassword
        }
        $Body = $Body | Select-Object * -ExcludeProperty APIKey, Enabled | ConvertTo-Json -Depth 10 -Compress
        $Config = @{
            'PartitionKey' = 'CippExtensions'
            'RowKey'       = 'Config'
            'config'       = [string]$Body
        }

        Add-CIPPAzDataTableEntity @Table -Entity $Config -Force | Out-Null

        #Write-Information ($Request.Headers | ConvertTo-Json)
        $AddObject = @{
            PartitionKey = 'InstanceProperties'
            RowKey       = 'CIPPURL'
            Value        = [string]([System.Uri]$Headers.'x-ms-original-url').Host
        }
        Write-Information ($AddObject | ConvertTo-Json -Compress)
        $ConfigTable = Get-CIPPTable -tablename 'Config'
        Add-AzDataTableEntity @ConfigTable -Entity $AddObject -Force

        Register-CIPPExtensionScheduledTasks
        "Successfully saved the extension configuration. $AddedText"
    } catch {
        "Failed to save the extensions configuration: $($_.Exception.message) Linenumber: $($_.InvocationInfo.ScriptLineNumber)"
    }



    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionsConfig.ps1' 90
#Region './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionSync.ps1' -1

Function Invoke-ExecExtensionSync {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    switch ($Request.Query.Extension) {
        'Gradient' {
            try {
                Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message 'Starting billing processing.' -sev Info
                $Table = Get-CIPPTable -TableName Extensionsconfig
                $Configuration = (Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json -Depth 10

                foreach ($ConfigItem in $Configuration.psobject.properties.name) {
                    switch ($ConfigItem) {
                        'Gradient' {
                            If ($Configuration.Gradient.enabled -and $Configuration.Gradient.BillingEnabled) {
                                $ProcessorQueue = Get-CIPPTable -TableName 'ProcessorQueue'
                                $ProcessorFunction = [PSCustomObject]@{
                                    PartitionKey = 'Function'
                                    RowKey       = 'New-GradientServiceSyncRun'
                                    FunctionName = 'New-GradientServiceSyncRun'
                                }
                                Add-AzDataTableEntity @ProcessorQueue -Entity $ProcessorFunction -Force
                                $Results = [pscustomobject]@{'Results' = 'Successfully queued Gradient Sync' }
                            }
                        }
                    }
                }
            } catch {
                $Results = [pscustomobject]@{'Results' = "Could not start Gradient Sync: $($_.Exception.Message)" }

                Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message "Could not start billing processing $($_.Exception.Message)" -sev Error
            }
        }

        'NinjaOne' {
            try {
                $Table = Get-CIPPTable -TableName NinjaOneSettings

                $CIPPMapping = Get-CIPPTable -TableName CippMapping
                $Filter = "PartitionKey eq 'NinjaOneMapping'"
                $TenantsToProcess = Get-AzDataTableEntity @CIPPMapping -Filter $Filter | Where-Object { $Null -ne $_.IntegrationId -and $_.IntegrationId -ne '' }

                if ($Request.Query.TenantID) {
                    $Tenant = $TenantsToProcess | Where-Object { $_.RowKey -eq $Request.Query.TenantID }
                    if (($Tenant | Measure-Object).count -eq 1) {
                        $Batch = [PSCustomObject]@{
                            'NinjaAction'  = 'SyncTenant'
                            'MappedTenant' = $Tenant
                            'FunctionName' = 'NinjaOneQueue'
                        }
                        $InputObject = [PSCustomObject]@{
                            OrchestratorName = 'NinjaOneOrchestrator'
                            Batch            = @($Batch)
                        }
                        #Write-Host ($InputObject | ConvertTo-Json)
                        $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)

                        $Results = [pscustomobject]@{'Results' = "NinjaOne Synchronization Queued for $($Tenant.IntegrationName)" }
                    } else {
                        $Results = [pscustomobject]@{'Results' = 'Tenant was not found.' }
                    }

                } else {
                    $Batch = [PSCustomObject]@{
                        'NinjaAction'  = 'SyncTenants'
                        'FunctionName' = 'NinjaOneQueue'
                    }
                    $InputObject = [PSCustomObject]@{
                        OrchestratorName = 'NinjaOneOrchestrator'
                        Batch            = @($Batch)
                    }
                    #Write-Host ($InputObject | ConvertTo-Json)
                    $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                    Write-Host "Started permissions orchestration with ID = '$InstanceId'"
                    $Results = [pscustomobject]@{'Results' = "NinjaOne Synchronization Queuing $(($TenantsToProcess | Measure-Object).count) Tenants" }

                }
            } catch {
                $Results = [pscustomobject]@{'Results' = "Could not start NinjaOne Sync: $($_.Exception.Message)" }
                Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message "Could not start NinjaOne Sync $($_.Exception.Message)" -sev Error
            }
        }
        'Hudu' {
            Register-CIPPExtensionScheduledTasks -Reschedule -Extensions 'Hudu'
            $Results = [pscustomobject]@{'Results' = 'Extension sync tasks have been rescheduled and will start within 15 minutes' }
        }

    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionSync.ps1' 102
#Region './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionTest.ps1' -1

Function Invoke-ExecExtensionTest {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Extension.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable -TableName Extensionsconfig
    $Configuration = ((Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json)
    # Interact with query parameters or the body of the request.
    try {
        switch ($Request.Query.extensionName) {
            'HaloPSA' {
                $token = Get-HaloToken -configuration $Configuration.HaloPSA
                if ($token) {
                    $Results = [pscustomobject]@{'Results' = 'Successfully Connected to HaloPSA' }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'Failed to connect to HaloPSA, check your API credentials and try again.' }
                }
            }
            'Gradient' {
                $GradientToken = Get-GradientToken -Configuration $Configuration.Gradient
                if ($GradientToken) {
                    try {
                        $ExistingIntegrations = Invoke-RestMethod -Uri 'https://app.usegradient.com/api/vendor-api/organization' -Method GET -Headers $GradientToken
                        if ($ExistingIntegrations.Status -ne 'active') {
                            $ActivateRequest = Invoke-RestMethod -Uri 'https://app.usegradient.com/api/vendor-api/organization/status/active' -Method PATCH -Headers $GradientToken
                        }
                        $Results = [pscustomobject]@{'Results' = 'Successfully Connected to Gradient' }
                    } catch {
                        $Results = [pscustomobject]@{'Results' = 'Failed to connect to Gradient, check your API credentials and try again.' }
                    }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'Failed to connect to Gradient, check your API credentials and try again.' }
                }
            }
            'CIPP-API' {
                $Results = [pscustomobject]@{'Results' = 'You cannot test the CIPP-API from CIPP. Please check the documentation on how to test the CIPP-API.' }
            }
            'NinjaOne' {
                $token = Get-NinjaOneToken -configuration $Configuration.NinjaOne
                if ($token) {
                    $Results = [pscustomobject]@{'Results' = 'Successfully Connected to NinjaOne' }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'Failed to connect to NinjaOne, check your API credentials and try again.' }
                }
            }
            'PWPush' {
                $Payload = 'This is a test from CIPP'
                $PasswordLink = New-PwPushLink -Payload $Payload
                if ($PasswordLink) {
                    $Results = [pscustomobject]@{Results = @(@{'resultText' = 'Successfully generated PWPush, hit the Copy to Clipboard button to retrieve the test.'; 'copyField' = $PasswordLink; 'state' = 'success' }) }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'PWPush is not enabled' }
                }
            }
            'Hudu' {
                Connect-HuduAPI -configuration $Configuration
                $Version = Get-HuduAppInfo
                if ($Version.version) {
                    $Results = [pscustomobject]@{'Results' = ('Successfully Connected to Hudu, version: {0}' -f $Version.version) }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'Failed to connect to Hudu, check your API credentials and try again.' }
                }
            }
            'Sherweb' {
                $token = Get-SherwebAuthentication
                if ($token) {
                    $Results = [pscustomobject]@{'Results' = 'Successfully Connected to Sherweb' }
                } else {
                    $Results = [pscustomobject]@{'Results' = 'Failed to connect to Sherweb, check your API credentials and try again.' }
                }
            }
            'HIBP' {
                $ConnectionTest = Get-HIBPConnectionTest
                $Results = [pscustomobject]@{'Results' = 'Successfully Connected to HIBP' }
            }
            'GitHub' {
                $GitHubResponse = Invoke-GitHubApiRequest -Method 'GET' -Path 'user' -ReturnHeaders
                if ($GitHubResponse.login) {
                    if ($GitHubResponse.Headers.'x-oauth-scopes') {
                        $Results = [pscustomobject]@{ 'Results' = "Successfully connected to GitHub user: $($GitHubResponse.login) with scopes: $($GitHubResponse.Headers.'x-oauth-scopes')" }
                    } else {
                        $Results = [pscustomobject]@{ 'Results' = "Successfully connected to GitHub user: $($GitHubResponse.login) using a Fine Grained PAT" }
                    }
                } else {
                    $Results = [pscustomobject]@{ 'Results' = 'Failed to connect to GitHub. Check your API credentials and try again.' }
                }
            }
        }
    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed to connect: $($_.Exception.Message). Line $($_.InvocationInfo.ScriptLineNumber)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ExecExtensionTest.ps1' 103
#Region './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ListExtensionSync.ps1' -1

Function Invoke-ListExtensionSync {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Extension.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $ScheduledTasksTable = Get-CIPPTable -TableName 'ScheduledTasks'
    $ScheduledTasks = Get-CIPPAzDataTableEntity @ScheduledTasksTable -Filter 'Hidden eq true' | Where-Object { $_.Command -match 'CippExtension' }

    $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList
    $TenantList = Get-Tenants -IncludeErrors
    $AllTasksArrayList = [system.collections.generic.list[object]]::new()

    foreach ($Task in $ScheduledTasks) {
        if ($Task.Results -and (Test-Json -Json $Task.Results -ErrorAction SilentlyContinue)) {
            $Results = $Task.Results | ConvertFrom-Json
        } else {
            $Results = $Task.Results
        }

        $TaskEntry = [PSCustomObject]@{
            RowKey        = $Task.RowKey
            PartitionKey  = $Task.PartitionKey
            Tenant        = $Task.Tenant
            Name          = $Task.Name
            SyncType      = $Task.SyncType
            ScheduledTime = $Task.ScheduledTime
            ExecutedTime  = $Task.ExecutedTime
            RepeatsEvery  = $Task.Recurrence
            Results       = $Results
        }

        if ($AllowedTenants -notcontains 'AllTenants') {
            $Tenant = $TenantList | Where-Object -Property defaultDomainName -EQ $Task.Tenant
            if ($AllowedTenants -contains $Tenant.customerId) {
                $AllTasksArrayList.Add($TaskEntry)
            }
        } else {
            $AllTasksArrayList.Add($TaskEntry)
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = (ConvertTo-Json -Depth 5 -InputObject @($AllTasksArrayList))
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Extensions/Invoke-ListExtensionSync.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-AddScheduledItem.ps1' -1

function Invoke-AddScheduledItem {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Scheduler.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    if ($null -eq $Request.Query.hidden) {
        $hidden = $false
    } else {
        $hidden = $true
    }

    if ($Request.Body.RunNow -eq $true) {
        try {
            $Table = Get-CIPPTable -TableName 'ScheduledTasks'
            $Filter = "PartitionKey eq 'ScheduledTask' and RowKey eq '$($Request.Body.RowKey)'"
            $ExistingTask = (Get-CIPPAzDataTableEntity @Table -Filter $Filter)
            if ($ExistingTask) {
                $Result = Add-CIPPScheduledTask -RowKey $Request.Body.RowKey -RunNow -Headers $Request.Headers
            } else {
                $Result = "Task with id $($Request.Body.RowKey) does not exist"
            }
        } catch {
            Write-Warning "Error scheduling task: $($_.Exception.Message)"
            Write-Information $_.InvocationInfo.PositionMessage
            $Result = "Error scheduling task: $($_.Exception.Message)"
        }
    } else {
        $ScheduledTask = @{
            Task                  = $Request.Body
            Headers               = $Request.Headers
            hidden                = $hidden
            DisallowDuplicateName = $Request.Query.DisallowDuplicateName
            DesiredStartTime      = $Request.Body.DesiredStartTime
        }
        $Result = Add-CIPPScheduledTask @ScheduledTask
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-AddScheduledItem.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-ListScheduledItemDetails.ps1' -1

function Invoke-ListScheduledItemDetails {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Scheduler.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Get parameters from the request
    $RowKey = $Request.Query.RowKey ?? $Request.Body.RowKey

    # Validate required parameters
    if (-not $RowKey) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = "Required parameter 'RowKey' is missing"
            })
        return
    }

    # Retrieve the task information
    $TaskTable = Get-CIPPTable -TableName 'ScheduledTasks'
    $Task = Get-CIPPAzDataTableEntity @TaskTable -Filter "RowKey eq '$RowKey' and PartitionKey eq 'ScheduledTask'" | Select-Object RowKey, Name, TaskState, Command, Parameters, Recurrence, ExecutedTime, ScheduledTime, PostExecution, Tenant, TenantGroup, Hidden, Results, Timestamp, Trigger

    if (-not $Task) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::NotFound
                Body       = "Task with RowKey '$RowKey' not found"
            })
        return
    }

    # Process the task (similar to the way it's done in Invoke-ListScheduledItems)
    if ($Task.Parameters) {
        $Task.Parameters = $Task.Parameters | ConvertFrom-Json -ErrorAction SilentlyContinue
    } else {
        $Task | Add-Member -NotePropertyName Parameters -NotePropertyValue @{}
    }

    if ($Task.Recurrence -eq 0 -or [string]::IsNullOrEmpty($Task.Recurrence)) {
        $Task.Recurrence = 'Once'
    }

    try {
        $Task.ExecutedTime = [DateTimeOffset]::FromUnixTimeSeconds($Task.ExecutedTime).UtcDateTime
    } catch {}

    try {
        $Task.ScheduledTime = [DateTimeOffset]::FromUnixTimeSeconds($Task.ScheduledTime).UtcDateTime
    } catch {}

    # Handle tenant group display information (similar to Invoke-ListScheduledItems)
    if ($Task.TenantGroup) {
        try {
            $TenantGroupObject = $Task.TenantGroup | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($TenantGroupObject) {
                # Create a tenant group object for the frontend formatting
                $TenantGroupForDisplay = [PSCustomObject]@{
                    label = $TenantGroupObject.label
                    value = $TenantGroupObject.value
                    type  = 'Group'
                }
                $Task | Add-Member -NotePropertyName TenantGroupInfo -NotePropertyValue $TenantGroupForDisplay -Force
                # Update the tenant to show the group object for proper formatting
                $Task.Tenant = $TenantGroupForDisplay
            }
        } catch {
            Write-Warning "Failed to parse tenant group information for task $($Task.RowKey): $($_.Exception.Message)"
            # Fall back to keeping original tenant value
        }
    } else {
        # For regular tenants, create a tenant object for consistent formatting
        $TenantForDisplay = [PSCustomObject]@{
            label = $Task.Tenant
            value = $Task.Tenant
            type  = 'Tenant'
        }
        $Task.Tenant = $TenantForDisplay
    }

    if ($Task.Trigger) {
        try {
            $TriggerObject = $Task.Trigger | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($TriggerObject) {
                $Task | Add-Member -NotePropertyName Trigger -NotePropertyValue $TriggerObject -Force
            }
        } catch {
            Write-Warning "Failed to parse trigger information for task $($Task.RowKey): $($_.Exception.Message)"
            # Fall back to keeping original trigger value
        }
    }

    # Get the results if available
    $ResultsTable = Get-CIPPTable -TableName 'ScheduledTaskResults'
    $ResultsFilter = "PartitionKey eq '$RowKey'"

    $Results = Get-CIPPAzDataTableEntity @ResultsTable -Filter $ResultsFilter

    if (!$Results) {
        try {
            # Handle the case when we need to use Task.Results
            if ($Task.Results) {
                # Try to safely parse JSON or use the raw value if parsing fails
                try {
                    if ($Task.Results -is [string]) {
                        $ResultString = $Task.Results.ToString().Trim()
                        if (($ResultString -match '^\[.*\]$') -or ($ResultString -match '^\{.*\}$')) {
                            $ResultData = $Task.Results | ConvertFrom-Json -ErrorAction Stop
                        } else {
                            # Not valid JSON format, use as is
                            $ResultData = $Task.Results
                        }
                    } else {
                        # Already an object, use as is
                        $ResultData = $Task.Results
                    }
                } catch {
                    # If JSON parsing fails, use raw value
                    Write-LogMessage -API $APIName -message "Error parsing Task.Results as JSON: $_" -Sev 'Warning'
                    $ResultData = $Task.Results
                }
            } else {
                $ResultData = $null
            }
        } catch {
            Write-LogMessage -API $APIName -message "Error processing Task.Results: $_" -Sev 'Error'
            $ResultData = $null
        }

        $Results = @(
            [PSCustomObject]@{
                RowKey    = $Task.Tenant
                Results   = $ResultData
                Timestamp = $Task.Timestamp
            }
        )
    }

    # Process the results if they exist
    $ProcessedResults = [System.Collections.Generic.List[object]]::new()
    foreach ($Result in $Results) {
        try {
            if ($null -ne $Result.Results) {
                # Safe handling based on result type
                if ($Result.Results -is [array] -or $Result.Results -is [System.Collections.ICollection]) {
                    # Already a collection, use as is
                    $ParsedResults = $Result.Results
                } elseif ($Result.Results -is [string]) {
                    $ResultString = $Result.Results.ToString().Trim()
                    # Only try to parse as JSON if it looks like JSON
                    if (($ResultString -match '^\[.*\]$') -or ($ResultString -match '^\{.*\}$')) {
                        try {
                            $ParsedResults = $Result.Results | ConvertFrom-Json -ErrorAction Stop
                        } catch {
                            Write-LogMessage -API $APIName -message "Failed to parse result as JSON: $_" -Sev 'Warning'
                            # On failure, keep as string
                            $ParsedResults = $Result.Results
                        }
                    } else {
                        # Not valid JSON format
                        $ParsedResults = $Result.Results
                    }
                } else {
                    # Any other object type
                    $ParsedResults = $Result.Results
                }

                # Ensure results is always an array
                if ($null -eq $ParsedResults -or 'null' -eq $ParsedResults) {
                    $Result.Results = @()
                } else {
                    $Result.Results = @($ParsedResults)
                }

                # Store tenant information with the result
                $TenantId = $Result.RowKey
                $TenantInfo = Get-Tenants -TenantFilter $TenantId -ErrorAction SilentlyContinue
                if ($TenantInfo) {
                    $Result | Add-Member -NotePropertyName TenantName -NotePropertyValue $TenantInfo.displayName -Force
                    $Result | Add-Member -NotePropertyName TenantDefaultDomain -NotePropertyValue $TenantInfo.defaultDomainName -Force
                    $Result | Add-Member -NotePropertyName TenantId -NotePropertyValue $TenantInfo.customerId -Force
                }
            }
        } catch {
            Write-LogMessage -API $APIName -message "Error processing results for task $RowKey with tenant $($Result.RowKey): $_" -Sev 'Error'
            # Set Results to an empty array to prevent further errors
            $Result.Results = @()
        }
        $EndResult = $Result | Select-Object Timestamp, @{n = 'Tenant'; Expression = { $_.RowKey } }, Results
        $ProcessedResults.Add($EndResult)
    }

    # Combine task and results into one response
    $Response = ConvertTo-Json -Depth 100 -InputObject @{
        Task    = $Task
        Details = $ProcessedResults
    }

    # Return the response
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Response
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-ListScheduledItemDetails.ps1' 208
#Region './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-ListScheduledItems.ps1' -1

function Invoke-ListScheduledItems {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Scheduler.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $ScheduledItemFilter = [System.Collections.Generic.List[string]]::new()
    $ScheduledItemFilter.Add("PartitionKey eq 'ScheduledTask'")

    $Id = $Request.Query.Id ?? $Request.Body.Id
    if ($Id) {
        # Interact with query parameters.
        $ScheduledItemFilter.Add("RowKey eq '$($Id)'")
    } else {
        # Interact with query parameters or the body of the request.
        $ShowHidden = $Request.Query.ShowHidden ?? $Request.Body.ShowHidden
        $Name = $Request.Query.Name ?? $Request.Body.Name
        $Type = $Request.Query.Type ?? $Request.Body.Type
        $SearchTitle = $Request.query.SearchTitle ?? $Request.body.SearchTitle

        if ($ShowHidden -eq $true) {
            $ScheduledItemFilter.Add('Hidden eq true')
        } else {
            $ScheduledItemFilter.Add('Hidden eq false')
        }

        if ($Name) {
            $ScheduledItemFilter.Add("Name eq '$($Name)'")
        }

    }

    $Filter = $ScheduledItemFilter -join ' and '

    Write-Host "Filter: $Filter"
    $Table = Get-CIPPTable -TableName 'ScheduledTasks'
    if ($ShowHidden -eq $true) {
        $HiddenTasks = $false
    } else {
        $HiddenTasks = $true
    }
    $Tasks = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    if ($Type) {
        $Tasks = $Tasks | Where-Object { $_.command -eq $Type }
    }

    if ($SearchTitle) {
        $Tasks = $Tasks | Where-Object { $_.Name -like $SearchTitle }
    }

    $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList

    if ($AllowedTenants -notcontains 'AllTenants') {
        $TenantList = Get-Tenants -IncludeErrors | Select-Object customerId, defaultDomainName
        $AllowedTenantDomains = $TenantList | Where-Object -Property customerId -In $AllowedTenants | Select-Object -ExpandProperty defaultDomainName
        $Tasks = $Tasks | Where-Object -Property Tenant -In $AllowedTenantDomains
    }
    $ScheduledTasks = foreach ($Task in $tasks) {
        if (!$Task.Tenant -or !$Task.Command) {
            continue
        }

        if ($Task.Parameters) {
            $Task.Parameters = $Task.Parameters | ConvertFrom-Json -ErrorAction SilentlyContinue
        } else {
            $Task | Add-Member -NotePropertyName Parameters -NotePropertyValue @{}
        }
        if (!$Task.Recurrence) {
            $Task | Add-Member -NotePropertyName Recurrence -NotePropertyValue 'Once' -Force
        } elseif ($Task.Recurrence -eq 0 -or [string]::IsNullOrEmpty($Task.Recurrence)) {
            $Task.Recurrence = 'Once'
        }
        try {
            $Task.ExecutedTime = [DateTimeOffset]::FromUnixTimeSeconds($Task.ExecutedTime).UtcDateTime
        } catch {}
        try {
            $Task.ScheduledTime = [DateTimeOffset]::FromUnixTimeSeconds($Task.ScheduledTime).UtcDateTime
        } catch {}

        # Handle tenant group display information
        if ($Task.TenantGroup) {
            try {
                $TenantGroupObject = $Task.TenantGroup | ConvertFrom-Json -ErrorAction SilentlyContinue
                if ($TenantGroupObject) {
                    # Create a tenant group object for the frontend formatting
                    $TenantGroupForDisplay = [PSCustomObject]@{
                        label = $TenantGroupObject.label
                        value = $TenantGroupObject.value
                        type  = 'Group'
                    }
                    $Task | Add-Member -NotePropertyName TenantGroupInfo -NotePropertyValue $TenantGroupForDisplay -Force
                    # Update the tenant to show the group object for proper formatting
                    $Task.Tenant = $TenantGroupForDisplay
                }
            } catch {
                Write-Warning "Failed to parse tenant group information for task $($Task.RowKey): $($_.Exception.Message)"
                # Fall back to keeping original tenant value
            }
        } else {
            $Task.Tenant = [PSCustomObject]@{
                label = $Task.Tenant
                value = $Task.Tenant
                type  = 'Tenant'
            }
        }
        if ($Task.Trigger) {
            try {
                $TriggerObject = $Task.Trigger | ConvertFrom-Json -ErrorAction SilentlyContinue
                if ($TriggerObject) {
                    $Task | Add-Member -NotePropertyName Trigger -NotePropertyValue $TriggerObject -Force
                }
            } catch {
                Write-Warning "Failed to parse trigger information for task $($Task.RowKey): $($_.Exception.Message)"
                # Fall back to keeping original trigger value
            }
        }

        $Task
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($ScheduledTasks | Sort-Object -Property ScheduledTime, ExecutedTime -Descending)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-ListScheduledItems.ps1' 130
#Region './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-RemoveScheduledItem.ps1' -1

function Invoke-RemoveScheduledItem {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Scheduler.ReadWrite
    .DESCRIPTION
        Removes a scheduled item from CIPP's scheduler.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $RowKey = $Request.Query.id ? $Request.Query.id : $Request.Body.id
    $task = @{
        RowKey       = $RowKey
        PartitionKey = 'ScheduledTask'
    }
    try {
        $Table = Get-CIPPTable -TableName 'ScheduledTasks'
        Remove-AzDataTableEntity -Force @Table -Entity $task

        $DetailTable = Get-CIPPTable -TableName 'ScheduledTaskDetails'
        $Details = Get-CIPPAzDataTableEntity @DetailTable -Filter "PartitionKey eq '$($RowKey)'" -Property RowKey, PartitionKey, ETag

        if ($Details) {
            Remove-AzDataTableEntity -Force @DetailTable -Entity $Details
        }

        Write-LogMessage -Headers $Headers -API $APIName -message "Task removed: $($task.RowKey)" -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APIName -message "Failed to remove task: $($task.RowKey). $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = 'Task removed successfully.' }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Scheduler/Invoke-RemoveScheduledItem.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAccessChecks.ps1' -1

function Invoke-ExecAccessChecks {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Table = Get-CIPPTable -tablename 'AccessChecks'
    $LastRun = (Get-Date).ToUniversalTime()
    $4HoursAgo = (Get-Date).AddHours(-1).ToUniversalTime()
    $TimestampFilter = $4HoursAgo.ToString('yyyy-MM-ddTHH:mm:ss.fffK')


    switch ($Request.Query.Type) {
        'Permissions' {
            if ($Request.Query.SkipCache -ne 'true' -or $Request.Query.SkipCache -ne $true) {
                try {
                    $Cache = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq 'AccessPermissions' and Timestamp and Timestamp ge datetime'$TimestampFilter'"
                    $Results = $Cache.Data | ConvertFrom-Json -ErrorAction Stop
                } catch {
                    $Results = $null
                }
                if (!$Results) {
                    $Results = Test-CIPPAccessPermissions -tenantfilter $env:TenantID -APIName $APINAME -Headers $Request.Headers
                } else {
                    try {
                        $LastRun = [DateTime]::SpecifyKind($Cache.Timestamp.DateTime, [DateTimeKind]::Utc)
                    } catch {
                        $LastRun = $null
                    }
                }
            } else {
                $Results = Test-CIPPAccessPermissions -tenantfilter $env:TenantID -APIName $APINAME -Headers $Request.Headers
            }
        }
        'Tenants' {
            $AccessChecks = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'TenantAccessChecks'"
            if (!$Request.Body.TenantId) {
                try {
                    $Tenants = Get-Tenants -IncludeErrors | Where-Object { $_.customerId -ne $env:TenantID }
                    $Results = foreach ($Tenant in $Tenants) {
                        $TenantCheck = $AccessChecks | Where-Object -Property RowKey -EQ $Tenant.customerId | Select-Object -Property Data
                        $TenantResult = [PSCustomObject]@{
                            TenantId                  = $Tenant.customerId
                            TenantName                = $Tenant.displayName
                            DefaultDomainName         = $Tenant.defaultDomainName
                            GraphStatus               = 'Not run yet'
                            ExchangeStatus            = 'Not run yet'
                            GDAPRoles                 = ''
                            MissingRoles              = ''
                            LastRun                   = ''
                            GraphTest                 = ''
                            ExchangeTest              = ''
                            OrgManagementRoles        = @()
                            OrgManagementRolesMissing = @()
                            OrgManagementRepairNeeded = $false
                        }
                        if ($TenantCheck) {
                            $Data = @($TenantCheck.Data | ConvertFrom-Json -ErrorAction Stop)
                            $TenantResult.GraphStatus = $Data.GraphStatus
                            $TenantResult.ExchangeStatus = $Data.ExchangeStatus
                            $TenantResult.GDAPRoles = $Data.GDAPRoles
                            $TenantResult.MissingRoles = $Data.MissingRoles
                            $TenantResult.LastRun = $Data.LastRun
                            $TenantResult.GraphTest = $Data.GraphTest
                            $TenantResult.ExchangeTest = $Data.ExchangeTest
                            $TenantResult.OrgManagementRoles = $Data.OrgManagementRoles ? @($Data.OrgManagementRoles) : @()
                            $TenantResult.OrgManagementRolesMissing = $Data.OrgManagementRolesMissing ? @($Data.OrgManagementRolesMissing) : @()
                            $TenantResult.OrgManagementRepairNeeded = $Data.OrgManagementRolesMissing.Count -gt 0
                        }
                        $TenantResult
                    }

                    $LastRunTime = $AccessChecks | Sort-Object Timestamp | Select-Object -Property Timestamp -Last 1
                    try {
                        $LastRun = [DateTime]::SpecifyKind($LastRunTime.Timestamp.DateTime, [DateTimeKind]::Utc)
                    } catch {
                        $LastRun = $null
                    }

                    if (!$Results) {
                        $Results = @()
                    }
                } catch {
                    Write-Warning "Error running tenant access check - $($_.Exception.Message)"
                    $Results = @()
                }
            }

            if ($Request.Query.SkipCache -eq 'true' -or $Request.Query.SkipCache -eq $true -or $LastRun -lt $4HoursAgo) {
                $Message = Test-CIPPAccessTenant -Headers $Request.Headers
            }

            if ($Request.Body.TenantId) {
                $Tenant = Get-Tenants -TenantFilter $Request.Body.TenantId
                $null = Test-CIPPAccessTenant -Tenant $Tenant.customerId -Headers $Request.Headers
                $Results = "Refreshing tenant $($Tenant.displayName)"
            }

        }
        'GDAP' {
            if (!$Request.Query.SkipCache -eq 'true' -or !$Request.Query.SkipCache -eq $true) {
                try {
                    $Cache = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq 'GDAPRelationships' and Timestamp ge datetime'$TimestampFilter'"
                    $Results = $Cache.Data | ConvertFrom-Json -ErrorAction Stop
                } catch {
                    $Results = $null
                }
                if (!$Results) {
                    $Results = Test-CIPPGDAPRelationships
                } else {
                    try {
                        $LastRun = [DateTime]::SpecifyKind($Cache.Timestamp.DateTime, [DateTimeKind]::Utc)
                    } catch {
                        $LastRun = $null
                    }
                }
            } else {
                $Results = Test-CIPPGDAPRelationships
            }
        }
    }
    $Metadata = @{
        LastRun = $LastRun
    }
    if ($Message) {
        $Metadata.AlertMessage = $Message
    }

    $body = [pscustomobject]@{
        'Results'  = $Results
        'Metadata' = $Metadata
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAccessChecks.ps1' 145
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAddTrustedIP.ps1' -1

function Invoke-ExecAddTrustedIP {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'trustedIps'
    foreach ($IP in $Request.body.IP) {
        Add-CIPPAzDataTableEntity @Table -Entity @{
            PartitionKey = $Request.Body.tenantfilter
            RowKey       = $IP
            state        = $Request.Body.State
        } -Force
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ results = "Added $($Request.Body.IP) to database with state $($Request.Body.State) for $($Request.Body.tenantfilter)" }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAddTrustedIP.ps1' 24
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecApiClient.ps1' -1

function Invoke-ExecApiClient {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'ApiClients'
    $Action = $Request.Query.Action ?? $Request.Body.Action

    switch ($Action) {
        'List' {
            $Apps = Get-CIPPAzDataTableEntity @Table | Where-Object { ![string]::IsNullOrEmpty($_.RowKey) }
            if (!$Apps) {
                $Apps = @()
            } else {
                $Apps = Get-CippApiClient
                $Body = @{ Results = @($Apps) }
            }
        }
        'ListAvailable' {
            $sitename = $env:WEBSITE_SITE_NAME
            $Apps = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications?`$filter=signInAudience eq 'AzureAdMyOrg' and web/redirectUris/any(x:x eq 'https://$($sitename).azurewebsites.net/.auth/login/aad/callback')&`$top=999&`$select=appId,displayName,createdDateTime,api,web,passwordCredentials&`$count=true" -NoAuthCheck $true -asapp $true -ComplexFilter
            $Body = @{
                Results = @($Apps)
            }
        }
        'AddUpdate' {
            if ($Request.Body.ClientId -or $Request.Body.AppName) {
                $ClientId = $Request.Body.ClientId.value ?? $Request.Body.ClientId
                $AddUpdateSuccess = $false
                try {
                    $ApiConfig = @{
                        Headers = $Request.Headers
                    }
                    if ($ClientId) {
                        $ApiConfig.ClientId = $ClientId
                        $ApiConfig.ResetSecret = $Request.Body.CIPPAPI.ResetSecret
                    }
                    if ($Request.Body.AppName) {
                        $ApiConfig.AppName = $Request.Body.AppName
                    }
                    $APIConfig = New-CIPPAPIConfig @ApiConfig

                    $ClientId = $APIConfig.ApplicationID
                    $AddedText = $APIConfig.Results
                    $AddUpdateSuccess = $true
                } catch {
                    $AddedText = "Could not modify App Registrations. Check the CIPP documentation for API requirements. Error: $($_.Exception.Message)"
                }
            }

            if ($Request.Body.IpRange.value) {
                $IpRange = [System.Collections.Generic.List[string]]::new()
                $regexPattern = '^(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?:/\d{1,2})?|(?:[0-9A-Fa-f]{1,4}:){1,7}[0-9A-Fa-f]{1,4}(?:/\d{1,3})?)$'
                foreach ($IP in @($Request.Body.IPRange.value)) {
                    if ($IP -match $regexPattern) {
                        $IpRange.Add($IP)
                    }
                }
            } else {
                $IpRange = @()
            }

            if (!$AddUpdateSuccess -and !$ClientId) {
                $Body = @{
                    Results = $AddedText
                }
            } else {
                $ExistingClient = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($ClientId)'"
                if ($ExistingClient) {
                    $Client = $ExistingClient
                    $Client.Role = [string]$Request.Body.Role.value
                    $Client.IPRange = "$(@($IpRange) | ConvertTo-Json -Compress)"
                    $Client.Enabled = $Request.Body.Enabled ?? $false
                    Write-LogMessage -headers $Request.Headers -API 'ExecApiClient' -message "Updated API client $($Request.Body.ClientId)" -Sev 'Info'
                    $Results = 'API client updated'
                } else {
                    $Client = @{
                        'PartitionKey' = 'ApiClients'
                        'RowKey'       = "$($ClientId)"
                        'AppName'      = "$($APIConfig.AppName ?? $Request.Body.ClientId.addedFields.displayName)"
                        'Role'         = [string]$Request.Body.Role.value
                        'IPRange'      = "$(@($IpRange) | ConvertTo-Json -Compress)"
                        'Enabled'      = $Request.Body.Enabled ?? $false
                    }
                    $Results = @{
                        resultText = "API Client created with the name '$($Client.AppName)'. Use the Copy to Clipboard button to retrieve the secret."
                        copyField  = $APIConfig.ApplicationSecret
                        state      = 'success'
                    }
                }

                Add-CIPPAzDataTableEntity @Table -Entity $Client -Force | Out-Null
                $Body = @($Results)
            }
        }
        'GetAzureConfiguration' {
            $Owner = $env:WEBSITE_OWNER_NAME
            Write-Information "Owner: $Owner"
            if ($env:WEBSITE_SKU -ne 'FlexConsumption' -and $Owner -match '^(?<SubscriptionId>[^+]+)\+(?<RGName>[^-]+(?:-[^-]+)*?)(?:-[^-]+webspace(?:-Linux)?)?$') {
                $RGName = $Matches.RGName
            } else {
                $RGName = $env:WEBSITE_RESOURCE_GROUP
            }
            $FunctionAppName = $env:WEBSITE_SITE_NAME
            try {
                $APIClients = Get-CippApiAuth -RGName $RGName -FunctionAppName $FunctionAppName
                $Results = $ApiClients
            } catch {
                $Results = @{
                    Enabled = 'Could not get API clients, ensure you have the appropriate rights to read the Authentication settings.'
                    Error   = (Get-CippException -Exception $_)
                }
            }
            $Body = @{
                Results = $Results
            }
        }
        'SaveToAzure' {
            $TenantId = $env:TenantID
            $Owner = $env:WEBSITE_OWNER_NAME
            if ($env:WEBSITE_SKU -ne 'FlexConsumption' -and $Owner -match '^(?<SubscriptionId>[^+]+)\+(?<RGName>[^-]+(?:-[^-]+)*?)(?:-[^-]+webspace(?:-Linux)?)?$') {
                $RGName = $Matches.RGName
            } else {
                $RGName = $env:WEBSITE_RESOURCE_GROUP
            }
            $FunctionAppName = $env:WEBSITE_SITE_NAME
            $AllClients = Get-CIPPAzDataTableEntity @Table -Filter 'Enabled eq true' | Where-Object { ![string]::IsNullOrEmpty($_.RowKey) }
            $ClientIds = $AllClients.RowKey
            try {
                Set-CippApiAuth -RGName $RGName -FunctionAppName $FunctionAppName -TenantId $TenantId -ClientIds $ClientIds
                $Body = @{ Results = 'API clients saved to Azure' }
                Write-LogMessage -headers $Request.Headers -API 'ExecApiClient' -message 'Saved API clients to Azure' -Sev 'Info'
            } catch {
                $Body = @{
                    Results = 'Failed to save allowed API clients to Azure, ensure your function app has the appropriate rights to make changes to the Authentication settings.'
                    Error   = (Get-CippException -Exception $_)
                }
                Write-Information (Get-CippException -Exception $_ | ConvertTo-Json)
            }
        }
        'ResetSecret' {
            $Client = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Request.Body.ClientId)'"
            if (!$Client) {
                $Results = @{
                    resultText = 'API client not found'
                    state      = 'error'
                }
            } else {
                $ApiConfig = New-CIPPAPIConfig -ResetSecret -AppId $Request.Body.ClientId -Headers $Request.Headers

                if ($ApiConfig.ApplicationSecret) {
                    $Results = @{
                        resultText = "API secret reset for $($Client.AppName). Use the Copy to Clipboard button to retrieve the new secret."
                        copyField  = $ApiConfig.ApplicationSecret
                        state      = 'success'
                    }
                } else {
                    $Results = @{
                        resultText = "Failed to reset secret for $($Client.AppName)"
                        state      = 'error'
                    }
                }
            }
            $Body = @($Results)
        }
        'Delete' {
            try {
                if ($Request.Body.ClientId) {
                    $ClientId = $Request.Body.ClientId.value ?? $Request.Body.ClientId
                    if ($Request.Body.RemoveAppReg -eq $true) {
                        Write-Information "Deleting API Client: $ClientId from Entra"
                        $App = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications?`$filter=appId eq '$($ClientId)'&`$select=id,appId,web" -NoAuthCheck $true -asapp $true
                        $Id = $App.id
                        if ($Id -and $App.web.redirectUris -like "*$($env:WEBSITE_SITE_NAME)*") {
                            New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/applications/$Id" -type DELETE -Body '{}' -NoAuthCheck $true -asapp $true
                            Write-Information "Deleted App Registration for $ClientId"
                        } else {
                            Write-Information "App Registration for $ClientId not found or Redirect URI does not match"
                        }
                    }
                    Write-Information "Deleting API Client: $ClientId from CIPP"
                    $Client = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($ClientId)'" -Property RowKey, PartitionKey
                    Remove-AzDataTableEntity @Table -Entity $Client -Force
                    Write-LogMessage -headers $Request.Headers -API 'ExecApiClient' -message "Deleted API client $ClientId" -Sev 'Info'
                    $Body = @{ Results = "API client $ClientId deleted" }
                } else {
                    $Body = @{ Results = "API client $ClientId not found or not a valid CIPP-API application" }
                }
            } catch {
                Write-LogMessage -headers $Request.Headers -API 'ExecApiClient' -message "Failed to remove app registration for $ClientId" -Sev 'Warning'
            }
        }
        default {
            $Body = @{Results = 'Invalid action' }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}

#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecApiClient.ps1' 209
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAPIPermissionList.ps1' -1

function Invoke-ExecAPIPermissionList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Roles = Get-CIPPHttpFunctions -ByRoleGroup | ConvertTo-Json -Depth 10

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Roles
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecAPIPermissionList.ps1' 18
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecBackendURLs.ps1' -1

function Invoke-ExecBackendURLs {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Subscription = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
    $SWAName = $env:WEBSITE_SITE_NAME -replace 'cipp', 'CIPP-SWA-'

    # Write to the Azure Functions log stream.
    Write-Host 'PowerShell HTTP trigger function processed a request.'

    $Owner = $env:WEBSITE_OWNER_NAME
    if ($env:WEBSITE_SKU -ne 'FlexConsumption' -and $Owner -match '^(?<SubscriptionId>[^+]+)\+(?<RGName>[^-]+(?:-[^-]+)*?)(?:-[^-]+webspace(?:-Linux)?)?$') {
        $RGName = $Matches.RGName
    } else {
        $RGName = $env:WEBSITE_RESOURCE_GROUP
    }

    $results = [PSCustomObject]@{
        ResourceGroup      = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/overview"
        KeyVault           = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.KeyVault/vaults/$($env:WEBSITE_SITE_NAME)/secrets"
        FunctionApp        = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($env:WEBSITE_SITE_NAME)/appServices"
        FunctionConfig     = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($env:WEBSITE_SITE_NAME)/configuration"
        FunctionDeployment = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.Web/sites/$($env:WEBSITE_SITE_NAME)/vstscd"
        SWADomains         = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.Web/staticSites/$SWAName/customDomains"
        SWARoles           = "https://portal.azure.com/#@Go/resource/subscriptions/$Subscription/resourceGroups/$RGName/providers/Microsoft.Web/staticSites/$SWAName/roleManagement"
        Subscription       = $Subscription
        RGName             = $RGName
        FunctionName       = $env:WEBSITE_SITE_NAME
        SWAName            = $SWAName
    }


    $body = @{Results = $Results }

    return ([HttpResponseContext]@{
            StatusCode = [httpstatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecBackendURLs.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecBrandingSettings.ps1' -1

Function Invoke-ExecBrandingSettings {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $StatusCode = [HttpStatusCode]::OK
    @{}

    try {
        $Table = Get-CIPPTable -TableName Config
        $Filter = "PartitionKey eq 'BrandingSettings' and RowKey eq 'BrandingSettings'"
        $BrandingConfig = Get-CIPPAzDataTableEntity @Table -Filter $Filter

        if (-not $BrandingConfig) {
            $BrandingConfig = @{
                PartitionKey = 'BrandingSettings'
                RowKey       = 'BrandingSettings'
                colour       = '#F77F00'
                logo         = $null
            }
        }

        $Action = if ($Request.Body.Action) { $Request.Body.Action } else { $Request.Query.Action }

        $Results = switch ($Action) {
            'Get' {
                @{
                    colour = $BrandingConfig.colour
                    logo   = $BrandingConfig.logo
                }
            }
            'Set' {
                $Updated = $false

                if ($Request.Body.colour) {
                    $Colour = $Request.Body.colour
                    if ($Colour -match '^#[0-9A-Fa-f]{6}$') {
                        $BrandingConfig.colour = $Colour
                        $Updated = $true
                    } else {
                        $StatusCode = [HttpStatusCode]::BadRequest
                        'Error: Invalid color format. Please use hex format (e.g., #F77F00)'
                    }
                }

                if ($Request.Body.logo) {
                    $Logo = $Request.Body.logo
                    if ($Logo -match '^data:image\/') {
                        $Base64Data = $Logo -replace '^data:image\/[^;]+;base64,', ''
                        try {
                            $ImageBytes = [Convert]::FromBase64String($Base64Data)
                            if ($ImageBytes.Length -le 2097152) {
                                Write-Host 'updating logo'
                                $BrandingConfig | Add-Member -MemberType NoteProperty -Name 'logo' -Value $Logo -Force
                                $Updated = $true
                            } else {
                                $StatusCode = [HttpStatusCode]::BadRequest
                                'Error: Image size must be less than 2MB'
                            }
                        } catch {
                            $StatusCode = [HttpStatusCode]::BadRequest
                            'Error: Invalid base64 image data: ' + $_.Exception.Message
                        }
                    } elseif ($Logo -eq $null -or $Logo -eq '') {
                        $BrandingConfig | Add-Member -MemberType NoteProperty -Name 'logo' -Value $null -Force
                        $Updated = $true
                    }
                }

                if ($Updated) {
                    $BrandingConfig.PartitionKey = 'BrandingSettings'
                    $BrandingConfig.RowKey = 'BrandingSettings'

                    Add-CIPPAzDataTableEntity @Table -Entity $BrandingConfig -Force | Out-Null
                    Write-LogMessage -API $APIName -tenant 'Global' -headers $Request.Headers -message 'Updated branding settings' -Sev 'Info'
                    'Successfully updated branding settings'
                } else {
                    $StatusCode = [HttpStatusCode]::BadRequest
                    'Error: No valid branding data provided'
                }
            }
            'Reset' {
                $DefaultConfig = @{
                    PartitionKey = 'BrandingSettings'
                    RowKey       = 'BrandingSettings'
                    colour       = '#F77F00'
                    logo         = $null
                }

                Add-CIPPAzDataTableEntity @Table -Entity $DefaultConfig -Force | Out-Null
                Write-LogMessage -API $APIName -tenant 'Global' -headers $Request.Headers -message 'Reset branding settings to defaults' -Sev 'Info'
                'Successfully reset branding settings to defaults'
            }
            default {
                $StatusCode = [HttpStatusCode]::BadRequest
                'Error: Invalid action specified'
            }
        }
    } catch {
        Write-LogMessage -API $APIName -tenant 'Global' -headers $Request.Headers -message "Branding Settings API failed: $($_.Exception.Message)" -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
        "Failed to process branding settings: $($_.Exception.Message)"
    }

    $body = [pscustomobject]@{'Results' = $Results }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecBrandingSettings.ps1' 118
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCippReplacemap.ps1' -1

function Invoke-ExecCippReplacemap {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Config.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'CippReplacemap'
    $Action = $Request.Query.Action ?? $Request.Body.Action
    $TenantId = $Request.Query.tenantId ?? $Request.Body.tenantId
    if ($TenantId -eq 'AllTenants') {
        $customerId = $TenantId
    } else {
        # ensure we use a consistent id for the table storage
        $Tenant = Get-Tenants -TenantFilter $TenantId
        $customerId = $Tenant.customerId
    }

    if (!$customerId) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'customerId is required'
            })
        return
    }

    switch ($Action) {
        'List' {
            $Variables = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$customerId'"
            if (!$Variables) {
                $Variables = @()
            }
            $Body = @{ Results = @($Variables) }
        }
        'AddEdit' {
            $VariableName = $Request.Body.RowKey
            $VariableValue = $Request.Body.Value
            $VariableDescription = $Request.Body.Description

            $VariableEntity = @{
                PartitionKey = $customerId
                RowKey       = $VariableName
                Value        = $VariableValue
                Description  = $VariableDescription
            }

            Add-CIPPAzDataTableEntity @Table -Entity $VariableEntity -Force
            $Body = @{ Results = "Variable '$VariableName' saved successfully" }
        }
        'Delete' {
            $VariableName = $Request.Body.RowKey

            $VariableEntity = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$customerId' and RowKey eq '$VariableName'"
            if ($VariableEntity) {
                Remove-AzDataTableEntity @Table -Entity $VariableEntity -Force
                $Body = @{ Results = "Variable '$VariableName' deleted successfully" }
            } else {
                $Body = @{ Results = "Variable '$VariableName' not found" }
            }
        }
        default {
            $Body = @{ Results = 'Invalid action' }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCippReplacemap.ps1' 74
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCPVPermissions.ps1' -1

function Invoke-ExecCPVPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Body.tenantFilter

    $Tenant = Get-Tenants -TenantFilter $TenantFilter -IncludeErrors

    if ($Tenant) {
        Write-Host "Our tenant is $($Tenant.displayName) - $($Tenant.defaultDomainName)"

        $CPVConsentParams = @{
            TenantFilter = $TenantFilter
        }
        if ($Request.Query.ResetSP -eq 'true') {
            $CPVConsentParams.ResetSP = $true
        }

        $GraphRequest = try {
            if ($TenantFilter -notin @('PartnerTenant', $env:TenantID)) {
                Set-CIPPCPVConsent @CPVConsentParams
            } else {
                $TenantFilter = $env:TenantID
                $Tenant = [PSCustomObject]@{
                    displayName       = '*Partner Tenant'
                    defaultDomainName = $env:TenantID
                }
            }
            Add-CIPPApplicationPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -tenantfilter $TenantFilter
            Add-CIPPDelegatedPermission -RequiredResourceAccess 'CIPPDefaults' -ApplicationId $env:ApplicationID -tenantfilter $TenantFilter
            if ($TenantFilter -notin @('PartnerTenant', $env:TenantID)) {
                Set-CIPPSAMAdminRoles -TenantFilter $TenantFilter
            }
            $Success = $true
        } catch {
            "Failed to update permissions for $($Tenant.displayName): $($_.Exception.Message)"
            $Success = $false
        }

        $Tenant = Get-Tenants -IncludeAll | Where-Object -Property customerId -EQ $TenantFilter | Select-Object -First 1

    } else {
        $GraphRequest = 'Tenant not found'
        $Success = $false
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{
                Results  = $GraphRequest
                Metadata = @{
                    Heading = ('CPV Permission - {0} ({1})' -f $Tenant.displayName, $Tenant.defaultDomainName)
                    Success = $Success
                }
            }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCPVPermissions.ps1' 63
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCreateDefaultGroups.ps1' -1

function Invoke-ExecCreateDefaultGroups {
    <#
    .SYNOPSIS
        Create default tenant groups
    .DESCRIPTION
        This function creates a set of default tenant groups that are commonly used
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Groups.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    try {
        $Table = Get-CippTable -tablename 'TenantGroups'
        $Results = [System.Collections.Generic.List[object]]::new()
        $ExistingGroups = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'TenantGroup' and Type eq 'dynamic'"
        $DefaultGroups = '[{"PartitionKey":"TenantGroup","RowKey":"369d985e-0fba-48f9-844f-9f793b10a12c","Description":"This group does not have a license for intune, nor a license for Entra ID Premium","Description@type":null,"DynamicRules":"[{\"property\":\"availableServicePlan\",\"operator\":\"notIn\",\"value\":[{\"label\":\"Microsoft Intune\",\"value\":\"INTUNE_A\",\"id\":\"c1ec4a95-1f05-45b3-a911-aa3fa01094f5\"}]},{\"property\":\"availableServicePlan\",\"operator\":\"notIn\",\"value\":[{\"label\":\"Microsoft Entra ID P1\",\"value\":\"AAD_PREMIUM\",\"id\":\"41781fb2-bc02-4b7c-bd55-b576c07bb09d\"}]}]","DynamicRules@type":null,"GroupType":"dynamic","GroupType@type":null,"RuleLogic":"and","RuleLogic@type":null,"Name":"Not Intune and Entra Premium Capable","Name@type":null},{"PartitionKey":"TenantGroup","RowKey":"4dbca08b-7dc5-4e0f-bc25-14a90c8e0941","Description":"This group has atleast one Business Premium License available","Description@type":null,"DynamicRules":"[{\"property\":\"availableLicense\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft 365 Business Premium\",\"value\":\"SPB\"}]},{\"property\":\"availableLicense\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft 365 Business Premium (no Teams)\",\"value\":\"Microsoft_365_ Business_ Premium_(no Teams)\"}]},{\"property\":\"availableLicense\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft 365 Business Premium Donation\",\"value\":\"Microsoft_365_Business_Premium_Donation_(Non_Profit_Pricing)\"}]},{\"property\":\"availableLicense\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft 365 Business Premium EEA (no Teams)\",\"value\":\"Office_365_w\/o_Teams_Bundle_Business_Premium\"}]}]","DynamicRules@type":null,"GroupType":"dynamic","GroupType@type":null,"RuleLogic":"or","RuleLogic@type":null,"Name":"Business Premium License available","Name@type":null},{"PartitionKey":"TenantGroup","RowKey":"703c0e69-84a8-4dcf-a1c2-4986d2ccc850","Description":"This group does have a license for Entra Premium but does not have a license for Intune","Description@type":null,"DynamicRules":"[{\"property\":\"availableServicePlan\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft Entra ID P1\",\"value\":\"AAD_PREMIUM\",\"id\":\"41781fb2-bc02-4b7c-bd55-b576c07bb09d\"}]},{\"property\":\"availableServicePlan\",\"operator\":\"notIn\",\"value\":[{\"label\":\"Microsoft Intune\",\"value\":\"INTUNE_A\",\"id\":\"c1ec4a95-1f05-45b3-a911-aa3fa01094f5\"}]}]","DynamicRules@type":null,"GroupType":"dynamic","GroupType@type":null,"RuleLogic":"and","RuleLogic@type":null,"Name":"Entra Premium Capable, Not Intune Capable","Name@type":null},{"PartitionKey":"TenantGroup","RowKey":"c1dadbc0-f0b4-448c-a2e6-e1938ba102e0","Description":"This group has Intune and Entra ID Premium available","Description@type":null,"DynamicRules":"{\"property\":\"availableServicePlan\",\"operator\":\"in\",\"value\":[{\"label\":\"Microsoft Intune\",\"value\":\"INTUNE_A\"},{\"label\":\"Microsoft Entra ID P1\",\"value\":\"AAD_PREMIUM\"}]}","DynamicRules@type":null,"GroupType":"dynamic","GroupType@type":null,"RuleLogic":"and","RuleLogic@type":null,"Name":"Entra ID Premium and Intune Capable","Name@type":null}]' | ConvertFrom-Json


        foreach ($Group in $DefaultGroups) {
            # Check if group with same name already exists
            $ExistingGroup = $ExistingGroups | Where-Object -Property Name -EQ $group.Name
            if ($ExistingGroup) {
                $Results.Add(@{
                        resultText = "Group '$($Group.Name)' already exists, skipping"
                        state      = 'warning'
                    })
                continue
            }
            $GroupEntity = @{
                PartitionKey = 'TenantGroup'
                RowKey       = $group.RowKey
                Name         = $Group.Name
                Description  = $Group.Description
                GroupType    = $Group.GroupType
                DynamicRules = $Group.DynamicRules
                RuleLogic    = $Group.RuleLogic
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GroupEntity -Force

            $Results.Add(@{
                    resultText = "Created default group: '$($Group.Name)'"
                    state      = 'success'
                })

            Write-LogMessage -API 'TenantGroups' -message "Created default tenant group: $($Group.Name)" -sev Info
        }

        $Body = @{ Results = $Results }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Body
            })
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'TenantGroups' -message "Failed to create default groups: $ErrorMessage" -sev Error
        $Body = @{ Results = "Failed to create default groups: $ErrorMessage" }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $Body
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCreateDefaultGroups.ps1' 67
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCustomData.ps1' -1

function Invoke-ExecCustomData {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Action = $Request.Query.Action ?? $Request.Body.Action
    $CustomDataTable = Get-CippTable -TableName 'CustomData'
    $CustomDataMappingsTable = Get-CippTable -TableName 'CustomDataMappings'

    Write-Information "Executing action '$Action'"

    switch ($Action) {
        'ListSchemaExtensions' {
            try {
                $SchemaExtensions = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'" | Select-Object -ExpandProperty JSON | ConvertFrom-Json
                if (!$SchemaExtensions -or $SchemaExtensions.id -notmatch '_') {
                    $SchemaExtensions = Get-CIPPSchemaExtensions | Sort-Object id
                }
                $Body = @{
                    Results = @($SchemaExtensions)
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to retrieve schema extensions: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'AddSchemaExtension' {
            try {
                $SchemaExtension = $Request.Body.schemaExtension
                if (!$SchemaExtension) {
                    throw 'SchemaExtension data is missing in the request body.'
                }

                $Entity = @{
                    PartitionKey = 'SchemaExtension'
                    RowKey       = $SchemaExtension.id
                    JSON         = [string]($SchemaExtension | ConvertTo-Json -Depth 5 -Compress)
                }

                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $Entity -Force
                $SchemaExtensions = Get-CIPPSchemaExtensions | Where-Object { $_.id -eq $SchemaExtension.id }

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Schema extension '$($SchemaExtension.id)' added successfully."
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to add schema extension: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'DeleteSchema' {
            try {
                $SchemaId = $Request.Body.id
                if (!$SchemaId) {
                    throw 'Schema ID is missing in the request body.'
                }

                # Retrieve the schema extension entity
                $SchemaEntity = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'" | Where-Object { $SchemaId -match $_.RowKey }
                if (!$SchemaEntity) {
                    throw "Schema extension with ID '$SchemaId' not found."
                }

                # Ensure the schema is in 'InDevelopment' state before deletion
                $SchemaDefinition = $SchemaEntity.JSON | ConvertFrom-Json
                if ($SchemaDefinition.status -ne 'InDevelopment') {
                    throw "Schema extension '$SchemaId' cannot be deleted because it is not in 'InDevelopment' state."
                }

                try {
                    $null = New-GraphPOSTRequest -Type DELETE -Uri "https://graph.microsoft.com/v1.0/schemaExtensions/$SchemaId" -AsApp $true -NoAuthCheck $true -tenantid $env:TenantID -Verbose
                } catch {
                    Write-Warning "Schema extension '$SchemaId' not found in Microsoft Graph."
                }


                # Delete the schema extension entity
                Remove-AzDataTableEntity @CustomDataTable -Entity $SchemaEntity

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Schema extension '$SchemaId' deleted successfully."
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to delete schema extension: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'AddSchemaProperty' {
            try {
                $SchemaId = $Request.Body.id
                $Name = $Request.Body.name
                $Type = $Request.Body.type
                $NewProperty = @{
                    name = $Name
                    type = $Type
                }
                if (!$SchemaId) {
                    throw 'Schema ID is missing in the request body.'
                }
                if (!$Name -or !$Type) {
                    throw 'Property data is missing or incomplete in the request body.'
                }

                # Retrieve the schema extension entity
                $SchemaEntity = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'" | Where-Object { $SchemaId -match $_.RowKey }
                if (!$SchemaEntity) {
                    throw "Schema extension with ID '$SchemaId' not found."
                }

                # Parse the schema definition
                $SchemaDefinition = $SchemaEntity.JSON | ConvertFrom-Json

                if ($SchemaDefinition.status -eq 'Deprecated') {
                    throw "Properties cannot be added to schema extension '$SchemaId' because it is in the 'Deprecated' state."
                }

                # Check if the property already exists
                if ($SchemaDefinition.properties | Where-Object { $_.name -eq $NewProperty.name }) {
                    throw "Property with name '$($NewProperty.name)' already exists in schema extension '$SchemaId'."
                }

                # Add the new property
                $Properties = [System.Collections.Generic.List[object]]::new()
                foreach ($Property in $SchemaDefinition.properties) {
                    $Properties.Add($Property)
                }
                $Properties.Add($NewProperty)
                $SchemaDefinition.properties = $Properties

                # Update the schema extension entity
                $SchemaEntity.JSON = [string]($SchemaDefinition | ConvertTo-Json -Depth 5 -Compress)
                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $SchemaEntity -Force
                try { $null = Get-CIPPSchemaExtensions } catch {}

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Property '$($NewProperty.name)' added to schema extension '$SchemaId' successfully."
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to add property to schema extension: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'ChangeSchemaState' {
            try {
                $SchemaId = $Request.Body.id
                $NewStatus = $Request.Body.status
                if (!$SchemaId) {
                    throw 'Schema ID is missing in the request body.'
                }
                if (!$NewStatus) {
                    throw 'New status is missing in the request body.'
                }

                # Retrieve the schema extension entity
                $SchemaEntity = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'" | Where-Object { $SchemaId -match $_.RowKey }
                if (!$SchemaEntity) {
                    throw "Schema extension with ID '$SchemaId' not found."
                }

                # Parse the schema definition
                $SchemaDefinition = $SchemaEntity.JSON | ConvertFrom-Json

                # Check if the status is already the same
                if ($SchemaDefinition.status -eq $NewStatus) {
                    throw "Schema extension '$SchemaId' is already in the '$NewStatus' state."
                }

                # Update the status
                $SchemaDefinition.status = $NewStatus

                # Update the schema extension entity
                $SchemaEntity.JSON = [string]($SchemaDefinition | ConvertTo-Json -Depth 5 -Compress)
                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $SchemaEntity -Force
                $null = Get-CIPPSchemaExtensions

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Schema extension '$SchemaId' status changed to '$NewStatus' successfully."
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to change schema extension status: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'ListDirectoryExtensions' {
            try {
                $Uri = "https://graph.microsoft.com/beta/applications(appId='$($env:ApplicationID)')/extensionProperties"
                $DirectoryExtensions = New-GraphGetRequest -uri $Uri -AsApp $true -NoAuthCheck $true -tenantid $env:TenantID
                $Existing = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'DirectoryExtension'"

                foreach ($DirectoryExtension in $DirectoryExtensions) {
                    if ($Existing -match $DirectoryExtension.name) {
                        continue
                    }
                    $Entity = @{
                        PartitionKey = 'DirectoryExtension'
                        RowKey       = $DirectoryExtension.name
                        JSON         = [string](ConvertTo-Json $DirectoryExtension -Compress -Depth 5)
                    }
                    Add-CIPPAzDataTableEntity @CustomDataTable -Entity $Entity -Force
                }

                $Body = @{
                    Results = @($DirectoryExtensions)
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to retrieve directory extensions: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'AddDirectoryExtension' {
            try {
                $ExtensionName = $Request.Body.name
                $DataType = $Request.Body.dataType
                $TargetObjects = $Request.Body.targetObjects
                $IsMultiValued = $Request.Body.isMultiValued -eq $true

                if (!$ExtensionName -or !$DataType -or !$TargetObjects) {
                    throw 'Extension name, data type, and target objects are required.'
                }

                $AppId = $env:ApplicationID # Replace with your application ID
                $Uri = "https://graph.microsoft.com/beta/applications(appId='$AppId')/extensionProperties"

                $BodyContent = @{
                    name          = $ExtensionName
                    dataType      = $DataType
                    targetObjects = $TargetObjects
                    isMultiValued = $IsMultiValued
                } | ConvertTo-Json -Depth 5 -Compress

                $Response = New-GraphPOSTRequest -Uri $Uri -Body $BodyContent -AsApp $true -NoAuthCheck $true -tenantid $env:TenantID

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Directory extension '$ExtensionName' added successfully."
                        extension  = $Response
                    }
                }

                # store the extension in the custom data table
                $Entity = @{
                    PartitionKey = 'DirectoryExtension'
                    RowKey       = $Response.name
                    JSON         = [string](ConvertTo-Json $Response -Compress -Depth 5)
                }
                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $Entity -Force
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to add directory extension: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'DeleteDirectoryExtension' {
            try {
                $ExtensionName = $Request.Body.name
                $ExtensionId = $Request.Body.id
                if (!$ExtensionName) {
                    throw 'Extension name is missing in the request body.'
                }
                $AppId = $env:ApplicationID # Replace with your application ID
                $Uri = "https://graph.microsoft.com/beta/applications(appId='$AppId')/extensionProperties/$ExtensionId"

                # Delete the directory extension from Microsoft Graph
                $null = New-GraphPOSTRequest -Type DELETE -Uri $Uri -AsApp $true -NoAuthCheck $true -tenantid $env:TenantID
                try {
                    $CustomDataTable = Get-CippTable -TableName 'CustomData'
                    $ExtensionEntity = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'DirectoryExtension' and RowKey eq '$ExtensionName'"
                    # Remove the extension from the custom data table
                    if ($ExtensionEntity) {
                        Remove-AzDataTableEntity @CustomDataTable -Entity $ExtensionEntity
                    }
                } catch {
                    Write-Warning "Failed to delete directory extension from custom data table: $($_.Exception.Message)"
                }

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = "Directory extension '$ExtensionName' deleted successfully."
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to delete directory extension: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'ListAvailableAttributes' {
            $TargetObject = $Request.Query.targetObject ?? 'All'
            $AvailableAttributes = Get-CippCustomDataAttributes -TargetObject $TargetObject
            $Body = @{
                Results = @($AvailableAttributes)
            }
        }
        'ListMappings' {
            try {
                $Mappings = Get-CIPPAzDataTableEntity @CustomDataMappingsTable | ForEach-Object {
                    $Mapping = $_.JSON | ConvertFrom-Json -AsHashtable

                    Write-Information ($Mapping | ConvertTo-Json -Depth 5)
                    [PSCustomObject]@{
                        id                  = $_.RowKey
                        tenant              = $Mapping.tenantFilter.label
                        dataset             = $Mapping.extensionSyncDataset.label ?? 'N/A'
                        sourceType          = $Mapping.sourceType.label
                        directoryObject     = $Mapping.directoryObjectType.label
                        syncProperty        = $Mapping.extensionSyncProperty.label ?? ($Mapping.extensionSyncDataset ? @($Mapping.extensionSyncDataset.addedFields.select -split ',') : 'N/A')
                        customDataAttribute = $Mapping.customDataAttribute.label
                    }
                }
                $Body = @{
                    Results = @($Mappings)
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to retrieve mappings: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'AddEditMapping' {
            try {
                $Mapping = $Request.Body.Mapping
                if (!$Mapping) {
                    throw 'Mapping data is missing in the request body.'
                }
                $MappingId = $Request.Body.id ?? [Guid]::NewGuid().ToString()
                $Entity = @{
                    PartitionKey = 'Mapping'
                    RowKey       = [string]$MappingId
                    JSON         = [string]($Mapping | ConvertTo-Json -Depth 5 -Compress)
                }

                Add-CIPPAzDataTableEntity @CustomDataMappingsTable -Entity $Entity -Force
                Register-CIPPExtensionScheduledTasks

                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = 'Mapping saved successfully.'
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to add mapping: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'DeleteMapping' {
            try {
                $MappingId = $Request.Body.id
                if (!$MappingId) {
                    throw 'Mapping ID is missing in the request body.'
                }

                # Retrieve the mapping entity
                $MappingEntity = Get-CIPPAzDataTableEntity @CustomDataMappingsTable -Filter "PartitionKey eq 'Mapping' and RowKey eq '$MappingId'"
                if (!$MappingEntity) {
                    throw "Mapping with ID '$MappingId' not found."
                }

                # Delete the mapping entity
                Remove-AzDataTableEntity @CustomDataMappingsTable -Entity $MappingEntity
                Register-CIPPExtensionScheduledTasks
                $Body = @{
                    Results = @{
                        state      = 'success'
                        resultText = 'Mapping deleted successfully.'
                    }
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to delete mapping: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }
        'GetMapping' {
            try {
                $MappingId = $Request.Query.id
                if (!$MappingId) {
                    throw 'Mapping ID is missing in the request query.'
                }

                # Retrieve the mapping entity
                $MappingEntity = Get-CIPPAzDataTableEntity @CustomDataMappingsTable -Filter "PartitionKey eq 'Mapping' and RowKey eq '$MappingId'"
                if (!$MappingEntity) {
                    throw "Mapping with ID '$MappingId' not found."
                }

                $Mapping = $MappingEntity.JSON | ConvertFrom-Json
                $Body = @{
                    Results = $Mapping
                }
            } catch {
                $Body = @{
                    Results = @(
                        @{
                            state      = 'error'
                            resultText = "Failed to retrieve mapping: $($_.Exception.Message)"
                        }
                    )
                }
            }
        }

        default {
            $Body = @{
                Results = @(
                    @{
                        state      = 'error'
                        resultText = 'Invalid action specified.'
                    }
                )
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCustomData.ps1' 501
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCustomRole.ps1' -1

function Invoke-ExecCustomRole {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'CustomRoles'
    $AccessRoleGroupTable = Get-CippTable -tablename 'AccessRoleGroups'
    $Action = $Request.Query.Action ?? $Request.Body.Action

    $CIPPCore = (Get-Module -Name CIPPCore).ModuleBase
    $CIPPRoot = (Get-Item -Path $CIPPCore).Parent.Parent.FullName

    $CippRolesJson = Join-Path -Path $CIPPRoot -ChildPath 'Config\cipp-roles.json'
    if (Test-Path $CippRolesJson) {
        $DefaultRoles = Get-Content -Path $CippRolesJson | ConvertFrom-Json
    } else {
        throw "Could not find $CippRolesJson"
    }

    $BlockedRoles = @('anonymous', 'authenticated')

    if ($Request.Body.RoleName -in $BlockedRoles) {
        throw "Role name $($Request.Body.RoleName) cannot be used"
    }

    switch ($Action) {
        'AddUpdate' {
            try {
                $Results = [System.Collections.Generic.List[string]]::new()
                Write-LogMessage -headers $Request.Headers -API 'ExecCustomRole' -message "Saved custom role $($Request.Body.RoleName)" -Sev 'Info'
                if ($Request.Body.RoleName -notin $DefaultRoles.PSObject.Properties.Name) {
                    $Role = @{
                        'PartitionKey'     = 'CustomRoles'
                        'RowKey'           = "$($Request.Body.RoleName.ToLower())"
                        'Permissions'      = "$($Request.Body.Permissions | ConvertTo-Json -Compress)"
                        'AllowedTenants'   = "$($Request.Body.AllowedTenants | ConvertTo-Json -Compress)"
                        'BlockedTenants'   = "$($Request.Body.BlockedTenants | ConvertTo-Json -Compress)"
                        'BlockedEndpoints' = "$($Request.Body.BlockedEndpoints | ConvertTo-Json -Compress)"
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $Role -Force | Out-Null
                    $Results.Add("Custom role $($Request.Body.RoleName) saved")
                }
                if ($Request.Body.EntraGroup) {
                    $RoleGroup = @{
                        'PartitionKey' = 'AccessRoleGroups'
                        'RowKey'       = "$($Request.Body.RoleName.ToLower())"
                        'GroupId'      = $Request.Body.EntraGroup.value
                        'GroupName'    = $Request.Body.EntraGroup.label
                    }
                    Add-CIPPAzDataTableEntity @AccessRoleGroupTable -Entity $RoleGroup -Force | Out-Null
                    $Results.Add("Security group '$($Request.Body.EntraGroup.label)' assigned to the '$($Request.Body.RoleName)' role.")
                    Write-LogMessage -headers $Request.Headers -API 'ExecCustomRole' -message "Security group '$($Request.Body.EntraGroup.label)' assigned to the '$($Request.Body.RoleName)' role." -Sev 'Info'
                } else {
                    $AccessRoleGroup = Get-CIPPAzDataTableEntity @AccessRoleGroupTable -Filter "RowKey eq '$($Request.Body.RoleName)'"
                    if ($AccessRoleGroup) {
                        Remove-AzDataTableEntity -Force @AccessRoleGroupTable -Entity $AccessRoleGroup
                        $Results.Add("Security group '$($AccessRoleGroup.GroupName)' removed from the '$($Request.Body.RoleName)' role.")
                        Write-LogMessage -headers $Request.Headers -API 'ExecCustomRole' -message "Security group '$($AccessRoleGroup.GroupName)' removed from the '$($Request.Body.RoleName)' role." -Sev 'Info'
                    }
                }
                $Body = @{Results = $Results }
            } catch {
                Write-Warning "Failed to save custom role $($Request.Body.RoleName): $($_.Exception.Message)"
                Write-Warning $_.InvocationInfo.PositionMessage
                $Body = @{Results = "Failed to save custom role $($Request.Body.RoleName)" }
            }
        }
        'Clone' {
            try {
                if ($Request.Body.NewRoleName -in $DefaultRoles.PSObject.Properties.Name) {
                    throw "Role name $($Request.Body.NewRoleName) cannot be used"
                }
                $ExistingRole = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Request.Body.RoleName.ToLower())'"
                if (!$ExistingRole) {
                    throw "Role $($Request.Body.RoleName) not found"
                }

                if ($ExistingRole.RowKey -eq $Request.Body.NewRoleName.ToLower()) {
                    throw 'New role name cannot be the same as the existing role name'
                }

                $NewRoleTest = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Request.Body.NewRoleName.ToLower())'"
                if ($NewRoleTest) {
                    throw "Role name $($Request.Body.NewRoleName) already exists"
                }

                $NewRole = @{
                    'PartitionKey'     = 'CustomRoles'
                    'RowKey'           = "$($Request.Body.NewRoleName.ToLower())"
                    'Permissions'      = $ExistingRole.Permissions
                    'AllowedTenants'   = $ExistingRole.AllowedTenants
                    'BlockedTenants'   = $ExistingRole.BlockedTenants
                    'BlockedEndpoints' = $ExistingRole.BlockedEndpoints
                }
                Add-CIPPAzDataTableEntity @Table -Entity $NewRole -Force | Out-Null
                $Body = @{Results = "Custom role '$($Request.Body.NewRoleName)' cloned from '$($Request.Body.RoleName)'" }
                Write-LogMessage -headers $Request.Headers -API 'ExecCustomRole' -message "Cloned custom role $($Request.Body.RoleName) to $($Request.Body.NewRoleName)" -Sev 'Info'
            } catch {
                Write-Warning "Failed to clone custom role $($Request.Body.RoleName): $($_.Exception.Message)"
                Write-Warning $_.InvocationInfo.PositionMessage
                $Body = @{Results = "Failed to clone custom role $($Request.Body.RoleName)" }
            }
        }
        'Delete' {
            Write-Information "Deleting custom role $($Request.Body.RoleName)"
            $Role = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Request.Body.RoleName)'" -Property RowKey, PartitionKey
            Remove-AzDataTableEntity -Force @Table -Entity $Role
            $AccessRoleGroup = Get-CIPPAzDataTableEntity @AccessRoleGroupTable -Filter "PartitionKey eq 'AccessRoleGroups' and RowKey eq '$($Request.Body.RoleName)'"
            if ($AccessRoleGroup) {
                Remove-AzDataTableEntity -Force @AccessRoleGroupTable -Entity $AccessRoleGroup
            }
            $Body = @{Results = 'Custom role deleted' }
            Write-LogMessage -headers $Request.Headers -API 'ExecCustomRole' -message "Deleted custom role $($Request.Body.RoleName)" -Sev 'Info'
        }
        'ListEntraGroups' {
            $Groups = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups?$filter=securityEnabled eq true' -tenantid $env:TenantID -NoAuthCheck $true
            $Body = @{
                Results  = @($Groups)
                Metadata = @{
                    GroupCount = $Groups.Count
                }
            }
        }
        default {
            $Body = Get-CIPPAzDataTableEntity @Table
            $EntraRoleGroups = Get-CIPPAzDataTableEntity @AccessRoleGroupTable
            if (!$Body) {
                $Body = @(
                    @{
                        RowKey = 'No custom roles found'
                    }
                )
            } else {
                $CustomRoles = foreach ($Role in $Body) {
                    try {
                        $Role.Permissions = $Role.Permissions | ConvertFrom-Json
                    } catch {
                        $Role.Permissions = @()
                    }
                    if ($Role.AllowedTenants) {
                        try {
                            $Role.AllowedTenants = @($Role.AllowedTenants | ConvertFrom-Json)
                        } catch {
                            $Role.AllowedTenants = @()
                        }
                    } else {
                        $Role | Add-Member -NotePropertyName AllowedTenants -NotePropertyValue @() -Force
                    }
                    if ($Role.BlockedTenants) {
                        try {
                            $Role.BlockedTenants = @($Role.BlockedTenants | ConvertFrom-Json)
                        } catch {
                            $Role.BlockedTenants = @()
                        }
                    } else {
                        $Role | Add-Member -NotePropertyName BlockedTenants -NotePropertyValue @() -Force
                    }
                    if ($Role.BlockedEndpoints) {
                        try {
                            $Role.BlockedEndpoints = @($Role.BlockedEndpoints | ConvertFrom-Json)
                        } catch {
                            $Role.BlockedEndpoints = @()
                        }
                    } else {
                        $Role | Add-Member -NotePropertyName BlockedEndpoints -NotePropertyValue @() -Force
                    }
                    $EntraRoleGroup = $EntraRoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey
                    if ($EntraRoleGroup) {
                        $EntraGroup = $EntraRoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey | Select-Object @{Name = 'label'; Expression = { $_.GroupName } }, @{Name = 'value'; Expression = { $_.GroupId } }

                        $Role | Add-Member -NotePropertyName EntraGroup -NotePropertyValue $EntraGroup -Force
                    }
                    $Role
                }
                $DefaultRoles = foreach ($DefaultRole in $DefaultRoles.PSObject.Properties.Name) {
                    $Role = @{
                        RowKey           = $DefaultRole
                        Permissions      = $DefaultRoles.$DefaultRole
                        AllowedTenants   = @('AllTenants')
                        BlockedTenants   = @()
                        BlockedEndpoints = @()
                    }
                    $EntraRoleGroup = $EntraRoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey
                    if ($EntraRoleGroup) {
                        $Role.EntraGroup = $EntraRoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey | Select-Object @{Name = 'label'; Expression = { $_.GroupName } }, @{Name = 'value'; Expression = { $_.GroupId } }
                    }
                    $Role
                }
                $Body = @($DefaultRoles + $CustomRoles)
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecCustomRole.ps1' 204
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecDnsConfig.ps1' -1

Function Invoke-ExecDnsConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # List of supported resolvers
    $ValidResolvers = @(
        'Google'
        'Cloudflare'
        'Quad9'
    )



    $StatusCode = [HttpStatusCode]::OK
    try {
        $ConfigTable = Get-CippTable -tablename Config
        $Filter = "PartitionKey eq 'Domains' and RowKey eq 'Domains'"
        $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter $Filter

        $DomainTable = Get-CippTable -tablename 'Domains'

        if ($ValidResolvers -notcontains $Config.Resolver) {
            $Config = @{
                PartitionKey = 'Domains'
                RowKey       = 'Domains'
                Resolver     = 'Google'
            }
            Add-CIPPAzDataTableEntity @ConfigTable -Entity $Config -Force
        }

        $updated = $false

        switch ($Request.Query.Action) {
            'SetConfig' {
                if ($Request.Body.Resolver) {
                    $Resolver = $Request.Body.Resolver
                    if ($ValidResolvers -contains $Resolver) {
                        try {
                            $Config.Resolver = $Resolver
                        } catch {
                            $Config = @{
                                Resolver = $Resolver
                            }
                        }
                        $updated = $true
                    }
                }
                if ($updated) {
                    Add-CIPPAzDataTableEntity @ConfigTable -Entity $Config -Force
                    Write-LogMessage -API $APINAME -tenant 'Global' -headers $Request.Headers -message 'DNS configuration updated' -Sev 'Info'
                    $body = [pscustomobject]@{'Results' = 'Success: DNS configuration updated.' }
                } else {
                    $StatusCode = [HttpStatusCode]::BadRequest
                    $body = [pscustomobject]@{'Results' = 'Error: No DNS resolver provided.' }
                }
            }
            'SetDkimConfig' {
                $Domain = $Request.Query.Domain
                $Selector = ($Request.Query.Selector).trim() -split '\s*,\s*'
                $DomainTable = Get-CIPPTable -Table 'Domains'
                $Filter = "RowKey eq '{0}'" -f $Domain
                $DomainInfo = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter
                $DkimSelectors = [string]($Selector | ConvertTo-Json -Compress)
                if ($DomainInfo) {
                    $DomainInfo.DkimSelectors = $DkimSelectors
                } else {
                    $DomainInfo = @{
                        'RowKey'         = $Request.Query.Domain
                        'PartitionKey'   = 'ManualEntry'
                        'TenantId'       = 'NoTenant'
                        'MailProviders'  = ''
                        'TenantDetails'  = ''
                        'DomainAnalyser' = ''
                        'DkimSelectors'  = $DkimSelectors
                    }
                }
                Add-CIPPAzDataTableEntity @DomainTable -Entity $DomainInfo -Force
            }
            'GetConfig' {
                $body = [pscustomobject]$Config
                Write-LogMessage -API $APINAME -tenant 'Global' -headers $Request.Headers -message 'Retrieved DNS configuration' -Sev 'Debug'
            }
            'RemoveDomain' {
                $Filter = "RowKey eq '{0}'" -f $Request.Query.Domain
                $DomainRow = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter -Property PartitionKey, RowKey
                Remove-AzDataTableEntity -Force @DomainTable -Entity $DomainRow
                Write-LogMessage -API $APINAME -tenant 'Global' -headers $Request.Headers -message "Removed Domain - $($Request.Query.Domain) " -Sev 'Info'
                $body = [pscustomobject]@{ 'Results' = "Domain removed - $($Request.Query.Domain)" }
            }
        }
    } catch {
        Write-LogMessage -API $APINAME -tenant $($name) -headers $Request.Headers -message "DNS Config API failed. $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecDnsConfig.ps1' 110
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExchangeRoleRepair.ps1' -1

function Invoke-ExecExchangeRoleRepair {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Headers = $Request.Headers

    $TenantId = $Request.Query.tenantId ?? $Request.Body.tenantId
    $Tenant = Get-Tenants -TenantFilter $TenantId

    try {
        Write-Information "Starting Exchange Organization Management role repair for tenant: $($Tenant.defaultDomainName)"
        $OrgManagementRoles = New-ExoRequest -tenantid $Tenant.customerId -cmdlet 'Get-ManagementRoleAssignment' -cmdParams @{ Delegating = $false } | Where-Object { $_.RoleAssigneeName -eq 'Organization Management' } | Select-Object -Property Role, Guid
        Write-Information "Found $($OrgManagementRoles.Count) Organization Management roles in Exchange"

        $RoleDefinitions = New-GraphGetRequest -tenantid $Tenant.customerId -uri 'https://graph.microsoft.com/beta/roleManagement/exchange/roleDefinitions'
        Write-Information "Found $($RoleDefinitions.Count) Exchange role definitions"

        $BasePath = Get-Module -Name 'CIPPCore' | Select-Object -ExpandProperty ModuleBase
        $AllOrgManagementRoles = Get-Content -Path "$BasePath\lib\data\OrganizationManagementRoles.json" -ErrorAction Stop | ConvertFrom-Json

        $AvailableRoles = $RoleDefinitions | Where-Object -Property displayName -In $AllOrgManagementRoles | Select-Object -Property displayName, id, description
        Write-Information "Found $($AvailableRoles.Count) available Organization Management roles in Exchange"
        $MissingOrgMgmtRoles = $AvailableRoles | Where-Object { $OrgManagementRoles.Role -notcontains $_.displayName }

        if ($MissingOrgMgmtRoles.Count -gt 0) {
            $Requests = foreach ($Role in $MissingOrgMgmtRoles) {
                [PSCustomObject]@{
                    id      = $Role.id
                    method  = 'POST'
                    url     = 'roleManagement/exchange/roleAssignments'
                    body    = @{
                        principalId      = '/RoleGroups/Organization Management'
                        roleDefinitionId = $Role.id
                        directoryScopeId = '/'
                        appScopeId       = $null
                    }
                    headers = @{
                        'Content-Type' = 'application/json'
                    }
                }
            }

            $RepairResults = New-GraphBulkRequest -tenantid $Tenant.customerId -Requests @($Requests) -asapp $true
            $RepairSuccess = $RepairResults.status -eq 201
            if ($RepairSuccess) {
                $Results = @{
                    state      = 'success'
                    resultText = "Successfully repaired the missing Organization Management roles: $($MissingOrgMgmtRoles.displayName -join ', ')"
                }
                Write-LogMessage -API 'ExecExchangeRoleRepair' -headers $Headers -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -Message "Successfully repaired the missing Organization Management roles: $($MissingOrgMgmtRoles.displayName -join ', '). Run another Tenant Access check after waiting a bit for replication." -sev 'Info'
            } else {
                # Get roles that failed to repair
                $FailedRoles = $RepairResults | Where-Object { $_.status -ne 201 } | ForEach-Object {
                    $RoleId = $_.id
                    $Role = $MissingOrgMgmtRoles | Where-Object { $_.id -eq $RoleId }
                    $Role.displayName
                }
                $PermissionError = $false
                if ($RepairResults.status -in (401, 403, 500)) {
                    $PermissionError = $true
                }
                $LogData = $RepairResults | Select-Object -Property id, status, body
                $Results = @{
                    state      = 'error'
                    resultText = "Failed to repair the missing Organization Management roles: $($FailedRoles -join ', ').$(if ($PermissionError) { " This may be due to insufficient permissions. The required Graph Permission is 'Application - RoleManagement.ReadWrite.Exchange'" })"
                }
                Write-LogMessage -API 'ExecExchangeRoleRepair' -headers $Headers -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -Message "Failed to repair the missing Organization Management roles: $($FailedRoles -join ', ')" -sev 'Error' -LogData $LogData
                Write-Warning 'Exchange role repair failed'
            }
        } else {
            $Results = @{
                state      = 'success'
                resultText = 'No missing Organization Management roles found.'
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Warning "Exception during Exchange Organization Management role repair: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API 'ExecExchangeRoleRepair' -headers $Headers -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -Message "Exchange Organization Management role repair failed: $($ErrorMessage.NormalizedError)" -sev 'Error' -LogData $ErrorMessage
        $Results = @{
            state      = 'error'
            resultText = "Exchange Organization Management role repair failed: $($ErrorMessage.NormalizedError)"
        }
    }

    Push-OutputBinding -Name 'Response' -Value ([HttpResponseContext]@{
            StatusCode = [System.Net.HttpStatusCode]::OK
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExchangeRoleRepair.ps1' 97
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExcludeLicenses.ps1' -1

Function Invoke-ExecExcludeLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Table = Get-CIPPTable -TableName ExcludedLicenses
    try {

        if ($Request.Query.List) {
            $Rows = Get-CIPPAzDataTableEntity @Table
            if ($Rows.Count -lt 1) {
                $TableBaseData = '[{"GUID":"16ddbbfc-09ea-4de2-b1d7-312db6112d70","Product_Display_Name":"MICROSOFT TEAMS (FREE)"},{"GUID":"1f2f344a-700d-42c9-9427-5cea1d5d7ba6","Product_Display_Name":"MICROSOFT STREAM"},{"GUID":"338148b6-1b11-4102-afb9-f92b6cdc0f8d","Product_Display_Name":"DYNAMICS 365 P1 TRIAL FOR INFORMATION WORKERS"},{"GUID":"606b54a9-78d8-4298-ad8b-df6ef4481c80","Product_Display_Name":"Power Virtual Agents Viral Trial"},{"GUID":"61e6bd70-fbdb-4deb-82ea-912842f39431","Product_Display_Name":"Dynamics 365 Customer Service Insights Trial"},{"GUID":"6470687e-a428-4b7a-bef2-8a291ad947c9","Product_Display_Name":"WINDOWS STORE FOR BUSINESS"},{"GUID":"710779e8-3d4a-4c88-adb9-386c958d1fdf","Product_Display_Name":"MICROSOFT TEAMS EXPLORATORY"},{"GUID":"74fbf1bb-47c6-4796-9623-77dc7371723b","Product_Display_Name":"Microsoft Teams Trial"},{"GUID":"90d8b3f8-712e-4f7b-aa1e-62e7ae6cbe96","Product_Display_Name":"Business Apps (free)"},{"GUID":"a403ebcc-fae0-4ca2-8c8c-7a907fd6c235","Product_Display_Name":"Power BI (free)"},{"GUID":"bc946dac-7877-4271-b2f7-99d2db13cd2c","Product_Display_Name":"Dynamics 365 Customer Voice Trial"},{"GUID":"dcb1a3ae-b33f-4487-846a-a640262fadf4","Product_Display_Name":"Microsoft Power Apps Plan 2 Trial"},{"GUID":"f30db892-07e9-47e9-837c-80727f46fd3d","Product_Display_Name":"MICROSOFT FLOW FREE"},{"GUID":"fcecd1f9-a91e-488d-a918-a96cdb6ce2b0","Product_Display_Name":"Microsoft Dynamics AX7 User Trial"}]' | ConvertFrom-Json -AsHashtable -Depth 10
                $TableRows = foreach ($Row in $TableBaseData) {
                    $Row.PartitionKey = 'License'
                    $Row.RowKey = $Row.GUID

                    Add-CIPPAzDataTableEntity @Table -Entity ([pscustomobject]$Row) -Force | Out-Null
                }

                $Rows = Get-CIPPAzDataTableEntity @Table

                Write-LogMessage -API $APINAME -headers $Request.Headers -message 'got excluded licenses list' -Sev 'Info'
            }
            $body = @($Rows)
        }

        # Interact with query parameters or the body of the request.
        $name = $Request.Query.TenantFilter
        if ($Request.Query.AddExclusion) {
            $AddObject = @{
                PartitionKey           = 'License'
                RowKey                 = $Request.body.GUID
                'GUID'                 = $Request.body.GUID
                'Product_Display_Name' = $request.body.SKUName
            }
            Add-CIPPAzDataTableEntity @Table -Entity $AddObject -Force

            Write-LogMessage -API $APINAME -headers $Request.Headers -message "Added exclusion $($request.body.SKUName)" -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "Success. We've added $($request.body.SKUName) to the excluded list." }
        }

        if ($Request.Query.RemoveExclusion) {
            $Filter = "RowKey eq '{0}' and PartitionKey eq 'License'" -f $Request.Body.GUID
            $Entity = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
            Remove-AzDataTableEntity -Force @Table -Entity $Entity
            Write-LogMessage -API $APINAME -headers $Request.Headers -message "Removed exclusion $($Request.Query.GUID)" -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "Success. We've removed $($Request.query.guid) from the excluded list." }
        }
    } catch {
        Write-LogMessage -API $APINAME -headers $Request.Headers -message "Exclusion API failed. $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExcludeLicenses.ps1' 66
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExcludeTenant.ps1' -1

Function Invoke-ExecExcludeTenant {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # $username = $Request.Headers.'x-ms-client-principal-name'
    $Username = $Headers.'x-ms-client-principal-name' ?? ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails
    Write-Host ($Username | ConvertTo-Json -Depth 10)
    $Date = (Get-Date).ToString('yyyy-MM-dd')
    $TenantsTable = Get-CippTable -tablename Tenants

    if ($Request.Query.List) {
        $ExcludedFilter = "PartitionKey eq 'Tenants' and Excluded eq true"
        $ExcludedTenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter $ExcludedFilter
        Write-LogMessage -API $APIName -headers $Headers -message 'got excluded tenants list' -Sev 'Debug'
        $body = @($ExcludedTenants)
    } elseif ($Request.Query.ListAll) {
        $ExcludedTenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter "PartitionKey eq 'Tenants'" | Sort-Object -Property displayName
        Write-LogMessage -API $APIName -headers $Headers -message 'got excluded tenants list' -Sev 'Debug'
        $body = @($ExcludedTenants)
    }
    try {
        # Interact with query parameters or the body of the request.
        $Name = $Request.Query.tenantFilter
        if ($Request.Query.AddExclusion) {
            $Tenants = Get-Tenants -IncludeAll | Where-Object { $Request.body.value -contains $_.customerId }

            $Excluded = foreach ($Tenant in $Tenants) {
                $Tenant.Excluded = $true
                $Tenant.ExcludeUser = $Username
                $Tenant.ExcludeDate = $Date
                $Tenant
            }
            Update-AzDataTableEntity -Force @TenantsTable -Entity ([pscustomobject]$Excluded)
            Write-LogMessage -API $APIName -tenant $($Name) -headers $Headers -message "Added exclusion for customer(s): $($Excluded.defaultDomainName -join ',')" -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "Success. Added exclusions for customer(s): $($Excluded.defaultDomainName -join ',')" }
        }

        if ($Request.Query.RemoveExclusion) {
            $Tenants = Get-Tenants -IncludeAll | Where-Object { $Request.body.value -contains $_.customerId }
            foreach ($Tenant in $Tenants) {
                $Tenant.Excluded = $false
                $Tenant.ExcludeUser = ''
                $Tenant.ExcludeDate = ''
                Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant
            }
            Write-LogMessage -API $APIName -tenant $($Name) -headers $Headers -message "Removed exclusion for customer $($Name)" -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "Success. We've removed $Name from the excluded tenants." }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant $($Name) -headers $Headers -message "Exclusion API failed. $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed. $($ErrorMessage.NormalizedError)" }
    }
    if (!$body) { $body = @() }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecExcludeTenant.ps1' 72
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecMaintenanceScripts.ps1' -1

Function Invoke-ExecMaintenanceScripts {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {
        $GraphToken = Get-GraphToken -returnRefresh $true
        $AccessTokenDetails = Read-JwtAccessDetails -Token $GraphToken.access_token

        $ReplacementStrings = @{
            '##TENANTID##'      = $env:TenantID
            '##RESOURCEGROUP##' = $env:WEBSITE_RESOURCE_GROUP
            '##FUNCTIONAPP##'   = $env:WEBSITE_SITE_NAME
            '##SUBSCRIPTION##'  = (($env:WEBSITE_OWNER_NAME).split('+') | Select-Object -First 1)
            '##TOKENIP##'       = $AccessTokenDetails.IPAddress
        }
    } catch { Write-Host $_.Exception.Message }
    #$ReplacementStrings | Format-Table

    try {
        $ScriptFile = $Request.Query.ScriptFile

        try {
            $Filename = Split-Path -Leaf $ScriptFile
        } catch {}

        if (!$ScriptFile -or [string]::IsNullOrEmpty($ScriptFile)) {
            $ScriptFiles = Get-ChildItem .\ExecMaintenanceScripts\Scripts | Select-Object -ExpandProperty PSChildName

            $ScriptOptions = foreach ($ScriptFile in $ScriptFiles) {
                @{label = $ScriptFile; value = $ScriptFile }
            }
            $Body = @{ ScriptFiles = @($ScriptOptions) }
        } elseif (!(Get-ChildItem .\ExecMaintenanceScripts\Scripts\$Filename -ErrorAction SilentlyContinue)) {
            $Body = @{ Status = 'Script does not exist' }
        } else {
            $Script = Get-Content -Raw .\ExecMaintenanceScripts\Scripts\$Filename
            foreach ($i in $ReplacementStrings.Keys) {
                $Script = $Script -replace $i, $ReplacementStrings.$i
            }

            $ScriptContent = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($Script))

            if ($Request.Query.MakeLink) {
                $Table = Get-CippTable -TableName 'MaintenanceScripts'
                $LinkGuid = ([guid]::NewGuid()).ToString()

                $MaintenanceScriptRow = @{
                    'RowKey'        = $LinkGuid
                    'PartitionKey'  = 'Maintenance'
                    'ScriptContent' = $ScriptContent
                }
                Add-CIPPAzDataTableEntity @Table -Entity $MaintenanceScriptRow -Force

                $Body = @{ Link = "/api/PublicScripts?guid=$LinkGuid" }
            } else {
                $Body = @{ ScriptContent = $ScriptContent }
            }
        }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($tenantfilter) -message "Failed to retrieve maintenance scripts. Error: $($_.Exception.Message)" -Sev 'Error'
        $Body = @{Status = "Failed to retrieve maintenance scripts $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecMaintenanceScripts.ps1' 77
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecNotificationConfig.ps1' -1

Function Invoke-ExecNotificationConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $sev = ([pscustomobject]$Request.body.Severity).value -join (',')
    $config = @{
        email             = $Request.body.email
        webhook           = $Request.body.webhook
        onepertenant      = $Request.body.onePerTenant
        logsToInclude     = $Request.body.logsToInclude
        sendtoIntegration = $Request.body.sendtoIntegration
        sev               = $sev
    }
    $Results = Set-cippNotificationConfig @Config
    $body = [pscustomobject]@{'Results' = $Results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecNotificationConfig.ps1' 28
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecOffloadFunctions.ps1' -1


function Invoke-ExecOffloadFunctions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'Config'

    if ($Request.Query.Action -eq 'ListCurrent') {
        $CurrentState = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"
        $VersionTable = Get-CippTable -tablename 'Version'
        $Version = Get-CIPPAzDataTableEntity @VersionTable -Filter "RowKey ne 'Version'"
        $MainVersion = $Version | Where-Object { $_.RowKey -eq $env:WEBSITE_SITE_NAME }
        $OffloadVersions = $Version | Where-Object { $_.RowKey -match '-' }

        $Alerts = [System.Collections.Generic.List[string]]::new()

        $CanEnable = $false
        if (!$OffloadVersions.Version) {
            $Alerts.Add('No offloaded function apps have been registered. If you''ve just deployed one, this can take up to 15 minutes.')
        } else {
            $CanEnable = $true
        }

        foreach ($Offload in $OffloadVersions) {
            $FunctionName = $Offload.RowKey
            if ([semver]$Offload.Version -ne [semver]$MainVersion.Version) {
                $CanEnable = $false
                $Alerts.Add("The version of $FunctionName ($($Offload.Version)) does not match the current version of $($MainVersion.Version).")
            }
        }

        $VersionTable = $Version | Select-Object @{n = 'Name'; e = { $_.RowKey } }, @{n = 'Version'; e = { $_.Version } }, @{n = 'Default'; e = { $_.RowKey -notmatch '-' } }

        $CurrentState = if (!$CurrentState) {
            [PSCustomObject]@{
                OffloadFunctions = $false
                Version          = @($VersionTable)
                Alerts           = $Alerts
                CanEnable        = $CanEnable
            }
        } else {
            [PSCustomObject]@{
                OffloadFunctions = $CurrentState.state
                Version          = @($VersionTable)
                Alerts           = $Alerts
                CanEnable        = $CanEnable
            }
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $CurrentState
            })
    } else {
        Add-CIPPAzDataTableEntity @Table -Entity @{
            PartitionKey = 'OffloadFunctions'
            RowKey       = 'OffloadFunctions'
            state        = $request.Body.OffloadFunctions
        } -Force

        if ($Request.Body.OffloadFunctions) {
            $Results = 'Enabled Offload Functions'
        } else {
            $Results = 'Disabled Offload Functions'
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{ results = $Results }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecOffloadFunctions.ps1' 77
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPartnerMode.ps1' -1

function Invoke-ExecPartnerMode {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $Table = Get-CippTable -tablename 'tenantMode'
    if ($request.body.TenantMode) {
        Add-CIPPAzDataTableEntity @Table -Entity @{
            PartitionKey = 'Setting'
            RowKey       = 'PartnerModeSetting'
            state        = $request.body.TenantMode
        } -Force

        if ($Request.Body.TenantMode -eq 'default') {
            $Table = Get-CippTable -tablename 'Tenants'
            $Tenant = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Tenants' and RowKey eq '$($env:TenantID)'" -Property RowKey, PartitionKey, customerId, displayName
            if ($Tenant) {
                try {
                    Remove-AzDataTableEntity -Force @Table -Entity $Tenant
                } catch {
                }
            }
        } elseif ($Request.Body.TenantMode -eq 'PartnerTenantAvailable') {
            $InputObject = [PSCustomObject]@{
                Batch            = @(
                    @{
                        FunctionName = 'UpdateTenants'
                    }
                )
                OrchestratorName = 'UpdateTenants'
                SkipLog          = $true
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{
                    results = @(
                        @{
                            resultText = "Set Tenant mode to $($Request.body.TenantMode)"
                            state      = 'success'
                        }
                    )
                }
            })

    }

    if ($request.query.action -eq 'ListCurrent') {
        $CurrentState = Get-CIPPAzDataTableEntity @Table
        $CurrentState = if (!$CurrentState) {
            [PSCustomObject]@{
                TenantMode = 'default'
            }
        } else {
            [PSCustomObject]@{
                TenantMode = $CurrentState.state
            }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $CurrentState
            })
    }

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPartnerMode.ps1' 75
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPasswordConfig.ps1' -1

Function Invoke-ExecPasswordConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable -TableName Settings
    $PasswordType = (Get-CIPPAzDataTableEntity @Table)


    $results = try {
        if ($Request.Query.List) {
            @{ passwordType = $PasswordType.passwordType }
        } else {
            $PasswordConfig = @{
                'passwordType'  = "$($Request.Body.passwordType)"
                'passwordCount' = '12'
                'PartitionKey'  = 'settings'
                'RowKey'        = 'settings'
            }

            Add-CIPPAzDataTableEntity @Table -Entity $PasswordConfig -Force | Out-Null
            'Successfully set the configuration'
        }
    } catch {
        "Failed to set configuration: $($_.Exception.message)"
    }


    $body = [pscustomobject]@{'Results' = $Results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPasswordConfig.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPermissionRepair.ps1' -1

function Invoke-ExecPermissionRepair {
    <#
    .SYNOPSIS
        This endpoint will update the CIPP-SAM app permissions.
    .DESCRIPTION
        Merges new permissions from the SAM manifest into the AppPermissions entry for CIPP-SAM.
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    try {
        $Table = Get-CippTable -tablename 'AppPermissions'
        $User = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Request.Headers.'x-ms-client-principal')) | ConvertFrom-Json

        $CurrentPermissions = Get-CippSamPermissions
        if (($CurrentPermissions.MissingPermissions | Measure-Object).Count -gt 0) {
            Write-Information 'Missing permissions found'
            $MissingPermissions = $CurrentPermissions.MissingPermissions
            $Permissions = $CurrentPermissions.Permissions

            $AppIds = @($Permissions.PSObject.Properties.Name + $MissingPermissions.PSObject.Properties.Name)

            $NewPermissions = @{}
            foreach ($AppId in $AppIds) {
                if (!$AppId) { continue }
                $ApplicationPermissions = [system.collections.generic.list[object]]::new()
                $DelegatedPermissions = [system.collections.generic.list[object]]::new()

                # App permissions
                foreach ($Permission in $Permissions.$AppId.applicationPermissions) {
                    $ApplicationPermissions.Add($Permission)
                }
                if (($MissingPermissions.$AppId.applicationPermissions | Measure-Object).Count -gt 0) {
                    foreach ($MissingPermission in $MissingPermissions.$AppId.applicationPermissions) {
                        Write-Host "Adding missing permission: $MissingPermission"
                        $ApplicationPermissions.Add($MissingPermission)
                    }
                }

                # Delegated permissions
                foreach ($Permission in $Permissions.$AppId.delegatedPermissions) {
                    $DelegatedPermissions.Add($Permission)
                }
                if (($MissingPermissions.$AppId.delegatedPermissions | Measure-Object).Count -gt 0) {
                    foreach ($MissingPermission in $MissingPermissions.$AppId.delegatedPermissions) {
                        Write-Host "Adding missing permission: $MissingPermission"
                        $DelegatedPermissions.Add($MissingPermission)
                    }
                }
                # New permission object
                $NewPermissions.$AppId = @{
                    applicationPermissions = @($ApplicationPermissions | Sort-Object -Property label)
                    delegatedPermissions   = @($DelegatedPermissions | Sort-Object -Property label)
                }
            }


            $Entity = @{
                'PartitionKey' = 'CIPP-SAM'
                'RowKey'       = 'CIPP-SAM'
                'Permissions'  = [string]([PSCustomObject]$NewPermissions | ConvertTo-Json -Depth 10 -Compress)
                'UpdatedBy'    = $User.UserDetails ?? 'CIPP-API'
            }
            $Table = Get-CIPPTable -TableName 'AppPermissions'
            $null = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

            $Body = @{
                'Results' = 'Permissions Updated'
            }
            Write-LogMessage -headers $Request.Headers -API 'ExecPermissionRepair' -message 'CIPP-SAM Permissions Updated' -Sev 'Info' -LogData $Permissions
        } else {
            $Body = @{
                'Results' = 'No permissions to update'
            }
        }
    } catch {
        $Body = @{
            'Results' = "$($_.Exception.Message) - at line $($_.InvocationInfo.ScriptLineNumber)"
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecPermissionRepair.ps1' 91
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRemoveTenant.ps1' -1

function Invoke-ExecRemoveTenant {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    if ($Request.Body.TenantID -notmatch '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {
        $Body = @{Results = "Tenant ID $($Request.Body.TenantID) is not a valid GUID." }
        $StatusCode = [HttpStatusCode]::BadRequest
    } else {
        $Table = Get-CippTable -tablename 'Tenants'
        $Tenant = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Tenants' and RowKey eq '$($Request.Body.TenantID)'" -Property RowKey, PartitionKey, customerId, displayName
        if ($Tenant) {
            try {
                Remove-AzDataTableEntity -Force @Table -Entity $Tenant
                $Body = @{Results = "$($Tenant.displayName) ($($Tenant.customerId)) deleted from CIPP. Note: This does not remove the GDAP relationship, see the Tenant Offboarding wizard to perform that action." }
                $StatusCode = [HttpStatusCode]::OK
            } catch {
                $Body = @{Results = "Failed to delete $($Tenant.displayName) ($($Tenant.customerId)) from CIPP. Error: $($_.Exception.Message)" }
                $StatusCode = [HttpStatusCode]::InternalServerError
            }
        } else {
            $Body = @{Results = "Tenant $($Request.Body.TenantID) not found in CIPP." }
            $StatusCode = [HttpStatusCode]::NotFound
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRemoveTenant.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRestoreBackup.ps1' -1

function Invoke-ExecRestoreBackup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {

        if ($Request.Body.BackupName -like 'CippBackup_*') {
            $Table = Get-CippTable -tablename 'CIPPBackup'
            $Backup = Get-CippAzDataTableEntity @Table -Filter "RowKey eq '$($Request.Body.BackupName)' or OriginalEntityId eq '$($Request.Body.BackupName)'"
            if ($Backup) {
                $BackupData = $Backup.Backup | ConvertFrom-Json -ErrorAction SilentlyContinue | Select-Object * -ExcludeProperty ETag, Timestamp
                $BackupData | ForEach-Object {
                    $Table = Get-CippTable -tablename $_.table
                    $ht2 = @{ }
                    $_.psobject.properties | ForEach-Object { $ht2[$_.Name] = [string]$_.Value }
                    $Table.Entity = $ht2
                    Add-CIPPAzDataTableEntity @Table -Force
                }
                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Restored backup $($Request.Body.BackupName)" -Sev 'Info'
                $body = [pscustomobject]@{
                    'Results' = 'Successfully restored backup.'
                }
            } else {
                $body = [pscustomobject]@{
                    'Results' = 'Backup not found.'
                }
            }
        } else {
            foreach ($line in ($Request.body | Select-Object * -ExcludeProperty ETag, Timestamp)) {
                $Table = Get-CippTable -tablename $line.table
                $ht2 = @{}
                $line.psobject.properties | ForEach-Object { $ht2[$_.Name] = [string]$_.Value }
                $Table.Entity = $ht2
                Add-AzDataTableEntity @Table -Force
            }
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Restored backup $($Request.Body.BackupName)" -Sev 'Info'

            $body = [pscustomobject]@{
                'Results' = 'Successfully restored backup.'
            }
        }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Failed to restore backup: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Backup restore failed: $($_.Exception.Message)" }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRestoreBackup.ps1' 61
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRunBackup.ps1' -1

Function Invoke-ExecRunBackup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint

    try {
        $CSVfile = New-CIPPBackup -BackupType 'CIPP' -Headers $Request.Headers
        $body = [pscustomobject]@{
            'Results' = @{
                resultText = 'Created backup'
                state      = 'success'
            }
            backup    = $CSVfile.BackupData
        } | ConvertTo-Json -Depth 5 -Compress

        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Created CIPP backup' -Sev 'Info'

    } catch {
        $body = [pscustomobject]@{
            'Results' = @(
                @{
                    resultText = 'Failed to create backup'
                    state      = 'error'
                }
            )
        } | ConvertTo-Json -Depth 5 -Compress
        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Failed to create CIPP backup' -Sev 'Error' -LogData (Get-CippException -Exception $_)
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRunBackup.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRunTenantGroupRule.ps1' -1

function Invoke-ExecRunTenantGroupRule {
    <#
    .SYNOPSIS
        Execute tenant group dynamic rules immediately
    .DESCRIPTION
        This function executes dynamic tenant group rules for immediate membership updates
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Groups.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $GroupId = $Request.Body.groupId ?? $Request.Query.groupId

    try {
        $GroupTable = Get-CippTable -tablename 'TenantGroups'
        $Group = Get-CIPPAzDataTableEntity @GroupTable -Filter "PartitionKey eq 'TenantGroup' and RowKey eq '$GroupId'"

        if (-not $Group) { $Body = @{ Results = 'Group not found' } }

        $null = Start-TenantDynamicGroupOrchestrator -GroupId $GroupId

        $Body = @{ Results = "Dynamic rules executed successfully for group '$($Group.Name)'. Processing will continue in the background. Check the logbook for details." }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Body
            })
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'TenantGroups' -message "Failed to execute tenant group rules: $ErrorMessage" -sev Error
        $Body = @{ Results = "Failed to execute dynamic rules: $ErrorMessage" }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $Body
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecRunTenantGroupRule.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecSAMAppPermissions.ps1' -1

function Invoke-ExecSAMAppPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $User = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Request.Headers.'x-ms-client-principal')) | ConvertFrom-Json

    switch ($Request.Query.Action) {
        'Update' {
            try {
                $Permissions = $Request.Body.Permissions
                $Entity = @{
                    'PartitionKey' = 'CIPP-SAM'
                    'RowKey'       = 'CIPP-SAM'
                    'Permissions'  = [string]($Permissions | ConvertTo-Json -Depth 10 -Compress)
                    'UpdatedBy'    = $User.UserDetails ?? 'CIPP-API'
                }
                $Table = Get-CIPPTable -TableName 'AppPermissions'
                $null = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
                $Body = @{
                    'Results' = 'Permissions Updated'
                }
                Write-LogMessage -headers $Request.Headers -API 'ExecSAMAppPermissions' -message 'CIPP-SAM Permissions Updated' -Sev 'Info' -LogData $Permissions
            } catch {
                $Body = @{
                    'Results' = $_.Exception.Message
                }
            }
        }
        default {
            $Body = Get-CippSamPermissions
        }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -Depth 10 -InputObject $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecSAMAppPermissions.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecSAMRoles.ps1' -1

function Invoke-ExecSAMRoles {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.SuperAdmin.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $SAMRolesTable = Get-CIPPTable -tablename 'SAMRoles'
    switch ($Request.Query.Action) {
        'Update' {
            $Entity = [pscustomobject]@{
                PartitionKey = 'SAMRoles'
                RowKey       = 'SAMRoles'
                Roles        = [string](ConvertTo-Json -Depth 5 -Compress -InputObject $Request.Body.Roles)
                Tenants      = [string](ConvertTo-Json -Depth 5 -Compress -InputObject $Request.Body.Tenants)
            }
            $null = Add-CIPPAzDataTableEntity @SAMRolesTable -Entity $Entity -Force
            $Body = [pscustomobject]@{'Results' = 'Successfully updated SAM roles' }
        }
        default {
            $SAMRoles = Get-CIPPAzDataTableEntity @SAMRolesTable
            $Roles = @($SAMRoles.Roles | ConvertFrom-Json)
            $Tenants = @($SAMRoles.Tenants | ConvertFrom-Json)
            $Body = @{
                'Roles'    = $Roles
                'Tenants'  = $Tenants
                'Metadata' = @{
                    'RoleCount'   = ($Roles | Measure-Object).Count
                    'TenantCount' = ($Tenants | Measure-Object).Count
                }
            } | ConvertTo-Json -Depth 5
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecSAMRoles.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecTenantGroup.ps1' -1

function Invoke-ExecTenantGroup {
    <#
    .SYNOPSIS
        Entrypoint for tenant group management
    .DESCRIPTION
        This function is used to manage tenant groups in CIPP
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Groups.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'TenantGroups'
    $MembersTable = Get-CippTable -tablename 'TenantGroupMembers'
    $Action = $Request.Body.Action
    $groupId = $Request.Body.groupId ?? [guid]::NewGuid().ToString()
    $groupName = $Request.Body.groupName
    $groupDescription = $Request.Body.groupDescription
    $members = $Request.Body.members
    $groupType = $Request.Body.groupType ?? 'static'
    $dynamicRules = $Request.Body.dynamicRules
    $ruleLogic = $Request.Body.ruleLogic ?? 'and'

    $AllowedGroups = Test-CippAccess -Request $Request -GroupList
    if ($AllowedGroups -notcontains 'AllGroups') {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::Forbidden
                Body       = @{ Results = 'You do not have permission to manage tenant groups.' }
            })
    }

    switch ($Action) {
        'AddEdit' {
            $Results = [System.Collections.Generic.List[object]]::new()
            # Update group details
            $GroupEntity = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'TenantGroup' and RowKey eq '$groupId'"
            if ($GroupEntity) {
                if ($groupName) {
                    $GroupEntity.Name = $groupName
                }
                if ($groupDescription) {
                    $GroupEntity.Description = $groupDescription
                }
                $GroupEntity | Add-Member -NotePropertyName 'GroupType' -NotePropertyValue $groupType -Force
                if ($groupType -eq 'dynamic' -and $dynamicRules) {
                    $GroupEntity.DynamicRules = "$($dynamicRules | ConvertTo-Json -Depth 100 -Compress)"
                    $GroupEntity | Add-Member -NotePropertyName 'RuleLogic' -NotePropertyValue $ruleLogic -Force
                } else {
                    $GroupEntity | Add-Member -NotePropertyName 'RuleLogic' -NotePropertyValue $null -Force
                }
                Add-CIPPAzDataTableEntity @Table -Entity $GroupEntity -Force
            } else {
                $GroupEntity = @{
                    PartitionKey = 'TenantGroup'
                    RowKey       = $groupId
                    Name         = $groupName
                    Description  = $groupDescription
                    GroupType    = $groupType
                }
                if ($groupType -eq 'dynamic' -and $dynamicRules) {
                    $GroupEntity.DynamicRules = "$($dynamicRules | ConvertTo-Json -Depth 100 -Compress)"
                    $GroupEntity.RuleLogic = $ruleLogic
                }
                Add-CIPPAzDataTableEntity @Table -Entity $GroupEntity -Force
            }

            # Handle members based on group type
            $Adds = [System.Collections.Generic.List[string]]::new()
            $Removes = [System.Collections.Generic.List[string]]::new()

            if ($groupType -eq 'static') {
                # Static group - manage members manually
                $CurrentMembers = Get-CIPPAzDataTableEntity @MembersTable -Filter "PartitionKey eq 'Member' and GroupId eq '$groupId'"

                # Add members
                foreach ($member in $members) {
                    if ($CurrentMembers) {
                        $CurrentMember = $CurrentMembers | Where-Object { $_.customerId -eq $member.value }
                        if ($CurrentMember) {
                            continue
                        }
                    }
                    $MemberEntity = @{
                        PartitionKey = 'Member'
                        RowKey       = '{0}-{1}' -f $groupId, $member.value
                        GroupId      = $groupId
                        customerId   = $member.value
                    }
                    Add-CIPPAzDataTableEntity @MembersTable -Entity $MemberEntity -Force
                    $Adds.Add('Added member {0}' -f $member.label)
                }

                if ($CurrentMembers) {
                    foreach ($CurrentMember in $CurrentMembers) {
                        if ($members.value -notcontains $CurrentMember.customerId) {
                            Remove-AzDataTableEntity @MembersTable -Entity $CurrentMember -Force
                            $Removes.Add('Removed member {0}' -f $CurrentMember.customerId)
                        }
                    }
                }
            } elseif ($groupType -eq 'dynamic') {
                $Adds.Add('Dynamic group updated. Rules will be processed on next scheduled run.')
            }
            $Results.Add(@{
                    resultText = "Group '$groupName' saved successfully"
                    state      = 'success'
                })
            foreach ($Add in $Adds) {
                $Results.Add(@{
                        resultText = $Add
                        state      = 'success'
                    })
            }
            foreach ($Remove in $Removes) {
                $Results.Add(@{
                        resultText = $Remove
                        state      = 'success'
                    })
            }

            $Body = @{ Results = $Results }
        }
        'Delete' {
            # Delete group
            $GroupEntity = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'TenantGroup' and RowKey eq '$groupId'"
            if ($GroupEntity) {
                Remove-AzDataTableEntity @Table -Entity $GroupEntity -Force
                $Body = @{ Results = "Group '$($GroupEntity.Name)' deleted successfully" }
            } else {
                $Body = @{ Results = "Group '$groupId' not found" }
            }
        }
        default {
            $Body = @{ Results = 'Invalid action' }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecTenantGroup.ps1' 145
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecWebhookSubscriptions.ps1' -1

function Invoke-ExecWebhookSubscriptions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CIPPTable -TableName webhookTable
    switch ($Request.Query.Action) {
        'Delete' {
            $Webhook = Get-AzDataTableEntity @Table -Filter "RowKey eq '$($Request.Query.WebhookID)'" -Property PartitionKey, RowKey
            if ($Webhook) {
                Remove-CIPPGraphSubscription -TenantFilter $Webhook.PartitionKey -CIPPID $Webhook.RowKey
                Remove-AzDataTableEntity -Force @Table -Entity $Webhook
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = @{ Results = "Deleted subscription $($Webhook.RowKey) for $($Webhook.PartitionKey)" }
                    })
            } else {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = @{ Results = "Subscription $($Request.Query.WebhookID) not found" }
                    })
            }
        }
        'Unsubscribe' {
            $Webhook = Get-AzDataTableEntity @Table -Filter "RowKey eq '$($Request.Query.WebhookID)'" -Property PartitionKey, RowKey
            if ($Webhook) {
                $Unsubscribe = @{
                    TenantFilter = $Webhook.PartitionKey
                }
                if ($EventType -match 'Audit.(Exchange|AzureActiveDirectory)') {
                    $Unsubscribe.Type = 'AuditLog'
                    $Unsubscribe.EventType = $Webhook.Resource
                } else {
                    $Unsubscribe.Type = 'Graph'
                    $Unsubscribe.CIPPID = $Webhook.RowKey
                    $Unsubscribe.EventType = $Webhook.EventType
                }
                if ($Webhook.Resource -match 'PartnerCenter') {
                    return ([HttpResponseContext]@{
                            StatusCode = [HttpStatusCode]::BadRequest
                            Body       = 'PartnerCenter subscriptions cannot be unsubscribed'
                        })
                    return
                }
                Remove-CIPPGraphSubscription @Unsubscribe
                Remove-AzDataTableEntity -Force @Table -Entity $Webhook
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = @{ Results = "Unsubscribed from $($Webhook.Resource) for $($Webhook.PartitionKey)" }
                    })
            } else {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = @{ Results = "Subscription $($Request.Query.WebhookID) not found" }
                    })
            }
        }
        'UnsubscribeAll' {
            $TenantList = Get-Tenants -IncludeErrors
            $Results = foreach ($tenant in $TenantList) {
                $TenantFilter = $tenant.defaultDomainName
                $Subscriptions = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscriptions' -tenantid $TenantFilter | Where-Object { $_.notificationUrl -like '*PublicWebhooks*' }
                "Unsubscribing from all CIPP subscriptions for $TenantFilter - $($Subscriptions.Count) subscriptions found"
                $Subscriptions | ForEach-Object {
                    New-GraphPostRequest -uri "https://graph.microsoft.com/beta/subscriptions/$($_.id)" -tenantid $TenantFilter -type DELETE -body {} -Verbose
                    # get row from table if exists and remove
                    $Webhook = Get-AzDataTableEntity @Table -Filter "WebhookNotificationUrl eq 'https://graph.microsoft.com/beta/subscriptions/$($_.id)'" -Property PartitionKey, RowKey, ETag
                    if ($Webhook) {
                        $null = Remove-AzDataTableEntity -Force @Table -Entity $Webhook
                    }
                }
            }
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @{ Results = $Results }
                })
        }
        'Resubscribe' {
            Write-Host "Resubscribing to $($Request.Query.WebhookID)"
            $Row = Get-AzDataTableEntity @Table -Filter "RowKey eq '$($Request.Query.WebhookID)'"
            if ($Row) {
                $NewSubParams = @{
                    TenantFilter = $Row.PartitionKey
                    EventType    = $Row.EventType
                }
                if ($Row.Resource -match 'Audit.(Exchange|AzureActiveDirectory)') {
                    $NewSubParams.auditLogAPI = $true
                    $NewSubParams.Recreate = $true
                    $NewSubParams.EventType = $Row.Resource
                } elseif ($Row.Resource -match 'PartnerCenter') {
                    $NewSubParams.PartnerCenter = $true
                }
                try {
                    $NewSub = New-CIPPGraphSubscription @NewSubParams
                    Write-Host ($NewSub | ConvertTo-Json -Depth 5 -Compress)
                } catch {
                    Write-Host $_.Exception.Message
                }
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = @{ Results = $NewSub.message }
                    })
            }
        }
        default {
            $Table = Get-CIPPTable -TableName webhookTable
            $Subscriptions = Get-AzDataTableEntity @Table
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = $Subscriptions
                })
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ExecWebhookSubscriptions.ps1' 120
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListCustomRole.ps1' -1

function Invoke-ListCustomRole {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $DefaultRoles = @('readonly', 'editor', 'admin', 'superadmin')
    $Table = Get-CippTable -tablename 'CustomRoles'
    $CustomRoles = Get-CIPPAzDataTableEntity @Table

    $AccessRoleGroupTable = Get-CippTable -tablename 'AccessRoleGroups'
    $RoleGroups = Get-CIPPAzDataTableEntity @AccessRoleGroupTable

    $TenantList = Get-Tenants -IncludeErrors

    $RoleList = [System.Collections.Generic.List[pscustomobject]]::new()
    foreach ($Role in $DefaultRoles) {
        $RoleGroup = $RoleGroups | Where-Object -Property RowKey -EQ $Role

        $RoleList.Add([pscustomobject]@{
                RoleName       = $Role
                Type           = 'Built-In'
                Permissions    = ''
                AllowedTenants = @('AllTenants')
                BlockedTenants = @()
                EntraGroup     = $RoleGroup.GroupName ?? $null
                EntraGroupId   = $RoleGroup.GroupId ?? $null
            })
    }
    foreach ($Role in $CustomRoles) {
        $Role | Add-Member -NotePropertyName RoleName -NotePropertyValue $Role.RowKey -Force
        $Role | Add-Member -NotePropertyName Type -NotePropertyValue 'Custom' -Force

        if ($Role.Permissions) {
            try {
                $Role.Permissions = $Role.Permissions | ConvertFrom-Json
            } catch {
                $Role.Permissions = ''
            }
        }
        if ($Role.AllowedTenants) {
            try {
                $AllowedTenants = $Role.AllowedTenants | ConvertFrom-Json -ErrorAction Stop | ForEach-Object {
                    if ($_ -is [PSCustomObject] -and $_.type -eq 'Group') {
                        # Return group objects as-is for frontend display
                        [PSCustomObject]@{
                            type  = 'Group'
                            value = $_.value
                            label = $_.label
                        }
                    } else {
                        # Convert tenant customer ID to domain name object for frontend
                        $TenantId = $_
                        $TenantInfo = $TenantList | Where-Object { $_.customerId -eq $TenantId }
                        if ($TenantInfo) {
                            [PSCustomObject]@{
                                type        = 'Tenant'
                                value       = $TenantInfo.defaultDomainName
                                label       = "$($TenantInfo.displayName) ($($TenantInfo.defaultDomainName))"
                                addedFields = @{
                                    defaultDomainName = $TenantInfo.defaultDomainName
                                    displayName       = $TenantInfo.displayName
                                    customerId        = $TenantInfo.customerId
                                }
                            }
                        }
                    }
                } | Where-Object { $_ -ne $null }
                $AllowedTenants = $AllowedTenants ?? @('AllTenants')
                $Role.AllowedTenants = @($AllowedTenants)
            } catch {
                $Role.AllowedTenants = @('AllTenants')
            }
        } else {
            $Role | Add-Member -NotePropertyName AllowedTenants -NotePropertyValue @() -Force
        }
        if ($Role.BlockedTenants) {
            try {
                $BlockedTenants = $Role.BlockedTenants | ConvertFrom-Json -ErrorAction Stop | ForEach-Object {
                    if ($_ -is [PSCustomObject] -and $_.type -eq 'Group') {
                        # Return group objects as-is for frontend display
                        [PSCustomObject]@{
                            type  = 'Group'
                            value = $_.value
                            label = $_.label
                        }
                    } else {
                        # Convert tenant customer ID to domain name object for frontend
                        $TenantId = $_
                        $TenantInfo = $TenantList | Where-Object { $_.customerId -eq $TenantId }
                        if ($TenantInfo) {
                            [PSCustomObject]@{
                                type        = 'Tenant'
                                value       = $TenantInfo.defaultDomainName
                                label       = "$($TenantInfo.displayName) ($($TenantInfo.defaultDomainName))"
                                addedFields = @{
                                    defaultDomainName = $TenantInfo.defaultDomainName
                                    displayName       = $TenantInfo.displayName
                                    customerId        = $TenantInfo.customerId
                                }
                            }
                        }
                    }
                } | Where-Object { $_ -ne $null }
                $BlockedTenants = $BlockedTenants ?? @()
                $Role.BlockedTenants = @($BlockedTenants)
            } catch {
                $Role.BlockedTenants = @()
            }
        } else {
            $Role | Add-Member -NotePropertyName BlockedTenants -NotePropertyValue @() -Force
        }

        $RoleGroup = $RoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey
        if ($RoleGroup) {
            $EntraGroup = $RoleGroups | Where-Object -Property RowKey -EQ $Role.RowKey | Select-Object GroupName, GroupId
            $Role | Add-Member -NotePropertyName EntraGroup -NotePropertyValue $EntraGroup.GroupName -Force
            $Role | Add-Member -NotePropertyName EntraGroupId -NotePropertyValue $EntraGroup.GroupId -Force
        }
        $RoleList.Add($Role)
    }
    $Body = @($RoleList)

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -InputObject $Body -Depth 5
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListCustomRole.ps1' 132
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListCustomVariables.ps1' -1

function Invoke-ListCustomVariables {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint

    $HttpResponse = [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @{}
    }

    try {
        # Define reserved variables (matching Get-CIPPTextReplacement)
        $ReservedVariables = @(
            @{
                Name        = 'tenantid'
                Variable    = '%tenantid%'
                Description = 'The tenant customer ID'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'organizationid'
                Variable    = '%organizationid%'
                Description = 'The tenant customer ID'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'tenantfilter'
                Variable    = '%tenantfilter%'
                Description = 'The tenant default domain name'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'tenantname'
                Variable    = '%tenantname%'
                Description = 'The tenant display name'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'defaultdomain'
                Variable    = '%defaultdomain%'
                Description = 'The tenant default domain name'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'initialdomain'
                Variable    = '%initialdomain%'
                Description = 'The tenant initial domain name'
                Type        = 'reserved'
                Category    = 'tenant'
            },
            @{
                Name        = 'partnertenantid'
                Variable    = '%partnertenantid%'
                Description = 'The partner tenant ID'
                Type        = 'reserved'
                Category    = 'partner'
            },
            @{
                Name        = 'samappid'
                Variable    = '%samappid%'
                Description = 'The SAM application ID'
                Type        = 'reserved'
                Category    = 'partner'
            },
            @{
                Name        = 'cippuserschema'
                Variable    = '%cippuserschema%'
                Description = 'The CIPP user schema extension ID'
                Type        = 'reserved'
                Category    = 'cipp'
            },
            @{
                Name        = 'cippurl'
                Variable    = '%cippurl%'
                Description = 'The CIPP instance URL'
                Type        = 'reserved'
                Category    = 'cipp'
            },
            @{
                Name        = 'serial'
                Variable    = '%serial%'
                Description = 'System serial number'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'systemroot'
                Variable    = '%systemroot%'
                Description = 'System root directory'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'systemdrive'
                Variable    = '%systemdrive%'
                Description = 'System drive letter'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'temp'
                Variable    = '%temp%'
                Description = 'Temporary directory path'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'userprofile'
                Variable    = '%userprofile%'
                Description = 'User profile directory'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'username'
                Variable    = '%username%'
                Description = 'Current username'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'userdomain'
                Variable    = '%userdomain%'
                Description = 'User domain'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'windir'
                Variable    = '%windir%'
                Description = 'Windows directory'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'programfiles'
                Variable    = '%programfiles%'
                Description = 'Program Files directory'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'programfiles(x86)'
                Variable    = '%programfiles(x86)%'
                Description = 'Program Files (x86) directory'
                Type        = 'reserved'
                Category    = 'system'
            },
            @{
                Name        = 'programdata'
                Variable    = '%programdata%'
                Description = 'Program Data directory'
                Type        = 'reserved'
                Category    = 'system'
            }
        )

        # Use a hashtable to track variables by name to handle overrides
        $VariableMap = @{}

        if ($Request.Query.includeSystem -and $Request.Query.includeSystem -ne 'true') {
            $ReservedVariables = $ReservedVariables | Where-Object { $_.Category -ne 'system' }
        }

        # Filter out global reserved variables if requested (for tenant group rules)
        # These variables are the same for all tenants so they're not useful for grouping
        if ($Request.Query.excludeGlobalReserved -eq 'true') {
            $ReservedVariables = $ReservedVariables | Where-Object {
                $_.Category -notin @('partner', 'cipp', 'system')
            }
        }

        # Add reserved variables first
        foreach ($Variable in $ReservedVariables) {
            $VariableMap[$Variable.Name] = $Variable
        }

        # Get custom variables from the replace map table
        $ReplaceTable = Get-CIPPTable -tablename 'CippReplacemap'

        # Get global variables (AllTenants) - these can be overridden by tenant-specific ones
        $GlobalVariables = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq 'AllTenants'"
        if ($GlobalVariables) {
            foreach ($Variable in $GlobalVariables) {
                if ($Variable.RowKey -and $Variable.Value) {
                    $VariableMap[$Variable.RowKey] = @{
                        Name        = $Variable.RowKey
                        Variable    = "%$($Variable.RowKey)%"
                        Description = 'Global custom variable'
                        Value       = $Variable.Value
                        Type        = 'custom'
                        Category    = 'global'
                        Scope       = 'AllTenants'
                    }
                }
            }
        }

        # Get tenant-specific variables if tenantFilter is provided
        # These override any global variables with the same name
        $TenantFilter = $Request.Query.tenantFilter
        if ($TenantFilter -and $TenantFilter -ne 'AllTenants') {
            # Try to get tenant to find customerId
            try {
                $Tenant = Get-Tenants -TenantFilter $TenantFilter
                $CustomerId = $Tenant.customerId

                # Get variables by customerId
                $TenantVariables = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$CustomerId'"

                # If no results found by customerId, try by defaultDomainName
                if (-not $TenantVariables) {
                    $TenantVariables = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$($Tenant.defaultDomainName)'"
                }

                if ($TenantVariables) {
                    foreach ($Variable in $TenantVariables) {
                        if ($Variable.RowKey -and $Variable.Value) {
                            # Tenant variables override global ones with the same name
                            $VariableMap[$Variable.RowKey] = @{
                                Name        = $Variable.RowKey
                                Variable    = "%$($Variable.RowKey)%"
                                Description = 'Tenant-specific custom variable'
                                Value       = $Variable.Value
                                Type        = 'custom'
                                Category    = 'tenant-custom'
                                Scope       = $TenantFilter
                            }
                        }
                    }
                }
            } catch {
                Write-LogMessage -API $APIName -message "Could not retrieve tenant-specific variables for $TenantFilter : $($_.Exception.Message)" -Sev 'Warning'
            }
        }

        # Convert hashtable values to array and sort
        $AllVariables = $VariableMap.Values
        $SortedVariables = $AllVariables | Sort-Object @{
            Expression = {
                switch ($_.Type) {
                    'reserved' { 1 }
                    'custom' {
                        switch ($_.Category) {
                            'global' { 2 }
                            'tenant-custom' { 3 }
                            default { 4 }
                        }
                    }
                    default { 5 }
                }
            }
        }, Name

        $HttpResponse.Body = @{
            Results  = @($SortedVariables)
            Metadata = @{
                TenantFilter  = $TenantFilter
                TotalCount    = $SortedVariables.Count
                ReservedCount = @($SortedVariables | Where-Object { $_.Type -eq 'reserved' }).Count
                CustomCount   = @($SortedVariables | Where-Object { $_.Type -eq 'custom' }).Count
            }
        }

    } catch {
        $HttpResponse.StatusCode = [HttpStatusCode]::InternalServerError
        $HttpResponse.Body = @{
            Results = @()
            Error   = $_.Exception.Message
        }
        Write-LogMessage -API $APIName -message "Failed to retrieve custom variables: $($_.Exception.Message)" -Sev 'Error'
    }

    return $HttpResponse
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListCustomVariables.ps1' 288
#Region './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListTenantGroups.ps1' -1

function Invoke-ListTenantGroups {
    <#
    .SYNOPSIS
        Entrypoint for listing tenant groups
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $groupFilter = $Request.Query.groupId ?? $Request.Body.groupId
    $TenantGroups = (Get-TenantGroups -GroupId $groupFilter) ?? @()
    $Body = @{ Results = @($TenantGroups) }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Settings/Invoke-ListTenantGroups.ps1' 22
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecAddTenant.ps1' -1

function Invoke-ExecAddTenant {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    try {
        # Get the tenant ID from the request body
        $tenantId = $Request.body.tenantId
        $defaultDomainName = $Request.body.defaultDomainName

        # Get the Tenants table
        $TenantsTable = Get-CippTable -tablename 'Tenants'
        #force a refresh of the authentication info
        $auth = Get-CIPPAuthentication
        # Check if tenant already exists
        $ExistingTenant = Get-CIPPAzDataTableEntity @TenantsTable -Filter "PartitionKey eq 'Tenants' and RowKey eq '$tenantId'"

        if ($tenantId -eq $env:TenantID) {
            # If the tenant is the partner tenant, return an error because you cannot add the partner tenant as direct tenant
            $Results = @{'message' = 'You cannot add the partner tenant as a direct tenant. Please connect the tenant using the "Connect to Partner Tenant" option. '; 'severity' = 'error'; }
        } elseif ($ExistingTenant) {
            # Update existing tenant
            $ExistingTenant.delegatedPrivilegeStatus = 'directTenant'
            Add-CIPPAzDataTableEntity @TenantsTable -Entity $ExistingTenant -Force | Out-Null
            $Results = @{'message' = 'Successfully updated tenant.'; 'severity' = 'success' }
        } else {
            # Create new tenant entry
            try {
                # Get tenant information from Microsoft Graph
                $headers = @{ Authorization = "Bearer $($request.body.accessToken)" }
                $Organization = (Invoke-RestMethod -Uri 'https://graph.microsoft.com/v1.0/organization' -Headers $headers -Method GET -ContentType 'application/json' -ErrorAction Stop).value
                $displayName = $Organization.displayName
                $Domains = (Invoke-RestMethod -Uri 'https://graph.microsoft.com/v1.0/domains?$top=999' -Headers $headers -Method GET -ContentType 'application/json' -ErrorAction Stop).value
                $defaultDomainName = ($Domains | Where-Object { $_.isDefault -eq $true }).id
                $initialDomainName = ($Domains | Where-Object { $_.isInitial -eq $true }).id
            } catch {
                Write-LogMessage -API 'Add-Tenant' -message "Failed to get information for tenant $tenantId - $($_.Exception.Message)" -Sev 'Critical'
                throw "Failed to get information for tenant $tenantId. Make sure the tenant is properly authenticated."
            }

            # Create new tenant object
            $NewTenant = [PSCustomObject]@{
                PartitionKey             = 'Tenants'
                RowKey                   = $tenantId
                customerId               = $tenantId
                displayName              = $displayName
                defaultDomainName        = $defaultDomainName
                initialDomainName        = $initialDomainName
                delegatedPrivilegeStatus = 'directTenant'
                domains                  = ''
                Excluded                 = $false
                ExcludeUser              = ''
                ExcludeDate              = ''
                GraphErrorCount          = 0
                LastGraphError           = ''
                RequiresRefresh          = $false
                LastRefresh              = (Get-Date).ToUniversalTime()
            }

            # Add tenant to table
            Add-CIPPAzDataTableEntity @TenantsTable -Entity $NewTenant -Force | Out-Null
            $Results = @{'message' = "Successfully added tenant $displayName ($defaultDomainName) to the tenant list with Direct Tenant status."; 'severity' = 'success' }
            Write-LogMessage -tenant $defaultDomainName -tenantid $tenantId -API 'Add-Tenant' -message "Added tenant $displayName ($defaultDomainName) with Direct Tenant status." -Sev 'Info'
        }
    } catch {
        $Results = @{'message' = "Failed to add tenant: $($_.Exception.Message)"; 'state' = 'error'; 'severity' = 'error' }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecAddTenant.ps1' 79
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecCombinedSetup.ps1' -1

function Invoke-ExecCombinedSetup {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '')]
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    #Make arraylist of Results
    $Results = [System.Collections.ArrayList]::new()
    try {
        # Set up Azure context if needed for Key Vault access
        if (($env:AzureWebJobsStorage -ne 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -ne 'true') -and $env:MSI_SECRET) {
            Disable-AzContextAutosave -Scope Process | Out-Null
            $null = Connect-AzAccount -Identity
            $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
            $null = Set-AzContext -SubscriptionId $SubscriptionId
        }
        if ($request.body.selectedBaselines -and $request.body.baselineOption -eq 'downloadBaselines') {
            #do a single download of the selected baselines.
            foreach ($template in $request.body.selectedBaselines) {
                $object = @{
                    TenantFilter  = 'No tenant'
                    Name          = "Download Single Baseline: $($template.value)"
                    Command       = @{
                        value = 'New-CIPPTemplateRun'
                    }
                    Parameters    = @{
                        TemplateSettings = @{
                            ca                 = $false
                            intuneconfig       = $false
                            intunecompliance   = $false
                            intuneprotection   = $false
                            templateRepo       = @{
                                label       = $Template.label
                                value       = $template.value
                                addedFields = @{
                                    branch = 'main'
                                }
                            }
                            templateRepoBranch = @{
                                label = 'main'
                                value = 'main'
                            }
                            standardsconfig    = $true
                            groupTemplates     = $true
                            policyTemplates    = $true
                            caTemplates        = $true
                        }
                    }
                    ScheduledTime = 0
                }
                $null = Add-CIPPScheduledTask -task $object -hidden $false -DisallowDuplicateName $true -Headers $Request.Headers
                $Results.add("Scheduled download of baseline: $($template.value)")
            }
        }
        if ($Request.body.email -or $Request.body.webhook) {
            #create hashtable from pscustomobject
            $notificationConfig = $request.body | Select-Object email, webhook, onepertenant, logsToInclude, sendtoIntegration, sev | ConvertTo-Json | ConvertFrom-Json -AsHashtable
            $notificationResults = Set-CIPPNotificationConfig @notificationConfig
            $Results.add($notificationResults)
        }
        if ($Request.Body.selectedOption -eq 'Manual') {
            $KV = $env:WEBSITE_DEPLOYMENT_ID

            if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
                $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
                if (!$Secret) {
                    $Secret = [PSCustomObject]@{
                        'PartitionKey'      = 'Secret'
                        'RowKey'            = 'Secret'
                        'TenantId'          = ''
                        'RefreshToken'      = ''
                        'ApplicationId'     = ''
                        'ApplicationSecret' = ''
                    }
                    Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
                }

                if ($Request.Body.tenantId) { $Secret.TenantId = $Request.Body.tenantid }
                if ($Request.Body.applicationId) { $Secret.ApplicationId = $Request.Body.applicationId }
                if ($Request.Body.ApplicationSecret) { $Secret.ApplicationSecret = $Request.Body.ApplicationSecret }
                if ($Request.Body.RefreshToken) { $Secret.RefreshToken = $Request.Body.RefreshToken }
                Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
                $Results.add('Manual credentials have been set in the DevSecrets table.')
            } else {
                if ($Request.Body.tenantId) {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'tenantid' -SecretValue (ConvertTo-SecureString -String $Request.Body.tenantId -AsPlainText -Force)
                    $Results.add('Set tenant ID in Key Vault.')
                }
                if ($Request.Body.applicationId) {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationid' -SecretValue (ConvertTo-SecureString -String $Request.Body.applicationId -AsPlainText -Force)
                    $Results.add('Set application ID in Key Vault.')
                }
                if ($Request.Body.applicationSecret) {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationsecret' -SecretValue (ConvertTo-SecureString -String $Request.Body.applicationSecret -AsPlainText -Force)
                    $Results.add('Set application secret in Key Vault.')
                }
                if ($Request.Body.RefreshToken) {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'refreshtoken' -SecretValue (ConvertTo-SecureString -String $Request.Body.RefreshToken -AsPlainText -Force)
                    $Results.add('Set refresh token in Key Vault.')
                }
            }

            $Results.add('Manual credentials setup has been completed.')
        }

        $Results.add('Setup is now complete. You may navigate away from this page and start using CIPP.')
        #one more force of reauth so env vars update.
        $auth = Get-CIPPAuthentication
    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.InvocationInfo.ScriptLineNumber):  $($_.Exception.message)"; severity = 'failed' }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecCombinedSetup.ps1' 124
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecCreateSAMApp.ps1' -1

function Invoke-ExecCreateSAMApp {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '')]
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $KV = $env:WEBSITE_DEPLOYMENT_ID

    try {
        $Token = $Request.body
        if ($Token) {
            $URL = ($Request.headers.'x-ms-original-url').split('/api') | Select-Object -First 1
            $TenantId = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/organization' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method GET -ContentType 'application/json').value.id
            #Find Existing app registration
            $AppId = (Invoke-RestMethod "https://graph.microsoft.com/v1.0/applications?`$filter=displayName eq 'CIPP-SAM'" -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method GET -ContentType 'application/json').value | Select-Object -Last 1
            #Check if the appId has the redirect URI, if not, add it.
            if ($AppId) {
                Write-Host "Found existing app: $($AppId.id). Reusing."
                $state = 'updated'
                #remove the entire web object from the app registration
                $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
                $SamManifestFile = Get-Item (Join-Path $ModuleBase 'lib\data\SAMManifest.json')
                $app = Get-Content $SamManifestFile.FullName | ConvertFrom-Json
                $app.web.redirectUris = @("$($url)/authredirect")
                $app = ConvertTo-Json -Depth 15 -Compress -InputObject $app
                Invoke-RestMethod "https://graph.microsoft.com/v1.0/applications/$($AppId.id)" -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method PATCH -Body $app -ContentType 'application/json'
            } else {
                $state = 'created'
                $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
                $SamManifestFile = Get-Item (Join-Path $ModuleBase 'lib\data\SAMManifest.json')
                $app = Get-Content $SamManifestFile.FullName | ConvertFrom-Json
                $app.web.redirectUris = @("$($url)/authredirect")
                $app = $app | ConvertTo-Json -Depth 15
                $AppId = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/applications' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body $app -ContentType 'application/json')
                $attempt = 0
                do {
                    try {
                        try {
                            $SPNDefender = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"fc780465-2017-40d4-a0c5-307022471b92`" }" -ContentType 'application/json')
                        } catch {
                            Write-Information "didn't deploy spn for defender, probably already there."
                        }
                        try {
                            $SPNTeams = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"48ac35b8-9aa8-4d74-927d-1f4a14a0b239`" }" -ContentType 'application/json')
                        } catch {
                            Write-Information "didn't deploy spn for Teams, probably already there."
                        }
                        try {
                            $SPNO365Manage = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"c5393580-f805-4401-95e8-94b7a6ef2fc2`" }" -ContentType 'application/json')
                        } catch {
                            Write-Information "didn't deploy spn for O365 Management, probably already there."
                        }
                        try {
                            $SPNPartnerCenter = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"fa3d9a0c-3fb0-42cc-9193-47c7ecd2edbd`" }" -ContentType 'application/json')
                        } catch {
                            Write-Information "didn't deploy spn for PartnerCenter, probably already there."
                        }
                        $SPN = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"$($AppId.appId)`" }" -ContentType 'application/json')
                        Start-Sleep 2
                        $attempt ++
                    } catch {
                        $attempt ++
                    }
                } until ($attempt -gt 3)
            }
            $AppPassword = (Invoke-RestMethod "https://graph.microsoft.com/v1.0/applications/$($AppId.id)/addPassword" -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body '{"passwordCredential":{"displayName":"CIPPInstall"}}' -ContentType 'application/json').secretText

            if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
                $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
                if (!$Secret) { $Secret = New-Object -TypeName PSObject }
                $Secret | Add-Member -MemberType NoteProperty -Name 'PartitionKey' -Value 'Secret' -Force
                $Secret | Add-Member -MemberType NoteProperty -Name 'RowKey' -Value 'Secret' -Force
                $Secret | Add-Member -MemberType NoteProperty -Name 'tenantid' -Value $TenantId -Force
                $Secret | Add-Member -MemberType NoteProperty -Name 'applicationid' -Value $AppId.appId -Force
                $Secret | Add-Member -MemberType NoteProperty -Name 'applicationsecret' -Value $AppPassword -Force
                Write-Information ($Secret | ConvertTo-Json -Depth 5)
                Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
            } else {

                Set-AzKeyVaultSecret -VaultName $kv -Name 'tenantid' -SecretValue (ConvertTo-SecureString -String $TenantId -AsPlainText -Force)
                Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationid' -SecretValue (ConvertTo-SecureString -String $Appid.appId -AsPlainText -Force)
                Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationsecret' -SecretValue (ConvertTo-SecureString -String $AppPassword -AsPlainText -Force)
            }
            $ConfigTable = Get-CippTable -tablename 'Config'
            #update the ConfigTable with the latest appId, for caching compare.
            $NewConfig = @{
                PartitionKey  = 'AppCache'
                RowKey        = 'AppCache'
                ApplicationId = $AppId.appId
            }
            Add-CIPPAzDataTableEntity @ConfigTable -Entity $NewConfig -Force | Out-Null
            $Results = @{'message' = "Succesfully $state the application registration. The application ID is $($AppId.appid). You may continue to the next step."; severity = 'success' }
        }

    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.InvocationInfo.ScriptLineNumber):  $($_.Exception.message)"; severity = 'failed' }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecCreateSAMApp.ps1' 111
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecDeviceCodeLogon.ps1' -1

function Invoke-ExecDeviceCodeLogon {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        $clientId = $Request.Query.clientId
        $scope = $Request.Query.scope
        $tenantId = $Request.Query.tenantId
        $deviceCode = $Request.Query.deviceCode

        if (!$scope) {
            $scope = 'https://graph.microsoft.com/.default'
        }
        if ($Request.Query.operation -eq 'getDeviceCode') {
            $deviceCodeInfo = New-DeviceLogin -clientid $clientId -scope $scope -FirstLogon -TenantId $tenantId
            $Results = @{
                user_code        = $deviceCodeInfo.user_code
                device_code      = $deviceCodeInfo.device_code
                verification_uri = $deviceCodeInfo.verification_uri
                expires_in       = $deviceCodeInfo.expires_in
                interval         = $deviceCodeInfo.interval
                message          = $deviceCodeInfo.message
            }
        } elseif ($Request.Query.operation -eq 'checkToken') {
            $tokenInfo = New-DeviceLogin -clientid $clientId -scope $scope -device_code $deviceCode

            if ($tokenInfo.refresh_token) {
                $Results = @{
                    status         = 'success'
                    access_token   = $tokenInfo.access_token
                    refresh_token  = $tokenInfo.refresh_token
                    id_token       = $tokenInfo.id_token
                    expires_in     = $tokenInfo.expires_in
                    ext_expires_in = $tokenInfo.ext_expires_in
                }
            } else {
                $Results = @{
                    status            = 'pending'
                    error             = $tokenInfo.error
                    error_description = $tokenInfo.error_description
                }
            }
        }
    } catch {
        $Results = @{
            error             = 'server_error'
            error_description = "An error occurred: $($_.Exception.Message)"
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results | ConvertTo-Json
            Headers    = @{'Content-Type' = 'application/json' }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecDeviceCodeLogon.ps1' 62
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecSAMSetup.ps1' -1

function Invoke-ExecSAMSetup {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    .LEGACY
        This function is a legacy function that was used to set up the CIPP application in Azure AD. It is not used in the current version of CIPP, look at Invoke-ExecCreateSAMApp for the new version.
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '')]
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    if ($Request.Query.error) {
        Add-Type -AssemblyName System.Web
        return ([HttpResponseContext]@{
                ContentType = 'text/html'
                StatusCode  = [HttpStatusCode]::Forbidden
                Body        = Get-normalizedError -Message [System.Web.HttpUtility]::UrlDecode($Request.Query.error_description)
            })
        exit
    }
    if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
        $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
        $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
        if (!$Secret) {
            $Secret = [PSCustomObject]@{
                'PartitionKey'      = 'Secret'
                'RowKey'            = 'Secret'
                'TenantId'          = ''
                'RefreshToken'      = ''
                'ApplicationId'     = ''
                'ApplicationSecret' = ''
            }
            Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
        }
    } else {
        if ($env:MSI_SECRET) {
            Disable-AzContextAutosave -Scope Process | Out-Null
            $null = Connect-AzAccount -Identity
            $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
            $null = Set-AzContext -SubscriptionId $SubscriptionId
        }
    }
    if (!$env:SetFromProfile) {
        Write-Information "We're reloading from KV"
        Get-CIPPAuthentication
    }

    $KV = $env:WEBSITE_DEPLOYMENT_ID
    $Table = Get-CIPPTable -TableName SAMWizard
    $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-10)

    try {
        if ($Request.Query.count -lt 1 ) { $Results = 'No authentication code found. Please go back to the wizard.' }

        if ($Request.Body.setkeys) {
            if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                if ($Request.Body.TenantId) { $Secret.TenantId = $Request.Body.tenantid }
                if ($Request.Body.RefreshToken) { $Secret.RefreshToken = $Request.Body.RefreshToken }
                if ($Request.Body.applicationid) { $Secret.ApplicationId = $Request.Body.ApplicationId }
                if ($Request.Body.ApplicationSecret) { $Secret.ApplicationSecret = $Request.Body.ApplicationSecret }
                Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
            } else {
                if ($Request.Body.tenantid) { Set-AzKeyVaultSecret -VaultName $kv -Name 'tenantid' -SecretValue (ConvertTo-SecureString -String $Request.Body.tenantid -AsPlainText -Force) }
                if ($Request.Body.RefreshToken) { Set-AzKeyVaultSecret -VaultName $kv -Name 'RefreshToken' -SecretValue (ConvertTo-SecureString -String $Request.Body.RefreshToken -AsPlainText -Force) }
                if ($Request.Body.applicationid) { Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationid' -SecretValue (ConvertTo-SecureString -String $Request.Body.applicationid -AsPlainText -Force) }
                if ($Request.Body.applicationsecret) { Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationsecret' -SecretValue (ConvertTo-SecureString -String $Request.Body.applicationsecret -AsPlainText -Force) }
            }

            $Results = @{ Results = 'The keys have been replaced. Please perform a permissions check.' }
        }
        if ($Request.Query.error -eq 'invalid_client') { $Results = 'Client ID was not found in Azure. Try waiting 10 seconds to try again, if you have gotten this error after 5 minutes, please restart the process.' }
        if ($Request.Query.code) {
            try {
                $TenantId = $Rows.tenantid
                if (!$TenantId -or $TenantId -eq 'NotStarted') { $TenantId = $env:TenantID }
                $AppID = $Rows.appid
                if (!$AppID -or $AppID -eq 'NotStarted') { $appid = $env:ApplicationID }
                $URL = ($Request.headers.'x-ms-original-url').split('?') | Select-Object -First 1
                if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                    $clientsecret = $Secret.ApplicationSecret
                } else {
                    $clientsecret = Get-AzKeyVaultSecret -VaultName $kv -Name 'ApplicationSecret' -AsPlainText
                }
                if (!$clientsecret) { $clientsecret = $env:ApplicationSecret }
                Write-Information "client_id=$appid&scope=https://graph.microsoft.com/.default+offline_access+openid+profile&code=$($Request.Query.code)&grant_type=authorization_code&redirect_uri=$($url)&client_secret=$clientsecret" #-Uri "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token"
                $RefreshToken = Invoke-RestMethod -Method POST -Body "client_id=$appid&scope=https://graph.microsoft.com/.default+offline_access+openid+profile&code=$($Request.Query.code)&grant_type=authorization_code&redirect_uri=$($url)&client_secret=$clientsecret" -Uri "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token" -ContentType 'application/x-www-form-urlencoded'

                if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                    $Secret.RefreshToken = $RefreshToken.refresh_token
                    Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
                } else {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'RefreshToken' -SecretValue (ConvertTo-SecureString -String $RefreshToken.refresh_token -AsPlainText -Force)
                }

                $Results = 'Authentication is now complete. You may now close this window.'
                try {
                    $SetupPhase = $rows.validated = $true
                    Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
                } catch {
                    #no need.
                }
            } catch {
                $Results = "Authentication failed. $($_.Exception.message)"
            }
        }
        if ($Request.Query.CreateSAM) {
            $Rows = @{
                RowKey       = 'setup'
                PartitionKey = 'setup'
                validated    = $false
                SamSetup     = 'NotStarted'
                partnersetup = $true
                appid        = 'NotStarted'
                tenantid     = 'NotStarted'
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
            $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-10)
            $step = 1
            $DeviceLogon = New-DeviceLogin -clientid '1b730954-1685-4b74-9bfd-dac224a7b894' -Scope 'https://graph.microsoft.com/.default' -FirstLogon
            $SetupPhase = $rows.SamSetup = [string]($DeviceLogon | ConvertTo-Json)
            Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
            $Results = @{ code = $($DeviceLogon.user_code); message = "Your code is $($DeviceLogon.user_code). Enter the code"  ; step = $step; url = $DeviceLogon.verification_uri }
        }
        if ($Request.Query.CheckSetupProcess -and $Request.Query.step -eq 1) {
            $SAMSetup = $Rows.SamSetup | ConvertFrom-Json -ErrorAction SilentlyContinue
            if ($SamSetup.token_type -eq 'Bearer') {
                #sleeping for 10 seconds to allow the token to be created.
                Start-Sleep 10
                #nulling the token to force a recheck.
                $step = 2
            }
            $Token = (New-DeviceLogin -clientid '1b730954-1685-4b74-9bfd-dac224a7b894' -Scope 'https://graph.microsoft.com/.default' -device_code $SAMSetup.device_code)
            Write-Information "Token is $($token | ConvertTo-Json)"
            if ($Token.access_token) {
                $step = 2
                $rows.SamSetup = [string]($Token | ConvertTo-Json)
                $URL = ($Request.headers.'x-ms-original-url').split('?') | Select-Object -First 1
                $PartnerSetup = $true
                $TenantId = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/organization' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method GET -ContentType 'application/json').value.id
                $SetupPhase = $rows.tenantid = [string]($TenantId)
                Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
                if ($PartnerSetup) {
                    #$app = Get-Content '.\Cache_SAMSetup\SAMManifest.json' | ConvertFrom-Json
                    $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
                    $SamManifestFile = Get-Item (Join-Path $ModuleBase 'lib\data\SAMManifest.json')
                    $app = Get-Content $SamManifestFile.FullName | ConvertFrom-Json

                    $App.web.redirectUris = @($App.web.redirectUris + $URL)
                    $app = $app | ConvertTo-Json -Depth 15
                    $AppId = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/applications' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body $app -ContentType 'application/json')
                    $rows.appid = [string]($AppId.appId)
                    Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
                    $attempt = 0
                    do {
                        try {
                            try {
                                $SPNDefender = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"fc780465-2017-40d4-a0c5-307022471b92`" }" -ContentType 'application/json')
                            } catch {
                                Write-Information "didn't deploy spn for defender, probably already there."
                            }
                            try {
                                $SPNTeams = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"48ac35b8-9aa8-4d74-927d-1f4a14a0b239`" }" -ContentType 'application/json')
                            } catch {
                                Write-Information "didn't deploy spn for Teams, probably already there."
                            }
                            try {
                                $SPNO365Manage = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"c5393580-f805-4401-95e8-94b7a6ef2fc2`" }" -ContentType 'application/json')
                            } catch {
                                Write-Information "didn't deploy spn for O365 Management, probably already there."
                            }
                            try {
                                $SPNPartnerCenter = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"fa3d9a0c-3fb0-42cc-9193-47c7ecd2edbd`" }" -ContentType 'application/json')
                            } catch {
                                Write-Information "didn't deploy spn for PartnerCenter, probably already there."
                            }
                            $SPN = (Invoke-RestMethod 'https://graph.microsoft.com/v1.0/servicePrincipals' -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body "{ `"appId`": `"$($AppId.appId)`" }" -ContentType 'application/json')
                            Start-Sleep 3
                            $attempt ++
                        } catch {
                            $attempt ++
                        }
                    } until ($attempt -gt 5)
                }
                $AppPassword = (Invoke-RestMethod "https://graph.microsoft.com/v1.0/applications/$($AppId.id)/addPassword" -Headers @{ authorization = "Bearer $($Token.access_token)" } -Method POST -Body '{"passwordCredential":{"displayName":"CIPPInstall"}}' -ContentType 'application/json').secretText
                if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                    $Secret.TenantId = $TenantId
                    $Secret.ApplicationId = $AppId.appId
                    $Secret.ApplicationSecret = $AppPassword
                    Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
                    Write-Information ($Secret | ConvertTo-Json -Depth 5)
                } else {
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'tenantid' -SecretValue (ConvertTo-SecureString -String $TenantId -AsPlainText -Force)
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationid' -SecretValue (ConvertTo-SecureString -String $Appid.appId -AsPlainText -Force)
                    Set-AzKeyVaultSecret -VaultName $kv -Name 'applicationsecret' -SecretValue (ConvertTo-SecureString -String $AppPassword -AsPlainText -Force)
                }
                $Results = @{'message' = 'Created application. Waiting 30 seconds for Azure propagation'; step = $step }
            } else {
                $step = 1
                $Results = @{ code = $($SAMSetup.user_code); message = "Your code is $($SAMSetup.user_code). Enter the code "  ; step = $step; url = $SAMSetup.verification_uri }
            }

        }
        switch ($Request.Query.step) {
            2 {
                $step = 2
                $TenantId = $Rows.tenantid
                $AppID = $rows.appid
                $PartnerSetup = $true
                $SetupPhase = $rows.SamSetup = [string]($FirstLogonRefreshtoken | ConvertTo-Json)
                Add-CIPPAzDataTableEntity @Table -Entity $Rows -Force | Out-Null
                $URL = ($Request.headers.'x-ms-original-url').split('?') | Select-Object -First 1
                $Validated = $Rows.validated
                if ($Validated) { $step = 3 }
                $Results = @{ appId = $AppID; message = 'Give the next approval by clicking ' ; step = $step; url = "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/authorize?scope=https://graph.microsoft.com/.default+offline_access+openid+profile&response_type=code&client_id=$($appid)&redirect_uri=$($url)" }
            }
            3 {
                $step = 4
                $Results = @{'message' = 'Received token.'; step = $step }
            }
            4 {
                Remove-AzDataTableEntity -Force @Table -Entity $Rows
                $step = 5
                $Results = @{'message' = 'setup completed.'; step = $step
                }
            }
        }

    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.InvocationInfo.ScriptLineNumber):  $($_.Exception.message)" ; step = $step }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecSAMSetup.ps1' 241
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecTokenExchange.ps1' -1

Function Invoke-ExecTokenExchange {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    # Get the key vault name
    $KV = $env:WEBSITE_DEPLOYMENT_ID
    $APIName = $Request.Params.CIPPEndpoint

    try {
        if (!$Request.Body) {
            Write-LogMessage -API $APIName -message 'Request body is missing' -Sev 'Error'
            throw 'Request body is missing'
        }

        $TokenRequest = $Request.Body.tokenRequest
        $TokenUrl = $Request.Body.tokenUrl
        $TenantId = $Request.Body.tenantId

        if (!$TokenRequest -or !$TokenUrl) {
            Write-LogMessage -API $APIName -message 'Missing required parameters: tokenRequest or tokenUrl' -Sev 'Error'
            throw 'Missing required parameters: tokenRequest or tokenUrl'
        }

        Write-LogMessage -API $APIName -message "Making token request to $TokenUrl" -Sev 'Info'

        # Make sure we get the latest authentication
        $auth = Get-CIPPAuthentication

        if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
            $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
            $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
            $ClientSecret = $Secret.applicationsecret
            Write-LogMessage -API $APIName -message 'Retrieved client secret from development secrets' -Sev 'Info'
        } else {
            try {
                $ClientSecret = (Get-AzKeyVaultSecret -VaultName $kv -Name 'applicationsecret' -AsPlainText)
                Write-LogMessage -API $APIName -message 'Retrieved client secret from key vault' -Sev 'Info'
            } catch {
                Write-LogMessage -API $APIName -message "Failed to retrieve client secret: $($_.Exception.Message)" -Sev 'Error'
                throw "Failed to retrieve client secret: $($_.Exception.Message)"
            }
        }

        if (!$ClientSecret) {
            Write-LogMessage -API $APIName -message 'Client secret is empty or null' -Sev 'Error'
            throw 'Client secret is empty or null'
        }

        # Convert token request to form data and add client secret
        $FormData = @{}
        foreach ($key in $TokenRequest.PSObject.Properties.Name) {
            $FormData[$key] = $TokenRequest.$key
        }

        # Add client_secret to the form data if not already present
        if (!$FormData.ContainsKey('client_secret')) {
            $FormData['client_secret'] = $ClientSecret
        }

        Write-Host "Posting this data: $($FormData | ConvertTo-Json -Depth 15)"
        $Results = Invoke-RestMethod -Uri $TokenUrl -Method Post -Body $FormData -ContentType 'application/x-www-form-urlencoded' -ErrorAction Stop -SkipHttpErrorCheck
    } catch {
        $ErrorMessage = $_.Exception
        $Results = @{
            error             = 'server_error'
            error_description = "Token exchange failed: $ErrorMessage"
        }
    }
    if ($Results.error) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = $Results
                Headers    = @{'Content-Type' = 'application/json' }
            })
    } else {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Results
                Headers    = @{'Content-Type' = 'application/json' }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecTokenExchange.ps1' 89
#Region './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecUpdateRefreshToken.ps1' -1

function Invoke-ExecUpdateRefreshToken {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.AppSettings.ReadWrite
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '')]
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $KV = $env:WEBSITE_DEPLOYMENT_ID

    try {
        # Handle refresh token update
        #make sure we get the latest authentication:
        $auth = Get-CIPPAuthentication
        if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
            $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
            $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"

            if ($env:TenantID -eq $Request.body.tenantId) {
                $Secret | Add-Member -MemberType NoteProperty -Name 'RefreshToken' -Value $Request.body.refreshtoken -Force
            } else {
                Write-Host "$($env:TenantID) does not match $($Request.body.tenantId)"
                $name = $Request.body.tenantId -replace '-', '_'
                $secret | Add-Member -MemberType NoteProperty -Name $name -Value $Request.body.refreshtoken -Force
            }
            Add-CIPPAzDataTableEntity @DevSecretsTable -Entity $Secret -Force
        } else {
            if ($env:TenantID -eq $Request.body.tenantId) {
                Set-AzKeyVaultSecret -VaultName $kv -Name 'RefreshToken' -SecretValue (ConvertTo-SecureString -String $Request.body.refreshtoken -AsPlainText -Force)
            } else {
                Write-Host "$($env:TenantID) does not match $($Request.body.tenantId) - we're adding a new secret for the tenant."
                $name = $Request.body.tenantId
                try {
                    Set-AzKeyVaultSecret -VaultName $kv -Name $name -SecretValue (ConvertTo-SecureString -String $Request.body.refreshtoken -AsPlainText -Force)
                } catch {
                    Write-Host "Failed to set secret $name in KeyVault. $($_.Exception.Message)"
                    throw $_
                }
            }
        }
        $InstanceId = Start-UpdatePermissionsOrchestrator #start the CPV refresh immediately while wizard still runs.

        if ($request.body.tenantId -eq $env:TenantID) {
            $TenantName = 'your partner tenant'
        } else {
            $TenantName = $request.body.tenantId
        }
        $Results = @{
            'resultText' = "Successfully updated the credentials for $($TenantName). You may continue to the next step, or add additional tenants if required."
            'state'      = 'success'
        }
    } catch {
        $Results = [pscustomobject]@{
            'Results' = @{
                resultText = "Failed. $($_.InvocationInfo.ScriptLineNumber): $($_.Exception.message)"
                state      = 'failed'
            }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Results
            })

    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/CIPP/Setup/Invoke-ExecUpdateRefreshToken.ps1' 70
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-AddContact.ps1' -1

function Invoke-AddContact {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Contact.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ContactObject = $Request.Body
    $TenantId = $ContactObject.tenantid

    try {
        # Prepare the body for New-MailContact cmdlet
        $BodyToship = @{
            displayName          = $ContactObject.displayName
            name                 = $ContactObject.displayName
            ExternalEmailAddress = $ContactObject.email
            FirstName            = $ContactObject.firstName
            LastName             = $ContactObject.lastName
        }

        # Create the mail contact first
        $NewContact = New-ExoRequest -tenantid $TenantId -cmdlet 'New-MailContact' -cmdParams $BodyToship -UseSystemMailbox $true

        # Build SetContactParams efficiently with only provided values
        $SetContactParams = @{
            Identity = $NewContact.id
        }

        # Helper to add non-empty values
        $PropertyMap = @{
            'Title'           = $ContactObject.Title
            'Company'         = $ContactObject.Company
            'StreetAddress'   = $ContactObject.StreetAddress
            'City'            = $ContactObject.City
            'StateOrProvince' = $ContactObject.State
            'PostalCode'      = $ContactObject.PostalCode
            'CountryOrRegion' = $ContactObject.CountryOrRegion
            'Phone'           = $ContactObject.phone
            'MobilePhone'     = $ContactObject.mobilePhone
            'WebPage'         = $ContactObject.website
        }

        # Add only non-null/non-empty properties
        foreach ($Property in $PropertyMap.GetEnumerator()) {
            if (![string]::IsNullOrWhiteSpace($Property.Value)) {
                $SetContactParams[$Property.Key] = $Property.Value
            }
        }

        # Update the contact with additional details only if we have properties to set
        if ($SetContactParams.Count -gt 1) {
            Start-Sleep -Milliseconds 500 # Ensure the contact is created before updating
            $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-Contact' -cmdParams $SetContactParams -UseSystemMailbox $true
        }

        # Check if we need to update MailContact properties
        $needsMailContactUpdate = $false
        $MailContactParams = @{
            Identity = $NewContact.id
        }

        # Only add HiddenFromAddressListsEnabled if we're actually hiding from GAL
        if ([bool]$ContactObject.hidefromGAL) {
            $MailContactParams.HiddenFromAddressListsEnabled = $true
            $needsMailContactUpdate = $true
        }

        # Add MailTip if provided
        if (![string]::IsNullOrWhiteSpace($ContactObject.mailTip)) {
            $MailContactParams.MailTip = $ContactObject.mailTip
            $needsMailContactUpdate = $true
        }

        # Only call Set-MailContact if we have changes to make
        if ($needsMailContactUpdate) {
            Start-Sleep -Milliseconds 500 # Ensure the contact is created before updating
            $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-MailContact' -cmdParams $MailContactParams -UseSystemMailbox $true
        }

        # Log the result
        $Result = "Successfully created contact $($ContactObject.displayName) with email address $($ContactObject.email)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create contact. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError

    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-AddContact.ps1' 104
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-AddContactTemplates.ps1' -1

Function Invoke-AddContactTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug
    Write-Host ($request | ConvertTo-Json -Depth 10 -Compress)

    try {
        $GUID = (New-Guid).GUID

        # Create a new ordered hashtable to store selected properties
        $contactObject = [ordered]@{}

        # Set name and comments first
        $contactObject["name"] = $Request.body.displayName
        $contactObject["comments"] = "Contact template created $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

        # Copy specific properties we want to keep
        $propertiesToKeep = @(
            "displayName", "firstName", "lastName", "email", "hidefromGAL", "streetAddress", "postalCode",
            "city", "state", "country", "companyName", "mobilePhone", "businessPhone", "jobTitle", "website", "mailTip"
        )

        # Copy each property if it exists
        foreach ($prop in $propertiesToKeep) {
            if ($null -ne $Request.body.$prop) {
                $contactObject[$prop] = $Request.body.$prop
            }
        }

        # Convert to JSON
        $JSON = $contactObject | ConvertTo-Json -Depth 10

        # Save the template to Azure Table Storage
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'ContactTemplate'
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Created Contact Template $($contactObject.name) with GUID $GUID" -Sev Info
        $body = [pscustomobject]@{'Results' = "Created Contact Template $($contactObject.name) with GUID $GUID" }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to create Contact template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to create Contact template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-AddContactTemplates.ps1' 66
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-DeployContactTemplates.ps1' -1

Function Invoke-DeployContactTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Contact.ReadWrite
    .DESCRIPTION
        This function deploys contact(s) from template(s) to selected tenants.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    try {
        $RequestBody = $Request.Body

        # Extract tenant IDs from the selectedTenants objects - get the value property
        $SelectedTenants = [System.Collections.Generic.List[string]]::new()

        foreach ($TenantItem in $RequestBody.selectedTenants) {
            if ($TenantItem.value) {
                $SelectedTenants.Add($TenantItem.value)
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "Tenant item missing value property: $($TenantItem | ConvertTo-Json -Compress)" -Sev 'Warning'
            }
        }

        # Handle AllTenants selection
        if ('AllTenants' -in $SelectedTenants) {
            $SelectedTenants = [System.Collections.Generic.List[string]]::new()
            $AllTenantsList = (Get-Tenants).defaultDomainName
            foreach ($Tenant in $AllTenantsList) {
                $SelectedTenants.Add($Tenant)
            }
        }

        # Get the contact templates from TemplateList
        $ContactTemplates = [System.Collections.Generic.List[object]]::new()

        if ($RequestBody.TemplateList -and $RequestBody.TemplateList.Count -gt 0) {
            # Templates are provided in TemplateList format
            foreach ($TemplateItem in $RequestBody.TemplateList) {
                if ($TemplateItem.value) {
                    $ContactTemplates.Add($TemplateItem.value)
                } else {
                    Write-LogMessage -headers $Headers -API $APIName -message "Template item missing value property: $($TemplateItem | ConvertTo-Json -Compress)" -Sev 'Warning'
                }
            }
        } else {
            throw "TemplateList is required and must contain at least one template"
        }

        if ($ContactTemplates.Count -eq 0) {
            throw "No valid contact templates found to deploy"
        }

        $Results = foreach ($TenantFilter in $SelectedTenants) {
            foreach ($ContactTemplate in $ContactTemplates) {
                try {
                    # Check if contact with this email already exists
                    $ExistingContactsParam = @{
                        tenantid         = $TenantFilter
                        cmdlet           = 'Get-MailContact'
                        cmdParams        = @{
                            Filter = "ExternalEmailAddress -eq '$($ContactTemplate.email)'"
                        }
                        useSystemMailbox = $true
                    }

                    $ExistingContacts = New-ExoRequest @ExistingContactsParam
                    $ContactExists = $ExistingContacts | Where-Object { $_.ExternalEmailAddress -eq $ContactTemplate.email }

                    if ($ContactExists) {
                        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Contact with email '$($ContactTemplate.email)' already exists in tenant $TenantFilter" -Sev 'Warning'
                        "Contact '$($ContactTemplate.displayName)' with email '$($ContactTemplate.email)' already exists in tenant $TenantFilter"
                        continue
                    }

                    # Prepare the body for New-MailContact cmdlet
                    $BodyToship = @{
                        displayName          = $ContactTemplate.displayName
                        name                 = $ContactTemplate.displayName
                        ExternalEmailAddress = $ContactTemplate.email
                        FirstName            = $ContactTemplate.firstName
                        LastName             = $ContactTemplate.lastName
                    }

                    # Create the mail contact first
                    $NewContact = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-MailContact' -cmdParams $BodyToship -UseSystemMailbox $true

                    # Build SetContactParams efficiently with only provided values
                    $SetContactParams = @{
                        Identity = $NewContact.id
                    }

                    # Helper to add non-empty values
                    $PropertyMap = @{
                        'Title'           = $ContactTemplate.jobTitle
                        'Company'         = $ContactTemplate.companyName
                        'StreetAddress'   = $ContactTemplate.streetAddress
                        'City'            = $ContactTemplate.city
                        'StateOrProvince' = $ContactTemplate.state
                        'PostalCode'      = $ContactTemplate.postalCode
                        'CountryOrRegion' = $ContactTemplate.country
                        'Phone'           = $ContactTemplate.businessPhone
                        'MobilePhone'     = $ContactTemplate.mobilePhone
                        'WebPage'         = $ContactTemplate.website
                    }

                    # Add only non-null/non-empty properties
                    foreach ($Property in $PropertyMap.GetEnumerator()) {
                        if (![string]::IsNullOrWhiteSpace($Property.Value)) {
                            $SetContactParams[$Property.Key] = $Property.Value
                        }
                    }

                    # Update the contact with additional details only if we have properties to set
                    if ($SetContactParams.Count -gt 1) {
                        Start-Sleep -Milliseconds 500 # Ensure the contact is created before updating
                        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Contact' -cmdParams $SetContactParams -UseSystemMailbox $true
                    }

                    # Check if we need to update MailContact properties
                    $needsMailContactUpdate = $false
                    $MailContactParams = @{
                        Identity = $NewContact.id
                    }

                    # Only add HiddenFromAddressListsEnabled if we're actually hiding from GAL
                    if ([bool]$ContactTemplate.hidefromGAL) {
                        $MailContactParams.HiddenFromAddressListsEnabled = $true
                        $needsMailContactUpdate = $true
                    }

                    # Add MailTip if provided
                    if (![string]::IsNullOrWhiteSpace($ContactTemplate.mailTip)) {
                        $MailContactParams.MailTip = $ContactTemplate.mailTip
                        $needsMailContactUpdate = $true
                    }

                    # Only call Set-MailContact if we have changes to make
                    if ($needsMailContactUpdate) {
                        Start-Sleep -Milliseconds 500 # Ensure the contact is created before updating
                        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailContact' -cmdParams $MailContactParams -UseSystemMailbox $true
                    }

                    # Log the result
                    $ContactResult = "Successfully created contact '$($ContactTemplate.displayName)' with email '$($ContactTemplate.email)'"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ContactResult -Sev 'Info'

                    # Return success message as a simple string
                    "Successfully deployed contact '$($ContactTemplate.displayName)' to tenant $TenantFilter"
                }
                catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    $ErrorDetail = "Failed to deploy contact '$($ContactTemplate.displayName)' to tenant $TenantFilter. Error: $($ErrorMessage.NormalizedError)"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ErrorDetail -Sev 'Error'

                    # Return error message as a simple string
                    "Failed to deploy contact '$($ContactTemplate.displayName)' to tenant $TenantFilter. Error: $($ErrorMessage.NormalizedError)"
                }
            }
        }

        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to process contact template deployment request. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Results}
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-DeployContactTemplates.ps1' 182
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-EditContact.ps1' -1

Function Invoke-EditContact {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Contact.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantID = $Request.Body.tenantID

    try {
        # Extract contact information from the request body
        $contactInfo = $Request.Body

        # Build contact parameters with only provided values
        $bodyForSetContact = @{
            Identity = $contactInfo.ContactID
        }

        # Map of properties to check and add
        $ContactPropertyMap = @{
            'DisplayName'         = $contactInfo.displayName
            'WindowsEmailAddress' = $contactInfo.email
            'FirstName'           = $contactInfo.firstName
            'LastName'            = $contactInfo.LastName
            'Title'               = $contactInfo.Title
            'StreetAddress'       = $contactInfo.StreetAddress
            'PostalCode'          = $contactInfo.PostalCode
            'City'                = $contactInfo.City
            'StateOrProvince'     = $contactInfo.State
            'CountryOrRegion'     = $contactInfo.CountryOrRegion
            'Company'             = $contactInfo.Company
            'MobilePhone'         = $contactInfo.mobilePhone
            'Phone'               = $contactInfo.phone
            'WebPage'             = $contactInfo.website
        }

        # Add only non-null/non-empty properties
        foreach ($Property in $ContactPropertyMap.GetEnumerator()) {
            if (![string]::IsNullOrWhiteSpace($Property.Value)) {
                $bodyForSetContact[$Property.Key] = $Property.Value
            }
        }

        # Update contact only if we have properties to set beyond Identity
        if ($bodyForSetContact.Count -gt 1) {
            $null = New-ExoRequest -tenantid $TenantID -cmdlet 'Set-Contact' -cmdParams $bodyForSetContact -UseSystemMailbox $true
        }

        # Prepare mail contact specific parameters
        $MailContactParams = @{
            Identity = $contactInfo.ContactID
        }

        # Handle boolean conversion safely
        if ($null -ne $contactInfo.hidefromGAL) {
            $MailContactParams.HiddenFromAddressListsEnabled = [bool]$contactInfo.hidefromGAL
        }

        # Add MailTip if provided
        if (![string]::IsNullOrWhiteSpace($contactInfo.mailTip)) {
            $MailContactParams.MailTip = $contactInfo.mailTip
        }

        # Update mail contact only if we have properties to set beyond Identity
        if ($MailContactParams.Count -gt 1) {
            $null = New-ExoRequest -tenantid $TenantID -cmdlet 'Set-MailContact' -cmdParams $MailContactParams -UseSystemMailbox $true
        }

        $Results = "Successfully edited contact $($contactInfo.displayName)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantID -message $Results -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to edit contact. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantID -message $Results -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = @{Results = $Results }
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-EditContact.ps1' 92
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-EditContactTemplates.ps1' -1

Function Invoke-EditContactTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug
    Write-Host ($request | ConvertTo-Json -Depth 10 -Compress)

    try {
        # Get the ContactTemplateID from the request body
        $ContactTemplateID = $Request.body.ContactTemplateID

        if (-not $ContactTemplateID) {
            throw "ContactTemplateID is required for editing a template"
        }

        # Check if the template exists
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'ContactTemplate' and RowKey eq '$ContactTemplateID'"
        $ExistingTemplate = Get-CIPPAzDataTableEntity @Table -Filter $Filter

        if (-not $ExistingTemplate) {
            throw "Contact template with ID $ContactTemplateID not found"
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Updating Contact Template with ID: $ContactTemplateID" -Sev Info

        # Create a new ordered hashtable to store selected properties
        $contactObject = [ordered]@{}

        # Set name and comments
        $contactObject["name"] = $Request.body.displayName
        $contactObject["comments"] = "Contact template updated $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

        # Copy specific properties we want to keep
        $propertiesToKeep = @(
            "displayName", "firstName", "lastName", "email", "hidefromGAL", "streetAddress", "postalCode",
            "city", "state", "country", "companyName", "mobilePhone", "businessPhone", "jobTitle", "website", "mailTip"
        )

        # Copy each property from the request
        foreach ($prop in $propertiesToKeep) {
            if ($null -ne $Request.body.$prop) {
                $contactObject[$prop] = $Request.body.$prop
            }
        }

        # Convert to JSON
        $JSON = $contactObject | ConvertTo-Json -Depth 10

        # Overwrite the template in Azure Table Storage
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$ContactTemplateID"
            PartitionKey = 'ContactTemplate'
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Updated Contact Template $($contactObject.name) with GUID $ContactTemplateID" -Sev Info
        $body = [pscustomobject]@{'Results' = "Updated Contact Template $($contactObject.name) with GUID $ContactTemplateID" }
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to update Contact template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to update Contact template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-EditContactTemplates.ps1' 82
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-ListContacts.ps1' -1

#using namespace System.Collections.Generic
#using namespace System.Text.RegularExpressions

function Invoke-ListContacts {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Contact.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    # Get query parameters
    $TenantFilter = $Request.Query.tenantFilter
    $ContactID = $Request.Query.id

    # Early validation and exit
    if (-not $TenantFilter) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'tenantFilter is required'
            })
    }

    # Pre-compiled regex for MailTip cleaning
    $script:HtmlTagRegex ??= [regex]::new('<[^>]+>', [RegexOptions]::Compiled)
    $script:LineBreakRegex ??= [regex]::new('\\n|\r\n|\r', [RegexOptions]::Compiled)
    $script:SmtpPrefixRegex ??= [regex]::new('^SMTP:', [RegexOptions]::Compiled -bor [RegexOptions]::IgnoreCase)

    function ConvertTo-ContactObject {
        param($Contact, $MailContact)

        # Early exit if essential data missing
        if (!$Contact.Id) { return $null }

        $mailAddress = if ($MailContact.ExternalEmailAddress) {
            $script:SmtpPrefixRegex.Replace($MailContact.ExternalEmailAddress, [string]::Empty, 1)
        } else { $null }

        $cleanMailTip = if ($MailContact.MailTip -and $MailContact.MailTip.Length -gt 0) {
            $cleaned = $script:HtmlTagRegex.Replace($MailContact.MailTip, [string]::Empty)
            $cleaned = $script:LineBreakRegex.Replace($cleaned, "`n")
            $cleaned.Trim()
        } else { $null }

        $phoneCapacity = 0
        if ($Contact.Phone) { $phoneCapacity++ }
        if ($Contact.MobilePhone) { $phoneCapacity++ }

        $phones = if ($phoneCapacity -gt 0) {
            $phoneList = [List[hashtable]]::new($phoneCapacity)
            if ($Contact.Phone) {
                $phoneList.Add(@{ type = 'business'; number = $Contact.Phone })
            }
            if ($Contact.MobilePhone) {
                $phoneList.Add(@{ type = 'mobile'; number = $Contact.MobilePhone })
            }
            $phoneList.ToArray()
        } else { @() }

        return @{
            id                    = $Contact.Id
            displayName           = $Contact.DisplayName
            givenName             = $Contact.FirstName
            surname               = $Contact.LastName
            mail                  = $mailAddress
            companyName           = $Contact.Company
            jobTitle              = $Contact.Title
            website               = $Contact.WebPage
            notes                 = $Contact.Notes
            hidefromGAL           = $MailContact.HiddenFromAddressListsEnabled
            mailTip               = $cleanMailTip
            onPremisesSyncEnabled = $Contact.IsDirSynced
            addresses             = @(@{
                    street          = $Contact.StreetAddress
                    city            = $Contact.City
                    state           = $Contact.StateOrProvince
                    countryOrRegion = $Contact.CountryOrRegion
                    postalCode      = $Contact.PostalCode
                })
            phones                = $phones
        }
    }

    try {
        if (![string]::IsNullOrWhiteSpace($ContactID)) {
            # Single contact request - keep existing complex formatting
            Write-Host "Getting specific contact: $ContactID"

            $Contact = New-EXORequest -tenantid $TenantFilter -cmdlet 'Get-Contact' -cmdParams @{
                Identity = $ContactID
            }

            $MailContact = New-EXORequest -tenantid $TenantFilter -cmdlet 'Get-MailContact' -cmdParams @{
                Identity = $ContactID
            }

            if (!$Contact -or !$MailContact) {
                throw 'Contact not found or insufficient permissions'
            }

            $ContactResponse = ConvertTo-ContactObject -Contact $Contact -MailContact $MailContact

        } else {
            # Get all contacts - simplified approach
            Write-Host 'Getting all contacts'

            $ContactResponse = New-EXORequest -tenantid $TenantFilter -cmdlet 'Get-Contact' -cmdParams @{
                Filter     = "RecipientTypeDetails -eq 'MailContact'"
                ResultSize = 'Unlimited'
            } | Select-Object -Property City, Company, Department, DisplayName, FirstName, LastName, IsDirSynced, Guid, WindowsEmailAddress

            # Add Graph ID to each contact based on email match
            $GraphContacts = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/contacts' -tenantid $TenantFilter
            foreach ($contact in $ContactResponse) {
                $GraphMatch = $GraphContacts | Where-Object { $_.mail -eq $contact.WindowsEmailAddress }
                if ($GraphMatch) {
                    $contact | Add-Member -MemberType NoteProperty -Name 'graphId' -Value $GraphMatch.id -Force
                }
            }

            # Return empty array if no contacts found
            if (!$ContactResponse) {
                $ContactResponse = @()
            }
        }

        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
        $ContactResponse = $ErrorMessage
        Write-Host "Error in ListContacts: $ErrorMessage"
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $ContactResponse
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-ListContacts.ps1' 143
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-ListContactTemplates.ps1' -1

Function Invoke-ListContactTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Table = Get-CippTable -tablename 'templates'
    $Templates = Get-ChildItem 'Config\*.ContactTemplate.json' | ForEach-Object {
        $Entity = @{
            JSON         = "$(Get-Content $_)"
            RowKey       = "$($_.name)"
            PartitionKey = 'ContactTemplate'
            GUID         = "$($_.name)"
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
    }

    # Check if a specific template ID is requested
    if ($Request.query.ID -or $Request.query.id) {
        $RequestedID = $Request.query.ID ?? $Request.query.id
        Write-LogMessage -headers $Headers -API $APIName -message "Retrieving specific template with ID: $RequestedID" -Sev 'Debug'

        # Query directly for the specific template by RowKey for efficiency
        $Filter = "PartitionKey eq 'ContactTemplate' and RowKey eq '$RequestedID'"
        $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
            $GUID = $_.RowKey
            $data = $_.JSON | ConvertFrom-Json
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
            $data
        }

        if (-not $Templates) {
            Write-LogMessage -headers $Headers -API $APIName -message "Template with ID $RequestedID not found" -Sev 'Warning'
            return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::NotFound
                Body       = @{ Error = "Template with ID $RequestedID not found" }
            })
            return
        }
    } else {
        # List all policies if no specific ID requested
        Write-LogMessage -headers $Headers -API $APIName -message 'Retrieving all contact templates' -Sev 'Debug'

        $Filter = "PartitionKey eq 'ContactTemplate'"
        $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
            $GUID = $_.RowKey
            $data = $_.JSON | ConvertFrom-Json
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
            $data
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-ListContactTemplates.ps1' 65
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-RemoveContact.ps1' -1

Function Invoke-RemoveContact {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Contact.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    Write-LogMessage -Headers $Request.Headers -API $APIName -message 'Accessed this API' -Sev 'Debug'

    # Interact with query parameters or the body of the request.
    $GUID = $Request.query.GUID ?? $Request.body.GUID
    $Mail = $Request.query.Mail ?? $Request.body.Mail

    try {
        $Params = @{
            Identity = $GUID
        }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-MailContact' -cmdParams $Params -UseSystemMailbox $true
        Write-LogMessage -Headers $Request.Headers -API $APIName -tenant $TenantFilter -message "Deleted contact $GUID" -sev Debug
        $Result = "Deleted $Mail"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete contact $GUID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Request.Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    $Results = [pscustomobject]@{'Results' = $Result }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-RemoveContact.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-RemoveContactTemplates.ps1' -1

function Invoke-RemoveContactTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    Write-LogMessage -Headers $Headers -API $APIName -message 'Accessed this API' -Sev 'Debug'
    $ID = $Request.Query.ID ?? $Request.Body.ID

    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'ContactTemplate' and RowKey eq '$id'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Contact Template with ID $ID."
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Contact template with ID $ID. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Contacts/Invoke-RemoveContactTemplates.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-AddSharedMailbox.ps1' -1

function Invoke-AddSharedMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Results = [System.Collections.Generic.List[string]]::new()
    $MailboxObject = $Request.Body
    $Tenant = $MailboxObject.tenantID
    $Aliases = $MailboxObject.addedAliases -split '\n'

    try {

        $Email = "$($MailboxObject.username)@$($MailboxObject.domain)"
        $BodyToShip = [pscustomobject] @{
            displayName        = $MailboxObject.displayName
            name               = $MailboxObject.username
            primarySMTPAddress = $Email
            Shared             = $true
        }
        $AddSharedRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-Mailbox' -cmdParams $BodyToShip
        $Results.Add("Successfully created shared mailbox: $Email.")
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message "Created shared mailbox $($MailboxObject.displayName) with email $Email" -Sev 'Info'

        # Block sign-in for the mailbox
        try {
            $null = Set-CIPPSignInState -userid $AddSharedRequest.ExternalDirectoryObjectId -TenantFilter $Tenant -APIName $APIName -Headers $Headers -AccountEnabled $false
            $Results.Add("Blocked sign-in for shared mailbox $Email")
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Message = "Failed to block sign-in for shared mailbox $Email Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
            $Results.Add($Message)
        }

        # Add aliases to the mailbox if any are provided
        if ($Aliases) {
            try {
                Start-Sleep 3 # Sleep since there is apparently a race condition with the mailbox creation if we don't delay for a lil bit
                $AliasBodyToShip = [pscustomobject] @{
                    Identity       = $AddSharedRequest.Guid
                    EmailAddresses = @{'@odata.type' = '#Exchange.GenericHashTable'; Add = $Aliases }
                }
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Mailbox' -cmdParams $AliasBodyToShip -UseSystemMailbox $true
                $Message = "Added aliases to $Email : $($Aliases -join ',')"
                Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Info'
                $Results.Add($Message)

            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                $Message = "Failed to add aliases to $Email : $($ErrorMessage.NormalizedError)"
                Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
                $Results.Add($Message)
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create shared mailbox. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-AddSharedMailbox.ps1' 80
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecConvertMailbox.ps1' -1

Function Invoke-ExecConvertMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $UserID = $Request.Body.ID
    $MailboxType = $Request.Body.MailboxType

    try {
        $Results = Set-CIPPMailboxType -UserID $UserID -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers -MailboxType $MailboxType
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecConvertMailbox.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecCopyForSent.ps1' -1

function Invoke-ExecCopyForSent {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.ID ?? $Request.Body.ID
    $MessageCopyState = $Request.Query.messageCopyState ?? $Request.Body.messageCopyState
    $MessageCopyState = [System.Convert]::ToBoolean($MessageCopyState)

    try {
        $params = @{
            UserId                            = $UserID
            TenantFilter                      = $TenantFilter
            APIName                           = $APIName
            Headers                           = $Headers
            MessageCopyForSentAsEnabled       = $MessageCopyState
            MessageCopyForSendOnBehalfEnabled = $MessageCopyState
        }
        $Result = Set-CIPPMessageCopy @params
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecCopyForSent.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEditCalendarPermissions.ps1' -1

function Invoke-ExecEditCalendarPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Extract parameters from query or body
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.userid ?? $Request.Body.userid
    $UserToGetPermissions = $Request.Query.UserToGetPermissions ?? $Request.Body.UserToGetPermissions.value
    $Permissions = $Request.Query.Permissions ?? $Request.Body.Permissions.value
    $FolderName = $Request.Query.FolderName ?? $Request.Body.FolderName
    $RemoveAccess = $Request.Query.RemoveAccess ?? $Request.Body.RemoveAccess.value
    $CanViewPrivateItems = $Request.Query.CanViewPrivateItems ?? $Request.Body.CanViewPrivateItems

    try {
        if ($RemoveAccess) {
            $Result = Set-CIPPCalendarPermission -Headers $Headers -UserID $UserID -FolderName $FolderName -RemoveAccess $RemoveAccess -TenantFilter $TenantFilter
        } else {
            $Result = Set-CIPPCalendarPermission -Headers $Headers -UserID $UserID -FolderName $FolderName -TenantFilter $TenantFilter -UserToGetPermissions $UserToGetPermissions -Permissions $Permissions -CanViewPrivateItems $CanViewPrivateItems
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        Write-Warning "Error in ExecEditCalendarPermissions: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEditCalendarPermissions.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEditMailboxPermissions.ps1' -1

Function Invoke-ExecEditMailboxPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -headers $Headers -API $APINAME-message 'Accessed this API' -Sev 'Debug'
    $Username = $request.body.userID
    $Tenantfilter = $request.body.tenantfilter
    if ($username -eq $null) { exit }
    $userid = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($username)" -tenantid $Tenantfilter).id
    $Results = [System.Collections.ArrayList]@()

    $RemoveFullAccess = ($Request.body.RemoveFullAccess).value
    foreach ($RemoveUser in $RemoveFullAccess) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Remove-mailboxpermission' -cmdParams @{Identity = $userid; user = $RemoveUser; accessRights = @('FullAccess'); }
            $results.add("Removed $($removeuser) from $($username) Shared Mailbox permissions")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Removed $($RemoveUser) from $($username) Shared Mailbox permission" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not remove mailbox permissions for $($removeuser) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not remove $($removeuser) shared mailbox permissions for $($username). Error: $($_.Exception.Message)")
        }
    }
    $AddFullAccess = ($Request.body.AddFullAccess).value

    foreach ($UserAutomap in $AddFullAccess) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Add-MailboxPermission' -cmdParams @{Identity = $userid; user = $UserAutomap; accessRights = @('FullAccess'); automapping = $true }
            $results.add( "Granted $($UserAutomap) access to $($username) Mailbox with automapping")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Granted $($UserAutomap) access to $($username) Mailbox with automapping" -Sev 'Info' -tenant $TenantFilter

        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not add mailbox permissions for $($UserAutomap) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add( "Could not add $($UserAutomap) shared mailbox permissions for $($username). Error: $($_.Exception.Message)")
        }
    }
    $AddFullAccessNoAutoMap = ($Request.body.AddFullAccessNoAutoMap).value

    foreach ($UserNoAutomap in $AddFullAccessNoAutoMap) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Add-MailboxPermission' -cmdParams @{Identity = $userid; user = $UserNoAutomap; accessRights = @('FullAccess'); automapping = $false }
            $results.add( "Granted $UserNoAutomap access to $($username) Mailbox without automapping")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Granted $UserNoAutomap access to $($username) Mailbox without automapping" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not add mailbox permissions for $($UserNoAutomap) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not add $($UserNoAutomap) shared mailbox permissions for $($username). Error: $($_.Exception.Message)")
        }
    }

    $AddSendAS = ($Request.body.AddSendAs).value

    foreach ($UserSendAs in $AddSendAS) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Add-RecipientPermission' -cmdParams @{Identity = $userid; Trustee = $UserSendAs; accessRights = @('SendAs') }
            $results.add( "Granted $UserSendAs access to $($username) with Send As permissions")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Granted $UserSendAs access to $($username) with Send As permissions" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not add mailbox permissions for $($UserSendAs) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not add $($UserSendAs) send-as permissions for $($username). Error: $($_.Exception.Message)")
        }
    }

    $RemoveSendAs = ($Request.body.RemoveSendAs).value

    foreach ($UserSendAs in $RemoveSendAs) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Remove-RecipientPermission' -cmdParams @{Identity = $userid; Trustee = $UserSendAs; accessRights = @('SendAs') }
            $results.add( "Removed $UserSendAs from $($username) with Send As permissions")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Removed $UserSendAs from $($username) with Send As permissions" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not remove mailbox permissions for $($UserSendAs) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not remove $($UserSendAs) send-as permissions for $($username). Error: $($_.Exception.Message)")
        }
    }

    $AddSendOnBehalf = ($Request.body.AddSendOnBehalf).value

    foreach ($UserSendOnBehalf in $AddSendOnBehalf) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $userid; GrantSendonBehalfTo = @{'@odata.type' = '#Exchange.GenericHashTable'; add = $UserSendOnBehalf }; }
            $results.add( "Granted $UserSendOnBehalf access to $($username) with Send On Behalf Permissions")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Granted $UserSendOnBehalf access to $($username) with Send On Behalf Permissions" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not add send on behalf permissions for $($UserSendOnBehalf) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not add $($UserSendOnBehalf) send on behalf permissions for $($username). Error: $($_.Exception.Message)")
        }
    }

    $RemoveSendOnBehalf = ($Request.body.RemoveSendOnBehalf).value

    foreach ($UserSendOnBehalf in $RemoveSendOnBehalf) {
        try {
            $MailboxPerms = New-ExoRequest -Anchor $username -tenantid $Tenantfilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $userid; GrantSendonBehalfTo = @{'@odata.type' = '#Exchange.GenericHashTable'; remove = $UserSendOnBehalf }; }
            $results.add( "Removed $UserSendOnBehalf from $($username) Send on Behalf Permissions")
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Removed $UserSendOnBehalf from $($username) Send on Behalf Permissions" -Sev 'Info' -tenant $TenantFilter
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME-message "Could not Remove send on behalf permissions for $($UserSendOnBehalf) on $($username)" -Sev 'Error' -tenant $TenantFilter
            $results.add("Could not remove $($UserSendOnBehalf) send on behalf permissions for $($username). Error: $($_.Exception.Message)")
        }
    }

    $body = [pscustomobject]@{'Results' = @($results) }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEditMailboxPermissions.ps1' 117
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEmailForward.ps1' -1

Function Invoke-ExecEmailForward {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -headers $Headers -API $APINAME-message 'Accessed this API' -Sev 'Debug'


    $TenantFilter = $Request.Body.tenantFilter
    $Username = $Request.Body.userID
    if ($Request.Body.ForwardInternal -is [string]) {
        $ForwardingAddress = $Request.Body.ForwardInternal
    } else {
        $ForwardingAddress = $Request.Body.ForwardInternal.value
    }
    $ForwardingSMTPAddress = $Request.Body.ForwardExternal
    $ForwardOption = $Request.Body.forwardOption
    [bool]$KeepCopy = if ($Request.Body.KeepCopy -eq 'true') { $true } else { $false }

    # Process the forwarding option based on the type selected
    switch ($ForwardOption) {
        'internalAddress' {
            # Set up internal forwarding to another mailbox within the organization
            try {
                $Results = Set-CIPPForwarding -UserID $Username -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers -Forward $ForwardingAddress -KeepCopy $KeepCopy
                $StatusCode = [HttpStatusCode]::OK
            } catch {
                $Results = $_.Exception.Message
                $StatusCode = [HttpStatusCode]::InternalServerError
            }
        }
        'ExternalAddress' {
            # Set up external forwarding to an SMTP address outside the organization
            try {
                $Results = Set-CIPPForwarding -UserID $Username -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers -ForwardingSMTPAddress $ForwardingSMTPAddress -KeepCopy $KeepCopy
                $StatusCode = [HttpStatusCode]::OK
            } catch {
                $Results = $_.Exception.Message
                $StatusCode = [HttpStatusCode]::InternalServerError
            }
        }
        'disabled' {
            # Disable email forwarding for the specified user
            try {
                $Results = Set-CIPPForwarding -UserID $Username -Username $Username -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName -Disable $true
                $StatusCode = [HttpStatusCode]::OK
            } catch {
                $Results = $_.Exception.Message
                $StatusCode = [HttpStatusCode]::InternalServerError
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEmailForward.ps1' 68
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEnableArchive.ps1' -1

Function Invoke-ExecEnableArchive {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.id ?? $Request.Body.id
    $UserName = $Request.Query.username ?? $Request.Body.username

    Try {
        $ResultsArch = Set-CIPPMailboxArchive -userid $ID -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers -ArchiveEnabled $true -Username $UserName
        if ($ResultsArch -like 'Failed to set archive*') { throw $ResultsArch }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ResultsArch = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    $Results = [pscustomobject]@{'Results' = "$ResultsArch" }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEnableArchive.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEnableAutoExpandingArchive.ps1' -1

function Invoke-ExecEnableAutoExpandingArchive {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $ID = $Request.Body.ID
    $TenantFilter = $Request.Body.tenantFilter
    $Username = $Request.Body.username

    try {
        $Result = Set-CIPPMailboxArchive -TenantFilter $TenantFilter -UserID $ID -Username $Username -Headers $Headers -AutoExpandingArchive
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = "$Result" }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecEnableAutoExpandingArchive.ps1' 31
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsDelete.ps1' -1

Function Invoke-ExecGroupsDelete {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $GroupType = $Request.Query.GroupType ?? $Request.Body.GroupType
    $ID = $Request.Query.id ?? $Request.Body.id
    $DisplayName = $Request.Query.displayName ?? $Request.Body.displayName

    Try {
        $Result = Remove-CIPPGroup -ID $ID -GroupType $GroupType -TenantFilter $TenantFilter -DisplayName $DisplayName -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsDelete.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsDeliveryManagement.ps1' -1

Function Invoke-ExecGroupsDeliveryManagement {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $GroupType = $Request.Query.GroupType ?? $Request.Body.GroupType
    $OnlyAllowInternal = $Request.Query.OnlyAllowInternal ?? $Request.Body.OnlyAllowInternal
    $ID = $Request.Query.ID ?? $Request.Body.ID

    Try {
        $Result = Set-CIPPGroupAuthentication -ID $ID -GroupType $GroupType -OnlyAllowInternal $OnlyAllowInternal -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsDeliveryManagement.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsHideFromGAL.ps1' -1

Function Invoke-ExecGroupsHideFromGAL {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $GroupType = $Request.Query.GroupType ?? $Request.Body.GroupType
    $GroupID = $Request.Query.ID ?? $Request.Body.ID
    $HideFromGAL = $Request.Query.HideFromGAL ?? $Request.Body.HideFromGAL

    Try {
        $Result = Set-CIPPGroupGAL -Id $GroupID -TenantFilter $TenantFilter -GroupType $GroupType -HiddenString $HideFromGAL -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecGroupsHideFromGAL.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecHideFromGAL.ps1' -1

Function Invoke-ExecHideFromGAL {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    # Support if the request is a POST or a GET. So to support legacy(GET) and new(POST) requests
    $UserId = $Request.Query.ID ?? $Request.body.ID
    $TenantFilter = $Request.Query.TenantFilter ?? $Request.body.tenantFilter
    $HideFromGAL = $Request.Query.HideFromGAL ?? $Request.body.HideFromGAL
    $HideFromGAL = [System.Convert]::ToBoolean($HideFromGAL)

    Try {
        $Result = Set-CIPPHideFromGAL -tenantFilter $TenantFilter -UserID $UserId -hidefromgal $HideFromGAL -Headers $Headers -APIName $APIName
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecHideFromGAL.ps1' 36
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecHVEUser.ps1' -1

function Invoke-ExecHVEUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Results = [System.Collections.Generic.List[string]]::new()
    $HVEUserObject = $Request.Body
    $Tenant = $HVEUserObject.TenantFilter

    try {
        # Check if Security Defaults are enabled
        try {
            $SecurityDefaults = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -tenantid $Tenant
            if ($SecurityDefaults.isEnabled -eq $true) {
                $Results.Add('WARNING: Security Defaults are enabled for this tenant. HVE might not function.')
            }
        } catch {
            $Results.Add('WARNING: Could not check Security Defaults status. Please verify authentication policies manually.')
        }

        # Create the HVE user using New-MailUser
        $BodyToShip = [pscustomobject] @{
            Name               = $HVEUserObject.displayName
            DisplayName        = $HVEUserObject.displayName
            PrimarySmtpAddress = $HVEUserObject.primarySMTPAddress
            Password           = $HVEUserObject.password
            HVEAccount         = $true
        }

        $CreateHVERequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-MailUser' -cmdParams $BodyToShip
        $Results.Add("Successfully created HVE user: $($HVEUserObject.primarySMTPAddress)")
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message "Created HVE user $($HVEUserObject.displayName) with email $($HVEUserObject.primarySMTPAddress)" -Sev 'Info'

        # Try to exclude from Conditional Access policies that block basic authentication
        try {
            # Get all Conditional Access policies
            $CAPolicies = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies' -tenantid $Tenant

            $BasicAuthPolicies = $CAPolicies | Where-Object {
                $_.conditions.clientAppTypes -contains 'exchangeActiveSync' -or
                $_.conditions.clientAppTypes -contains 'other' -or
                $_.conditions.applications.includeApplications -contains 'All' -and
                $_.grantControls.builtInControls -contains 'block'
            }

            if ($BasicAuthPolicies) {
                foreach ($Policy in $BasicAuthPolicies) {
                    try {
                        # Add the HVE user to the exclusions
                        $ExcludedUsers = @($Policy.conditions.users.excludeUsers)
                        if ($CreateHVERequest.ExternalDirectoryObjectId -notin $ExcludedUsers) {

                            $ExcludeUsers = @($ExcludedUsers + $CreateHVERequest.ExternalDirectoryObjectId)
                            $UpdateBody = @{
                                conditions = @{
                                    users = @{
                                        excludeUsers = @($ExcludeUsers | Sort-Object -Unique)
                                    }
                                }
                            }

                            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($Policy.id)" -type PATCH -body (ConvertTo-Json -InputObject $UpdateBody -Depth 10) -tenantid $Tenant
                            $Results.Add("Excluded HVE user from Conditional Access policy: $($Policy.displayName)")
                            Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message "Excluded HVE user from CA policy: $($Policy.displayName)" -Sev 'Info'
                        }
                    } catch {
                        $ErrorMessage = Get-CippException -Exception $_
                        $Message = "Failed to exclude from CA policy '$($Policy.displayName)': $($ErrorMessage.NormalizedError)"
                        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Warning' -LogData $ErrorMessage
                        $Results.Add($Message)
                    }
                }
            } else {
                $Results.Add('No Conditional Access policies blocking basic authentication found.')
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Message = "Failed to check/update Conditional Access policies: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Warning' -LogData $ErrorMessage
            $Results.Add($Message)
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create HVE user: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecHVEUser.ps1' 106
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecMailboxMobileDevices.ps1' -1

Function Invoke-ExecMailboxMobileDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Interact with query parameters or the body of the request.
    Try {
        $MobileResults = Set-CIPPMobileDevice -UserId $request.query.Userid -Guid $request.query.guid -DeviceId $request.query.deviceid -Quarantine $request.query.Quarantine -tenantFilter $request.query.tenantfilter -APIName $APINAME -Delete $Request.query.Delete -Headers $Request.Headers
        $Results = [pscustomobject]@{'Results' = $MobileResults }
    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed  $($request.query.Userid): $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecMailboxMobileDevices.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyCalPerms.ps1' -1

function Invoke-ExecModifyCalPerms {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # UPN of the mailbox to modify calendar permissions for
    $Username = $Request.Body.userID

    $TenantFilter = $Request.Body.tenantFilter
    $Permissions = $Request.Body.permissions

    Write-LogMessage -headers $Headers -API $APIName -message "Processing request for user: $Username, tenant: $TenantFilter" -Sev 'Debug'

    if ([string]::IsNullOrWhiteSpace($Username)) {
        Write-LogMessage -headers $Headers -API $APIName -message 'Username is null or whitespace' -Sev 'Error'
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = @{'Results' = @('Username is required') }
            })
        return
    }

    try {
        try {
            $UserId = [guid]$Username
        } catch {
            # If not a GUID, assume it's a UPN and look up the ID via Graph
            $UserId = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Username)" -tenantid $TenantFilter).id
            Write-LogMessage -headers $Headers -API $APIName -message "Retrieved user ID: $UserId" -Sev 'Debug'
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to get user ID: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::NotFound
                Body       = @{'Results' = @("Failed to get user ID: $($ErrorMessage.NormalizedError)") }
            })
        return
    }

    $Results = [System.Collections.Generic.List[string]]::new()
    $HasErrors = $false

    # Convert permissions to array format if it's an object with numeric keys
    if ($Permissions -is [PSCustomObject]) {
        if ($Permissions.PSObject.Properties.Name -match '^\d+$') {
            $Permissions = $Permissions.PSObject.Properties.Value
        } else {
            $Permissions = @($Permissions)
        }
    }

    Write-LogMessage -headers $Headers -API $APIName -message "Processing $($Permissions.Count) permission entries" -Sev 'Debug'

    foreach ($Permission in $Permissions) {
        Write-LogMessage -headers $Headers -API $APIName -message "Processing permission: $($Permission | ConvertTo-Json)" -Sev 'Debug'

        $PermissionLevel = $Permission.PermissionLevel.value ?? $Permission.PermissionLevel
        $Modification = $Permission.Modification
        $CanViewPrivateItems = $Permission.CanViewPrivateItems ?? $false
        $FolderName = $Permission.FolderName ?? 'Calendar'
        $SendNotificationToUser = $Permission.SendNotificationToUser ?? $false

        Write-LogMessage -headers $Headers -API $APIName -message "Permission Level: $PermissionLevel, Modification: $Modification, CanViewPrivateItems: $CanViewPrivateItems, FolderName: $FolderName" -Sev 'Debug'

        # Handle UserID as array or single value
        $TargetUsers = @($Permission.UserID | ForEach-Object { $_.value ?? $_ })

        Write-LogMessage -headers $Headers -API $APIName -message "Target Users: $($TargetUsers -join ', ')" -Sev 'Debug'

        foreach ($TargetUser in $TargetUsers) {
            try {
                Write-LogMessage -headers $Headers -API $APIName -message "Processing target user: $TargetUser" -Sev 'Debug'
                $Params = @{
                    APIName                = $APIName
                    Headers                = $Headers
                    RemoveAccess           = if ($Modification -eq 'Remove') { $TargetUser } else { $null }
                    TenantFilter           = $TenantFilter
                    UserID                 = $UserId
                    folderName             = $FolderName
                    UserToGetPermissions   = $TargetUser
                    LoggingName            = $TargetUser
                    Permissions            = $PermissionLevel
                    CanViewPrivateItems    = $CanViewPrivateItems
                    SendNotificationToUser = $SendNotificationToUser
                }

                # Write-Host "Request params: $($Params | ConvertTo-Json)"
                $Result = Set-CIPPCalendarPermission @Params

                $Results.Add($Result)
            } catch {
                $HasErrors = $true
                $Results.Add("$($_.Exception.Message)")
            }
        }
    }

    if ($Results.Count -eq 0) {
        Write-LogMessage -headers $Headers -API $APIName -message 'No results were generated from the operation' -Sev 'Warning'
        $Results.Add('No results were generated from the operation. Please check the logs for more details.')
        $HasErrors = $true
    }

    return ([HttpResponseContext]@{
            StatusCode = if ($HasErrors) { [HttpStatusCode]::InternalServerError } else { [HttpStatusCode]::OK }
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyCalPerms.ps1' 118
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyContactPerms.ps1' -1

function Invoke-ExecModifyContactPerms {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # UPN of the mailbox to modify contact permissions for
    $Username = $Request.Body.userID

    $TenantFilter = $Request.Body.tenantFilter
    $Permissions = $Request.Body.permissions

    Write-LogMessage -headers $Headers -API $APIName -message "Processing request for user: $Username, tenant: $TenantFilter" -Sev 'Debug'

    if ([string]::IsNullOrWhiteSpace($Username)) {
        Write-LogMessage -headers $Headers -API $APIName -message 'Username is null or whitespace' -Sev 'Error'
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = @{'Results' = @('Username is required') }
            })
        return
    }

    try {
        try {
            $UserId = [guid]$Username
        } catch {
            # If not a GUID, assume it's a UPN and look up the ID via Graph
            $UserId = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Username)" -tenantid $TenantFilter).id
            Write-LogMessage -headers $Headers -API $APIName -message "Retrieved user ID: $UserId" -Sev 'Debug'
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to get user ID: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::NotFound
                Body       = @{'Results' = @("Failed to get user ID: $($ErrorMessage.NormalizedError)") }
            })
        return
    }

    $Results = [System.Collections.Generic.List[string]]::new()
    $HasErrors = $false

    # Convert permissions to array format if it's an object with numeric keys
    if ($Permissions -is [PSCustomObject]) {
        if ($Permissions.PSObject.Properties.Name -match '^\d+$') {
            $Permissions = $Permissions.PSObject.Properties.Value
        } else {
            $Permissions = @($Permissions)
        }
    }

    Write-LogMessage -headers $Headers -API $APIName -message "Processing $($Permissions.Count) permission entries" -Sev 'Debug'

    foreach ($Permission in $Permissions) {
        Write-LogMessage -headers $Headers -API $APIName -message "Processing permission: $($Permission | ConvertTo-Json)" -Sev 'Debug'

        $PermissionLevel = $Permission.PermissionLevel.value ?? $Permission.PermissionLevel
        $Modification = $Permission.Modification
        $CanViewPrivateItems = $Permission.CanViewPrivateItems ?? $false
        $FolderName = $Permission.FolderName ?? 'Contact'
        $SendNotificationToUser = $Permission.SendNotificationToUser ?? $false

        Write-LogMessage -headers $Headers -API $APIName -message "Permission Level: $PermissionLevel, Modification: $Modification, CanViewPrivateItems: $CanViewPrivateItems, FolderName: $FolderName" -Sev 'Debug'

        # Handle UserID as array or single value
        $TargetUsers = @($Permission.UserID | ForEach-Object { $_.value ?? $_ })

        Write-LogMessage -headers $Headers -API $APIName -message "Target Users: $($TargetUsers -join ', ')" -Sev 'Debug'

        foreach ($TargetUser in $TargetUsers) {
            try {
                Write-LogMessage -headers $Headers -API $APIName -message "Processing target user: $TargetUser" -Sev 'Debug'
                $Params = @{
                    APIName                = $APIName
                    Headers                = $Headers
                    RemoveAccess           = if ($Modification -eq 'Remove') { $TargetUser } else { $null }
                    TenantFilter           = $TenantFilter
                    UserID                 = $UserId
                    folderName             = $FolderName
                    UserToGetPermissions   = $TargetUser
                    LoggingName            = $TargetUser
                    Permissions            = $PermissionLevel
                    SendNotificationToUser = $SendNotificationToUser
                }

                # Write-Host "Request params: $($Params | ConvertTo-Json)"
                $Result = Set-CIPPContactPermission @Params

                $Results.Add($Result)
            } catch {
                $HasErrors = $true
                $Results.Add("$($_.Exception.Message)")
            }
        }
    }

    if ($Results.Count -eq 0) {
        Write-LogMessage -headers $Headers -API $APIName -message 'No results were generated from the operation' -Sev 'Warning'
        $Results.Add('No results were generated from the operation. Please check the logs for more details.')
        $HasErrors = $true
    }


    return ([HttpResponseContext]@{
            StatusCode = if ($HasErrors) { [HttpStatusCode]::InternalServerError } else { [HttpStatusCode]::OK }
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyContactPerms.ps1' 118
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyMBPerms.ps1' -1

Function Invoke-ExecModifyMBPerms {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    # Extract mailbox requests - handle all three formats
    $MailboxRequests = $null
    $Results = [System.Collections.ArrayList]::new()

    # Direct array format
    if ($request.body -is [array]) {
        $MailboxRequests = $request.body
    }
    # Bulk format with mailboxRequests property
    elseif ($request.body.mailboxRequests) {
        $MailboxRequests = $request.body.mailboxRequests
    }
    # Legacy single mailbox format
    elseif ($request.body.userID -and $request.body.permissions) {
        $MailboxRequests = @([PSCustomObject]@{
            userID = $request.body.userID
            tenantFilter = $request.body.tenantFilter
            permissions = $request.body.permissions
        })
    }

    if (-not $MailboxRequests -or $MailboxRequests.Count -eq 0) {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'No mailbox requests provided' -Sev 'Error'
        $body = [pscustomobject]@{'Results' = @("No mailbox requests provided") }
        return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = $Body
        })
        return
    }

    $TenantFilter = $Request.body.tenantFilter
    Write-LogMessage -headers $Request.Headers -API $APINAME -message "Processing permission changes for $($MailboxRequests.Count) mailboxes" -Sev 'Info' -tenant $TenantFilter

    # Build cmdlet array for processing
    $CmdletArray = [System.Collections.ArrayList]::new()
    $CmdletMetadataArray = [System.Collections.ArrayList]::new()
    $GuidToMetadataMap = @{}  # Map GUIDs to our metadata
    $UserLookupCache = @{}

    foreach ($MailboxRequest in $MailboxRequests) {
        $Username = $MailboxRequest.userID
        $Permissions = $MailboxRequest.permissions

        if ([string]::IsNullOrEmpty($Username)) {
            $null = $Results.Add("Skipped mailbox with missing userID")
            continue
        }

        # User lookup with caching for bulk operations
        if (-not $UserLookupCache.ContainsKey($Username)) {
            try {
                $UserObject = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Username)" -tenantid $TenantFilter
                $UserLookupCache[$Username] = $UserObject.userPrincipalName
            }
            catch {
                try {
                    $UserObject = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$filter=userPrincipalName eq '$Username'" -tenantid $TenantFilter
                    if ($UserObject.value -and $UserObject.value.Count -gt 0) {
                        $UserLookupCache[$Username] = $UserObject.value[0].userPrincipalName
                    } else {
                        throw "User not found"
                    }
                }
                catch {
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message "Could not find user $($Username)" -Sev 'Error' -tenant $TenantFilter
                    $null = $Results.Add("Could not find user $($Username)")
                    continue
                }
            }
        }
        $UserId = $UserLookupCache[$Username]

        # Convert permissions to array if needed
        if ($Permissions -is [PSCustomObject]) {
            if ($Permissions.PSObject.Properties.Name -match '^\d+$') {
                $Permissions = $Permissions.PSObject.Properties.Value
            } else {
                $Permissions = @($Permissions)
            }
        }

        foreach ($Permission in $Permissions) {
            $PermissionLevels = $Permission.PermissionLevel
            $Modification = $Permission.Modification
            $AutoMap = if ($Permission.PSObject.Properties.Name -contains 'AutoMap') { $Permission.AutoMap } else { $true }

            # Handle multiple permission levels
            $PermissionLevelArray = if ($PermissionLevels -like "*,*") {
                $PermissionLevels -split ',' | ForEach-Object { $_.Trim() }
            } else {
                @($PermissionLevels.Trim())
            }

            # Extract target users from UserID (handle array of objects or single values)
            $TargetUsers = if ($Permission.UserID -is [array]) {
                $Permission.UserID | ForEach-Object {
                    if ($_ -is [PSCustomObject] -and $_.value) {
                        $_.value
                    } else {
                        $_.ToString()
                    }
                }
            } else {
                if ($Permission.UserID -is [PSCustomObject] -and $Permission.UserID.value) {
                    @($Permission.UserID.value)
                } else {
                    @($Permission.UserID.ToString())
                }
            }

            foreach ($TargetUser in $TargetUsers) {
                foreach ($PermissionLevel in $PermissionLevelArray) {

                    # Create cmdlet parameters based on permission type and action
                    $CmdletParams = @{}
                    $CmdletName = ""
                    $ExpectedResult = ""

                    switch ($PermissionLevel) {
                        'FullAccess' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('FullAccess')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) from $($Username) FullAccess permissions"
                            } else {
                                $CmdletName = 'Add-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('FullAccess')
                                    automapping  = $AutoMap
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Granted $($TargetUser) FullAccess to $($Username) with automapping $($AutoMap)"
                            }
                        }
                        'SendAs' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-RecipientPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    Trustee      = $TargetUser
                                    accessRights = @('SendAs')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) SendAs permissions from $($Username)"
                            } else {
                                $CmdletName = 'Add-RecipientPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    Trustee      = $TargetUser
                                    accessRights = @('SendAs')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Granted $($TargetUser) SendAs permissions to $($Username)"
                            }
                        }
                        'SendOnBehalf' {
                            $CmdletName = 'Set-Mailbox'
                            if ($Modification -eq 'Remove') {
                                $CmdletParams = @{
                                    Identity            = $UserId
                                    GrantSendonBehalfTo = @{
                                        '@odata.type' = '#Exchange.GenericHashTable'
                                        remove        = $TargetUser
                                    }
                                    Confirm             = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) SendOnBehalf permissions from $($Username)"
                            } else {
                                $CmdletParams = @{
                                    Identity            = $UserId
                                    GrantSendonBehalfTo = @{
                                        '@odata.type' = '#Exchange.GenericHashTable'
                                        add           = $TargetUser
                                    }
                                    Confirm             = $false
                                }
                                $ExpectedResult = "Granted $($TargetUser) SendOnBehalf permissions to $($Username)"
                            }
                        }
                        'ReadPermission' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('ReadPermission')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) ReadPermission from $($Username)"
                            }
                        }
                        'ExternalAccount' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('ExternalAccount')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) ExternalAccount permissions from $($Username)"
                            }
                        }
                        'DeleteItem' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('DeleteItem')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) DeleteItem permissions from $($Username)"
                            }
                        }
                        'ChangePermission' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('ChangePermission')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) ChangePermission from $($Username)"
                            }
                        }
                        'ChangeOwner' {
                            if ($Modification -eq 'Remove') {
                                $CmdletName = 'Remove-MailboxPermission'
                                $CmdletParams = @{
                                    Identity     = $UserId
                                    user         = $TargetUser
                                    accessRights = @('ChangeOwner')
                                    Confirm      = $false
                                }
                                $ExpectedResult = "Removed $($TargetUser) ChangeOwner permissions from $($Username)"
                            }
                        }
                    }

                    if ($CmdletName) {
                        # Generate unique GUID for this operation
                        $OperationGuid = [Guid]::NewGuid().ToString()

                        $CmdletObj = @{
                            CmdletInput = @{
                                CmdletName = $CmdletName
                                Parameters = $CmdletParams
                            }
                            OperationGuid = $OperationGuid  # Add GUID to cmdlet object
                        }

                        $CmdletMetadata = [PSCustomObject]@{
                            ExpectedResult = $ExpectedResult
                            Mailbox = $Username
                            TargetUser = $TargetUser
                            Permission = $PermissionLevel
                            Action = $Modification
                            OperationGuid = $OperationGuid
                        }

                        $null = $CmdletArray.Add($CmdletObj)
                        $null = $CmdletMetadataArray.Add($CmdletMetadata)

                        # Map GUID to metadata for precise result mapping
                        $GuidToMetadataMap[$OperationGuid] = $CmdletMetadata
                    }
                }
            }
        }
    }

    if ($CmdletArray.Count -eq 0) {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'No valid cmdlets to process' -Sev 'Warning' -tenant $TenantFilter
        $body = [pscustomobject]@{'Results' = @("No valid permission changes to process") }
        return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
        return
    }

    # Execute requests - use enhanced bulk processing with GUID mapping
    if ($CmdletArray.Count -gt 1) {
        # Use bulk processing with GUID tracking
        try {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Executing bulk request with $($CmdletArray.Count) cmdlets" -Sev 'Info' -tenant $TenantFilter
            $BulkResults = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($CmdletArray) -ReturnWithCommand $true

            # Process bulk results using GUID mapping
            if ($BulkResults -is [hashtable] -and $BulkResults.Keys.Count -gt 0) {
                foreach ($cmdletName in $BulkResults.Keys) {
                    foreach ($result in $BulkResults[$cmdletName]) {
                        $operationGuid = $result.OperationGuid

                        if ($operationGuid -and $GuidToMetadataMap.ContainsKey($operationGuid)) {
                            $metadata = $GuidToMetadataMap[$operationGuid]

                            if ($result.error) {
                                $ErrorMessage = try { (Get-CippException -Exception $result.error).NormalizedError } catch { $result.error }
                                $null = $Results.Add("Error processing $($metadata.Permission) for $($metadata.TargetUser) on $($metadata.Mailbox): $ErrorMessage")
                                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Error for operation $operationGuid`: $ErrorMessage" -Sev 'Error' -tenant $TenantFilter
                            } else {
                                $null = $Results.Add($metadata.ExpectedResult)
                                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Success for operation $operationGuid`: $($metadata.ExpectedResult)" -Sev 'Info' -tenant $TenantFilter
                            }
                        } else {
                            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Could not map result to operation. GUID: $operationGuid, Available GUIDs: $($GuidToMetadataMap.Keys -join ', ')" -Sev 'Warning' -tenant $TenantFilter

                            # Fallback for unmapped results
                            if ($result.error) {
                                $ErrorMessage = try { (Get-CippException -Exception $result.error).NormalizedError } catch { $result.error }
                                $null = $Results.Add("Error in $cmdletName`: $ErrorMessage")
                            } else {
                                $null = $Results.Add("Completed $cmdletName operation")
                            }
                        }
                    }
                }
            } else {
                # If no results returned but no error thrown, assume all succeeded
                foreach ($CmdletMetadata in $CmdletMetadataArray) {
                    if ($CmdletMetadata.ExpectedResult) {
                        $null = $Results.Add($CmdletMetadata.ExpectedResult)
                    }
                }
            }

            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Bulk request completed successfully" -Sev 'Info' -tenant $TenantFilter
        }
        catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Bulk request failed, using fallback: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter

            # Fallback to individual processing
            for ($i = 0; $i -lt $CmdletArray.Count; $i++) {
                $CmdletObj = $CmdletArray[$i]
                $CmdletMetadata = $CmdletMetadataArray[$i]
                try {
                    $null = New-ExoRequest -Anchor $CmdletMetadata.Mailbox -tenantid $TenantFilter -cmdlet $CmdletObj.CmdletInput.CmdletName -cmdParams $CmdletObj.CmdletInput.Parameters
                    $null = $Results.Add($CmdletMetadata.ExpectedResult)
                }
                catch {
                    $null = $Results.Add("Error processing $($CmdletMetadata.Permission) for $($CmdletMetadata.TargetUser) on $($CmdletMetadata.Mailbox): $($_.Exception.Message)")
                }
            }
        }
    }
    else {
        # Use individual processing for single operation
        $CmdletObj = $CmdletArray[0]
        $CmdletMetadata = $CmdletMetadataArray[0]
        try {
            $null = New-ExoRequest -Anchor $CmdletMetadata.Mailbox -tenantid $TenantFilter -cmdlet $CmdletObj.CmdletInput.CmdletName -cmdParams $CmdletObj.CmdletInput.Parameters
            $null = $Results.Add($CmdletMetadata.ExpectedResult)
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Executed $($CmdletMetadata.Permission) permission modification" -Sev 'Info' -tenant $TenantFilter
        }
        catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Permission modification failed: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter
            $null = $Results.Add("Error processing $($CmdletMetadata.Permission) for $($CmdletMetadata.TargetUser) on $($CmdletMetadata.Mailbox): $($_.Exception.Message)")
        }
    }

    $body = [pscustomobject]@{'Results' = @($Results) }
    return ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $Body
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecModifyMBPerms.ps1' 391
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecRemoveMailboxRule.ps1' -1

Function Invoke-ExecRemoveMailboxRule {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message 'Accessed this API' -Sev 'Debug'

    # Interact with the query or body of the request
    $TenantFilter = $Request.Query.TenantFilter ?? $Request.Body.TenantFilter
    $RuleName = $Request.Query.ruleName ?? $Request.Body.ruleName
    $RuleId = $Request.Query.ruleId ?? $Request.Body.ruleId
    $Username = $Request.Query.userPrincipalName ?? $Request.Body.userPrincipalName

    try {
        # Remove the rule
        $Results = Remove-CIPPMailboxRule -username $Username -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers -RuleId $RuleId -RuleName $RuleName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecRemoveMailboxRule.ps1' 36
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecRemoveRestrictedUser.ps1' -1

function Invoke-ExecRemoveRestrictedUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    .DESCRIPTION
        Removes a user from the restricted senders list in Exchange Online.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $SenderAddress = $Request.Body.SenderAddress

    try {
        if ([string]::IsNullOrEmpty($SenderAddress)) { throw 'SenderAddress parameter is required' }
        if ([string]::IsNullOrEmpty($TenantFilter)) { throw 'tenantFilter parameter is required' }

        # Remove the user from the restricted list
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-BlockedSenderAddress' -cmdParams @{SenderAddress = $SenderAddress }
        $Results = "Successfully removed $SenderAddress from the restricted users list."


        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Info' -tenant $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to remove $SenderAddress from restricted list: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecRemoveRestrictedUser.ps1' 44
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetCalendarProcessing.ps1' -1

function Invoke-ExecSetCalendarProcessing {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = 'ExecSetCalendarProcessing'
    Write-LogMessage -Headers $Request.Headers -API $APIName -message 'Accessed this API' -Sev 'Debug'

    try {
        $cmdParams = @{
            Identity                       = $Request.Body.UPN
            AutomateProcessing             = if ($Request.Body.automaticallyAccept -as [bool]) { 'AutoAccept' } elseif ($Request.Body.automaticallyProcess -as [bool]) { 'AutoUpdate' } else { 'None' }
            AllowConflicts                 = $Request.Body.allowConflicts -as [bool]
            AllowRecurringMeetings         = $Request.Body.allowRecurringMeetings -as [bool]
            ScheduleOnlyDuringWorkHours    = $Request.Body.scheduleOnlyDuringWorkHours -as [bool]
            AddOrganizerToSubject          = $Request.Body.addOrganizerToSubject -as [bool]
            DeleteComments                 = $Request.Body.deleteComments -as [bool]
            DeleteSubject                  = $Request.Body.deleteSubject -as [bool]
            RemovePrivateProperty          = $Request.Body.removePrivateProperty -as [bool]
            RemoveCanceledMeetings         = $Request.Body.removeCanceledMeetings -as [bool]
            RemoveOldMeetingMessages       = $Request.Body.removeOldMeetingMessages -as [bool]
            ProcessExternalMeetingMessages = $Request.Body.processExternalMeetingMessages -as [bool]
        }

        # Add optional numeric parameters only if they have values
        if ($Request.Body.maxConflicts) {
            $cmdParams['MaximumConflictInstances'] = $Request.Body.maxConflicts -as [int]
        }
        if ($Request.Body.maximumDurationInMinutes) {
            $cmdParams['MaximumDurationInMinutes'] = $Request.Body.maximumDurationInMinutes -as [int]
        }
        if ($Request.Body.minimumDurationInMinutes) {
            $cmdParams['MinimumDurationInMinutes'] = $Request.Body.minimumDurationInMinutes -as [int]
        }
        if ($Request.Body.bookingWindowInDays) {
            $cmdParams['BookingWindowInDays'] = $Request.Body.bookingWindowInDays -as [int]
        }
        if ($Request.Body.additionalResponse) {
            $cmdParams['AdditionalResponse'] = $Request.Body.additionalResponse
        }

        $null = New-ExoRequest -tenantid $Request.Body.tenantFilter -cmdlet 'Set-CalendarProcessing' -cmdParams $cmdParams

        $Results = "Calendar processing settings for $($Request.Body.UPN) have been updated successfully"
        Write-LogMessage -API $APIName -tenant $Request.Body.tenantFilter -message $Results -sev Info
        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not update calendar processing settings for $($Request.Body.UPN). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant $Request.Body.tenantFilter -message $Results -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetCalendarProcessing.ps1' 65
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetLitigationHold.ps1' -1

function Invoke-ExecSetLitigationHold {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message 'Accessed this API' -Sev 'Debug'

    # Interact with the query or body of the request
    $TenantFilter = $Request.Body.tenantFilter
    $LitHoldState = -not $Request.Body.disable -as [bool]
    $Identity = $Request.Body.Identity
    $UserPrincipalName = $Request.Body.UPN
    $Days = $Request.Body.days -as [int]

    # Set the parameters for the EXO request
    $ExoRequest = @{
        tenantid  = $TenantFilter
        cmdlet    = 'Set-Mailbox'
        cmdParams = @{
            Identity              = $Identity
            LitigationHoldEnabled = $LitHoldState
        }
    }

    # Add the duration of the hold if specified
    if ($Days -ne 0 -and $LitHoldState -eq $true) {
        $ExoRequest.cmdParams['LitigationHoldDuration'] = $Days
    }

    # Execute the EXO request
    try {
        $null = New-ExoRequest @ExoRequest
        $Results = "Litigation hold for $UserPrincipalName with Id $Identity has been set to $LitHoldState"
        if ($Days -ne 0 -and $LitHoldState -eq $true) {
            $Results += " for $Days days"
        }
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not set litigation hold for $UserPrincipalName with Id $Identity to $LitHoldState. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetLitigationHold.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxEmailSize.ps1' -1

Function Invoke-ExecSetMailboxEmailSize {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $User -API $APIName -message 'Accessed this API' -Sev 'Debug'

    # Interact with query parameters or the body of the request.
    $Tenant = $Request.Body.tenantFilter
    $UserPrincipalName = $Request.Body.UPN
    $UserID = $Request.Body.id
    $MaxSendSize = $Request.Body.maxSendSize
    $MaxReceiveSize = $Request.Body.maxReceiveSize

    try {
        $Params = @{
            TenantFilter      = $Tenant
            APIName           = $APIName
            Headers           = $Headers
            UserPrincipalName = $UserPrincipalName
            UserID            = $UserID
            MaxSendSize       = $MaxSendSize
            MaxReceiveSize    = $MaxReceiveSize
        }
        if ([string]::IsNullOrWhiteSpace($MaxSendSize)) { $Params.Remove('MaxSendSize') }
        if ([string]::IsNullOrWhiteSpace($MaxReceiveSize)) { $Params.Remove('MaxReceiveSize') }
        $Result = Set-CippMaxEmailSize @Params
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxEmailSize.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxLocale.ps1' -1

Function Invoke-ExecSetMailboxLocale {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $User -API $APIName -message 'Accessed this API' -Sev 'Debug'

    # Interact with query parameters or the body of the request.
    $Tenant = $Request.Body.tenantFilter
    $User = $Request.Body.user
    $Locale = $Request.Body.locale

    try {
        $Result = Set-CippMailboxLocale -username $User -locale $Locale -tenantFilter $Tenant -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxLocale.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxQuota.ps1' -1

Function Invoke-ExecSetMailboxQuota {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        $APIName = $Request.Params.CIPPEndpoint
        Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Accessed this API' -Sev 'Debug'
        $Username = $request.body.user
        $Tenantfilter = $request.body.tenantfilter
        $quota = $Request.body.quota
        $Results = try {
            if ($Request.Body.ProhibitSendQuota) {
                $quota = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $Username; ProhibitSendQuota = $quota }
                "Changed ProhibitSendQuota for $username - $($message)"
                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Changed ProhibitSendQuota for $username - $($message)" -Sev 'Info' -tenant $TenantFilter
            }
            if ($Request.Body.ProhibitSendReceiveQuota) {
                $quota = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $Username; ProhibitSendReceiveQuota = $quota }
                "Changed ProhibitSendReceiveQuota for $username - $($message)"
                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Changed ProhibitSendReceiveQuota for $username - $($message)" -Sev 'Info' -tenant $TenantFilter
            }
            if ($Request.Body.IssueWarningQuota) {
                $quota = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $Username; IssueWarningQuota = $quota }
                "Changed IssueWarningQuota for $username - $($message)"
                Write-LogMessage -headers $Request.Headers -API $APINAME -message "Changed IssueWarningQuota for $username - $($message)" -Sev 'Info' -tenant $TenantFilter
            }
        } catch {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Could not adjust mailbox quota for $($username)" -Sev 'Error' -tenant $TenantFilter
            "Could not adjust mailbox quota for $($username). Error: $($_.Exception.Message)"
        }

        $body = [pscustomobject]@{'Results' = @($results) }
    } catch {
        $body = [pscustomobject]@{'Results' = @("Could not adjust mailbox quota: $($_.Exception.message)") }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxQuota.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxRule.ps1' -1

Function Invoke-ExecSetMailboxRule {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message 'Accessed this API' -Sev 'Debug'

    # Interact with the query or body of the request
    $TenantFilter = $Request.Body.TenantFilter
    $RuleName = $Request.Body.ruleName
    $RuleId = $Request.Body.ruleId
    $Username = $Request.Body.userPrincipalName
    $Enable = $Request.Body.Enable -as [bool]
    $Disable = $Request.Body.Disable -as [bool]


    # Set the rule
    $SetCIPPMailboxRuleParams = @{
        Username     = $Username
        TenantFilter = $TenantFilter
        APIName      = $APIName
        Headers      = $Headers
        RuleId       = $RuleId
        RuleName     = $RuleName
    }
    if ($Enable -eq $true) {
        $SetCIPPMailboxRuleParams.Add('Enable', $true)
    } elseif ($Disable -eq $true) {
        $SetCIPPMailboxRuleParams.Add('Disable', $true)
    } else {
        Write-LogMessage -headers $Headers -API $APIName -message 'No state provided for mailbox rule' -Sev 'Error' -tenant $TenantFilter
        throw 'No state provided for mailbox rule'
    }

    $Results = Set-CIPPMailboxRule @SetCIPPMailboxRuleParams

    if ($Results -like '*Could not set*') {
        $StatusCode = [HttpStatusCode]::InternalServerError
    } else {
        $StatusCode = [HttpStatusCode]::OK
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetMailboxRule.ps1' 56
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetOoO.ps1' -1

function Invoke-ExecSetOoO {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        $APIName = $Request.Params.CIPPEndpoint
        $Headers = $Request.Headers



        $Username = $Request.Body.userId
        $TenantFilter = $Request.Body.tenantFilter
        $State = $Request.Body.AutoReplyState.value ?? $Request.Body.AutoReplyState
        $SplatParams = @{
            userid       = $Username
            tenantFilter = $TenantFilter
            APIName      = $APIName
            Headers      = $Headers
            State        = $State
        }

        # User action uses input, edit exchange uses InternalMessage and ExternalMessage
        # User action disable OoO doesn't send any input
        if ($Request.Body.input) {
            $SplatParams.InternalMessage = $Request.Body.input
            $SplatParams.ExternalMessage = $Request.Body.input
        } else {
            $InternalMessage = $Request.Body.InternalMessage
            $ExternalMessage = $Request.Body.ExternalMessage

            # Only add the internal and external message if they are not empty/null. Done to be able to set the OOO to disabled, while keeping the existing messages intact.
            # This works because the frontend always sends some HTML even if the fields are empty.
            if (-not [string]::IsNullOrWhiteSpace($InternalMessage)) {
                $SplatParams.InternalMessage = $InternalMessage
            }
            if (-not [string]::IsNullOrWhiteSpace($ExternalMessage)) {
                $SplatParams.ExternalMessage = $ExternalMessage
            }
        }


        # If the state is scheduled, add the start and end times to the splat params
        if ($State -eq 'Scheduled') {
            # If starttime and endtime are a number, they are unix timestamps and need to be converted to datetime, otherwise just use them.
            $StartTime = $Request.Body.StartTime -match '^\d+$' ? [DateTimeOffset]::FromUnixTimeSeconds([int]$Request.Body.StartTime).DateTime : $Request.Body.StartTime
            $EndTime = $Request.Body.EndTime -match '^\d+$' ? [DateTimeOffset]::FromUnixTimeSeconds([int]$Request.Body.EndTime).DateTime : $Request.Body.EndTime
            $SplatParams.StartTime = $StartTime
            $SplatParams.EndTime = $EndTime
        }

        $Results = Set-CIPPOutOfOffice @SplatParams
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not set Out of Office for user: $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetOoO.ps1' 71
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetRecipientLimits.ps1' -1

function Invoke-ExecSetRecipientLimits {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message 'Accessed this API' -Sev 'Debug'

    # Interact with the query or body of the request
    $TenantFilter = $Request.Body.tenantFilter
    $recipientLimit = $Request.Body.recipientLimit
    $Identity = $Request.Body.Identity
    $UserPrincipalName = $Request.Body.userid

    # Set the parameters for the EXO request
    $ExoRequest = @{
        tenantid  = $TenantFilter
        cmdlet    = 'Set-Mailbox'
        cmdParams = @{
            Identity              = $Identity
            RecipientLimits       = $recipientLimit
        }
    }

    # Execute the EXO request
    try {
        $null = New-ExoRequest @ExoRequest
        $Results = "Recipient limit for $UserPrincipalName has been set to $recipientLimit"

        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not set recipient limit for $UserPrincipalName to $recipientLimit. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetRecipientLimits.ps1' 50
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetRetentionHold.ps1' -1

function Invoke-ExecSetRetentionHold {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message 'Accessed this API' -Sev 'Debug'

    # Interact with the query or body of the request
    $TenantFilter = $Request.Body.tenantFilter
    $RetentionHoldState = -not $Request.Body.disable -as [bool]
    $Identity = $Request.Body.Identity
    $UserPrincipalName = $Request.Body.UPN

    # Set the parameters for the EXO request
    $ExoRequest = @{
        tenantid  = $TenantFilter
        cmdlet    = 'Set-Mailbox'
        cmdParams = @{
            Identity              = $Identity
            RetentionHoldEnabled = $RetentionHoldState
        }
    }

    # Execute the EXO request
    try {
        $null = New-ExoRequest @ExoRequest
        $Results = "Retention hold for $UserPrincipalName with Id $Identity has been set to $RetentionHoldState"

        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not set retention hold for $UserPrincipalName with Id $Identity to $RetentionHoldState. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Results -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecSetRetentionHold.ps1' 50
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecStartManagedFolderAssistant.ps1' -1

Function Invoke-ExecStartManagedFolderAssistant {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $Tenant = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.Id ?? $Request.Body.Id
    $UserPrincipalName = $Request.Body.UserPrincipalName
    $Identity = $ID ?? $UserPrincipalName
    $ShownName = $UserPrincipalName ?? $ID


    $ExoParams = @{
        Identity          = $Identity
        FullCrawl         = $true
    }

    try {
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Start-ManagedFolderAssistant' -cmdParams $ExoParams
        $Result = "Successfully started Managed Folder Assistant for mailbox $($ShownName)."
        $Severity = 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to start Managed Folder Assistant for mailbox $($ShownName). Error: $($ErrorMessage.NormalizedError)"
        $Severity = 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    } finally {
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Result -Sev $Severity -LogData $ErrorMessage
    }

    $Body = [pscustomobject] @{ 'Results' = $Result }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ExecStartManagedFolderAssistant.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListCalendarPermissions.ps1' -1

Function Invoke-ListCalendarPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $UserID = $Request.Query.UserID
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GetCalParam = @{Identity = $UserID; FolderScope = 'Calendar' }
        $CalendarFolder = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxFolderStatistics' -anchor $UserID -cmdParams $GetCalParam | Select-Object -First 1 -ExcludeProperty *data.type*
        $CalParam = @{Identity = "$($UserID):\$($CalendarFolder.name)" }
        $Mailbox = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{Identity = $UserID }
        $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxFolderPermission' -anchor $UserID -cmdParams $CalParam -UseSystemMailbox $true | Select-Object Identity, User, AccessRights, FolderName, @{ Name = 'MailboxInfo'; Expression = { $Mailbox } }

        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Calendar permissions listed for $($TenantFilter)" -sev Debug
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListCalendarPermissions.ps1' 36
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListContactPermissions.ps1' -1

Function Invoke-ListContactPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $UserID = $Request.Query.UserID
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GetContactParam = @{Identity = $UserID; FolderScope = 'Contacts' }
        $ContactFolder = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxFolderStatistics' -anchor $UserID -cmdParams $GetContactParam | Select-Object -First 1 -ExcludeProperty *data.type*
        $ContactParam = @{Identity = "$($UserID):\$($ContactFolder.name)" }
        $Mailbox = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{Identity = $UserID }
        $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxFolderPermission' -anchor $UserID -cmdParams $ContactParam -UseSystemMailbox $true | Select-Object Identity, User, AccessRights, FolderName, @{ Name = 'MailboxInfo'; Expression = { $Mailbox } }

        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Contact permissions listed for $($TenantFilter)" -sev Debug
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListContactPermissions.ps1' 36
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxes.ps1' -1

function Invoke-ListMailboxes {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    try {
        $Select = 'id,ExchangeGuid,ArchiveGuid,UserPrincipalName,DisplayName,PrimarySMTPAddress,RecipientType,RecipientTypeDetails,EmailAddresses,WhenSoftDeleted,IsInactiveMailbox,ForwardingSmtpAddress,DeliverToMailboxAndForward,ForwardingAddress,HiddenFromAddressListsEnabled,ExternalDirectoryObjectId,MessageCopyForSendOnBehalfEnabled,MessageCopyForSentAsEnabled,PersistedCapabilities,LitigationHoldEnabled,LitigationHoldDate,LitigationHoldDuration,ComplianceTagHoldApplied,RetentionHoldEnabled,InPlaceHolds,RetentionPolicy'
        $ExoRequest = @{
            tenantid  = $TenantFilter
            cmdlet    = 'Get-Mailbox'
            cmdParams = @{}
            Select    = $Select
        }

        $AllowedParameters = @(
            @{Parameter = 'Anr'; Type = 'String' }
            @{Parameter = 'Archive'; Type = 'Bool' }
            @{Parameter = 'Filter'; Type = 'String' }
            @{Parameter = 'GroupMailbox'; Type = 'Bool' }
            @{Parameter = 'PublicFolder'; Type = 'Bool' }
            @{Parameter = 'RecipientTypeDetails'; Type = 'String' }
            @{Parameter = 'SoftDeletedMailbox'; Type = 'Bool' }
            @{Parameter = 'Identity'; Type = 'String' }
        )

        foreach ($Param in $Request.Query.PSObject.Properties.Name) {
            $CmdParam = $AllowedParameters | Where-Object { $_.Parameter -eq $Param }
            if ($CmdParam) {
                switch ($CmdParam.Type) {
                    'String' {
                        if (![string]::IsNullOrEmpty($Request.Query.$Param)) {
                            $ExoRequest.cmdParams.$Param = $Request.Query.$Param
                        }
                    }
                    'Bool' {
                        $ParamIsTrue = $false
                        [bool]::TryParse($Request.Query.$Param, [ref]$ParamIsTrue) | Out-Null
                        if ($ParamIsTrue -eq $true) {
                            $ExoRequest.cmdParams.$Param = $true
                        }
                    }
                }
            }
        }

        $GraphRequest = (New-ExoRequest @ExoRequest) | Select-Object id, ExchangeGuid, ArchiveGuid, WhenSoftDeleted,
        @{ Name = 'UPN'; Expression = { $_.'UserPrincipalName' } },
        @{ Name = 'displayName'; Expression = { $_.'DisplayName' } },
        @{ Name = 'primarySmtpAddress'; Expression = { $_.'PrimarySMTPAddress' } },
        @{ Name = 'recipientType'; Expression = { $_.'RecipientType' } },
        @{ Name = 'recipientTypeDetails'; Expression = { $_.'RecipientTypeDetails' } },
        @{ Name = 'AdditionalEmailAddresses'; Expression = { ($_.'EmailAddresses' | Where-Object { $_ -clike 'smtp:*' }).Replace('smtp:', '') -join ', ' } },
        @{ Name = 'ForwardingSmtpAddress'; Expression = { $_.'ForwardingSmtpAddress' -replace 'smtp:', '' } },
        @{ Name = 'InternalForwardingAddress'; Expression = { $_.'ForwardingAddress' } },
        DeliverToMailboxAndForward,
        HiddenFromAddressListsEnabled,
        ExternalDirectoryObjectId,
        MessageCopyForSendOnBehalfEnabled,
        MessageCopyForSentAsEnabled,
        LitigationHoldEnabled,
        LitigationHoldDate,
        LitigationHoldDuration,
        @{ Name = 'LicensedForLitigationHold'; Expression = { ($_.PersistedCapabilities -contains 'EXCHANGE_S_ARCHIVE_ADDON' -or $_.PersistedCapabilities -contains 'EXCHANGE_S_ENTERPRISE') } },
        ComplianceTagHoldApplied,
        RetentionHoldEnabled,
        InPlaceHolds,
        RetentionPolicy
        # This select also exists in ListUserMailboxDetails and should be updated if this is changed here


        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxes.ps1' 89
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxMobileDevices.ps1' -1

Function Invoke-ListMailboxMobileDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $Mailbox = $Request.Query.Mailbox

    Write-Host $TenantFilter
    Write-Host $Mailbox

    $Bytes = [System.Text.Encoding]::UTF8.GetBytes($Mailbox)
    $base64IdentityParam = [Convert]::ToBase64String($Bytes)

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://outlook.office365.com:443/adminapi/beta/$($TenantFilter)/mailbox('$($base64IdentityParam)')/MobileDevice/Exchange.GetMobileDeviceStatistics()/?IsEncoded=True" -Tenantid $TenantFilter -scope ExchangeOnline | Select-Object @{ Name = 'clientType'; Expression = { $_.ClientType } },
        @{ Name = 'clientVersion'; Expression = { $_.ClientVersion } },
        @{ Name = 'deviceAccessState'; Expression = { $_.DeviceAccessState } },
        @{ Name = 'deviceFriendlyName'; Expression = { if ([string]::IsNullOrEmpty($_.DeviceFriendlyName)) { 'Unknown' }else { $_.DeviceFriendlyName } } },
        @{ Name = 'deviceModel'; Expression = { $_.DeviceModel } },
        @{ Name = 'deviceOS'; Expression = { $_.DeviceOS } },
        @{ Name = 'deviceType'; Expression = { $_.DeviceType } },
        @{ Name = 'firstSync'; Expression = { $_.FirstSyncTime.toString() } },
        @{ Name = 'lastSyncAttempt'; Expression = { $_.LastSyncAttemptTime.toString() } },
        @{ Name = 'lastSuccessSync'; Expression = { $_.LastSuccessSync.toString() } },
        @{ Name = 'status'; Expression = { $_.Status } },
        @{ Name = 'deviceID'; Expression = { $_.deviceID } },
        @{ Name = 'Guid'; Expression = { $_.Guid } }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxMobileDevices.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListmailboxPermissions.ps1' -1

Function Invoke-ListmailboxPermissions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.userId

    try {
        $Requests = @(
            @{
                CmdletInput = @{
                    CmdletName = 'Get-Mailbox'
                    Parameters = @{ Identity = $UserID }
                }
            }
            @{
                CmdletInput = @{
                    CmdletName = 'Get-MailboxPermission'
                    Parameters = @{ Identity = $UserID }
                }
            }
            @{
                CmdletInput = @{
                    CmdletName = 'Get-RecipientPermission'
                    Parameters = @{ Identity = $UserID }
                }
            }
        )

        $Results = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray $Requests
        $GraphRequest = foreach ($Perm in $Results) {
            if ($Perm.Trustee) {
                $Perm | Where-Object Trustee | ForEach-Object { [PSCustomObject]@{
                        User        = $_.Trustee
                        Permissions = $_.accessRights
                    }
                }
            }
            if ($Perm.AccessRights) {
                $Perm | Where-Object User | ForEach-Object { [PSCustomObject]@{
                        User        = $_.User
                        Permissions = $_.AccessRights -join ', '
                    }
                }
            }
            if ($Perm.GrantSendonBehalfTo -ne $null) {
                $Perm.GrantSendonBehalfTo | ForEach-Object { [PSCustomObject]@{
                        User        = $_
                        Permissions = 'SendOnBehalf'
                    }
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListmailboxPermissions.ps1' 71
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxRules.ps1' -1

function Invoke-ListMailboxRules {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    $Table = Get-CIPPTable -TableName cachembxrules
    if ($TenantFilter -ne 'AllTenants') {
        $Table.Filter = "PartitionKey eq 'MailboxRules' and Tenant eq '$TenantFilter'"
    } else {
        $Table.Filter = "PartitionKey eq 'MailboxRules'"
    }

    Write-Information 'Getting cached mailbox rules'
    $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-1)
    $PartitionKey = 'MailboxRules'
    $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
    $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }

    $Metadata = @{}
    # If a queue is running, we will not start a new one
    if ($RunningQueue -and !$Rows) {
        Write-Information "Queue is already running for $TenantFilter"
        $Metadata = [PSCustomObject]@{
            QueueMessage = "Still loading data for $TenantFilter. Please check back in a few more minutes"
            QueueId      = $RunningQueue.RowKey
        }
        [PSCustomObject]@{
            Waiting = $true
        }
    } elseif ((!$Rows -and !$RunningQueue) -or ($TenantFilter -eq 'AllTenants' -and ($Rows | Measure-Object).Count -eq 1)) {
        Write-Information "No cached mailbox rules found for $TenantFilter, starting new orchestration"
        if ($TenantFilter -eq 'AllTenants') {
            $Tenants = Get-Tenants -IncludeErrors | Select-Object defaultDomainName
            $Type = 'All Tenants'
        } else {
            $Tenants = @(@{ defaultDomainName = $TenantFilter })
            $Type = $TenantFilter
        }
        $Queue = New-CippQueueEntry -Name "Mailbox Rules ($Type)" -Reference $QueueReference -TotalTasks ($Tenants | Measure-Object).Count
        # If no rows are found and no queue is running, we will start a new one
        $Metadata = [PSCustomObject]@{
            QueueMessage = "Loading data for $TenantFilter. Please check back in 1 minute"
            QueueId      = $Queue.RowKey
        }

        $Batch = $Tenants | Select-Object defaultDomainName, @{Name = 'FunctionName'; Expression = { 'ListMailboxRulesQueue' } }, @{Name = 'QueueName'; Expression = { $_.defaultDomainName } }, @{Name = 'QueueId'; Expression = { $Queue.RowKey } }
        if (($Batch | Measure-Object).Count -gt 0) {
            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'ListMailboxRulesOrchestrator'
                Batch            = @($Batch)
                SkipLog          = $true
            }
            #Write-Host ($InputObject | ConvertTo-Json)
            $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
            Write-Host "Started mailbox rules orchestration with ID = '$InstanceId'"
        }

    } else {
        $Metadata = [PSCustomObject]@{
            QueueId = $RunningQueue.RowKey ?? $null
        }
        $GraphRequest = $Rows | ForEach-Object {
            $NewObj = $_.Rules | ConvertFrom-Json -ErrorAction SilentlyContinue
            $NewObj | Add-Member -NotePropertyName 'Tenant' -NotePropertyValue $_.Tenant -Force
            $NewObj
        }
    }

    # If no results are found, we will return an empty message to prevent null reference errors in the frontend
    $GraphRequest = $GraphRequest ?? @()
    $Body = @{
        Results  = @($GraphRequest)
        Metadata = $Metadata
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListMailboxRules.ps1' 89
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListOoO.ps1' -1

Function Invoke-ListOoO {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.userid
    try {
        $Results = Get-CIPPOutOfOffice -UserID $UserID -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListOoO.ps1' 31
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListRestrictedUsers.ps1' -1

function Invoke-ListRestrictedUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    .DESCRIPTION
        Lists users from the restricted senders list in Exchange Online.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $BlockedUsers = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-BlockedSenderAddress'

        if ($BlockedUsers) {
            $GraphRequest = foreach ($User in $BlockedUsers) {
                # Parse the reason to make it more readable
                $ReasonParts = $User.Reason -split ';'
                $LimitType = ($ReasonParts | Where-Object { $_ -like 'ExceedingLimitType=*' }) -replace 'ExceedingLimitType=', ''
                $InternalCount = ($ReasonParts | Where-Object { $_ -like 'InternalRecipientCountToday=*' }) -replace 'InternalRecipientCountToday=', ''
                $ExternalCount = ($ReasonParts | Where-Object { $_ -like 'ExternalRecipientCountToday=*' }) -replace 'ExternalRecipientCountToday=', ''

                [PSCustomObject]@{
                    SenderAddress   = $User.SenderAddress
                    Reason          = $User.Reason
                    BlockType       = if ($LimitType) { "$LimitType recipient limit exceeded" } else { 'Email sending limit exceeded' }
                    CreatedDatetime = $User.CreatedDatetime
                    ChangedDatetime = $User.ChangedDatetime
                    TemporaryBlock  = $User.TemporaryBlock
                    InternalCount   = $InternalCount
                    ExternalCount   = $ExternalCount
                }
            }
        } else {
            $GraphRequest = @()
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListRestrictedUsers.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListSharedMailboxStatistics.ps1' -1

Function Invoke-ListSharedMailboxStatistics {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # XXX Seems like an unused endpoint? -Bobby

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -uri "https://outlook.office365.com/adminapi/beta/$($tenantFilter)/Mailbox?RecipientTypeDetails=sharedmailbox" -Tenantid $tenantFilter -scope ExchangeOnline | ForEach-Object {
            try {
                New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxStatistics' -cmdParams @{Identity = $_.GUID }
            } catch {
                continue
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Invoke-ListSharedMailboxStatistics.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecManageRetentionPolicies.ps1' -1

Function Invoke-ExecManageRetentionPolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.RetentionPolicies.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Results = [System.Collections.Generic.List[string]]::new()
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $CmdletArray = [System.Collections.ArrayList]::new()
    $CmdletMetadataArray = [System.Collections.ArrayList]::new()
    $GuidToMetadataMap = @{}

    if ([string]::IsNullOrEmpty($TenantFilter)) {
        return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = "Tenant filter is required"
        })
        return
    }

    try {
        # Helper function to add cmdlet to bulk array
        function Add-BulkCmdlet {
            param($CmdletName, $Parameters, $ExpectedResult, $Operation, $Identity = "")

            $OperationGuid = [Guid]::NewGuid().ToString()

            $CmdletObj = @{
                CmdletInput = @{
                    CmdletName = $CmdletName
                    Parameters = $Parameters
                }
                OperationGuid = $OperationGuid
            }

            $CmdletMetadata = [PSCustomObject]@{
                ExpectedResult = $ExpectedResult
                Operation = $Operation
                Identity = $Identity
                OperationGuid = $OperationGuid
            }

            $null = $CmdletArray.Add($CmdletObj)
            $null = $CmdletMetadataArray.Add($CmdletMetadata)
            $GuidToMetadataMap[$OperationGuid] = $CmdletMetadata
        }

        # Create Retention Policies
        $CreatePolicies = $Request.body.CreatePolicies
        if ($CreatePolicies) {
            foreach ($Policy in $CreatePolicies) {
                if ([string]::IsNullOrEmpty($Policy.Name)) {
                    $Results.Add("Failed to create policy - Name is required")
                    continue
                }

                $cmdParams = @{
                    Name = $Policy.Name
                }

                if ($Policy.RetentionPolicyTagLinks) {
                    $cmdParams.RetentionPolicyTagLinks = $Policy.RetentionPolicyTagLinks
                }

                Add-BulkCmdlet -CmdletName 'New-RetentionPolicy' -Parameters $cmdParams -ExpectedResult "Successfully created retention policy: $($Policy.Name)" -Operation 'Create' -Identity $Policy.Name
            }
        }

        # Modify Retention Policies
        $ModifyPolicies = $Request.body.ModifyPolicies
        if ($ModifyPolicies) {
            foreach ($Policy in $ModifyPolicies) {
                if ([string]::IsNullOrEmpty($Policy.Identity)) {
                    $Results.Add("Failed to modify policy - Identity is required")
                    continue
                }

                $cmdParams = @{
                    Identity = $Policy.Identity
                }

                if ($Policy.Name) {
                    $cmdParams.Name = $Policy.Name
                }

                # Handle tag modifications - need to get current policy first for add/remove operations
                if ($Policy.AddTags -or $Policy.RemoveTags) {
                    try {
                        $currentPolicy = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicy' -cmdParams @{Identity = $Policy.Identity}
                        $currentTags = $currentPolicy.RetentionPolicyTagLinks
                    } catch {
                        $Results.Add("Failed to modify policy $($Policy.Identity) - Could not retrieve current policy")
                        continue
                    }

                    if ($Policy.AddTags) {
                        $newTagsList = [System.Collections.ArrayList]::new()
                        if ($currentTags) {
                            foreach ($tag in $currentTags) { $null = $newTagsList.Add($tag) }
                        }
                        foreach ($tag in $Policy.AddTags) {
                            if ($tag -notin $newTagsList) { $null = $newTagsList.Add($tag) }
                        }
                        $cmdParams.RetentionPolicyTagLinks = @($newTagsList)
                    }

                    if ($Policy.RemoveTags) {
                        $newTagsList = [System.Collections.ArrayList]::new()
                        if ($currentTags) {
                            foreach ($tag in $currentTags) {
                                if ($tag -notin $Policy.RemoveTags) { $null = $newTagsList.Add($tag) }
                            }
                        }
                        $cmdParams.RetentionPolicyTagLinks = @($newTagsList)
                    }
                } elseif ($Policy.RetentionPolicyTagLinks) {
                    $cmdParams.RetentionPolicyTagLinks = $Policy.RetentionPolicyTagLinks
                }

                Add-BulkCmdlet -CmdletName 'Set-RetentionPolicy' -Parameters $cmdParams -ExpectedResult "Successfully modified retention policy: $($Policy.Identity)" -Operation 'Modify' -Identity $Policy.Identity
            }
        }

        # Delete Retention Policies
        $DeletePolicies = $Request.body.DeletePolicies
        if ($DeletePolicies) {
            foreach ($PolicyIdentity in $DeletePolicies) {
                if ([string]::IsNullOrEmpty($PolicyIdentity)) {
                    $Results.Add("Failed to delete policy - Identity is required")
                    continue
                }

                # Check if policy is assigned to mailboxes (do this before bulk processing)
                $assignedMailboxes = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{
                    Filter = "RetentionPolicy -eq '$PolicyIdentity'"
                    ResultSize = 1
                } -ErrorAction SilentlyContinue

                if ($assignedMailboxes) {
                    $Results.Add("Cannot delete retention policy $PolicyIdentity - still assigned to mailboxes")
                    continue
                }

                Add-BulkCmdlet -CmdletName 'Remove-RetentionPolicy' -Parameters @{Identity = $PolicyIdentity; Confirm = $false} -ExpectedResult "Successfully deleted retention policy: $PolicyIdentity" -Operation 'Delete' -Identity $PolicyIdentity
            }
        }

        # Execute bulk operations
        if ($CmdletArray.Count -gt 0) {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Executing $($CmdletArray.Count) retention policy operations" -Sev 'Info' -tenant $TenantFilter

            if ($CmdletArray.Count -gt 1) {
                # Use bulk processing
                $BulkResults = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($CmdletArray) -ReturnWithCommand $true

                # Process bulk results using GUID mapping
                if ($BulkResults -is [hashtable] -and $BulkResults.Keys.Count -gt 0) {
                    foreach ($cmdletName in $BulkResults.Keys) {
                        foreach ($result in $BulkResults[$cmdletName]) {
                            $operationGuid = $result.OperationGuid

                            if ($operationGuid -and $GuidToMetadataMap.ContainsKey($operationGuid)) {
                                $metadata = $GuidToMetadataMap[$operationGuid]

                                if ($result.error) {
                                    $ErrorMessage = try { (Get-CippException -Exception $result.error).NormalizedError } catch { $result.error }
                                    $Message = "Failed to $($metadata.Operation.ToLower()) retention policy $($metadata.Identity): $ErrorMessage"
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                                    $Results.Add($Message)
                                } else {
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $metadata.ExpectedResult -Sev 'Info' -tenant $TenantFilter
                                    $Results.Add($metadata.ExpectedResult)
                                }
                            }
                        }
                    }
                }
            } else {
                # Single operation
                $CmdletObj = $CmdletArray[0]
                $CmdletMetadata = $CmdletMetadataArray[0]

                try {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $CmdletObj.CmdletInput.CmdletName -cmdParams $CmdletObj.CmdletInput.Parameters
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $CmdletMetadata.ExpectedResult -Sev 'Info' -tenant $TenantFilter
                    $Results.Add($CmdletMetadata.ExpectedResult)
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    $Message = "Failed to $($CmdletMetadata.Operation.ToLower()) retention policy $($CmdletMetadata.Identity): $ErrorMessage"
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                    $Results.Add($Message)
                }
            }
        }

        $StatusCode = [HttpStatusCode]::OK

        # Simple response logic
        if ($CreatePolicies -or $ModifyPolicies -or $DeletePolicies) {
            # For any operations, return the results messages
            $GraphRequest = @($Results)
        } else {
            # For listing, return all policies or specific policy - wrapped in try-catch
            try {
                $SpecificName = $Request.Query.name
                if ($SpecificName) {
                    # Get specific policy by name
                    $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicy' -cmdParams @{Identity = $SpecificName}
                } else {
                    # Get all policies
                    $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicy'
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                $Message = if ($Request.Query.name) {
                    "Failed to retrieve retention policy '$($Request.Query.name)': $ErrorMessage"
                } else {
                    "Failed to retrieve retention policies: $ErrorMessage"
                }
                Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                $Results.Add($Message)
                $StatusCode = [HttpStatusCode]::InternalServerError
                $GraphRequest = @($Results)
            }
        }

        # If no results are found, we will return an empty message to prevent null reference errors in the frontend
        $GraphRequest = $GraphRequest ?? @()

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $Message = "Failed to manage retention policies: $ErrorMessage"
        Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = @($Results)
    }

    # If no results are found, we will return an empty message to prevent null reference errors in the frontend
    $GraphRequest = $GraphRequest ?? @()

    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $GraphRequest
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecManageRetentionPolicies.ps1' 252
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecManageRetentionTags.ps1' -1

Function Invoke-ExecManageRetentionTags {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.RetentionPolicies.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Results = [System.Collections.Generic.List[string]]::new()
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $CmdletArray = [System.Collections.ArrayList]::new()
    $CmdletMetadataArray = [System.Collections.ArrayList]::new()
    $GuidToMetadataMap = @{}

    if ([string]::IsNullOrEmpty($TenantFilter)) {
        return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = "Tenant filter is required"
        })
        return
    }

    try {
        # Helper function to add cmdlet to bulk array
        function Add-BulkCmdlet {
            param($CmdletName, $Parameters, $ExpectedResult, $Operation, $Identity = "")

            $OperationGuid = [Guid]::NewGuid().ToString()

            $CmdletObj = @{
                CmdletInput = @{
                    CmdletName = $CmdletName
                    Parameters = $Parameters
                }
                OperationGuid = $OperationGuid
            }

            $CmdletMetadata = [PSCustomObject]@{
                ExpectedResult = $ExpectedResult
                Operation = $Operation
                Identity = $Identity
                OperationGuid = $OperationGuid
            }

            $null = $CmdletArray.Add($CmdletObj)
            $null = $CmdletMetadataArray.Add($CmdletMetadata)
            $GuidToMetadataMap[$OperationGuid] = $CmdletMetadata
        }

        # Validation function for retention tag parameters
        function Test-RetentionTagParams {
            param($Tag, $IsModification = $false)

            if (-not $IsModification) {
                if ([string]::IsNullOrEmpty($Tag.Name)) {
                    return "Tag Name is required"
                }

                if ([string]::IsNullOrEmpty($Tag.Type)) {
                    return "Tag Type is required"
                }

                # Valid tag types
                $validTypes = @('All', 'Inbox', 'SentItems', 'DeletedItems', 'Drafts', 'Outbox', 'JunkEmail', 'Journal', 'SyncIssues', 'ConversationHistory', 'Personal', 'RecoverableItems', 'NonIpmRoot', 'LegacyArchiveJournals', 'Clutter', 'Calendar', 'Notes', 'Tasks', 'Contacts', 'RssSubscriptions', 'ManagedCustomFolder')
                if ($Tag.Type -notin $validTypes) {
                    return "Invalid Type '$($Tag.Type)'. Valid types: $($validTypes -join ', ')"
                }

                # Validate RetentionAction compatibility with Type (only for creation)
                if ($Tag.RetentionAction) {
                    switch ($Tag.RetentionAction) {
                        'MoveToArchive' {
                            $allowedTypesForArchive = @('All', 'Personal', 'RecoverableItems')
                            if ($Tag.Type -notin $allowedTypesForArchive) {
                                return "RetentionAction 'MoveToArchive' can only be used with tag types: $($allowedTypesForArchive -join ', '). Current type: '$($Tag.Type)'"
                            }
                        }
                        'DeleteAndAllowRecovery' {
                            $excludedTypesForDelete = @('RecoverableItems')
                            if ($Tag.Type -in $excludedTypesForDelete) {
                                return "RetentionAction 'DeleteAndAllowRecovery' cannot be used with tag type '$($Tag.Type)'"
                            }
                        }
                        'PermanentlyDelete' {
                            $excludedTypesForPermanentDelete = @('RecoverableItems')
                            if ($Tag.Type -in $excludedTypesForPermanentDelete) {
                                return "RetentionAction 'PermanentlyDelete' cannot be used with tag type '$($Tag.Type)'"
                            }
                        }
                    }
                }

                # Validate RetentionEnabled and RetentionAction relationship (only for creation)
                if ($Tag.RetentionEnabled -eq $true -and [string]::IsNullOrEmpty($Tag.RetentionAction)) {
                    return "RetentionAction is required when RetentionEnabled is set to true"
                }
            }

            # Common validations for both create and modify
            if ($Tag.Name) {
                if ($Tag.Name -match '[\\/:*?\"<>|]') {
                    return "Tag name contains invalid characters. Avoid using: \ / : * ? `" < > |"
                }

                if ($Tag.Name.Length -gt 64) {
                    return "Tag name cannot exceed 64 characters"
                }
            }

            if ($Tag.RetentionAction) {
                $validActions = @('DeleteAndAllowRecovery', 'PermanentlyDelete', 'MoveToArchive', 'MarkAsPastRetentionLimit')
                if ($Tag.RetentionAction -notin $validActions) {
                    return "Invalid RetentionAction '$($Tag.RetentionAction)'. Valid actions: $($validActions -join ', ')"
                }
            }

            if ($Tag.AgeLimitForRetention -and ($Tag.AgeLimitForRetention -lt 0 -or $Tag.AgeLimitForRetention -gt 24855)) {
                return "AgeLimitForRetention must be between 0 and 24855 days"
            }

            return $null
        }

        # Create Retention Tags
        $CreateTags = $Request.body.CreateTags
        if ($CreateTags) {
            foreach ($Tag in $CreateTags) {
                $validationError = Test-RetentionTagParams -Tag $Tag -IsModification $false
                if ($validationError) {
                    $Results.Add("Failed to create tag '$($Tag.Name)': $validationError")
                    continue
                }

                $cmdParams = @{
                    Name = $Tag.Name
                    Type = $Tag.Type
                }

                if ($Tag.AgeLimitForRetention) {
                    $cmdParams.AgeLimitForRetention = $Tag.AgeLimitForRetention
                }

                if ($Tag.RetentionAction) {
                    $cmdParams.RetentionAction = $Tag.RetentionAction
                }

                if ($Tag.Comment) {
                    $cmdParams.Comment = $Tag.Comment
                }

                if ($Tag.RetentionEnabled -ne $null) {
                    $cmdParams.RetentionEnabled = $Tag.RetentionEnabled
                }

                if ($Tag.LocalizedComment) {
                    $cmdParams.LocalizedComment = $Tag.LocalizedComment
                }

                if ($Tag.LocalizedRetentionPolicyTagName) {
                    $cmdParams.LocalizedRetentionPolicyTagName = $Tag.LocalizedRetentionPolicyTagName
                }

                $resultParts = [System.Collections.ArrayList]::new()
                $null = $resultParts.Add("Successfully created retention tag: $($Tag.Name) (Type: $($Tag.Type)")
                if ($Tag.RetentionAction) { $null = $resultParts.Add(", Action: $($Tag.RetentionAction)") }
                if ($Tag.AgeLimitForRetention) { $null = $resultParts.Add(", Age: $($Tag.AgeLimitForRetention) days") }
                $null = $resultParts.Add(")")
                $expectedResult = $resultParts -join ""

                Add-BulkCmdlet -CmdletName 'New-RetentionPolicyTag' -Parameters $cmdParams -ExpectedResult $expectedResult -Operation 'Create' -Identity $Tag.Name
            }
        }

        # Modify Retention Tags
        $ModifyTags = $Request.body.ModifyTags
        if ($ModifyTags) {
            foreach ($Tag in $ModifyTags) {
                if ([string]::IsNullOrEmpty($Tag.Identity)) {
                    $Results.Add("Failed to modify tag - Identity is required")
                    continue
                }

                # Use basic validation for modifications
                $validationError = Test-RetentionTagParams -Tag $Tag -IsModification $true
                if ($validationError) {
                    $Results.Add("Failed to modify tag '$($Tag.Identity)': $validationError")
                    continue
                }

                $cmdParams = @{
                    Identity = $Tag.Identity
                }

                if ($Tag.Name) {
                    $cmdParams.Name = $Tag.Name
                }

                if ($Tag.AgeLimitForRetention) {
                    $cmdParams.AgeLimitForRetention = $Tag.AgeLimitForRetention
                }

                if ($Tag.RetentionAction) {
                    $cmdParams.RetentionAction = $Tag.RetentionAction
                }

                if ($Tag.Comment) {
                    $cmdParams.Comment = $Tag.Comment
                }

                if ($Tag.RetentionEnabled -ne $null) {
                    $cmdParams.RetentionEnabled = $Tag.RetentionEnabled
                }

                if ($Tag.LocalizedComment) {
                    $cmdParams.LocalizedComment = $Tag.LocalizedComment
                }

                if ($Tag.LocalizedRetentionPolicyTagName) {
                    $cmdParams.LocalizedRetentionPolicyTagName = $Tag.LocalizedRetentionPolicyTagName
                }

                Add-BulkCmdlet -CmdletName 'Set-RetentionPolicyTag' -Parameters $cmdParams -ExpectedResult "Successfully modified retention tag: $($Tag.Identity)" -Operation 'Modify' -Identity $Tag.Identity
            }
        }

        # Delete Retention Tags
        $DeleteTags = $Request.body.DeleteTags
        if ($DeleteTags) {
            foreach ($TagIdentity in $DeleteTags) {
                if ([string]::IsNullOrEmpty($TagIdentity)) {
                    $Results.Add("Failed to delete tag - Identity is required")
                    continue
                }

                # Check if tag is used in any retention policies
                $AllPolicies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicy' -ErrorAction SilentlyContinue
                $policiesUsingTag = $AllPolicies | Where-Object {
                    $_.RetentionPolicyTagLinks -contains $TagIdentity
                }

                if ($policiesUsingTag) {
                    $policyNames = ($policiesUsingTag | ForEach-Object { $_.Name }) -join ', '
                    $Results.Add("Cannot delete retention tag '$TagIdentity' - still used in policies: $policyNames")
                    continue
                }

                Add-BulkCmdlet -CmdletName 'Remove-RetentionPolicyTag' -Parameters @{Identity = $TagIdentity; Confirm = $false} -ExpectedResult "Successfully deleted retention tag: $TagIdentity" -Operation 'Delete' -Identity $TagIdentity
            }
        }

        # Execute bulk operations
        if ($CmdletArray.Count -gt 0) {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Executing $($CmdletArray.Count) retention tag operations" -Sev 'Info' -tenant $TenantFilter

            if ($CmdletArray.Count -gt 1) {
                # Use bulk processing
                $BulkResults = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($CmdletArray) -ReturnWithCommand $true

                # Process bulk results using GUID mapping
                if ($BulkResults -is [hashtable] -and $BulkResults.Keys.Count -gt 0) {
                    foreach ($cmdletName in $BulkResults.Keys) {
                        foreach ($result in $BulkResults[$cmdletName]) {
                            $operationGuid = $result.OperationGuid

                            if ($operationGuid -and $GuidToMetadataMap.ContainsKey($operationGuid)) {
                                $metadata = $GuidToMetadataMap[$operationGuid]

                                if ($result.error) {
                                    $ErrorMessage = try { (Get-CippException -Exception $result.error).NormalizedError } catch { $result.error }
                                    $Message = "Failed to $($metadata.Operation.ToLower()) retention tag $($metadata.Identity): $ErrorMessage"
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                                    $Results.Add($Message)
                                } else {
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $metadata.ExpectedResult -Sev 'Info' -tenant $TenantFilter
                                    $Results.Add($metadata.ExpectedResult)
                                }
                            }
                        }
                    }
                }
            } else {
                # Single operation
                $CmdletObj = $CmdletArray[0]
                $CmdletMetadata = $CmdletMetadataArray[0]

                try {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $CmdletObj.CmdletInput.CmdletName -cmdParams $CmdletObj.CmdletInput.Parameters
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $CmdletMetadata.ExpectedResult -Sev 'Info' -tenant $TenantFilter
                    $Results.Add($CmdletMetadata.ExpectedResult)
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    $Message = "Failed to $($CmdletMetadata.Operation.ToLower()) retention tag $($CmdletMetadata.Identity): $ErrorMessage"
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                    $Results.Add($Message)
                }
            }
        }

        $StatusCode = [HttpStatusCode]::OK

        # Simple response logic
        if ($CreateTags -or $ModifyTags -or $DeleteTags) {
            # For any operations, return the results messages
            $GraphRequest = @($Results)
        } else {
            # For listing, return all tags or specific tag - wrapped in try-catch
            try {
                $SpecificName = $Request.Query.name
                if ($SpecificName) {
                    # Get specific tag by name
                    $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicyTag' -cmdParams @{Identity = $SpecificName}
                } else {
                    # Get all tags
                    $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-RetentionPolicyTag'
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                $Message = if ($Request.Query.name) {
                    "Failed to retrieve retention tag '$($Request.Query.name)': $ErrorMessage"
                } else {
                    "Failed to retrieve retention tags: $ErrorMessage"
                }
                Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                $Results.Add($Message)
                $StatusCode = [HttpStatusCode]::InternalServerError
                $GraphRequest = @($Results)
            }
        }

        # If no results are found, we will return an empty message to prevent null reference errors in the frontend
        $GraphRequest = $GraphRequest ?? @()

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $Message = "Failed to manage retention tags: $ErrorMessage"
        Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = @($Results)
    }

    # If no results are found, we will return an empty message to prevent null reference errors in the frontend
    $GraphRequest = $GraphRequest ?? @()

    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $GraphRequest
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecManageRetentionTags.ps1' 353
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecSetMailboxRetentionPolicies.ps1' -1

Function Invoke-ExecSetMailboxRetentionPolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Results = [System.Collections.Generic.List[string]]::new()
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $CmdletArray = [System.Collections.ArrayList]::new()
    $CmdletMetadataArray = [System.Collections.ArrayList]::new()
    $GuidToMetadataMap = @{}

    if ([string]::IsNullOrEmpty($TenantFilter)) {
        return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = "Tenant filter is required"
        })
        return
    }

    try {
        $PolicyName = $Request.body.PolicyName
        $Mailboxes = $Request.body.Mailboxes

        # Validate required parameters
        if ([string]::IsNullOrEmpty($PolicyName)) {
            return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = "PolicyName is required"
            })
            return
        }

        if (-not $Mailboxes -or $Mailboxes.Count -eq 0) {
            return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = "Mailboxes array is required"
            })
            return
        }

        # Helper function to add cmdlet to bulk array
        function Add-BulkCmdlet {
            param($CmdletName, $Parameters, $MailboxIdentity)

            $OperationGuid = [Guid]::NewGuid().ToString()

            $CmdletObj = @{
                CmdletInput = @{
                    CmdletName = $CmdletName
                    Parameters = $Parameters
                }
                OperationGuid = $OperationGuid
            }

            $CmdletMetadata = [PSCustomObject]@{
                MailboxIdentity = $MailboxIdentity
                OperationGuid = $OperationGuid
            }

            $null = $CmdletArray.Add($CmdletObj)
            $null = $CmdletMetadataArray.Add($CmdletMetadata)
            $GuidToMetadataMap[$OperationGuid] = $CmdletMetadata
        }

        # Process each mailbox
        foreach ($MailboxIdentity in $Mailboxes) {
            if ([string]::IsNullOrEmpty($MailboxIdentity)) {
                $Results.Add("Failed to apply retention policy to empty mailbox identity")
                continue
            }

            Add-BulkCmdlet -CmdletName 'Set-Mailbox' -Parameters @{Identity = $MailboxIdentity; RetentionPolicy = $PolicyName} -MailboxIdentity $MailboxIdentity
        }

        # Execute bulk operations
        if ($CmdletArray.Count -gt 0) {
            Write-LogMessage -headers $Request.Headers -API $APINAME -message "Applying retention policy '$PolicyName' to $($CmdletArray.Count) mailboxes" -Sev 'Info' -tenant $TenantFilter

            if ($CmdletArray.Count -gt 1) {
                # Use bulk processing
                $BulkResults = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($CmdletArray) -ReturnWithCommand $true

                # Process bulk results using GUID mapping
                if ($BulkResults -is [hashtable] -and $BulkResults.Keys.Count -gt 0) {
                    foreach ($cmdletName in $BulkResults.Keys) {
                        foreach ($result in $BulkResults[$cmdletName]) {
                            $operationGuid = $result.OperationGuid

                            if ($operationGuid -and $GuidToMetadataMap.ContainsKey($operationGuid)) {
                                $metadata = $GuidToMetadataMap[$operationGuid]

                                if ($result.error) {
                                    $ErrorMessage = try { (Get-CippException -Exception $result.error).NormalizedError } catch { $result.error }
                                    $Message = "Failed to apply retention policy '$PolicyName' to $($metadata.MailboxIdentity): $ErrorMessage"
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                                    $Results.Add($Message)
                                } else {
                                    $Message = "Successfully applied retention policy '$PolicyName' to $($metadata.MailboxIdentity)"
                                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Info' -tenant $TenantFilter
                                    $Results.Add($Message)
                                }
                            }
                        }
                    }
                }
            } else {
                # Single operation
                $CmdletObj = $CmdletArray[0]
                $CmdletMetadata = $CmdletMetadataArray[0]

                try {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $CmdletObj.CmdletInput.CmdletName -cmdParams $CmdletObj.CmdletInput.Parameters
                    $Message = "Successfully applied retention policy '$PolicyName' to $($CmdletMetadata.MailboxIdentity)"
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Info' -tenant $TenantFilter
                    $Results.Add($Message)
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    $Message = "Failed to apply retention policy '$PolicyName' to $($CmdletMetadata.MailboxIdentity): $ErrorMessage"
                    Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
                    $Results.Add($Message)
                }
            }
        }

        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $Message = "Failed to set mailbox retention policies: $ErrorMessage"
        Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Error' -tenant $TenantFilter
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = @{ Results = @($Results) }
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Administration/Mailbox Retention/Invoke-ExecSetMailboxRetentionPolicies.ps1' 146
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListAntiPhishingFilters.ps1' -1

function Invoke-ListAntiPhishingFilters {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    $Policies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-AntiPhishPolicy' | Select-Object -Property *
    $Rules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-AntiPhishRule' | Select-Object -Property *

    $Output = $Policies | Select-Object -Property *,
    @{ Name = 'RuleName'; Expression = { foreach ($item in $Rules) { if ($item.AntiPhishPolicy -eq $_.Name) { $item.Name } } } },
    @{ Name = 'Priority'; Expression = { foreach ($item in $Rules) { if ($item.AntiPhishPolicy -eq $_.Name) { $item.Priority } } } },
    @{ Name = 'RecipientDomainIs'; Expression = { foreach ($item in $Rules) { if ($item.AntiPhishPolicy -eq $_.Name) { $item.RecipientDomainIs } } } },
    @{ Name = 'State'; Expression = { foreach ($item in $Rules) { if ($item.AntiPhishPolicy -eq $_.Name) { $item.State } } } }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Output
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListAntiPhishingFilters.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListGlobalAddressList.ps1' -1

Function Invoke-ListGlobalAddressList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GAL = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Recipient' -cmdParams @{ResultSize = 'unlimited'; SortBy = 'DisplayName' } `
            -Select 'Identity, DisplayName, Alias, PrimarySmtpAddress, ExternalDirectoryObjectId, HiddenFromAddressListsEnabled, EmailAddresses, IsDirSynced, SKUAssigned, RecipientType, RecipientTypeDetails, AddressListMembership' |
            Select-Object -ExcludeProperty *odata*, *data.type*
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $StatusCode = [HttpStatusCode]::Forbidden
        $GAL = $ErrorMessage.NormalizedError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GAL)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListGlobalAddressList.ps1' 29
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListMailboxCAS.ps1' -1

Function Invoke-ListMailboxCAS {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -uri "https://outlook.office365.com/adminapi/beta/$($tenantfilter)/CasMailbox" -Tenantid $tenantfilter -scope ExchangeOnline | Select-Object @{ Name = 'displayName'; Expression = { $_.'DisplayName' } },
        @{ Name = 'primarySmtpAddress'; Expression = { $_.'PrimarySMTPAddress' } },
        @{ Name = 'ecpenabled'; Expression = { $_.'ECPEnabled' } },
        @{ Name = 'owaenabled'; Expression = { $_.'OWAEnabled' } },
        @{ Name = 'imapenabled'; Expression = { $_.'IMAPEnabled' } },
        @{ Name = 'popenabled'; Expression = { $_.'POPEnabled' } },
        @{ Name = 'mapienabled'; Expression = { $_.'MAPIEnabled' } },
        @{ Name = 'ewsenabled'; Expression = { $_.'EWSEnabled' } },
        @{ Name = 'activesyncenabled'; Expression = { $_.'ActiveSyncEnabled' } }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListMailboxCAS.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListMalwareFilters.ps1' -1

function Invoke-ListMalwareFilters {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $Policies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MalwareFilterPolicy' | Select-Object -Property *
    $Rules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MalwareFilterRule' | Select-Object -Property *

    $Output = $Policies | Select-Object -Property *,
    @{ Name = 'RuleName'; Expression = { foreach ($item in $Rules) { if ($item.MalwareFilterPolicy -eq $_.Name) { $item.Name } } } },
    @{ Name = 'Priority'; Expression = { foreach ($item in $Rules) { if ($item.MalwareFilterPolicy -eq $_.Name) { $item.Priority } } } },
    @{ Name = 'RecipientDomainIs'; Expression = { foreach ($item in $Rules) { if ($item.MalwareFilterPolicy -eq $_.Name) { $item.RecipientDomainIs } } } },
    @{ Name = 'State'; Expression = { foreach ($item in $Rules) { if ($item.MalwareFilterPolicy -eq $_.Name) { $item.State } } } }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Output
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListMalwareFilters.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListSafeAttachmentsFilters.ps1' -1

function Invoke-ListSafeAttachmentsFilters {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    $Policies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeAttachmentPolicy' | Select-Object -Property *
    $Rules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeAttachmentRule' | Select-Object -Property *

    $Output = $Policies | Select-Object -Property *,
    @{ Name = 'RuleName'; Expression = { foreach ($item in $Rules) { if ($item.SafeAttachmentPolicy -eq $_.Name) { $item.Name } } } },
    @{ Name = 'Priority'; Expression = { foreach ($item in $Rules) { if ($item.SafeAttachmentPolicy -eq $_.Name) { $item.Priority } } } },
    @{ Name = 'RecipientDomainIs'; Expression = { foreach ($item in $Rules) { if ($item.SafeAttachmentPolicy -eq $_.Name) { $item.RecipientDomainIs } } } },
    @{ Name = 'State'; Expression = { foreach ($item in $Rules) { if ($item.SafeAttachmentPolicy -eq $_.Name) { $item.State } } } }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Output
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListSafeAttachmentsFilters.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListSharedMailboxAccountEnabled.ps1' -1

function Invoke-ListSharedMailboxAccountEnabled {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $Request.Query.tenantFilter

    # Get Shared Mailbox Stuff
    try {
        $SharedMailboxList = (New-GraphGetRequest -uri "https://outlook.office365.com/adminapi/beta/$($TenantFilter)/Mailbox?`$filter=RecipientTypeDetails eq 'SharedMailbox'" -Tenantid $TenantFilter -scope ExchangeOnline)
        $AllUsersInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/users?$select=id,userPrincipalName,accountEnabled,displayName,givenName,surname,onPremisesSyncEnabled,assignedLicenses' -tenantid $TenantFilter
        $SharedMailboxDetails = foreach ($SharedMailbox in $SharedMailboxList) {
            # Match the User
            $User = $AllUsersInfo | Where-Object { $_.userPrincipalName -eq $SharedMailbox.userPrincipalName } | Select-Object -First 1

            if ($User) {
                # Return all shared mailboxes with license information
                [PSCustomObject]@{
                    UserPrincipalName     = $User.userPrincipalName
                    displayName           = $User.displayName
                    givenName             = $User.givenName
                    surname               = $User.surname
                    accountEnabled        = $User.accountEnabled
                    assignedLicenses      = $User.assignedLicenses
                    id                    = $User.id
                    onPremisesSyncEnabled = $User.onPremisesSyncEnabled
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $StatusCode = [HttpStatusCode]::InternalServerError
        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Shared Mailbox List on $($TenantFilter). Error: $($_.exception.message)" -sev 'Error'
    }
    $GraphRequest = $SharedMailboxDetails
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Reports/Invoke-ListSharedMailboxAccountEnabled.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddEquipmentMailbox.ps1' -1

Function Invoke-AddEquipmentMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Equipment.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenant = $Request.Body.tenantID

    $Results = [System.Collections.Generic.List[Object]]::new()
    $MailboxObject = $Request.Body

    # Create the equipment mailbox
    $NewMailboxParams = @{
        Name               = $MailboxObject.username
        DisplayName        = $MailboxObject.displayName
        Equipment          = $true
        PrimarySmtpAddress = $MailboxObject.userPrincipalName
    }

    try {
        # Create the equipment mailbox
        $AddEquipmentRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-Mailbox' -cmdParams $NewMailboxParams
        $Results.Add("Successfully created equipment mailbox: $($MailboxObject.displayName)")

        # Block sign-in for the mailbox
        try {
            $null = Set-CIPPSignInState -userid $AddEquipmentRequest.ExternalDirectoryObjectId -TenantFilter $Tenant -APIName $APINAME -Headers $Headers -AccountEnabled $false
            $Results.Add("Successfully blocked sign-in for Equipment mailbox $($MailboxObject.userPrincipalName)")
        } catch {
            $ErrorMessage = $_.Exception.Message
            $Results.Add("Failed to block sign-in for Equipment mailbox: $($MailboxObject.userPrincipalName). Error: $ErrorMessage")
        }
        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Created equipment mailbox $($MailboxObject.displayName)" -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create equipment mailbox: $($MailboxObject.displayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $Body = [pscustomobject]@{ 'Results' = @($Results) }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddEquipmentMailbox.ps1' 59
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddRoomList.ps1' -1

Function Invoke-AddRoomList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenant = $Request.Body.tenantFilter ?? $Request.Body.tenantid

    $Results = [System.Collections.Generic.List[Object]]::new()
    $RoomListObject = $Request.Body

    # Construct email address from username and domain
    $EmailAddress = if ($RoomListObject.primDomain.value) {
        "$($RoomListObject.username)@$($RoomListObject.primDomain.value)"
    } else {
        "$($RoomListObject.username)@$($Tenant)"
    }

    # Parameters for New-DistributionGroup with RoomList
    $AddRoomListParams = @{
        Name               = $RoomListObject.username
        DisplayName        = $RoomListObject.displayName
        RoomList           = $true
        PrimarySMTPAddress = $EmailAddress
    }

    try {
        $AddRoomListRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-DistributionGroup' -cmdParams $AddRoomListParams
        $Results.Add("Successfully created room list: $($RoomListObject.displayName).")
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $Tenant -message "Created room list $($RoomListObject.displayName) with id $($AddRoomListRequest.identity)" -Sev 'Info'

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create room list: $($RoomListObject.displayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    $Body = [pscustomobject] @{ 'Results' = @($Results) }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddRoomList.ps1' 55
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddRoomMailbox.ps1' -1

Function Invoke-AddRoomMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenant = $Request.Body.tenantid

    $Results = [System.Collections.Generic.List[Object]]::new()
    $MailboxObject = $Request.Body
    $AddRoomParams = [pscustomobject]@{
        Name               = $MailboxObject.username
        DisplayName        = $MailboxObject.displayName
        Room               = $true
        PrimarySMTPAddress = $MailboxObject.userPrincipalName
        ResourceCapacity   = if (![string]::IsNullOrWhiteSpace($MailboxObject.ResourceCapacity)) { $MailboxObject.ResourceCapacity } else { $null }

    }
    # Interact with query parameters or the body of the request.
    try {
        $AddRoomRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-Mailbox' -cmdParams $AddRoomParams
        $Results.Add("Successfully created room: $($MailboxObject.DisplayName).")
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $Tenant -message "Created room $($MailboxObject.DisplayName) with id $($AddRoomRequest.id)" -Sev 'Info'

        # Block sign-in for the mailbox
        try {
            $null = Set-CIPPSignInState -userid $AddRoomRequest.ExternalDirectoryObjectId -TenantFilter $Tenant -APIName $APINAME -Headers $Headers -AccountEnabled $false
            $Results.Add("Successfully blocked sign-in for Room mailbox $($MailboxObject.userPrincipalName)")
        } catch {
            $ErrorMessage = $_.Exception.Message
            $Results.Add("Failed to block sign-in for Room mailbox: $($MailboxObject.userPrincipalName). Error: $ErrorMessage")
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create room mailbox: $($MailboxObject.DisplayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $Tenant -message $Message -Sev 'Error' -LogData $ErrorMessage
        $Results.Add($Message)
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    $Body = [pscustomobject] @{ 'Results' = @($Results) }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-AddRoomMailbox.ps1' 56
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditEquipmentMailbox.ps1' -1

Function Invoke-EditEquipmentMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Equipment.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $Tenant = $Request.Body.tenantID

    $Results = [System.Collections.Generic.List[Object]]::new()
    $MailboxObject = $Request.Body

    # First update the mailbox properties
    $UpdateMailboxParams = @{
        Identity    = $MailboxObject.equipmentId
        DisplayName = $MailboxObject.displayName
    }

    if (![string]::IsNullOrWhiteSpace($MailboxObject.hiddenFromAddressListsEnabled)) {
        $UpdateMailboxParams.Add('HiddenFromAddressListsEnabled', $MailboxObject.hiddenFromAddressListsEnabled)
    }

    # Then update the user properties
    $UpdateUserParams = @{
        Identity = $MailboxObject.equipmentId
    }

    # Add optional parameters if they exist
    $UserProperties = @(
        'Location', 'Department', 'Company',
        'Phone', 'Tags',
        'StreetAddress', 'City', 'StateOrProvince', 'CountryOrRegion',
        'PostalCode'
    )

    foreach ($prop in $UserProperties) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdateUserParams[$prop] = $MailboxObject.$prop
        }
    }

    # Then update the calendar properties
    $UpdateCalendarParams = @{
        Identity = $MailboxObject.equipmentId
    }

    $CalendarProperties = @(
        'AllowConflicts', 'AllowRecurringMeetings', 'BookingWindowInDays',
        'MaximumDurationInMinutes', 'ProcessExternalMeetingMessages',
        'ForwardRequestsToDelegates', 'ScheduleOnlyDuringWorkHours', 'AutomateProcessing'
    )

    foreach ($prop in $CalendarProperties) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdateCalendarParams[$prop] = $MailboxObject.$prop
        }
    }

    # Then update the calendar configuration
    $UpdateCalendarConfigParams = @{
        Identity = $MailboxObject.equipmentId
    }

    $CalendarConfiguration = @(
        'WorkDays', 'WorkHoursStartTime', 'WorkHoursEndTime', 'WorkingHoursTimeZone'
    )

    foreach ($prop in $CalendarConfiguration) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdateCalendarConfigParams[$prop] = $MailboxObject.$prop
        }
    }

    try {
        # Update mailbox properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Mailbox' -cmdParams $UpdateMailboxParams

        # Update user properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-User' -cmdParams $UpdateUserParams
        $Results.Add("Successfully updated equipment: $($MailboxObject.DisplayName) (User Properties)")

        # Update calendar properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-CalendarProcessing' -cmdParams $UpdateCalendarParams
        $Results.Add("Successfully updated equipment: $($MailboxObject.DisplayName) (Calendar Properties)")

        # Update calendar configuration properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailboxCalendarConfiguration' -cmdParams $UpdateCalendarConfigParams
        $Results.Add("Successfully updated equipment: $($MailboxObject.DisplayName) (Calendar Configuration)")

        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Updated equipment $($MailboxObject.DisplayName)" -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Failed to update equipment: $($MailboxObject.DisplayName). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $Results.Add("Failed to update Equipment mailbox $($MailboxObject.userPrincipalName). $($ErrorMessage.NormalizedError)")
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $Body = [pscustomobject]@{ 'Results' = @($Results) }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditEquipmentMailbox.ps1' 113
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditRoomList.ps1' -1

Function Invoke-EditRoomList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Results = [System.Collections.Generic.List[string]]::new()
    $RoomListObj = $Request.Body
    $GroupId = $RoomListObj.groupId
    $TenantId = $RoomListObj.tenantFilter

    try {
        # Edit basic room list properties
        if ($RoomListObj.displayName -or $RoomListObj.description -or $RoomListObj.mailNickname) {
            $SetRoomListParams = @{
                Identity = $GroupId
            }

            if ($RoomListObj.displayName) {
                $SetRoomListParams.DisplayName = $RoomListObj.displayName
            }

            if ($RoomListObj.description) {
                $SetRoomListParams.Description = $RoomListObj.description
            }

            if ($RoomListObj.mailNickname) {
                $SetRoomListParams.Name = $RoomListObj.mailNickname
            }

            try {
                $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-DistributionGroup' -cmdParams $SetRoomListParams -useSystemMailbox $true
                $Results.Add("Successfully updated room list properties for $($RoomListObj.displayName)")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Updated room list properties for $($RoomListObj.displayName)" -Sev 'Info'
            } catch {
                $Results.Add("Failed to update room list properties: $($_.Exception.Message)")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to update room list properties: $($_.Exception.Message)" -Sev 'Error'
            }
        }

        # Add room members
        if ($RoomListObj.AddMember) {
            foreach ($Member in $RoomListObj.AddMember) {
                try {
                    $MemberEmail = if ($Member.value) { $Member.value } else { $Member }
                    $AddMemberParams = @{
                        Identity                        = $GroupId
                        Member                          = $MemberEmail
                        BypassSecurityGroupManagerCheck = $true
                    }

                    $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Add-DistributionGroupMember' -cmdParams $AddMemberParams -useSystemMailbox $true
                    $Results.Add("Successfully added room $MemberEmail to room list")
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Added room $MemberEmail to room list $GroupId" -Sev 'Info'
                } catch {
                    $Results.Add("Failed to add room $MemberEmail : $($_.Exception.Message)")
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to add room $MemberEmail : $($_.Exception.Message)" -Sev 'Error'
                }
            }
        }

        # Remove room members
        if ($RoomListObj.RemoveMember) {
            foreach ($Member in $RoomListObj.RemoveMember) {
                try {
                    $MemberEmail = if ($Member.value) { $Member.value } else { $Member }
                    $RemoveMemberParams = @{
                        Identity                        = $GroupId
                        Member                          = $MemberEmail
                        BypassSecurityGroupManagerCheck = $true
                    }

                    $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Remove-DistributionGroupMember' -cmdParams $RemoveMemberParams -useSystemMailbox $true
                    $Results.Add("Successfully removed room $MemberEmail from room list")
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Removed room $MemberEmail from room list $GroupId" -Sev 'Info'
                } catch {
                    $Results.Add("Failed to remove room $MemberEmail from room list: $($_.Exception.Message)")
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to remove room $MemberEmail from room list: $($_.Exception.Message)" -Sev 'Error'
                }
            }
        }

        # Handle owners (ManagedBy property)
        if ($RoomListObj.AddOwner -or $RoomListObj.RemoveOwner) {
            try {
                # Get current owners
                $CurrentGroup = New-ExoRequest -tenantid $TenantId -cmdlet 'Get-DistributionGroup' -cmdParams @{ Identity = $GroupId } -useSystemMailbox $true
                $CurrentOwners = [System.Collections.Generic.List[string]]::new()

                if ($CurrentGroup.ManagedBy) {
                    # Convert ManagedBy objects to strings explicitly
                    foreach ($ManagedByItem in $CurrentGroup.ManagedBy) {
                        $StringValue = [string]$ManagedByItem
                        $CurrentOwners.Add($StringValue)
                    }
                }

                # Remove owners
                if ($RoomListObj.RemoveOwner) {
                    foreach ($Owner in $RoomListObj.RemoveOwner) {
                        $OwnerToRemove = if ($Owner.addedFields.id) { $Owner.addedFields.id } else { $Owner.value }
                        if ($CurrentOwners -contains $OwnerToRemove) {
                            $CurrentOwners.Remove($OwnerToRemove)
                            $Results.Add("Removed owner $(if ($Owner.label) { $Owner.label } else { $OwnerToRemove }) from room list")
                        }
                    }
                }

                # Add owners
                if ($RoomListObj.AddOwner) {
                    foreach ($Owner in $RoomListObj.AddOwner) {
                        $OwnerToAdd = if ($Owner.addedFields.id) { $Owner.addedFields.id } else { $Owner.value }
                        if ($CurrentOwners -notcontains $OwnerToAdd) {
                            $CurrentOwners.Add($OwnerToAdd)
                            $Results.Add("Added owner $(if ($Owner.label) { $Owner.label } else { $OwnerToAdd }) to room list")
                        }
                    }
                }

                # Update ManagedBy with new owners list
                $SetOwnersParams = @{
                    Identity  = $GroupId
                    ManagedBy = $CurrentOwners.ToArray()
                }

                $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-DistributionGroup' -cmdParams $SetOwnersParams -useSystemMailbox $true
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Updated owners for room list $GroupId" -Sev 'Info'
            } catch {
                $Results.Add("Failed to update room list owners: $($_.Exception.Message)")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to update room list owners: $($_.Exception.Message)" -Sev 'Error'
            }
        }

        # Handle external email settings
        if ($null -ne $RoomListObj.allowExternal) {
            try {
                $SetExternalParams = @{
                    Identity                           = $GroupId
                    RequireSenderAuthenticationEnabled = !$RoomListObj.allowExternal
                }

                $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-DistributionGroup' -cmdParams $SetExternalParams -useSystemMailbox $true

                if ($RoomListObj.allowExternal) {
                    $Results.Add('Enabled external email access for room list')
                } else {
                    $Results.Add('Disabled external email access for room list')
                }

                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Updated external email settings for room list $GroupId" -Sev 'Info'
            } catch {
                $Results.Add("Failed to update external email settings: $($_.Exception.Message)")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to update external email settings: $($_.Exception.Message)" -Sev 'Error'
            }
        }

    } catch {
        $Results.Add("An error occurred while editing the room list: $($_.Exception.Message)")
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to edit room list: $($_.Exception.Message)" -Sev 'Error'
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditRoomList.ps1' 175
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditRoomMailbox.ps1' -1

Function Invoke-EditRoomMailbox {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Tenant = $Request.Body.tenantID


    $Results = [System.Collections.Generic.List[Object]]::new()
    $MailboxObject = $Request.Body

    # First update the mailbox properties
    $UpdateMailboxParams = @{
        Identity    = $MailboxObject.roomId
        DisplayName = $MailboxObject.displayName
    }

    if (![string]::IsNullOrWhiteSpace($MailboxObject.capacity)) {
        $UpdateMailboxParams.Add('ResourceCapacity', $MailboxObject.capacity)
    }
    if (![string]::IsNullOrWhiteSpace($MailboxObject.hiddenFromAddressListsEnabled)) {
        $UpdateMailboxParams.Add('HiddenFromAddressListsEnabled', $MailboxObject.hiddenFromAddressListsEnabled)
    }


    # Then update the place properties
    $UpdatePlaceParams = @{
        Identity = $MailboxObject.roomId
    }

    # Add optional parameters if they exist
    $PlaceProperties = @(
        'Building', 'Floor', 'FloorLabel', 'Phone',
        'AudioDeviceName', 'VideoDeviceName', 'DisplayDeviceName',
        'IsWheelChairAccessible', 'Tags',
        'Street', 'City', 'State', 'CountryOrRegion', 'Desks',
        'PostalCode', 'Localities', 'SpaceType', 'CustomSpaceType',
        'ResourceLinks'
    )

    foreach ($prop in $PlaceProperties) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdatePlaceParams[$prop] = $MailboxObject.$prop
        }
    }


    # Then update the calendar properties
    $UpdateCalendarParams = @{
        Identity = $MailboxObject.roomId
    }

    $CalendarProperties = @(
        'AllowConflicts', 'AllowRecurringMeetings', 'BookingWindowInDays',
        'MaximumDurationInMinutes', 'ProcessExternalMeetingMessages', 'EnforceCapacity',
        'ForwardRequestsToDelegates', 'ScheduleOnlyDuringWorkHours ', 'AutomateProcessing'
    )

    foreach ($prop in $CalendarProperties) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdateCalendarParams[$prop] = $MailboxObject.$prop
        }
    }

    # Then update the calendar configuration
    $UpdateCalendarConfigParams = @{
        Identity = $MailboxObject.roomId
    }

    $CalendarConfiguration = @(
        'WorkDays', 'WorkHoursStartTime', 'WorkHoursEndTime', 'WorkingHoursTimeZone'
    )

    foreach ($prop in $CalendarConfiguration) {
        if (![string]::IsNullOrWhiteSpace($MailboxObject.$prop)) {
            $UpdateCalendarConfigParams[$prop] = $MailboxObject.$prop
        }
    }

    try {
        # Update mailbox properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Mailbox' -cmdParams $UpdateMailboxParams

        # Update place properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Place' -cmdParams $UpdatePlaceParams
        $Results.Add("Successfully updated room: $($MailboxObject.DisplayName) (Place Properties)")

        # Update calendar properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-CalendarProcessing' -cmdParams $UpdateCalendarParams
        $Results.Add("Successfully updated room: $($MailboxObject.DisplayName) (Calendar Properties)")

        # Update calendar configuration properties
        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailboxCalendarConfiguration' -cmdParams $UpdateCalendarConfigParams
        $Results.Add("Successfully updated room: $($MailboxObject.DisplayName) (Calendar Configuration)")

        Write-LogMessage -headers $Request.Headers -API $APIName -tenant $Tenant -message "Updated room $($MailboxObject.DisplayName)" -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Request.Headers -API $APIName -tenant $Tenant -message "Failed to update room: $($MailboxObject.DisplayName). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $Results.Add("Failed to update Room mailbox $($MailboxObject.userPrincipalName). $($ErrorMessage.NormalizedError)")

        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $Body = [pscustomobject]@{ 'Results' = @($Results) }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-EditRoomMailbox.ps1' 120
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListEquipment.ps1' -1

function Invoke-ListEquipment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Equipment.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $EquipmentId = $Request.Query.EquipmentId
    $Tenant = $Request.Query.TenantFilter

    try {
        if ($EquipmentId) {
            # Get specific equipment details
            $Equipment = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{
                Identity             = $EquipmentId
                RecipientTypeDetails = 'EquipmentMailbox'
            }

            $UserDetails = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-User' -cmdParams @{
                Identity = $EquipmentId
            }

            $CalendarProcessing = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-CalendarProcessing' -cmdParams @{
                Identity = $EquipmentId
            }

            $CalendarConfig = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailboxCalendarConfiguration' -cmdParams @{
                Identity = $EquipmentId
            }

            $Results = [PSCustomObject]@{
                # Core mailbox properties
                displayName                    = $Equipment.DisplayName
                hiddenFromAddressListsEnabled  = $Equipment.HiddenFromAddressListsEnabled
                userPrincipalName              = $Equipment.UserPrincipalName
                primarySmtpAddress             = $Equipment.PrimarySmtpAddress

                # Equipment details from Get-User
                department                     = $UserDetails.Department
                company                        = $UserDetails.Company

                # Location information from Get-User
                street                         = $UserDetails.Street
                city                           = $UserDetails.City
                state                          = $UserDetails.State
                postalCode                     = $UserDetails.PostalCode
                countryOrRegion                = $UserDetails.CountryOrRegion

                # Equipment features
                phone                          = $UserDetails.Phone
                tags                           = $UserDetails.Tags

                # Calendar properties from Get-CalendarProcessing
                allowConflicts                 = $CalendarProcessing.AllowConflicts
                allowRecurringMeetings         = $CalendarProcessing.AllowRecurringMeetings
                bookingWindowInDays            = $CalendarProcessing.BookingWindowInDays
                maximumDurationInMinutes       = $CalendarProcessing.MaximumDurationInMinutes
                processExternalMeetingMessages = $CalendarProcessing.ProcessExternalMeetingMessages
                forwardRequestsToDelegates     = $CalendarProcessing.ForwardRequestsToDelegates
                scheduleOnlyDuringWorkHours    = $CalendarProcessing.ScheduleOnlyDuringWorkHours
                automateProcessing             = $CalendarProcessing.AutomateProcessing

                # Calendar configuration from Get-MailboxCalendarConfiguration
                workDays                       = $CalendarConfig.WorkDays
                workHoursStartTime             = $CalendarConfig.WorkHoursStartTime
                workHoursEndTime               = $CalendarConfig.WorkHoursEndTime
                workingHoursTimeZone           = $CalendarConfig.WorkingHoursTimeZone
            }
        } else {
            # List all equipment mailboxes
            $Results = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{
                RecipientTypeDetails = 'EquipmentMailbox'
                ResultSize           = 'Unlimited'
            } | Select-Object -ExcludeProperty *data.type*
        }
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $Results = $ErrorMessage
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results | Sort-Object displayName)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListEquipment.ps1' 92
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListRoomLists.ps1' -1

Function Invoke-ListRoomLists {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $GroupID = $Request.Query.groupID
    $Members = $Request.Query.members
    $Owners = $Request.Query.owners

    try {
        if ($GroupID) {
            # Get specific room list with detailed information
            $GroupInfo = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-DistributionGroup' -cmdParams @{Identity = $GroupID } -useSystemMailbox $true |
                Select-Object -ExcludeProperty *data.type*

            $Result = [PSCustomObject]@{
                groupInfo     = $GroupInfo | Select-Object *, @{ Name = 'primDomain'; Expression = { $_.PrimarySmtpAddress -split '@' | Select-Object -Last 1 } }
                members       = @{}
                owners        = @{}
                allowExternal = (!$GroupInfo.RequireSenderAuthenticationEnabled)
            }

            # Get members if requested
            if ($Members -eq 'true') {
                $RoomListMembers = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-DistributionGroupMember' -cmdParams @{Identity = $GroupID } | Select-Object -ExcludeProperty *data.type* -Property @{Name = 'id'; Expression = { $_.ExternalDirectoryObjectId } },
                @{Name = 'displayName'; Expression = { $_.DisplayName } },
                @{Name = 'mail'; Expression = { $_.PrimarySmtpAddress } },
                @{Name = 'mailNickname'; Expression = { $_.Alias } },
                @{Name = 'userPrincipalName'; Expression = { $_.PrimarySmtpAddress } }
                $Result.members = @($RoomListMembers)
            }

            # Get owners if requested
            if ($Owners -eq 'true' -and $GroupInfo.ManagedBy) {
                try {
                    # Separate valid and invalid GUIDs
                    $ValidOwnerIds = [System.Collections.Generic.List[string]]::new()
                    $InvalidOwnerIds = [System.Collections.Generic.List[string]]::new()

                    foreach ($OwnerId in $GroupInfo.ManagedBy) {
                        $OwnerIdString = [string]$OwnerId
                        # Check if it's a valid GUID format
                        if ($OwnerIdString -match '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$') {
                            $ValidOwnerIds.Add($OwnerIdString)
                        } else {
                            $InvalidOwnerIds.Add($OwnerIdString)
                            Write-Warning "Found invalid GUID for owner: $OwnerIdString"
                        }
                    }

                    $AllOwners = [System.Collections.Generic.List[PSCustomObject]]::new()

                    # Get valid owners from Graph API
                    if ($ValidOwnerIds.Count -gt 0) {
                        $body = ConvertTo-Json -InputObject @{ids = @($ValidOwnerIds) } -Compress
                        $OwnersData = New-GraphPOSTRequest -tenantid $TenantFilter -uri 'https://graph.microsoft.com/beta/directoryObjects/getByIds' -body $body
                        foreach ($Owner in $OwnersData.value) {
                            $AllOwners.Add($Owner)
                        }
                    }

                    # Add invalid GUIDs as placeholder objects so they can be removed
                    foreach ($InvalidId in $InvalidOwnerIds) {
                        $PlaceholderOwner = [PSCustomObject]@{
                            id                = $InvalidId
                            displayName       = "Invalid Owner ID: $InvalidId"
                            userPrincipalName = "invalid-$InvalidId"
                            '@odata.type'     = '#microsoft.graph.user'
                        }
                        $AllOwners.Add($PlaceholderOwner)
                    }

                    $Result.owners = @($AllOwners)

                } catch {
                    Write-Warning "Failed to get owners: $($_.Exception.Message)"
                    $Result.owners = @()
                }
            }



            $StatusCode = [HttpStatusCode]::OK
            $ResponseBody = $Result
        } else {
            # Get all room lists (original functionality)
            $RoomLists = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-DistributionGroup' -cmdParams @{RecipientTypeDetails = 'RoomList'; ResultSize = 'Unlimited' } |
                Select-Object Guid, DisplayName, PrimarySmtpAddress, Alias, Phone, Identity, Notes, Description, Id -ExcludeProperty *data.type*
            $StatusCode = [HttpStatusCode]::OK
            $ResponseBody = @{ Results = @($RoomLists | Sort-Object DisplayName) }
        }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
        $ResponseBody = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $ResponseBody
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListRoomLists.ps1' 110
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListRooms.ps1' -1

Function Invoke-ListRooms {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Room.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $RoomId = $Request.Query.roomId

    # I dont like that i had to change it to EXO commands, but the waiting time for the Rooms to sync to Graph is too long :(  -Bobby
    try {
        if ($RoomId) {
            # Get specific room mailbox
            $RoomMailbox = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{
                Identity             = $RoomId
                RecipientTypeDetails = 'RoomMailbox'
            } | Select-Object -ExcludeProperty *@odata.type*

            # Get place details
            $PlaceDetails = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Place' -cmdParams @{
                Identity = $RoomId
            } | Select-Object -ExcludeProperty *@odata.type*

            # Get calendar properties
            $CalendarProperties = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-CalendarProcessing' -cmdParams @{
                Identity = $RoomId
            } | Select-Object -ExcludeProperty *@odata.type*

            # Get calendar properties
            $CalendarConfigurationProperties = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxCalendarConfiguration' -cmdParams @{
                Identity = $RoomId
            } | Select-Object -ExcludeProperty *@odata.type*

            if ($RoomMailbox -and $PlaceDetails -and $CalendarProperties -and $CalendarConfigurationProperties) {
                $GraphRequest = @(
                    [PSCustomObject]@{
                        # Core Mailbox Properties
                        id                             = $RoomMailbox.ExternalDirectoryObjectId
                        displayName                    = $RoomMailbox.DisplayName
                        mail                           = $RoomMailbox.PrimarySmtpAddress
                        mailNickname                   = $RoomMailbox.Alias
                        accountDisabled                = $RoomMailbox.AccountDisabled
                        hiddenFromAddressListsEnabled  = $RoomMailbox.HiddenFromAddressListsEnabled
                        isDirSynced                    = $RoomMailbox.IsDirSynced

                        # Room Booking Settings
                        bookingType                    = $PlaceDetails.BookingType
                        resourceDelegates              = $PlaceDetails.ResourceDelegates
                        capacity                       = [int]($PlaceDetails.Capacity ?? $RoomMailbox.ResourceCapacity ?? 0)

                        # Location Information
                        building                       = $PlaceDetails.Building
                        floor                          = $PlaceDetails.Floor
                        floorLabel                     = $PlaceDetails.FloorLabel
                        street                         = if ([string]::IsNullOrWhiteSpace($PlaceDetails.Street)) { $null } else { $PlaceDetails.Street }
                        city                           = if ([string]::IsNullOrWhiteSpace($PlaceDetails.City)) { $null } else { $PlaceDetails.City }
                        state                          = if ([string]::IsNullOrWhiteSpace($PlaceDetails.State)) { $null } else { $PlaceDetails.State }
                        postalCode                     = if ([string]::IsNullOrWhiteSpace($PlaceDetails.PostalCode)) { $null } else { $PlaceDetails.PostalCode }
                        countryOrRegion                = if ([string]::IsNullOrWhiteSpace($PlaceDetails.CountryOrRegion)) { $null } else { $PlaceDetails.CountryOrRegion }

                        # Room Equipment
                        audioDeviceName                = $PlaceDetails.AudioDeviceName
                        videoDeviceName                = $PlaceDetails.VideoDeviceName
                        displayDeviceName              = $PlaceDetails.DisplayDeviceName
                        mtrEnabled                     = $PlaceDetails.MTREnabled

                        # Room Features
                        isWheelChairAccessible         = $PlaceDetails.IsWheelChairAccessible
                        phone                          = if ([string]::IsNullOrWhiteSpace($PlaceDetails.Phone)) { $null } else { $PlaceDetails.Phone }
                        tags                           = $PlaceDetails.Tags
                        spaceType                      = $PlaceDetails.SpaceType

                        # Calendar Properties
                        AllowConflicts                 = $CalendarProperties.AllowConflicts
                        AllowRecurringMeetings         = $CalendarProperties.AllowRecurringMeetings
                        BookingWindowInDays            = $CalendarProperties.BookingWindowInDays
                        MaximumDurationInMinutes       = $CalendarProperties.MaximumDurationInMinutes
                        ProcessExternalMeetingMessages = $CalendarProperties.ProcessExternalMeetingMessages
                        EnforceCapacity                = $CalendarProperties.EnforceCapacity
                        ForwardRequestsToDelegates     = $CalendarProperties.ForwardRequestsToDelegates
                        ScheduleOnlyDuringWorkHours    = $CalendarProperties.ScheduleOnlyDuringWorkHours
                        AutomateProcessing             = $CalendarProperties.AutomateProcessing

                        # Calendar Configuration Properties
                        WorkDays                       = if ([string]::IsNullOrWhiteSpace($CalendarConfigurationProperties.WorkDays)) { $null } else { $CalendarConfigurationProperties.WorkDays }
                        WorkHoursStartTime             = if ([string]::IsNullOrWhiteSpace($CalendarConfigurationProperties.WorkHoursStartTime)) { $null } else { $CalendarConfigurationProperties.WorkHoursStartTime }
                        WorkHoursEndTime               = if ([string]::IsNullOrWhiteSpace($CalendarConfigurationProperties.WorkHoursEndTime)) { $null } else { $CalendarConfigurationProperties.WorkHoursEndTime }
                        WorkingHoursTimeZone           = $CalendarConfigurationProperties.WorkingHoursTimeZone
                    }
                )
            }
        } else {
            # Get all room mailboxes in one call
            $RoomMailboxes = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{
                RecipientTypeDetails = 'RoomMailbox'
                ResultSize           = 'Unlimited'
            } | Select-Object -ExcludeProperty *@odata.type*

            # Get all places in one call
            $Places = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Place' -cmdParams @{
                ResultSize = 'Unlimited'
            } | Select-Object -ExcludeProperty *@odata.type*

            # Create hashtable for quick place lookups
            $PlacesLookup = @{}
            foreach ($Place in $Places) {
                if ($Place.Identity) {
                    $PlacesLookup[$Place.Identity] = $Place
                }
            }

            $GraphRequest = @(
                foreach ($Room in $RoomMailboxes) {
                    $PlaceDetails = $PlacesLookup[$Room.UserPrincipalName] ?? $PlacesLookup[$Room.PrimarySmtpAddress]

                    [PSCustomObject]@{
                        # Core Mailbox Properties
                        id                            = $Room.ExternalDirectoryObjectId
                        displayName                   = $Room.DisplayName
                        mail                          = $Room.PrimarySmtpAddress
                        mailNickname                  = $Room.Alias
                        accountDisabled               = $Room.AccountDisabled
                        hiddenFromAddressListsEnabled = $Room.HiddenFromAddressListsEnabled
                        isDirSynced                   = $RoomMailbox.IsDirSynced

                        # Room Booking Settings
                        bookingType                   = $PlaceDetails.BookingType
                        resourceDelegates             = $PlaceDetails.ResourceDelegates
                        capacity                      = [int]($PlaceDetails.Capacity ?? $Room.ResourceCapacity ?? 0)

                        # Location Information
                        building                      = $PlaceDetails.Building
                        floor                         = $PlaceDetails.Floor
                        floorLabel                    = $PlaceDetails.FloorLabel
                        street                        = if ([string]::IsNullOrWhiteSpace($PlaceDetails.Street)) { $null } else { $PlaceDetails.Street }
                        city                          = if ([string]::IsNullOrWhiteSpace($PlaceDetails.City)) { $null } else { $PlaceDetails.City }
                        state                         = if ([string]::IsNullOrWhiteSpace($PlaceDetails.State)) { $null } else { $PlaceDetails.State }
                        postalCode                    = if ([string]::IsNullOrWhiteSpace($PlaceDetails.PostalCode)) { $null } else { $PlaceDetails.PostalCode }
                        countryOrRegion               = if ([string]::IsNullOrWhiteSpace($PlaceDetails.CountryOrRegion)) { $null } else { $PlaceDetails.CountryOrRegion }


                        # Room Equipment
                        audioDeviceName               = $PlaceDetails.AudioDeviceName
                        videoDeviceName               = $PlaceDetails.VideoDeviceName
                        displayDeviceName             = $PlaceDetails.DisplayDeviceName
                        mtrEnabled                    = $PlaceDetails.MTREnabled

                        # Room Features
                        isWheelChairAccessible        = $PlaceDetails.IsWheelChairAccessible
                        phone                         = if ([string]::IsNullOrWhiteSpace($PlaceDetails.Phone)) { $null } else { $PlaceDetails.Phone }
                        tags                          = $PlaceDetails.Tags
                        spaceType                     = $PlaceDetails.SpaceType
                    }
                }
            )
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest | Sort-Object displayName)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Resources/Invoke-ListRooms.ps1' 174
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddQuarantinePolicy.ps1' -1

Function Invoke-AddQuarantinePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenants = ($Request.body.selectedTenants).value

    # If allTenants is selected, get all tenants and overwrite any other tenant selection
    if ("AllTenants" -in $Tenants) {
        $tenants = (Get-Tenants).defaultDomainName
    }

    $Result = foreach ($TenantFilter in $tenants) {
        try {
            $ReleaseActionPreference = $Request.Body.ReleaseActionPreference.value ?? $Request.Body.ReleaseActionPreference

            $EndUserQuarantinePermissions   = @{
                PermissionToBlockSender = $Request.Body.BlockSender
                PermissionToDelete  = $Request.Body.Delete
                PermissionToPreview = $Request.Body.Preview
                PermissionToRelease = $ReleaseActionPreference -eq "Release" ? $true : $false
                PermissionToRequestRelease  = $ReleaseActionPreference -eq "RequestRelease" ? $true : $false
                PermissionToAllowSender = $Request.Body.AllowSender
            }

            $Params = @{
                Identity = $Request.Body.Name
                EndUserQuarantinePermissions = $EndUserQuarantinePermissions
                ESNEnabled = $Request.Body.QuarantineNotification
                IncludeMessagesFromBlockedSenderAddress = $Request.Body.IncludeMessagesFromBlockedSenderAddress
                action = "New"
                tenantFilter = $TenantFilter
                APIName = $APIName
            }

            Set-CIPPQuarantinePolicy @Params
            $Message = "Created Quarantine policy '$($Request.Body.Name)' for tenant '$($TenantFilter)'"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev Info
            $Message

        }
        catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Message = "Failed to create Quarantine policy '$($Request.Body.Name)' for tenant '$($TenantFilter)' - $($ErrorMessage.NormalizedError)"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev Error -LogData $ErrorMessage
            $Message
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddQuarantinePolicy.ps1' 65
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddSpamFilter.ps1' -1

Function Invoke-AddSpamFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $RequestParams = $Request.Body.PowerShellCommand | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty GUID, comments
    $RequestPriority = $Request.Body.Priority

    $Tenants = ($Request.body.selectedTenants).value
    $Result = foreach ($TenantFilter in $tenants) {
        try {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-HostedContentFilterPolicy' -cmdParams $RequestParams
            $Domains = (New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-AcceptedDomain').name
            $ruleparams = @{
                'name'                      = "$($RequestParams.name)"
                'hostedcontentfilterpolicy' = "$($RequestParams.name)"
                'recipientdomainis'         = @($domains)
                'Enabled'                   = $true
                'Priority'                  = $RequestPriority
            }
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-HostedContentFilterRule' -cmdParams $ruleparams
            "Successfully created spamfilter for $TenantFilter."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully created spamfilter for $TenantFilter." -sev Info
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Could not create spamfilter rule for $($TenantFilter): $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Could not create spamfilter rule for $($TenantFilter): $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddSpamFilter.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddSpamFilterTemplate.ps1' -1

Function Invoke-AddSpamFilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    try {
        $GUID = (New-Guid).GUID
        $JSON = if ($Request.Body.PowerShellCommand) {
            Write-Host 'PowerShellCommand'
            $Request.Body.PowerShellCommand | ConvertFrom-Json
        } else {
        ([pscustomobject]$Request.Body | Select-Object name, AddXHeaderValue, AdminDisplayName, AllowedSenderDomains, AllowedSenders, BlockedSenderDomains, BlockedSenders, BulkQuarantineTag, BulkSpamAction, BulkThreshold, Confirm, DownloadLink, EnableEndUserSpamNotifications, EnableLanguageBlockList, EnableRegionBlockList, EndUserSpamNotificationCustomFromAddress, EndUserSpamNotificationCustomFromName, EndUserSpamNotificationCustomSubject, EndUserSpamNotificationFrequency, EndUserSpamNotificationLanguage, EndUserSpamNotificationCustomFromAddress, HighConfidencePhishAction, HighConfidencePhishQuarantineTag, HighConfidenceSpamAction, HighConfidenceSpamQuarantineTag, IncreaseScoreWithBizOrInfoUrls, IncreaseScoreWithImageLinks, IncreaseScoreWithNumericIps, IncreaseScoreWithRedirectToOtherPort, InlineSafetyTipsEnabled, LanguageBlockList, MarkAsSpamBulkMail, MarkAsSpamEmbedTagsInHtml, MarkAsSpamEmptyMessages, MarkAsSpamFormTagsInHtml, MarkAsSpamFramesInHtml, MarkAsSpamFromAddressAuthFail, MarkAsSpamJavaScriptInHtml, MarkAsSpamNdrBackscatter, MarkAsSpamObjectTagsInHtml, MarkAsSpamSensitiveWordList, MarkAsSpamSpfRecordHardFail, MarkAsSpamWebBugsInHtml, ModifySubjectValue, PhishQuarantineTag, PhishSpamAction, PhishZapEnabled, QuarantineRetentionPeriod, RecommendedPolicyType, RedirectToRecipients, RegionBlockList, SpamAction, SpamQuarantineTag, SpamZapEnabled, TestModeAction, TestModeBccToRecipients ) | ForEach-Object {
                $NonEmptyProperties = $_.PSObject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
                $_ | Select-Object -Property $NonEmptyProperties
            }
        }
        $JSON = ($JSON | Select-Object @{n = 'name'; e = { $_.name } }, @{n = 'comments'; e = { $_.comments } }, * | ConvertTo-Json -Depth 10)
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$json"
            RowKey       = "$GUID"
            PartitionKey = 'SpamfilterTemplate'
        }
        $Result = "Successfully created Spam Filter Template: $($Request.Body.name) with GUID $GUID"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Debug'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create Spam Filter Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddSpamFilterTemplate.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddTenantAllowBlockList.ps1' -1

function Invoke-AddTenantAllowBlockList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $BlockListObject = $Request.Body
    $TenantID = $Request.Body.tenantID.value ?? $Request.Body.tenantID

    if ($TenantID -eq 'AllTenants') {
        $Tenants = (Get-Tenants).defaultDomainName
    } elseif ($TenantID -is [array]) {
        $Tenants = $TenantID
    } else {
        $Tenants = @($TenantID)
    }
    $Results = [System.Collections.Generic.List[string]]::new()
    $Entries = @()
    if ($BlockListObject.entries -is [array]) {
        $Entries = $BlockListObject.entries
    } else {
        $Entries = @($BlockListObject.entries -split '[,;]' | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | ForEach-Object { $_.Trim() })
    }
    foreach ($Tenant in $Tenants) {
        try {
            $ExoRequest = @{
                tenantid  = $Tenant
                cmdlet    = 'New-TenantAllowBlockListItems'
                cmdParams = @{
                    Entries                     = $Entries
                    ListType                    = [string]$BlockListObject.listType
                    Notes                       = [string]$BlockListObject.notes
                    $BlockListObject.listMethod = [bool]$true
                }
            }

            if ($BlockListObject.NoExpiration -eq $true) {
                $ExoRequest.cmdParams.NoExpiration = $true
            } elseif ($BlockListObject.RemoveAfter -eq $true) {
                $ExoRequest.cmdParams.RemoveAfter = 45
            }

            New-ExoRequest @ExoRequest
            $Result = "Successfully added $($BlockListObject.Entries) as type $($BlockListObject.ListType) to the $($BlockListObject.listMethod) list for $tenant"
            $Results.Add($Result)
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message $Result -Sev 'Info'
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Result = "Failed to create blocklist. Error: $($ErrorMessage.NormalizedError)"
            $Results.Add($Result)
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message $Result -Sev 'Error' -LogData $ErrorMessage
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{
                'Results' = $Results
                'Request' = $ExoRequest
            }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-AddTenantAllowBlockList.ps1' 69
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditAntiPhishingFilter.ps1' -1

function Invoke-EditAntiPhishingFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName
    $State = $Request.Query.State ?? $Request.Body.State

    try {
        $ExoRequestParam = @{
            tenantid         = $TenantFilter
            cmdParams        = @{
                Identity = $RuleName
            }
            useSystemMailbox = $true
        }

        switch ($State) {
            'Enable' {
                $ExoRequestParam.Add('cmdlet', 'Enable-AntiPhishRule')
            }
            'Disable' {
                $ExoRequestParam.Add('cmdlet', 'Disable-AntiPhishRule')
            }
            default {
                throw 'Invalid state'
            }
        }
        $null = New-ExoRequest @ExoRequestParam

        $Result = "Successfully set Anti-Phishing rule $RuleName to $State"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $TenantFilter -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed setting Anti-Phishing rule $RuleName to $State. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditAntiPhishingFilter.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditMalwareFilter.ps1' -1

function Invoke-EditMalwareFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName
    $State = $Request.Query.State ?? $Request.Body.State

    try {
        $ExoRequestParam = @{
            tenantid         = $TenantFilter
            cmdParams        = @{
                Identity = $RuleName
            }
            useSystemMailbox = $true
        }

        switch ($State) {
            'Enable' {
                $ExoRequestParam.Add('cmdlet', 'Enable-MalwareFilterRule')
            }
            'Disable' {
                $ExoRequestParam.Add('cmdlet', 'Disable-MalwareFilterRule')
            }
            default {
                throw 'Invalid state'
            }
        }
        $null = New-ExoRequest @ExoRequestParam

        $Result = "Successfully set Malware Filter rule $($RuleName) to $($State)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed setting Malware Filter rule $($RuleName) to $($State). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditMalwareFilter.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditQuarantinePolicy.ps1' -1

Function Invoke-EditQuarantinePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Query.TenantFilter ?? $Request.Body.TenantFilter

    if ($Request.Query.Type -eq "GlobalQuarantinePolicy") {

        $Frequency = $Request.Body.EndUserSpamNotificationFrequency.value ?? $Request.Body.EndUserSpamNotificationFrequency
        # If request EndUserSpamNotificationFrequency it not set to a ISO 8601 timeformat, convert it to one.
        # This happens if the user doesn't change the Notification Frequency value in the UI. Because of a "bug" with setDefaultValue function with the cippApiDialog, where "label" is set to both label and value.
        $EndUserSpamNotificationFrequency = switch ($Frequency) {
            "4 Hours" { "PT4H" }
            "Daily" { "P1D" }
            "Weekly" { "P7D" }
            Default { $Frequency }
        }

        $Params = @{
            Identity = $Request.Body.Identity
            # Convert the requested frequency from ISO 8601 to a TimeSpan object
            EndUserSpamNotificationFrequency = [System.Xml.XmlConvert]::ToTimeSpan($EndUserSpamNotificationFrequency)
            EndUserSpamNotificationCustomFromAddress = $Request.Body.EndUserSpamNotificationCustomFromAddress
            OrganizationBrandingEnabled = $Request.Body.OrganizationBrandingEnabled
        }
    }
    else {
        $ReleaseActionPreference = $Request.Body.ReleaseActionPreference.value ?? $Request.Body.ReleaseActionPreference

        $EndUserQuarantinePermissions   = @{
            PermissionToBlockSender = $Request.Body.BlockSender
            PermissionToDelete  = $Request.Body.Delete
            PermissionToPreview = $Request.Body.Preview
            PermissionToRelease = $ReleaseActionPreference -eq "Release" ? $true : $false
            PermissionToRequestRelease  = $ReleaseActionPreference -eq "RequestRelease" ? $true : $false
            PermissionToAllowSender = $Request.Body.AllowSender
        }

        $Params = @{
            Identity = $Request.Body.Identity
            EndUserQuarantinePermissions = $EndUserQuarantinePermissions
            ESNEnabled = $Request.Body.QuarantineNotification
            IncludeMessagesFromBlockedSenderAddress = $Request.Body.IncludeMessagesFromBlockedSenderAddress
            action = $Request.Body.Action ?? "Set"
        }
    }

    try {
        Set-CIPPQuarantinePolicy @Params -tenantFilter $TenantFilter -APIName $APIName

        $Result = "Updated Quarantine policy '$($Request.Body.Name)'"
        $StatusCode = [HttpStatusCode]::OK
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
    }
    catch {
        $Result = "Failed to update Quarantine policy '$($Request.Body.Name)' - $($_)"
        $StatusCode = [HttpStatusCode]::Forbidden
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditQuarantinePolicy.ps1' 77
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditSafeAttachmentsFilter.ps1' -1

function Invoke-EditSafeAttachmentsFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName
    $State = $Request.Query.State ?? $Request.Body.State

    try {
        $ExoRequestParam = @{
            tenantid         = $TenantFilter
            cmdParams        = @{
                Identity = $RuleName
            }
            useSystemMailbox = $true
        }

        switch ($State) {
            'Enable' {
                $ExoRequestParam.Add('cmdlet', 'Enable-SafeAttachmentRule')
            }
            'Disable' {
                $ExoRequestParam.Add('cmdlet', 'Disable-SafeAttachmentRule')
            }
            default {
                throw 'Invalid state'
            }
        }
        $null = New-ExoRequest @ExoRequestParam

        $Result = "Successfully set SafeAttachment rule $($RuleName) to $($State)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed setting SafeAttachment rule $($RuleName) to $($State). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditSafeAttachmentsFilter.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditSpamFilter.ps1' -1

Function Invoke-EditSpamFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $request.Query.tenantFilter
    $Name = $Request.Query.name ?? $Request.Body.name
    $State = $State ?? $Request.Body.state

    try {
        $Params = @{
            Identity = $Name
        }
        $Cmdlet = if ($State -eq 'enable') { 'Enable-HostedContentFilterRule' } else { 'Disable-HostedContentFilterRule' }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $Cmdlet -cmdParams $Params -useSystemMailbox $true
        $Result = "Set Spamfilter rule $($Name) to $($State)"
        Write-LogMessage -headers $Request.Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed setting Spamfilter rule $($Name) to $($State). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Request.Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-EditSpamFilter.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ExecQuarantineManagement.ps1' -1

function Invoke-ExecQuarantineManagement {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Interact with query parameters or the body of the request.
    try {
        $TenantFilter = $Request.Body.tenantFilter | Select-Object -First 1
        $params = @{
            AllowSender  = [boolean]$Request.Body.AllowSender
            ReleaseToAll = $true
            ActionType   = ($Request.Body.Type | Select-Object -First 1)
        }
        if ($Request.Body.Identity -is [string]) {
            $params['Identity'] = $Request.Body.Identity
        } else {
            $params['Identities'] = $Request.Body.Identity
        }
        New-ExoRequest -tenantid $TenantFilter -cmdlet 'Release-QuarantineMessage' -cmdParams $Params
        $Results = [pscustomobject]@{'Results' = "Successfully processed $($Request.Body.Identity)" }
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $TenantFilter -message "Successfully processed Quarantine ID $($Request.Body.Identity)" -Sev 'Info'
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $TenantFilter -message "Quarantine Management failed: $($_.Exception.Message)" -Sev 'Error' -LogData $_
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ExecQuarantineManagement.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListConnectionFilter.ps1' -1

function Invoke-ListConnectionFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.ConnectionFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $request.Query.tenantFilter

    try {
        $Policies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-HostedConnectionFilterPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $Policies = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Policies)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListConnectionFilter.ps1' 27
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListConnectionFilterTemplates.ps1' -1

Function Invoke-ListConnectionFilterTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.ConnectionFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'

    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'ConnectionfilterTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $GUID = $_.RowKey
        $data = $_.JSON | ConvertFrom-Json
        $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
        $data
    }

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property RowKey -EQ $Request.query.id }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListConnectionFilterTemplates.ps1' 31
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListMailQuarantine.ps1' -1

function Invoke-ListMailQuarantine {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-QuarantineMessage' -cmdParams @{ 'PageSize' = 1000 } | Select-Object -ExcludeProperty *data.type*
        } else {
            $Table = Get-CIPPTable -TableName cacheQuarantineMessages
            $PartitionKey = 'QuarantineMessage'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-30)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue | Where-Object { $_.Reference -eq $QueueReference -and $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            # If a queue is running, we will not start a new one
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
                [PSCustomObject]@{
                    Waiting = $true
                }
            } elseif (!$Rows -and !$RunningQueue) {
                # If no rows are found and no queue is running, we will start a new one
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'Mail Quarantine - All Tenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'MailQuarantineOrchestrator'
                    QueueFunction    = @{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ListMailQuarantineAllTenants'
                    }
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                [PSCustomObject]@{
                    Waiting = $true
                }
            } else {
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }
                $messages = $Rows
                foreach ($message in $messages) {
                    $messageObj = $message.QuarantineMessage | ConvertFrom-Json
                    $messageObj | Add-Member -NotePropertyName 'Tenant' -NotePropertyValue $message.Tenant -Force
                    $messageObj
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    if (!$body) {
        $StatusCode = [HttpStatusCode]::OK
        $body = [PSCustomObject]@{
            Results  = @($GraphRequest | Where-Object -Property Identity -NE $null | Sort-Object -Property ReceivedTime -Descending )
            Metadata = $Metadata
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListMailQuarantine.ps1' 88
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListMailQuarantineMessage.ps1' -1

function Invoke-ListMailQuarantineMessage {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $Identity = $Request.Query.Identity

    try {
        $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Export-QuarantineMessage' -cmdParams @{ 'Identity' = $Identity }
        $EmlBase64 = $GraphRequest.Eml
        $EmlContent = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($EmlBase64))
        $Body = @{
            'Identity' = $Identity
            'Message'  = $EmlContent
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $Body = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListMailQuarantineMessage.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListQuarantinePolicy.ps1' -1

function Invoke-ListQuarantinePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter ?? $Request.body.TenantFilter
    $QuarantinePolicyType = $Request.Query.Type ?? 'QuarantinePolicy'

    $Policies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-QuarantinePolicy' -cmdParams @{QuarantinePolicyType=$QuarantinePolicyType} | Select-Object -Property * -ExcludeProperty *odata*, *data.type*

    if ($QuarantinePolicyType -eq 'QuarantinePolicy') {
        # Convert the string EndUserQuarantinePermissions to individual properties
        $Policies | ForEach-Object {
            $Permissions = Convert-QuarantinePermissionsValue -InputObject $_.EndUserQuarantinePermissions
            foreach ($Perm in $Permissions.GetEnumerator()) {
                $_ | Add-Member -MemberType NoteProperty -Name ($Perm.Key -replace "PermissionTo", "" ) -Value $Perm.Value
            }
        }

        # "convert" to values display in the UI and Builtin used for filtering
        $Policies = $Policies | Select-Object -Property *,
        @{ Name = 'QuarantineNotification'; Expression = { $_.ESNEnabled -eq $true ? $true : $false} },
        @{ Name = 'ReleaseActionPreference'; Expression = { $_.Release -eq $true ? "Release" : "RequestRelease"} },
        @{ Name = 'Builtin'; Expression = { $_.Guid -eq "00000000-0000-0000-0000-000000000000" ? $true : $false} }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Policies)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListQuarantinePolicy.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListSpamfilter.ps1' -1

Function Invoke-ListSpamfilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Tenantfilter = $request.Query.tenantfilter

    try {
        $Policies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
        $RuleState = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterRule' | Select-Object * -ExcludeProperty *odata*, *data.type*
        $GraphRequest = $Policies | Select-Object *, @{l = 'ruleState'; e = { $name = $_.name; ($RuleState | Where-Object name -EQ $name).State } }, @{l = 'rulePrio'; e = { $name = $_.name; ($RuleState | Where-Object name -EQ $name).Priority } }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListSpamfilter.ps1' 29
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListSpamFilterTemplates.ps1' -1

Function Invoke-ListSpamFilterTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'

    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'SpamfilterTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $GUID = $_.RowKey
        $data = $_.JSON | ConvertFrom-Json
        $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
        $data
    }

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property RowKey -EQ $Request.query.id }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-ListSpamFilterTemplates.ps1' 31
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveConnectionfilterTemplate.ps1' -1

Function Invoke-RemoveConnectionfilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.ConnectionFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $Request.body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'ConnectionfilterTemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Connection Filter template with ID $($ID)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Connection Filter template with ID $ID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveConnectionfilterTemplate.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveQuarantinePolicy.ps1' -1

Function Invoke-RemoveQuarantinePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Query.TenantFilter ?? $Request.Body.TenantFilter
    $PolicyName = $Request.Query.Name ?? $Request.Body.Name
    $Identity = $Request.Query.Identity ?? $Request.Body.Identity

    try {
        $Params = @{
            Identity = ($Identity -eq "00000000-0000-0000-0000-000000000000" ? $PolicyName : $Identity)
        }

        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-QuarantinePolicy' -cmdParams $Params -useSystemMailbox $true

        $Result = "Deleted Quarantine policy '$($PolicyName)'"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Quarantine policy '$($PolicyName)' - $($ErrorMessage.NormalizedError -replace '\|Microsoft.Exchange.Management.Tasks.ValidationException\|', '')"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $StatusCode = [HttpStatusCode]::OK

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveQuarantinePolicy.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveSpamfilter.ps1' -1

Function Invoke-RemoveSpamfilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Query.tenantFilter
    $Name = $Request.Query.name ?? $Request.Body.name


    try {
        $Params = @{
            Identity = $Name
        }
        $Cmdlet = 'Remove-HostedContentFilterRule'
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $Cmdlet -cmdParams $Params -useSystemMailbox $true
        $Cmdlet = 'Remove-HostedContentFilterPolicy'
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $Cmdlet -cmdParams $Params -useSystemMailbox $true
        $Result = "Deleted Spam filter rule $($Name)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete Spam filter rule $($Name) - $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveSpamfilter.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveSpamfilterTemplate.ps1' -1

Function Invoke-RemoveSpamfilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Spamfilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'SpamfilterTemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Spamfilter template with ID $ID"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Spam filter Rule template $ID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Spamfilter/Invoke-RemoveSpamfilterTemplate.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ExecMailboxRestore.ps1' -1

function Invoke-ExecMailboxRestore {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.ReadWrite
    #>
    Param($Request, $TriggerMetadata)
    try {
        $Action = $Request.Query.Action ?? $Request.Body.Action
        $Identity = $Request.Query.Identity ?? $Request.Body.Identity
        $TenantFilter = $Request.Query.TenantFilter ?? $Request.Body.TenantFilter

        switch ($Action) {
            'Remove' {
                $ExoRequest = @{
                    tenantid  = $TenantFilter
                    cmdlet    = 'Remove-MailboxRestoreRequest'
                    cmdParams = @{
                        Identity = $Identity
                    }
                }
                $SuccessMessage = 'Mailbox restore request removed successfully'
            }
            'Resume' {
                $ExoRequest = @{
                    tenantid  = $TenantFilter
                    cmdlet    = 'Resume-MailboxRestoreRequest'
                    cmdParams = @{
                        Identity = $Identity
                    }
                }
                $SuccessMessage = 'Mailbox restore request resumed successfully'
            }
            'Suspend' {
                $ExoRequest = @{
                    tenantid  = $TenantFilter
                    cmdlet    = 'Suspend-MailboxRestoreRequest'
                    cmdParams = @{
                        Identity = $Identity
                    }
                }
                $SuccessMessage = 'Mailbox restore request suspended successfully'
            }
            default {
                $RequestName = $Request.Body.RequestName
                $SourceMailbox = $Request.Body.SourceMailbox.value ?? $Request.Body.SourceMailbox
                $TargetMailbox = $Request.Body.TargetMailbox.value ?? $Request.Body.TargetMailbox

                $ExoRequest = @{
                    tenantid  = $TenantFilter
                    cmdlet    = 'New-MailboxRestoreRequest'
                    cmdParams = @{
                        Name                  = $RequestName
                        SourceMailbox         = $SourceMailbox
                        TargetMailbox         = $TargetMailbox
                        AllowLegacyDNMismatch = $true
                    }
                }
                if ($Request.Body.AssociatedMessagesCopyOption) {
                    $ExoRequest.cmdParams.AssociatedMessagesCopyOption = $Request.Body.AssociatedMessagesCopyOption.value
                }
                if ($Request.Body.ExcludeFolders) {
                    $ExoRequest.cmdParams.ExcludeFolders = $Request.Body.ExcludeFolders.value
                }
                if ($Request.Body.IncludeFolders) {
                    $ExoRequest.cmdParams.IncludeFolders = $Request.Body.IncludeFolders.value
                }
                if ($Request.Body.BatchName) {
                    $ExoRequest.cmdParams.BatchName = $Request.Body.BatchName
                }
                if ($Request.Body.CompletedRequestAgeLimit) {
                    $ExoRequest.cmdParams.CompletedRequestAgeLimit = $Request.Body.CompletedRequestAgeLimit
                }
                if ($Request.Body.ConflictResolutionOption) {
                    $ExoRequest.cmdParams.ConflictResolutionOption = $Request.Body.ConflictResolutionOption.value
                }
                if ($Request.Body.SourceRootFolder) {
                    $ExoRequest.cmdParams.SourceRootFolder = $Request.Body.SourceRootFolder
                }
                if ($Request.Body.TargetRootFolder) {
                    $ExoRequest.cmdParams.TargetRootFolder = $Request.Body.TargetRootFolder
                }
                if ($Request.Body.TargetType) {
                    $ExoRequest.cmdParams.TargetType = $Request.Body.TargetType.value
                }
                if ([int]$Request.Body.BadItemLimit -gt 0) {
                    $ExoRequest.cmdParams.BadItemLimit = $Request.Body.BadItemLimit
                }
                if ([int]$Request.Body.LargeItemLimit -gt 0) {
                    $ExoRequest.cmdParams.LargeItemLimit = $Request.Body.LargeItemLimit
                }
                if ($Request.Body.ExcludeDumpster) {
                    $ExoRequest.cmdParams.ExcludeDumpster = $Request.Body.ExcludeDumpster
                }
                if ($Request.Body.SourceIsArchive) {
                    $ExoRequest.cmdParams.SourceIsArchive = $Request.Body.SourceIsArchive
                }
                if ($Request.Body.TargetIsArchive) {
                    $ExoRequest.cmdParams.TargetIsArchive = $Request.Body.TargetIsArchive
                }

                Write-Information ($ExoRequest | ConvertTo-Json)
                $SuccessMessage = 'Mailbox restore request created successfully'
            }
        }

        $GraphRequest = New-ExoRequest @ExoRequest

        $Body = @{
            RestoreRequest = $GraphRequest
            Results        = @($SuccessMessage)
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::OK
        $Body = @{
            RestoreRequest = $null
            Results        = @($ErrorMessage)
            colour         = 'danger'
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ExecMailboxRestore.ps1' 129
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ExecMailTest.ps1' -1

Function Invoke-ExecMailTest {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        switch ($Request.Query.Action) {
            'CheckConfig' {
                $GraphToken = Get-GraphToken -returnRefresh $true -SkipCache $true
                $AccessTokenDetails = Read-JwtAccessDetails -Token $GraphToken.access_token
                $Me = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/me?$select=displayName,userPrincipalName,proxyAddresses' -NoAuthCheck $true
                if ($AccessTokenDetails.Scope -contains 'Mail.Read') {
                    $Message = 'Mail.Read - Delegated was found in the token scope.'
                    $HasMailRead = $true
                } else {
                    $Message = 'Please add Mail.Read - Delegated to the API permissions for CIPP-SAM.'
                    $HasMailRead = $false
                }

                if ($Me.proxyAddresses) {
                    $Emails = $Me.proxyAddresses | Select-Object @{n = 'Address'; exp = { ($_ -split ':')[1] } }, @{n = 'IsPrimary'; exp = { $_ -cmatch 'SMTP' } }
                } else {
                    $Emails = @(@{ Address = $Me.userPrincipalName; IsPrimary = $true })
                }

                $Body = [PSCustomObject]@{
                    Message       = $Message
                    HasMailRead   = $HasMailRead
                    MailUser      = $Me.displayName
                    MailAddresses = @($Emails)
                }
            }
            default {
                $Messages = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/me/mailFolders/Inbox/messages?`$select=receivedDateTime,subject,sender,internetMessageHeaders,webLink" -NoAuthCheck $true
                $Results = foreach ($Message in $Messages) {
                    if ($Message.receivedDateTime) {
                        $AuthResult = ($Message.internetMessageHeaders | Where-Object -Property name -EQ 'Authentication-Results').value
                        $AuthResult = $AuthResult -split ';\s*'
                        $AuthResult = $AuthResult | ForEach-Object {
                            if ($_ -match '^(?<Name>.+?)=\s*(?<Status>.+?)\s(?<Info>.+)$') {
                                [PSCustomObject]@{
                                    Name   = $Matches.Name
                                    Status = $Matches.Status
                                    Info   = $Matches.Info
                                }
                            }
                        }
                        [PSCustomObject]@{
                            Received   = $Message.receivedDateTime
                            Subject    = $Message.subject
                            Sender     = $Message.sender.emailAddress.name
                            From       = $Message.sender.emailAddress.address
                            Link       = $Message.webLink
                            Headers    = $Message.internetMessageHeaders
                            AuthResult = $AuthResult
                        }
                    }
                }
                $Body = [PSCustomObject]@{
                    Results  = @($Results)
                    Metadata = [PSCustomObject]@{
                        Count = ($Results | Measure-Object).Count
                    }
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::BadRequest
        $Body = [PSCustomObject]@{
            Results = @($ErrorMessage)
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ExecMailTest.ps1' 84
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListExoRequest.ps1' -1

function Invoke-ListExoRequest {
    param($Request, $TriggerMetadata)
    try {
        $AllowedVerbs = @(
            'Get'
            'Search'
        )

        $Cmdlet = $Request.Body.Cmdlet
        $cmdParams = if ($Request.Body.cmdParams) { $Request.Body.cmdParams } else { [PSCustomObject]@{} }
        $Verb = ($Cmdlet -split '-')[0]

        $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList

        $TenantFilter = $Request.Body.TenantFilter
        $Tenants = Get-Tenants -IncludeErrors
        $Tenant = $Tenants | Where-Object { $_.defaultDomainName -eq $TenantFilter -or $_.customerId -eq $TenantFilter }
        if ($Tenant.customerId -in $AllowedTenants -or $AllowedTenants -eq 'AllTenants') {
            if ($Request.Body.AvailableCmdlets) {
                $ExoRequest = @{
                    TenantID         = $TenantFilter
                    AvailableCmdlets = $true
                }
                if ($Request.Body.AsApp -eq $true) {
                    $ExoRequest.AsApp = $true
                }
                if ($Request.Body.Compliance -eq $true) {
                    $ExoRequest.Compliance = $true
                }
                $Results = New-ExoRequest @ExoRequest
                $Body = [PSCustomObject]@{
                    Results  = $Results | Select-Object @{ Name = 'Cmdlet'; Expression = { $_ } }
                    Metadata = @{
                        Count = ($Results | Measure-Object).Count
                    }
                }
            } else {
                if ($AllowedVerbs -notcontains $Verb) {
                    $Body = [pscustomobject]@{
                        Results = "Invalid cmdlet: $Cmdlet"
                    }
                    return ([HttpResponseContext]@{
                            StatusCode = [HttpStatusCode]::BadRequest
                            Body       = $Body
                        })
                    return
                }
                $ExoParams = @{
                    Cmdlet    = $Cmdlet
                    cmdParams = $cmdParams
                    tenantid  = $TenantFilter
                }

                if ($Request.Body.Select) {
                    $ExoParams.Select = $Request.Body.Select
                }

                if ($Request.Body.UseSystemMailbox -eq $true) {
                    $ExoParams.useSystemMailbox = $true
                }

                if ($Request.Body.Anchor) {
                    $ExoParams.Anchor = $Request.Body.Anchor
                }

                if ($Request.Body.Compliance -eq $true) {
                    $ExoParams.Compliance = $true
                }

                if ($Request.Body.AsApp -eq $true) {
                    $ExoParams.AsApp = $true
                }

                try {
                    $Results = New-ExoRequest @ExoParams
                    $Body = [pscustomobject]@{
                        Results = $Results
                    }
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    $Body = [pscustomobject]@{
                        Results = @(@{ Error = $ErrorMessage })
                    }
                }
            } else {
                $Body = [pscustomobject]@{
                    Results = "Invalid tenant: $TenantFilter"
                }
            }
        }
    } catch {
        Write-Information "ExoRequest Error: $($_.Exception.Message)"
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -InputObject $Body -Compress
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListExoRequest.ps1' 99
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListMailboxRestores.ps1' -1

function Invoke-ListMailboxRestores {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        if ([bool]$Request.Query.Statistics -eq $true -and $Request.Query.Identity) {
            $ExoRequest = @{
                tenantid  = $TenantFilter
                cmdlet    = 'Get-MailboxRestoreRequestStatistics'
                cmdParams = @{ Identity = $Request.Query.Identity }
            }

            if ([bool]$Request.Query.IncludeReport -eq $true) {
                $ExoRequest.cmdParams.IncludeReport = $true
            }
            $GraphRequest = New-ExoRequest @ExoRequest

        } else {
            $ExoRequest = @{
                tenantid = $TenantFilter
                cmdlet   = 'Get-MailboxRestoreRequest'
            }

            $RestoreRequests = (New-ExoRequest @ExoRequest)
            $GraphRequest = $RestoreRequests
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListMailboxRestores.ps1' 45
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListMessageTrace.ps1' -1

function Invoke-ListMessageTrace {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.TransportRule.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {
        $TenantFilter = $Request.Body.tenantFilter

        if ($Request.Body.MessageId) {
            $SearchParams = @{ 'MessageId' = $Request.Body.messageId }
        } else {
            $SearchParams = @{}
            if ($Request.Body.days) {
                $Days = $Request.Body.days
                $SearchParams.StartDate = (Get-Date).AddDays(-$Days).ToUniversalTime().ToString('s')
                $SearchParams.EndDate = (Get-Date).ToUniversalTime().ToString('s')
            } else {
                if ($Request.Body.startDate) {
                    if ($Request.Body.startDate -match '^\d+$') {
                        $SearchParams.StartDate = [DateTimeOffset]::FromUnixTimeSeconds([int64]$Request.Body.startDate).UtcDateTime.ToString('s')
                    } else {
                        $SearchParams.StartDate = [DateTime]::ParseExact($Request.Body.startDate, 'yyyy-MM-ddTHH:mm:ssZ', $null).ToUniversalTime().ToString('s')
                    }
                }
                if ($Request.Body.endDate) {
                    if ($Request.Body.endDate -match '^\d+$') {
                        $SearchParams.EndDate = [DateTimeOffset]::FromUnixTimeSeconds([int64]$Request.Body.endDate).UtcDateTime.ToString('s')
                    } else {
                        $SearchParams.EndDate = [DateTime]::ParseExact($Request.Body.endDate, 'yyyy-MM-ddTHH:mm:ssZ', $null).ToUniversalTime().ToString('s')
                    }
                }
            }

            if ($Request.Body.status) {
                $SearchParams.Add('Status', $Request.Body.status.value)
            }
            if (![string]::IsNullOrEmpty($Request.Body.fromIP)) {
                $SearchParams.Add('FromIP', $Request.Body.fromIP)
            }
            if (![string]::IsNullOrEmpty($Request.Body.toIP)) {
                $SearchParams.Add('ToIP', $Request.Body.toIP)
            }
        }

        if ($Request.Body.recipient) {
            $Searchparams.Add('RecipientAddress', $($Request.Body.recipient.value ?? $Request.Body.recipient))
        }
        if ($Request.Body.sender) {
            $Searchparams.Add('SenderAddress', $($Request.Body.sender.value ?? $Request.Body.sender))
        }

        $trace = if ($Request.Body.traceDetail) {
            $CmdParams = @{
                MessageTraceId   = $Request.Body.ID
                RecipientAddress = $Request.Body.recipient
            }
            New-ExoRequest -TenantId $TenantFilter -Cmdlet 'Get-MessageTraceDetailV2' -CmdParams $CmdParams | Select-Object @{ Name = 'Date'; Expression = { $_.Date.ToString('u') } }, Event, Action, Detail
        } else {
            Write-Information ($SearchParams | ConvertTo-Json)

            New-ExoRequest -TenantId $TenantFilter -Cmdlet 'Get-MessageTraceV2' -CmdParams $SearchParams | Select-Object MessageTraceId, Status, Subject, RecipientAddress, SenderAddress, @{ Name = 'Received'; Expression = { $_.Received.ToString('u') } }, FromIP, ToIP
            Write-LogMessage -headers $Request.Headers -API $APIName -tenant $($TenantFilter) -message 'Executed message trace' -Sev 'Info'

        }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($tenantfilter) -message "Failed executing messagetrace. Error: $($_.Exception.Message)" -Sev 'Error'
        $trace = @{Status = "Failed to retrieve message trace $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($trace)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Tools/Invoke-ListMessageTrace.ps1' 82
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddConnectionFilter.ps1' -1

Function Invoke-AddConnectionFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.ConnectionFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $RequestParams = $Request.Body.PowerShellCommand |
        ConvertFrom-Json |
        Select-Object -Property *, @{Name = 'identity'; Expression = { $_.name } } -ExcludeProperty GUID, comments, name

    $Tenants = ($Request.Body.selectedTenants).value
    $Result = foreach ($TenantFilter in $Tenants) {
        try {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-HostedConnectionFilterPolicy' -cmdParams $RequestParams
            "Successfully created Connection filter for $TenantFilter."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully created Connection filter for $TenantFilter." -sev Info
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Failed to create Connection Filter rule for $($TenantFilter): $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to create connection filter rule for $($TenantFilter): $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddConnectionFilter.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddConnectionFilterTemplate.ps1' -1

function Invoke-AddConnectionFilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.ConnectionFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    Write-Host ($request | ConvertTo-Json -Compress)

    try {
        $GUID = (New-Guid).GUID
        $JSON = if ($request.body.PowerShellCommand) {
            Write-Host 'PowerShellCommand'
            $request.body.PowerShellCommand | ConvertFrom-Json
        } else {
            $GUID = (New-Guid).GUID
            ([pscustomobject]$Request.body | Select-Object Name, EnableSafeList, IPAllowList , IPBlockList ) | ForEach-Object {
                $NonEmptyProperties = $_.psobject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
                $_ | Select-Object -Property $NonEmptyProperties
            }
        }
        $JSON = ($JSON | Select-Object @{n = 'name'; e = { $_.name } }, @{n = 'comments'; e = { $_.comments } }, * | ConvertTo-Json -Depth 10)
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$json"
            RowKey       = "$GUID"
            PartitionKey = 'ConnectionfilterTemplate'
        }
        $Result = "Successfully created Connection Filter Template: $($Request.Body.name) with GUID $GUID"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Debug'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create Connection Filter Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddConnectionFilterTemplate.ps1' 54
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddEditTransportRule.ps1' -1

function Invoke-AddEditTransportRule {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.TransportRule.ReadWrite
    .DESCRIPTION
        This function creates a new transport rule or edits an existing one (mail flow rule).
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter

    if (!$TenantFilter) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'TenantFilter is required'
            })
        return
    }

    # Extract basic rule settings from body
    $Identity = $Request.Body.ruleId
    $Name = $Request.Body.Name
    $Priority = $Request.Body.Priority
    $Comments = $Request.Body.Comments
    $Mode = $Request.Body.Mode
    $SetAuditSeverity = $Request.Body.SetAuditSeverity
    $State = $Request.Body.State
    $CmdletState = $Request.Body.State ?? $Request.Body.Enabled
    $Enabled = $Request.Body.Enabled
    $StopRuleProcessing = $Request.Body.StopRuleProcessing
    $SenderAddressLocation = $Request.Body.SenderAddressLocation
    $ActivationDate = $Request.Body.ActivationDate
    $ExpiryDate = $Request.Body.ExpiryDate

    # Extract condition fields
    $From = $Request.Body.From
    $FromScope = $Request.Body.FromScope
    $FromMemberOf = $Request.Body.FromMemberOf
    $SentTo = $Request.Body.SentTo
    $SentToScope = $Request.Body.SentToScope
    $SentToMemberOf = $Request.Body.SentToMemberOf
    $SubjectContainsWords = $Request.Body.SubjectContainsWords
    $SubjectMatchesPatterns = $Request.Body.SubjectMatchesPatterns
    $SubjectOrBodyContainsWords = $Request.Body.SubjectOrBodyContainsWords
    $SubjectOrBodyMatchesPatterns = $Request.Body.SubjectOrBodyMatchesPatterns
    $FromAddressContainsWords = $Request.Body.FromAddressContainsWords
    $FromAddressMatchesPatterns = $Request.Body.FromAddressMatchesPatterns
    $AttachmentContainsWords = $Request.Body.AttachmentContainsWords
    $AttachmentMatchesPatterns = $Request.Body.AttachmentMatchesPatterns
    $AttachmentExtensionMatchesWords = $Request.Body.AttachmentExtensionMatchesWords
    $AttachmentSizeOver = $Request.Body.AttachmentSizeOver
    $MessageSizeOver = $Request.Body.MessageSizeOver
    $SCLOver = $Request.Body.SCLOver
    $WithImportance = $Request.Body.WithImportance
    $MessageTypeMatches = $Request.Body.MessageTypeMatches
    $SenderDomainIs = $Request.Body.SenderDomainIs
    $RecipientDomainIs = $Request.Body.RecipientDomainIs
    $RecipientAddressContainsWords = $Request.Body.RecipientAddressContainsWords
    $RecipientAddressMatchesPatterns = $Request.Body.RecipientAddressMatchesPatterns
    $AnyOfRecipientAddressContainsWords = $Request.Body.AnyOfRecipientAddressContainsWords
    $AnyOfRecipientAddressMatchesPatterns = $Request.Body.AnyOfRecipientAddressMatchesPatterns
    $AnyOfToHeader = $Request.Body.AnyOfToHeader
    $AnyOfToHeaderMemberOf = $Request.Body.AnyOfToHeaderMemberOf
    $AnyOfCcHeader = $Request.Body.AnyOfCcHeader
    $AnyOfCcHeaderMemberOf = $Request.Body.AnyOfCcHeaderMemberOf
    $AnyOfToCcHeader = $Request.Body.AnyOfToCcHeader
    $AnyOfToCcHeaderMemberOf = $Request.Body.AnyOfToCcHeaderMemberOf
    $HeaderContainsWords = $Request.Body.HeaderContainsWords
    $HeaderContainsWordsMessageHeader = $Request.Body.HeaderContainsWordsMessageHeader
    $HeaderMatchesPatterns = $Request.Body.HeaderMatchesPatterns
    $HeaderMatchesPatternsMessageHeader = $Request.Body.HeaderMatchesPatternsMessageHeader
    $SenderIpRanges = $Request.Body.SenderIpRanges

    # Extract action fields
    $DeleteMessage = $Request.Body.DeleteMessage
    $Quarantine = $Request.Body.Quarantine
    $RedirectMessageTo = $Request.Body.RedirectMessageTo
    $BlindCopyTo = $Request.Body.BlindCopyTo
    $CopyTo = $Request.Body.CopyTo
    $ModerateMessageByUser = $Request.Body.ModerateMessageByUser
    $ModerateMessageByManager = $Request.Body.ModerateMessageByManager
    $RejectMessageReasonText = $Request.Body.RejectMessageReasonText
    $RejectMessageEnhancedStatusCode = $Request.Body.RejectMessageEnhancedStatusCode
    $PrependSubject = $Request.Body.PrependSubject
    $SetSCL = $Request.Body.SetSCL
    $SetHeaderName = $Request.Body.SetHeaderName
    $SetHeaderValue = $Request.Body.SetHeaderValue
    $RemoveHeader = $Request.Body.RemoveHeader
    $ApplyClassification = $Request.Body.ApplyClassification
    $ApplyHtmlDisclaimerText = $Request.Body.ApplyHtmlDisclaimerText
    $ApplyHtmlDisclaimerLocation = $Request.Body.ApplyHtmlDisclaimerLocation
    $ApplyHtmlDisclaimerFallbackAction = $Request.Body.ApplyHtmlDisclaimerFallbackAction
    $GenerateIncidentReport = $Request.Body.GenerateIncidentReport
    $GenerateNotification = $Request.Body.GenerateNotification
    $ApplyOME = $Request.Body.ApplyOME

    # Extract exception fields (ExceptIf versions)
    $ExceptIfFrom = $Request.Body.ExceptIfFrom
    $ExceptIfFromScope = $Request.Body.ExceptIfFromScope
    $ExceptIfFromMemberOf = $Request.Body.ExceptIfFromMemberOf
    $ExceptIfSentTo = $Request.Body.ExceptIfSentTo
    $ExceptIfSentToScope = $Request.Body.ExceptIfSentToScope
    $ExceptIfSentToMemberOf = $Request.Body.ExceptIfSentToMemberOf
    $ExceptIfSubjectContainsWords = $Request.Body.ExceptIfSubjectContainsWords
    $ExceptIfSubjectMatchesPatterns = $Request.Body.ExceptIfSubjectMatchesPatterns
    $ExceptIfSubjectOrBodyContainsWords = $Request.Body.ExceptIfSubjectOrBodyContainsWords
    $ExceptIfSubjectOrBodyMatchesPatterns = $Request.Body.ExceptIfSubjectOrBodyMatchesPatterns
    $ExceptIfFromAddressContainsWords = $Request.Body.ExceptIfFromAddressContainsWords
    $ExceptIfFromAddressMatchesPatterns = $Request.Body.ExceptIfFromAddressMatchesPatterns
    $ExceptIfAttachmentContainsWords = $Request.Body.ExceptIfAttachmentContainsWords
    $ExceptIfAttachmentMatchesPatterns = $Request.Body.ExceptIfAttachmentMatchesPatterns
    $ExceptIfAttachmentExtensionMatchesWords = $Request.Body.ExceptIfAttachmentExtensionMatchesWords
    $ExceptIfAttachmentSizeOver = $Request.Body.ExceptIfAttachmentSizeOver
    $ExceptIfMessageSizeOver = $Request.Body.ExceptIfMessageSizeOver
    $ExceptIfSCLOver = $Request.Body.ExceptIfSCLOver
    $ExceptIfWithImportance = $Request.Body.ExceptIfWithImportance
    $ExceptIfMessageTypeMatches = $Request.Body.ExceptIfMessageTypeMatches
    $ExceptIfSenderDomainIs = $Request.Body.ExceptIfSenderDomainIs
    $ExceptIfRecipientDomainIs = $Request.Body.ExceptIfRecipientDomainIs
    $ExceptIfRecipientAddressContainsWords = $Request.Body.ExceptIfRecipientAddressContainsWords
    $ExceptIfRecipientAddressMatchesPatterns = $Request.Body.ExceptIfRecipientAddressMatchesPatterns
    $ExceptIfAnyOfRecipientAddressContainsWords = $Request.Body.ExceptIfAnyOfRecipientAddressContainsWords
    $ExceptIfAnyOfRecipientAddressMatchesPatterns = $Request.Body.ExceptIfAnyOfRecipientAddressMatchesPatterns
    $ExceptIfAnyOfToHeader = $Request.Body.ExceptIfAnyOfToHeader
    $ExceptIfAnyOfToHeaderMemberOf = $Request.Body.ExceptIfAnyOfToHeaderMemberOf
    $ExceptIfAnyOfCcHeader = $Request.Body.ExceptIfAnyOfCcHeader
    $ExceptIfAnyOfCcHeaderMemberOf = $Request.Body.ExceptIfAnyOfCcHeaderMemberOf
    $ExceptIfAnyOfToCcHeader = $Request.Body.ExceptIfAnyOfToCcHeader
    $ExceptIfAnyOfToCcHeaderMemberOf = $Request.Body.ExceptIfAnyOfToCcHeaderMemberOf
    $ExceptIfHeaderContainsWords = $Request.Body.ExceptIfHeaderContainsWords
    $ExceptIfHeaderContainsWordsMessageHeader = $Request.Body.ExceptIfHeaderContainsWordsMessageHeader
    $ExceptIfHeaderMatchesPatterns = $Request.Body.ExceptIfHeaderMatchesPatterns
    $ExceptIfHeaderMatchesPatternsMessageHeader = $Request.Body.ExceptIfHeaderMatchesPatternsMessageHeader
    $ExceptIfSenderIpRanges = $Request.Body.ExceptIfSenderIpRanges

    # Helper function to process array fields
    function Process-ArrayField {
        param (
            [Parameter(Mandatory = $false)]
            $Field
        )

        if ($null -eq $Field) { return @() }

        # If already an array, process each item
        if ($Field -is [array]) {
            $result = [System.Collections.ArrayList]@()
            foreach ($item in $Field) {
                if ($item -is [string]) {
                    $result.Add($item) | Out-Null
                } elseif ($item -is [hashtable] -or $item -is [PSCustomObject]) {
                    # Extract value from object
                    if ($null -ne $item.value) {
                        $result.Add($item.value) | Out-Null
                    } elseif ($null -ne $item.userPrincipalName) {
                        $result.Add($item.userPrincipalName) | Out-Null
                    } elseif ($null -ne $item.id) {
                        $result.Add($item.id) | Out-Null
                    } else {
                        $result.Add($item.ToString()) | Out-Null
                    }
                } else {
                    $result.Add($item.ToString()) | Out-Null
                }
            }
            return $result.ToArray()
        }

        # If it's a single object
        if ($Field -is [hashtable] -or $Field -is [PSCustomObject]) {
            if ($null -ne $Field.value) { return @($Field.value) }
            if ($null -ne $Field.userPrincipalName) { return @($Field.userPrincipalName) }
            if ($null -ne $Field.id) { return @($Field.id) }
        }

        # If it's a string, return as an array with one item
        if ($Field -is [string]) {
            return @($Field)
        }

        return @($Field)
    }

    # Helper function to process comma-separated text fields into arrays
    function Process-TextArrayField {
        param (
            [Parameter(Mandatory = $false)]
            $Field
        )

        if ($null -eq $Field -or $Field -eq '') { return @() }

        if ($Field -is [array]) {
            return $Field
        }

        if ($Field -is [string]) {
            # Split by comma and trim whitespace
            return ($Field -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })
        }

        return @($Field)
    }

    # Convert state to bool when creating new rule
    if ($State -eq "Disabled") {
        $State = $false
    }

    if ($State -eq "Enabled") {
        $State = $true
    }

    if ($Enabled -eq "Disabled") {
        $State = $false
    }

    if ($Enabled -eq "Enabled") {
        $State = $true
    }

    # Process array fields for recipients/users
    $From = Process-ArrayField -Field $From
    $FromMemberOf = Process-ArrayField -Field $FromMemberOf
    $SentTo = Process-ArrayField -Field $SentTo
    $SentToMemberOf = Process-ArrayField -Field $SentToMemberOf
    $AnyOfToHeader = Process-ArrayField -Field $AnyOfToHeader
    $AnyOfToHeaderMemberOf = Process-ArrayField -Field $AnyOfToHeaderMemberOf
    $AnyOfCcHeader = Process-ArrayField -Field $AnyOfCcHeader
    $AnyOfCcHeaderMemberOf = Process-ArrayField -Field $AnyOfCcHeaderMemberOf
    $AnyOfToCcHeader = Process-ArrayField -Field $AnyOfToCcHeader
    $AnyOfToCcHeaderMemberOf = Process-ArrayField -Field $AnyOfToCcHeaderMemberOf
    $RedirectMessageTo = Process-ArrayField -Field $RedirectMessageTo
    $BlindCopyTo = Process-ArrayField -Field $BlindCopyTo
    $CopyTo = Process-ArrayField -Field $CopyTo
    $ModerateMessageByUser = Process-ArrayField -Field $ModerateMessageByUser
    $ExceptIfFrom = Process-ArrayField -Field $ExceptIfFrom
    $ExceptIfFromMemberOf = Process-ArrayField -Field $ExceptIfFromMemberOf
    $ExceptIfSentTo = Process-ArrayField -Field $ExceptIfSentTo
    $ExceptIfSentToMemberOf = Process-ArrayField -Field $ExceptIfSentToMemberOf
    $ExceptIfAnyOfToHeader = Process-ArrayField -Field $ExceptIfAnyOfToHeader
    $ExceptIfAnyOfToHeaderMemberOf = Process-ArrayField -Field $ExceptIfAnyOfToHeaderMemberOf
    $ExceptIfAnyOfCcHeader = Process-ArrayField -Field $ExceptIfAnyOfCcHeader
    $ExceptIfAnyOfCcHeaderMemberOf = Process-ArrayField -Field $ExceptIfAnyOfCcHeaderMemberOf
    $ExceptIfAnyOfToCcHeader = Process-ArrayField -Field $ExceptIfAnyOfToCcHeader
    $ExceptIfAnyOfToCcHeaderMemberOf = Process-ArrayField -Field $ExceptIfAnyOfToCcHeaderMemberOf
    $SenderDomainIs = Process-ArrayField -Field $SenderDomainIs
    $RecipientDomainIs = Process-ArrayField -Field $RecipientDomainIs
    $ExceptIfSenderDomainIs = Process-ArrayField -Field $ExceptIfSenderDomainIs
    $ExceptIfRecipientDomainIs = Process-ArrayField -Field $ExceptIfRecipientDomainIs

    # Process text array fields (comma-separated strings)
    $SubjectContainsWords = Process-TextArrayField -Field $SubjectContainsWords
    $SubjectMatchesPatterns = Process-TextArrayField -Field $SubjectMatchesPatterns
    $SubjectOrBodyContainsWords = Process-TextArrayField -Field $SubjectOrBodyContainsWords
    $SubjectOrBodyMatchesPatterns = Process-TextArrayField -Field $SubjectOrBodyMatchesPatterns
    $FromAddressContainsWords = Process-TextArrayField -Field $FromAddressContainsWords
    $FromAddressMatchesPatterns = Process-TextArrayField -Field $FromAddressMatchesPatterns
    $AttachmentContainsWords = Process-TextArrayField -Field $AttachmentContainsWords
    $AttachmentMatchesPatterns = Process-TextArrayField -Field $AttachmentMatchesPatterns
    $AttachmentExtensionMatchesWords = Process-TextArrayField -Field $AttachmentExtensionMatchesWords
    $RecipientAddressContainsWords = Process-TextArrayField -Field $RecipientAddressContainsWords
    $RecipientAddressMatchesPatterns = Process-TextArrayField -Field $RecipientAddressMatchesPatterns
    $AnyOfRecipientAddressContainsWords = Process-TextArrayField -Field $AnyOfRecipientAddressContainsWords
    $AnyOfRecipientAddressMatchesPatterns = Process-TextArrayField -Field $AnyOfRecipientAddressMatchesPatterns
    $HeaderContainsWords = Process-TextArrayField -Field $HeaderContainsWords
    $HeaderMatchesPatterns = Process-TextArrayField -Field $HeaderMatchesPatterns

    # Process exception text array fields
    $ExceptIfSubjectContainsWords = Process-TextArrayField -Field $ExceptIfSubjectContainsWords
    $ExceptIfSubjectMatchesPatterns = Process-TextArrayField -Field $ExceptIfSubjectMatchesPatterns
    $ExceptIfSubjectOrBodyContainsWords = Process-TextArrayField -Field $ExceptIfSubjectOrBodyContainsWords
    $ExceptIfSubjectOrBodyMatchesPatterns = Process-TextArrayField -Field $ExceptIfSubjectOrBodyMatchesPatterns
    $ExceptIfFromAddressContainsWords = Process-TextArrayField -Field $ExceptIfFromAddressContainsWords
    $ExceptIfFromAddressMatchesPatterns = Process-TextArrayField -Field $ExceptIfFromAddressMatchesPatterns
    $ExceptIfAttachmentContainsWords = Process-TextArrayField -Field $ExceptIfAttachmentContainsWords
    $ExceptIfAttachmentMatchesPatterns = Process-TextArrayField -Field $ExceptIfAttachmentMatchesPatterns
    $ExceptIfAttachmentExtensionMatchesWords = Process-TextArrayField -Field $ExceptIfAttachmentExtensionMatchesWords
    $ExceptIfRecipientAddressContainsWords = Process-TextArrayField -Field $ExceptIfRecipientAddressContainsWords
    $ExceptIfRecipientAddressMatchesPatterns = Process-TextArrayField -Field $ExceptIfRecipientAddressMatchesPatterns
    $ExceptIfAnyOfRecipientAddressContainsWords = Process-TextArrayField -Field $ExceptIfAnyOfRecipientAddressContainsWords
    $ExceptIfAnyOfRecipientAddressMatchesPatterns = Process-TextArrayField -Field $ExceptIfAnyOfRecipientAddressMatchesPatterns
    $ExceptIfHeaderContainsWords = Process-TextArrayField -Field $ExceptIfHeaderContainsWords
    $ExceptIfHeaderMatchesPatterns = Process-TextArrayField -Field $ExceptIfHeaderMatchesPatterns

    # Process IP range fields
    $SenderIpRanges = Process-TextArrayField -Field $SenderIpRanges
    $ExceptIfSenderIpRanges = Process-TextArrayField -Field $ExceptIfSenderIpRanges

    try {
        # Build command parameters for transport rule
        $ruleParams = @{
            Name = $Name
        }

        # If editing existing rule add Identity
        if ($null -ne $Identity) { $ruleParams.Add('Identity', $Identity) }

        # State uses a different cmdlet for updating an existing rule so extract the required data to enable or disable it
        $CmdletState = if ($CmdletState -eq 'Enabled') { 'Enable-TransportRule' } else { 'Disable-TransportRule' }

        # Basic parameters
        if (($null -ne $State) -and (!$Identity)) { $ruleParams.Add('Enabled', $State) }
        if ($null -ne $Priority) { $ruleParams.Add('Priority', $Priority) }
        if ($null -ne $Comments) { $ruleParams.Add('Comments', $Comments) }
        if ($null -ne $Mode) {
            $modeValue = if ($Mode.value) { $Mode.value } else { $Mode }
            $ruleParams.Add('Mode', $modeValue)
        }
        if ($null -ne $SetAuditSeverity) {
            $severityValue = if ($SetAuditSeverity.value) { $SetAuditSeverity.value } else { $SetAuditSeverity }
            if ($severityValue -ne '') {
                $ruleParams.Add('SetAuditSeverity', $severityValue)
            }
        }
        if ($null -ne $StopRuleProcessing) { $ruleParams.Add('StopRuleProcessing', $StopRuleProcessing) }
        if ($null -ne $SenderAddressLocation) {
            $locationValue = if ($SenderAddressLocation.value) { $SenderAddressLocation.value } else { $SenderAddressLocation }
            $ruleParams.Add('SenderAddressLocation', $locationValue)
        }
        if ($null -ne $ActivationDate -and $ActivationDate -ne '') { $ruleParams.Add('ActivationDate', $ActivationDate) }
        if ($null -ne $ExpiryDate -and $ExpiryDate -ne '') { $ruleParams.Add('ExpiryDate', $ExpiryDate) }

        # Condition parameters
        if ($null -ne $From -and $From.Count -gt 0) { $ruleParams.Add('From', $From) }
        if ($null -ne $FromScope) {
            $fromScopeValue = if ($FromScope.value) { $FromScope.value } else { $FromScope }
            $ruleParams.Add('FromScope', $fromScopeValue)
        }
        if ($null -ne $FromMemberOf -and $FromMemberOf.Count -gt 0) { $ruleParams.Add('FromMemberOf', $FromMemberOf) }
        if ($null -ne $SentTo -and $SentTo.Count -gt 0) { $ruleParams.Add('SentTo', $SentTo) }
        if ($null -ne $SentToScope) {
            $sentToScopeValue = if ($SentToScope.value) { $SentToScope.value } else { $SentToScope }
            $ruleParams.Add('SentToScope', $sentToScopeValue)
        }
        if ($null -ne $SentToMemberOf -and $SentToMemberOf.Count -gt 0) { $ruleParams.Add('SentToMemberOf', $SentToMemberOf) }
        if ($null -ne $SubjectContainsWords -and $SubjectContainsWords.Count -gt 0) {
            $ruleParams.Add('SubjectContainsWords', $SubjectContainsWords)
        }
        if ($null -ne $SubjectMatchesPatterns -and $SubjectMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('SubjectMatchesPatterns', $SubjectMatchesPatterns)
        }
        if ($null -ne $SubjectOrBodyContainsWords -and $SubjectOrBodyContainsWords.Count -gt 0) {
            $ruleParams.Add('SubjectOrBodyContainsWords', $SubjectOrBodyContainsWords)
        }
        if ($null -ne $SubjectOrBodyMatchesPatterns -and $SubjectOrBodyMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('SubjectOrBodyMatchesPatterns', $SubjectOrBodyMatchesPatterns)
        }
        if ($null -ne $FromAddressContainsWords -and $FromAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('FromAddressContainsWords', $FromAddressContainsWords)
        }
        if ($null -ne $FromAddressMatchesPatterns -and $FromAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('FromAddressMatchesPatterns', $FromAddressMatchesPatterns)
        }
        if ($null -ne $AttachmentContainsWords -and $AttachmentContainsWords.Count -gt 0) {
            $ruleParams.Add('AttachmentContainsWords', $AttachmentContainsWords)
        }
        if ($null -ne $AttachmentMatchesPatterns -and $AttachmentMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('AttachmentMatchesPatterns', $AttachmentMatchesPatterns)
        }
        if ($null -ne $AttachmentExtensionMatchesWords -and $AttachmentExtensionMatchesWords.Count -gt 0) {
            $ruleParams.Add('AttachmentExtensionMatchesWords', $AttachmentExtensionMatchesWords)
        }
        if ($null -ne $AttachmentSizeOver) { $ruleParams.Add('AttachmentSizeOver', $AttachmentSizeOver) }
        if ($null -ne $MessageSizeOver) { $ruleParams.Add('MessageSizeOver', $MessageSizeOver) }
        if ($null -ne $SCLOver) {
            $sclValue = if ($SCLOver.value) { $SCLOver.value } else { $SCLOver }
            $ruleParams.Add('SCLOver', $sclValue)
        }
        if ($null -ne $WithImportance) {
            $importanceValue = if ($WithImportance.value) { $WithImportance.value } else { $WithImportance }
            $ruleParams.Add('WithImportance', $importanceValue)
        }
        if ($null -ne $MessageTypeMatches) {
            $messageTypeValue = if ($MessageTypeMatches.value) { $MessageTypeMatches.value } else { $MessageTypeMatches }
            $ruleParams.Add('MessageTypeMatches', $messageTypeValue)
        }
        if ($null -ne $SenderDomainIs -and $SenderDomainIs.Count -gt 0) {
            $ruleParams.Add('SenderDomainIs', $SenderDomainIs)
        }
        if ($null -ne $RecipientDomainIs -and $RecipientDomainIs.Count -gt 0) {
            $ruleParams.Add('RecipientDomainIs', $RecipientDomainIs)
        }
        if ($null -ne $RecipientAddressContainsWords -and $RecipientAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('RecipientAddressContainsWords', $RecipientAddressContainsWords)
        }
        if ($null -ne $RecipientAddressMatchesPatterns -and $RecipientAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('RecipientAddressMatchesPatterns', $RecipientAddressMatchesPatterns)
        }
        if ($null -ne $AnyOfRecipientAddressContainsWords -and $AnyOfRecipientAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('AnyOfRecipientAddressContainsWords', $AnyOfRecipientAddressContainsWords)
        }
        if ($null -ne $AnyOfRecipientAddressMatchesPatterns -and $AnyOfRecipientAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('AnyOfRecipientAddressMatchesPatterns', $AnyOfRecipientAddressMatchesPatterns)
        }
        if ($null -ne $AnyOfToHeader -and $AnyOfToHeader.Count -gt 0) {
            $ruleParams.Add('AnyOfToHeader', $AnyOfToHeader)
        }
        if ($null -ne $AnyOfToHeaderMemberOf -and $AnyOfToHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('AnyOfToHeaderMemberOf', $AnyOfToHeaderMemberOf)
        }
        if ($null -ne $AnyOfCcHeader -and $AnyOfCcHeader.Count -gt 0) {
            $ruleParams.Add('AnyOfCcHeader', $AnyOfCcHeader)
        }
        if ($null -ne $AnyOfCcHeaderMemberOf -and $AnyOfCcHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('AnyOfCcHeaderMemberOf', $AnyOfCcHeaderMemberOf)
        }
        if ($null -ne $AnyOfToCcHeader -and $AnyOfToCcHeader.Count -gt 0) {
            $ruleParams.Add('AnyOfToCcHeader', $AnyOfToCcHeader)
        }
        if ($null -ne $AnyOfToCcHeaderMemberOf -and $AnyOfToCcHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('AnyOfToCcHeaderMemberOf', $AnyOfToCcHeaderMemberOf)
        }
        if ($null -ne $HeaderContainsWords -and $HeaderContainsWords.Count -gt 0 -and $null -ne $HeaderContainsWordsMessageHeader) {
            $ruleParams.Add('HeaderContainsMessageHeader', $HeaderContainsWordsMessageHeader)
            $ruleParams.Add('HeaderContainsWords', $HeaderContainsWords)
        }
        if ($null -ne $HeaderMatchesPatterns -and $HeaderMatchesPatterns.Count -gt 0 -and $null -ne $HeaderMatchesPatternsMessageHeader) {
            $ruleParams.Add('HeaderMatchesMessageHeader', $HeaderMatchesPatternsMessageHeader)
            $ruleParams.Add('HeaderMatchesPatterns', $HeaderMatchesPatterns)
        }
        if ($null -ne $SenderIpRanges -and $SenderIpRanges.Count -gt 0) {
            $ruleParams.Add('SenderIpRanges', $SenderIpRanges)
        }

        # Action parameters
        if ($null -ne $DeleteMessage) { $ruleParams.Add('DeleteMessage', $DeleteMessage) }
        if ($null -ne $Quarantine) { $ruleParams.Add('Quarantine', $Quarantine) }
        if ($null -ne $RedirectMessageTo -and $RedirectMessageTo.Count -gt 0) {
            $ruleParams.Add('RedirectMessageTo', $RedirectMessageTo)
        }
        if ($null -ne $BlindCopyTo -and $BlindCopyTo.Count -gt 0) { $ruleParams.Add('BlindCopyTo', $BlindCopyTo) }
        if ($null -ne $CopyTo -and $CopyTo.Count -gt 0) { $ruleParams.Add('CopyTo', $CopyTo) }
        if ($null -ne $ModerateMessageByUser -and $ModerateMessageByUser.Count -gt 0) {
            $ruleParams.Add('ModerateMessageByUser', $ModerateMessageByUser)
        }
        if ($null -ne $ModerateMessageByManager) { $ruleParams.Add('ModerateMessageByManager', $ModerateMessageByManager) }
        if ($null -ne $RejectMessageReasonText -and $RejectMessageReasonText -ne '') {
            $ruleParams.Add('RejectMessageReasonText', $RejectMessageReasonText)
        }
        if ($null -ne $RejectMessageEnhancedStatusCode -and $RejectMessageEnhancedStatusCode -ne '') {
            $ruleParams.Add('RejectMessageEnhancedStatusCode', $RejectMessageEnhancedStatusCode)
        }
        if ($null -ne $PrependSubject -and $PrependSubject -ne '') { $ruleParams.Add('PrependSubject', $PrependSubject) }
        if ($null -ne $SetSCL) {
            $setSclValue = if ($SetSCL.value) { $SetSCL.value } else { $SetSCL }
            $ruleParams.Add('SetSCL', $setSclValue)
        }
        if ($null -ne $SetHeaderName -and $SetHeaderName -ne '' -and $null -ne $SetHeaderValue) {
            $ruleParams.Add('SetHeaderName', $SetHeaderName)
            $ruleParams.Add('SetHeaderValue', $SetHeaderValue)
        }
        if ($null -ne $RemoveHeader -and $RemoveHeader -ne '') { $ruleParams.Add('RemoveHeader', $RemoveHeader) }
        if ($null -ne $ApplyClassification -and $ApplyClassification -ne '') {
            $ruleParams.Add('ApplyClassification', $ApplyClassification)
        }
        if ($null -ne $ApplyHtmlDisclaimerText -and $ApplyHtmlDisclaimerText -ne '') {
            $ruleParams.Add('ApplyHtmlDisclaimerText', $ApplyHtmlDisclaimerText)
            if ($null -ne $ApplyHtmlDisclaimerLocation) {
                $disclaimerLocationValue = if ($ApplyHtmlDisclaimerLocation.value) { $ApplyHtmlDisclaimerLocation.value } else { $ApplyHtmlDisclaimerLocation }
                $ruleParams.Add('ApplyHtmlDisclaimerLocation', $disclaimerLocationValue)
            }
            if ($null -ne $ApplyHtmlDisclaimerFallbackAction) {
                $disclaimerFallbackValue = if ($ApplyHtmlDisclaimerFallbackAction.value) { $ApplyHtmlDisclaimerFallbackAction.value } else { $ApplyHtmlDisclaimerFallbackAction }
                $ruleParams.Add('ApplyHtmlDisclaimerFallbackAction', $disclaimerFallbackValue)
            }
        }
        if ($null -ne $GenerateIncidentReport -and $GenerateIncidentReport.Count -gt 0) {
            $ruleParams.Add('GenerateIncidentReport', $GenerateIncidentReport)
        }
        if ($null -ne $GenerateNotification -and $GenerateNotification -ne '') {
            $ruleParams.Add('GenerateNotification', $GenerateNotification)
        }
        if ($null -ne $ApplyOME) { $ruleParams.Add('ApplyOME', $ApplyOME) }

        # Exception parameters (ExceptIf versions)
        if ($null -ne $ExceptIfFrom -and $ExceptIfFrom.Count -gt 0) { $ruleParams.Add('ExceptIfFrom', $ExceptIfFrom) }
        if ($null -ne $ExceptIfFromScope) {
            $exceptFromScopeValue = if ($ExceptIfFromScope.value) { $ExceptIfFromScope.value } else { $ExceptIfFromScope }
            $ruleParams.Add('ExceptIfFromScope', $exceptFromScopeValue)
        }
        if ($null -ne $ExceptIfFromMemberOf -and $ExceptIfFromMemberOf.Count -gt 0) { $ruleParams.Add('ExceptIfFromMemberOf', $ExceptIfFromMemberOf) }
        if ($null -ne $ExceptIfSentTo -and $ExceptIfSentTo.Count -gt 0) { $ruleParams.Add('ExceptIfSentTo', $ExceptIfSentTo) }
        if ($null -ne $ExceptIfSentToScope) {
            $exceptSentToScopeValue = if ($ExceptIfSentToScope.value) { $ExceptIfSentToScope.value } else { $ExceptIfSentToScope }
            $ruleParams.Add('ExceptIfSentToScope', $exceptSentToScopeValue)
        }
        if ($null -ne $ExceptIfSentToMemberOf -and $ExceptIfSentToMemberOf.Count -gt 0) { $ruleParams.Add('ExceptIfSentToMemberOf', $ExceptIfSentToMemberOf) }
        if ($null -ne $ExceptIfSubjectContainsWords -and $ExceptIfSubjectContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfSubjectContainsWords', $ExceptIfSubjectContainsWords)
        }
        if ($null -ne $ExceptIfSubjectMatchesPatterns -and $ExceptIfSubjectMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfSubjectMatchesPatterns', $ExceptIfSubjectMatchesPatterns)
        }
        if ($null -ne $ExceptIfSubjectOrBodyContainsWords -and $ExceptIfSubjectOrBodyContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfSubjectOrBodyContainsWords', $ExceptIfSubjectOrBodyContainsWords)
        }
        if ($null -ne $ExceptIfSubjectOrBodyMatchesPatterns -and $ExceptIfSubjectOrBodyMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfSubjectOrBodyMatchesPatterns', $ExceptIfSubjectOrBodyMatchesPatterns)
        }
        if ($null -ne $ExceptIfFromAddressContainsWords -and $ExceptIfFromAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfFromAddressContainsWords', $ExceptIfFromAddressContainsWords)
        }
        if ($null -ne $ExceptIfFromAddressMatchesPatterns -and $ExceptIfFromAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfFromAddressMatchesPatterns', $ExceptIfFromAddressMatchesPatterns)
        }
        if ($null -ne $ExceptIfAttachmentContainsWords -and $ExceptIfAttachmentContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfAttachmentContainsWords', $ExceptIfAttachmentContainsWords)
        }
        if ($null -ne $ExceptIfAttachmentMatchesPatterns -and $ExceptIfAttachmentMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfAttachmentMatchesPatterns', $ExceptIfAttachmentMatchesPatterns)
        }
        if ($null -ne $ExceptIfAttachmentExtensionMatchesWords -and $ExceptIfAttachmentExtensionMatchesWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfAttachmentExtensionMatchesWords', $ExceptIfAttachmentExtensionMatchesWords)
        }
        if ($null -ne $ExceptIfAttachmentSizeOver) {
            $ruleParams.Add('ExceptIfAttachmentSizeOver', $ExceptIfAttachmentSizeOver)
        }
        if ($null -ne $ExceptIfMessageSizeOver) { $ruleParams.Add('ExceptIfMessageSizeOver', $ExceptIfMessageSizeOver) }
        if ($null -ne $ExceptIfSCLOver) {
            $exceptSclValue = if ($ExceptIfSCLOver.value) { $ExceptIfSCLOver.value } else { $ExceptIfSCLOver }
            $ruleParams.Add('ExceptIfSCLOver', $exceptSclValue)
        }
        if ($null -ne $ExceptIfWithImportance) {
            $exceptImportanceValue = if ($ExceptIfWithImportance.value) { $ExceptIfWithImportance.value } else { $ExceptIfWithImportance }
            $ruleParams.Add('ExceptIfWithImportance', $exceptImportanceValue)
        }
        if ($null -ne $ExceptIfMessageTypeMatches) {
            $exceptMessageTypeValue = if ($ExceptIfMessageTypeMatches.value) { $ExceptIfMessageTypeMatches.value } else { $ExceptIfMessageTypeMatches }
            $ruleParams.Add('ExceptIfMessageTypeMatches', $exceptMessageTypeValue)
        }
        if ($null -ne $ExceptIfSenderDomainIs -and $ExceptIfSenderDomainIs.Count -gt 0) {
            $ruleParams.Add('ExceptIfSenderDomainIs', $ExceptIfSenderDomainIs)
        }
        if ($null -ne $ExceptIfRecipientDomainIs -and $ExceptIfRecipientDomainIs.Count -gt 0) {
            $ruleParams.Add('ExceptIfRecipientDomainIs', $ExceptIfRecipientDomainIs)
        }
        if ($null -ne $ExceptIfRecipientAddressContainsWords -and $ExceptIfRecipientAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfRecipientAddressContainsWords', $ExceptIfRecipientAddressContainsWords)
        }
        if ($null -ne $ExceptIfRecipientAddressMatchesPatterns -and $ExceptIfRecipientAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfRecipientAddressMatchesPatterns', $ExceptIfRecipientAddressMatchesPatterns)
        }
        if ($null -ne $ExceptIfAnyOfRecipientAddressContainsWords -and $ExceptIfAnyOfRecipientAddressContainsWords.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfRecipientAddressContainsWords', $ExceptIfAnyOfRecipientAddressContainsWords)
        }
        if ($null -ne $ExceptIfAnyOfRecipientAddressMatchesPatterns -and $ExceptIfAnyOfRecipientAddressMatchesPatterns.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfRecipientAddressMatchesPatterns', $ExceptIfAnyOfRecipientAddressMatchesPatterns)
        }
        if ($null -ne $ExceptIfAnyOfToHeader -and $ExceptIfAnyOfToHeader.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfToHeader', $ExceptIfAnyOfToHeader)
        }
        if ($null -ne $ExceptIfAnyOfToHeaderMemberOf -and $ExceptIfAnyOfToHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfToHeaderMemberOf', $ExceptIfAnyOfToHeaderMemberOf)
        }
        if ($null -ne $ExceptIfAnyOfCcHeader -and $ExceptIfAnyOfCcHeader.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfCcHeader', $ExceptIfAnyOfCcHeader)
        }
        if ($null -ne $ExceptIfAnyOfCcHeaderMemberOf -and $ExceptIfAnyOfCcHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfCcHeaderMemberOf', $ExceptIfAnyOfCcHeaderMemberOf)
        }
        if ($null -ne $ExceptIfAnyOfToCcHeader -and $ExceptIfAnyOfToCcHeader.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfToCcHeader', $ExceptIfAnyOfToCcHeader)
        }
        if ($null -ne $ExceptIfAnyOfToCcHeaderMemberOf -and $ExceptIfAnyOfToCcHeaderMemberOf.Count -gt 0) {
            $ruleParams.Add('ExceptIfAnyOfToCcHeaderMemberOf', $ExceptIfAnyOfToCcHeaderMemberOf)
        }
        if ($null -ne $ExceptIfHeaderContainsWords -and $ExceptIfHeaderContainsWords.Count -gt 0 -and $null -ne $ExceptIfHeaderContainsWordsMessageHeader) {
            $ruleParams.Add('ExceptIfHeaderContainsMessageHeader', $ExceptIfHeaderContainsWordsMessageHeader)
            $ruleParams.Add('ExceptIfHeaderContainsWords', $ExceptIfHeaderContainsWords)
        }
        if ($null -ne $ExceptIfHeaderMatchesPatterns -and $ExceptIfHeaderMatchesPatterns.Count -gt 0 -and $null -ne $ExceptIfHeaderMatchesPatternsMessageHeader) {
            $ruleParams.Add('ExceptIfHeaderMatchesMessageHeader', $ExceptIfHeaderMatchesPatternsMessageHeader)
            $ruleParams.Add('ExceptIfHeaderMatchesPatterns', $ExceptIfHeaderMatchesPatterns)
        }
        if ($null -ne $ExceptIfSenderIpRanges -and $ExceptIfSenderIpRanges.Count -gt 0) {
            $ruleParams.Add('ExceptIfSenderIpRanges', $ExceptIfSenderIpRanges)
        }

        if (!$Identity) {
            $ExoRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = 'New-TransportRule'
                cmdParams        = $ruleParams
                useSystemMailbox = $true
            }
            $null = New-ExoRequest @ExoRequestParam
            $Results = "Successfully created transport rule '$Name'"
        }
        else {
            $ExoRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = 'Set-TransportRule'
                cmdParams        = $ruleParams
                useSystemMailbox = $true
            }
            $ExoRequestState = @{
                tenantid         = $TenantFilter
                cmdlet           = $CmdletState
                cmdParams        = @{ Identity = $Identity }
                useSystemMailbox = $true
            }
            if ($Enabled) {
                $null = New-ExoRequest @ExoRequestState
                $Results = "Successfully $($Enabled) transport rule $($Name)"
            } else {
                $null = New-ExoRequest @ExoRequestParam
                $null = New-ExoRequest @ExoRequestState
                $Results = "Successfully configured transport rule '$Name'"
            }
        }
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to configure transport rule '$Name'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddEditTransportRule.ps1' 633
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddExConnector.ps1' -1

function Invoke-AddExConnector {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.Connector.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    $ConnectorType = ($Request.Body.PowerShellCommand | ConvertFrom-Json).cippConnectorType
    $RequestParams = $Request.Body.PowerShellCommand | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty GUID, cippConnectorType, SenderRewritingEnabled
    if ($RequestParams.comment) { $RequestParams.comment = Get-CIPPTextReplacement -Text $RequestParams.comment -TenantFilter $Tenant } else { $RequestParams | Add-Member -NotePropertyValue 'no comment' -NotePropertyName comment -Force }
    $Tenants = ($Request.Body.selectedTenants).value

    $AllowedTenants = Test-CippAccess -Request $Request -TenantList

    if ($AllowedTenants -ne 'AllTenants') {
        $AllTenants = Get-Tenants -IncludeErrors
        $AllowedTenantList = $AllTenants | Where-Object { $_.customerId -in $AllowedTenants }
        $Tenants = $Tenants | Where-Object { $_ -in $AllowedTenantList.defaultDomainName }
    }

    $Result = foreach ($TenantFilter in $Tenants) {
        try {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet "New-$($ConnectorType)connector" -cmdParams $RequestParams
            "Successfully created Connector for $TenantFilter."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully created Connector for $TenantFilter." -sev 'Info'
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Could not create Connector for $($TenantFilter): $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Could not create Connector for $($TenantFilter): $($ErrorMessage.NormalizedError)" -sev 'Error'
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddExConnector.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddExConnectorTemplate.ps1' -1

Function Invoke-AddExConnectorTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.Connector.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    Write-Host ($Request | ConvertTo-Json -Compress)

    try {
        $GUID = (New-Guid).GUID
        $Select = if ($Request.Body.cippconnectortype -eq 'outbound') {
            @(
                'name', 'AllAcceptedDomains', 'CloudServicesMailEnabled', 'Comment', 'Confirm', 'ConnectorSource', 'ConnectorType', 'Enabled', 'IsTransportRuleScoped', 'RecipientDomains', 'RouteAllMessagesViaOnPremises', 'SmartHosts', 'TestMode', 'TlsDomain', 'TlsSettings', 'UseMXRecord'
            )
        } else {
            @(
                'name', 'SenderDomains', 'ConnectorSource', 'ConnectorType', 'EFSkipIPs', 'EFSkipLastIP', 'EFSkipMailGateway', 'EFTestMode', 'EFUsers', 'Enabled ', 'RequireTls', 'RestrictDomainsToCertificate', 'RestrictDomainsToIPAddresses', 'ScanAndDropRecipients', 'SenderIPAddresses', 'TlsSenderCertificateName', 'TreatMessagesAsInternal', 'TrustedOrganizations'
            )
        }

        $JSON = ([pscustomobject]$Request.Body | Select-Object $Select) | ForEach-Object {
            $NonEmptyProperties = $_.psobject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
            $_ | Select-Object -Property $NonEmptyProperties
        }
        $JSON = ($JSON | Select-Object @{n = 'name'; e = { $_.name } }, * | ConvertTo-Json -Depth 10)
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            direction    = $Request.Body.cippconnectortype
            PartitionKey = 'ExConnectorTemplate'
        }
        $Result = "Successfully created Connector Template: $($Request.Body.name) with GUID $GUID"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Debug'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create Connector Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddExConnectorTemplate.ps1' 59
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddTransportRule.ps1' -1

function Invoke-AddTransportRule {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.TransportRule.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $ExecutingUser = $Request.Headers
    Write-LogMessage -Headers $ExecutingUser -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    $RequestParams = $Request.Body.PowerShellCommand | ConvertFrom-Json | Select-Object -Property * -ExcludeProperty GUID, HasSenderOverride, ExceptIfHasSenderOverride, ExceptIfMessageContainsDataClassifications, MessageContainsDataClassifications

    # Remove null properties from payload
    $RequestParams.PSObject.Properties | Where-Object { $_.Value -eq $null } | ForEach-Object { $RequestParams.PSObject.Properties.Remove($_.Name) }

    $Tenants = ($Request.body.selectedTenants).value

    $AllowedTenants = Test-CippAccess -Request $Request -TenantList

    if ($AllowedTenants -ne 'AllTenants') {
        $AllTenants = Get-Tenants -IncludeErrors
        $AllowedTenantList = $AllTenants | Where-Object { $_.customerId -in $AllowedTenants }
        $Tenants = $Tenants | Where-Object { $_ -in $AllowedTenantList.defaultDomainName }
    }

    $Result = foreach ($tenantFilter in $tenants) {
        $Existing = New-ExoRequest -ErrorAction SilentlyContinue -tenantid $tenantFilter -cmdlet 'Get-TransportRule' -useSystemMailbox $true | Where-Object -Property Identity -EQ $RequestParams.name
        try {
            if ($Existing) {
                Write-Host 'Found existing'
                $RequestParams | Add-Member -NotePropertyValue $Existing.Identity -NotePropertyName Identity -Force
                $null = New-ExoRequest -tenantid $tenantFilter -cmdlet 'Set-TransportRule' -cmdParams ($RequestParams | Select-Object -Property * -ExcludeProperty UseLegacyRegex) -useSystemMailbox $true
                "Successfully set transport rule for $tenantFilter."
            } else {
                Write-Host 'Creating new'
                $null = New-ExoRequest -tenantid $tenantFilter -cmdlet 'New-TransportRule' -cmdParams $RequestParams -useSystemMailbox $true
                "Successfully created transport rule for $tenantFilter."
            }

            Write-LogMessage -Headers $ExecutingUser -API $APINAME -tenant $tenantFilter -message "Created transport rule for $($tenantFilter)" -sev Info
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Could not create transport rule for $($tenantFilter): $($ErrorMessage.NormalizedError)"
            Write-LogMessage -Headers $ExecutingUser -API $APINAME -tenant $tenantFilter -message "Could not create transport rule for $($tenantFilter). Error:$($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{Results = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddTransportRule.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddTransportTemplate.ps1' -1

Function Invoke-AddTransportTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.TransportRule.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug
    Write-Host ($request | ConvertTo-Json -Depth 10 -Compress)

    try {
        $GUID = (New-Guid).GUID
        $JSON = if ($request.body.PowerShellCommand) {
            Write-Host 'PowerShellCommand'
            $request.body.PowerShellCommand | ConvertFrom-Json
        } else {
        ([pscustomobject]$Request.body | Select-Object Name, ActivationDate, ADComparisonAttribute, ADComparisonOperator, AddManagerAsRecipientType, AddToRecipients, AnyOfCcHeader, AnyOfCcHeaderMemberOf, AnyOfRecipientAddressContainsWords, AnyOfRecipientAddressMatchesPatterns, AnyOfToCcHeader, AnyOfToCcHeaderMemberOf, AnyOfToHeader, AnyOfToHeaderMemberOf, ApplyClassification, ApplyHtmlDisclaimerFallbackAction, ApplyHtmlDisclaimerLocation, ApplyHtmlDisclaimerText, ApplyOME, ApplyRightsProtectionCustomizationTemplate, ApplyRightsProtectionTemplate, AttachmentContainsWords, AttachmentExtensionMatchesWords, AttachmentHasExecutableContent, AttachmentIsPasswordProtected, AttachmentIsUnsupported, AttachmentMatchesPatterns, AttachmentNameMatchesPatterns, AttachmentProcessingLimitExceeded, AttachmentPropertyContainsWords, AttachmentSizeOver, BetweenMemberOf1, BetweenMemberOf2, BlindCopyTo, Comments, Confirm, ContentCharacterSetContainsWords, CopyTo, DeleteMessage, DlpPolicy, DomainController, Enabled, ExceptIfADComparisonAttribute, ExceptIfADComparisonOperator, ExceptIfAnyOfCcHeader, ExceptIfAnyOfCcHeaderMemberOf, ExceptIfAnyOfRecipientAddressContainsWords, ExceptIfAnyOfRecipientAddressMatchesPatterns, ExceptIfAnyOfToCcHeader, ExceptIfAnyOfToCcHeaderMemberOf, ExceptIfAnyOfToHeader, ExceptIfAnyOfToHeaderMemberOf, ExceptIfAttachmentContainsWords, ExceptIfAttachmentExtensionMatchesWords, ExceptIfAttachmentHasExecutableContent, ExceptIfAttachmentIsPasswordProtected, ExceptIfAttachmentIsUnsupported, ExceptIfAttachmentMatchesPatterns, ExceptIfAttachmentNameMatchesPatterns, ExceptIfAttachmentProcessingLimitExceeded, ExceptIfAttachmentPropertyContainsWords, ExceptIfAttachmentSizeOver, ExceptIfBetweenMemberOf1, ExceptIfBetweenMemberOf2, ExceptIfContentCharacterSetContainsWords, ExceptIfFrom, ExceptIfFromAddressContainsWords, ExceptIfFromAddressMatchesPatterns, ExceptIfFromMemberOf, ExceptIfFromScope, ExceptIfHasClassification, ExceptIfHasNoClassification, ExceptIfHasSenderOverride, ExceptIfHeaderContainsMessageHeader, ExceptIfHeaderContainsWords, ExceptIfHeaderMatchesMessageHeader, ExceptIfHeaderMatchesPatterns, ExceptIfManagerAddresses, ExceptIfManagerForEvaluatedUser, ExceptIfMessageContainsDataClassifications, ExceptIfMessageSizeOver, ExceptIfMessageTypeMatches, ExceptIfRecipientADAttributeContainsWords, ExceptIfRecipientADAttributeMatchesPatterns, ExceptIfRecipientAddressContainsWords, ExceptIfRecipientAddressMatchesPatterns, ExceptIfRecipientDomainIs, ExceptIfRecipientInSenderList, ExceptIfSCLOver, ExceptIfSenderADAttributeContainsWords, ExceptIfSenderADAttributeMatchesPatterns, ExceptIfSenderDomainIs, ExceptIfSenderInRecipientList, ExceptIfSenderIpRanges, ExceptIfSenderManagementRelationship, ExceptIfSentTo, ExceptIfSentToMemberOf, ExceptIfSentToScope, ExceptIfSubjectContainsWords, ExceptIfSubjectMatchesPatterns, ExceptIfSubjectOrBodyContainsWords, ExceptIfSubjectOrBodyMatchesPatterns, ExceptIfWithImportance, ExpiryDate, From, FromAddressContainsWords, FromAddressMatchesPatterns, FromMemberOf, FromScope, GenerateIncidentReport, GenerateNotification, HasClassification, HasNoClassification, HasSenderOverride, HeaderContainsMessageHeader, HeaderContainsWords, HeaderMatchesMessageHeader, HeaderMatchesPatterns, IncidentReportContent, IncidentReportOriginalMail, LogEventText, ManagerAddresses, ManagerForEvaluatedUser, MessageContainsDataClassifications, MessageSizeOver, MessageTypeMatches, Mode, ModerateMessageByManager, ModerateMessageByUser, NotifySender, PrependSubject, Quarantine, RecipientADAttributeContainsWords, RecipientADAttributeMatchesPatterns, RecipientAddressContainsWords, RecipientAddressMatchesPatterns, RecipientAddressType, RecipientDomainIs, RecipientInSenderList, RedirectMessageTo, RejectMessageEnhancedStatusCode, RejectMessageReasonText, RemoveHeader, RemoveOME, RemoveOMEv2, RemoveRMSAttachmentEncryption, RouteMessageOutboundConnector, RouteMessageOutboundRequireTls, RuleErrorAction, RuleSubType, SCLOver, SenderADAttributeContainsWords, SenderADAttributeMatchesPatterns, SenderAddressLocation, SenderDomainIs, SenderInRecipientList, SenderIpRanges, SenderManagementRelationship, SentTo, SentToMemberOf, SentToScope, SetAuditSeverity, SetHeaderName, SetHeaderValue, SetSCL, SmtpRejectMessageRejectStatusCode, SmtpRejectMessageRejectText, StopRuleProcessing, SubjectContainsWords, SubjectMatchesPatterns, SubjectOrBodyContainsWords, SubjectOrBodyMatchesPatterns, UseLegacyRegex, WithImportance ) |
                ForEach-Object {
                    $NonEmptyProperties = $_.PSObject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
                    $_ | Select-Object -Property $NonEmptyProperties
                }
        }
        $JSON = ($JSON | Select-Object @{n = 'name'; e = { $_.name } }, @{n = 'comments'; e = { $_.comments } }, * | ConvertTo-Json -Depth 10)
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'TransportTemplate'
        }
        Write-LogMessage -Headers $Headers -API $APINAME -message "Created Transport Rule Template $($Request.body.name) with GUID $GUID" -Sev Debug
        $body = [pscustomobject]@{'Results' = "Created Transport Rule Template $($Request.body.name) with GUID $GUID" }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to create Transport Rule Template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to create Transport Rule Template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-AddTransportTemplate.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-EditExConnector.ps1' -1

function Invoke-EditExConnector {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Connector.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    try {
        $ConnectorState = $Request.Query.State ?? $Request.Body.State
        $State = if ($ConnectorState -eq 'Enable') { $true } else { $false }
        $Guid = $Request.Query.GUID ?? $Request.Body.GUID
        $Type = $Request.Query.Type ?? $Request.Body.Type
        $Params = @{
            Identity = $Guid
            Enabled  = $State
        }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet "Set-$($Type)Connector" -cmdParams $params -UseSystemMailbox $true
        $Result = "Set Connector $($Guid) to $($ConnectorState)"
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message "Set Connector $($Guid) to $($ConnectorState)" -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CIPPException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message "Failed setting Connector $($Guid) to $($ConnectorState). Error:$($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Result = $ErrorMessage.NormalizedError
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-EditExConnector.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-EditTransportRule.ps1' -1

function Invoke-EditTransportRule {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.TransportRule.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $Identity = $Request.Query.guid ?? $Request.body.guid
    $State = $Request.Query.state ?? $Request.body.state

    $Params = @{
        Identity = $Identity
    }

    try {
        $cmdlet = if ($State -eq 'enable') { 'Enable-TransportRule' } else { 'Disable-TransportRule' }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $cmdlet -cmdParams $params -UseSystemMailbox $true
        $Result = "Set transport rule $($Identity) to $($State)"
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message $Result -sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message "Failed setting transport rule $($Identity) to $($State). Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $Result = $ErrorMessage.NormalizedError
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-EditTransportRule.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListExchangeConnectors.ps1' -1

function Invoke-ListExchangeConnectors {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Connector.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $request.Query.tenantFilter

    $Results = try {
        New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-OutboundConnector' | Select-Object *, @{n = 'cippconnectortype'; e = { 'outbound' } }
        New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-InboundConnector' | Select-Object *, @{n = 'cippconnectortype'; e = { 'Inbound' } }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListExchangeConnectors.ps1' 28
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListExConnectorTemplates.ps1' -1

function Invoke-ListExConnectorTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.Connector.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'

    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'ExConnectorTemplate'"

    if ($Request.Query.ID) {
        $Filter += " and RowKey eq '$($Request.Query.ID)'"
    }

    $TemplateRows = (Get-CIPPAzDataTableEntity @Table -Filter $Filter)

    if ($TemplateRows) {
        $Templates = $TemplateRows | ForEach-Object {
            $GUID = $_.RowKey
            $Direction = $_.direction
            $data = $_.JSON | ConvertFrom-Json
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID -Force
            $data | Add-Member -NotePropertyName 'cippconnectortype' -NotePropertyValue $Direction -Force
            $data
        } | Sort-Object -Property displayName
    } else {
        $Templates = @()
    }
    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property RowKey -EQ $Request.query.id }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListExConnectorTemplates.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListTransportRules.ps1' -1

function Invoke-ListTransportRules {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.TransportRule.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $RuleId = $Request.Query.id

    try {
        # If an ID is provided, fetch the specific rule
        if ($RuleId) {
            $Results = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-TransportRule' -cmdParams @{Identity = $RuleId}
        }
        # Otherwise, use existing logic
        else {
            $Results = if ($TenantFilter -ne 'AllTenants') {
                # Single tenant functionality
                New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-TransportRule'
            } else {
                # AllTenants functionality
                $Table = Get-CIPPTable -TableName CacheTransportRules
                $PartitionKey = 'TransportRule'
                $Filter = "PartitionKey eq '$PartitionKey'"
                $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-60)
                $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
                $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
                # If a queue is running, we will not start a new one
                if ($RunningQueue) {
                    $Metadata = [PSCustomObject]@{
                        QueueMessage = 'Still loading transport rules for all tenants. Please check back in a few more minutes'
                        QueueId      = $RunningQueue.RowKey
                    }
                } elseif (!$Rows -and !$RunningQueue) {
                    # If no rows are found and no queue is running, we will start a new one
                    $TenantList = Get-Tenants -IncludeErrors
                    $Queue = New-CippQueueEntry -Name 'Transport Rules - All Tenants' -Link '/email/transport/list-rules?tenantFilter=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                    $Metadata = [PSCustomObject]@{
                        QueueMessage = 'Loading transport rules for all tenants. Please check back in a few minutes'
                        QueueId      = $Queue.RowKey
                    }
                    $InputObject = [PSCustomObject]@{
                        OrchestratorName = 'TransportRuleOrchestrator'
                        QueueFunction    = @{
                            FunctionName = 'GetTenants'
                            QueueId      = $Queue.RowKey
                            TenantParams = @{
                                IncludeErrors = $true
                            }
                            DurableName  = 'ListTransportRulesAllTenants'
                        }
                        SkipLog          = $true
                    }
                    Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress) | Out-Null
                } else {
                    # Return cached data
                    $Metadata = [PSCustomObject]@{
                        QueueId = $RunningQueue.RowKey ?? $null
                    }
                    $Rules = $Rows
                    foreach ($rule in $Rules) {
                        $RuleObj = $rule.TransportRule | ConvertFrom-Json
                        $RuleObj | Add-Member -MemberType NoteProperty -Name Tenant -Value $rule.Tenant -Force
                        $RuleObj
                    }
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $Body = $ErrorMessage
    }

    # If the body is not set by an error, we will set it here
    if (!$Body) {
        $Body = [PSCustomObject]@{
            Results  = @($Results)
            Metadata = $Metadata
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListTransportRules.ps1' 93
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListTransportRulesTemplates.ps1' -1

Function Invoke-ListTransportRulesTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.TransportRule.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'

    $Templates = Get-ChildItem 'Config\*.TransportRuleTemplate.json' | ForEach-Object {

        $Entity = @{
            JSON         = "$(Get-Content $_)"
            RowKey       = "$($_.name)"
            PartitionKey = 'TransportTemplate'
            GUID         = "$($_.name)"
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

    }

    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'TransportTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $GUID = $_.RowKey
        $data = $_.JSON | ConvertFrom-Json
        $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
        $data
    }

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property RowKey -EQ $Request.query.id }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-ListTransportRulesTemplates.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveExConnector.ps1' -1

Function Invoke-RemoveExConnector {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Connector.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $TenantFilter = $request.Query.tenantFilter ?? $Request.Body.tenantFilter


    try {
        $Type = $Request.Query.Type ?? $Request.Body.Type
        $Guid = $Request.Query.GUID ?? $Request.Body.GUID
        $Params = @{ Identity = $Guid }

        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet "Remove-$($Type)Connector" -cmdParams $params -useSystemMailbox $true
        $Result = "Deleted Connector: $($Guid)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Deleted connector $($Guid)" -sev Debug
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed deleting connector $($Guid). Error:$($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Result = $ErrorMessage.NormalizedError
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveExConnector.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveExConnectorTemplate.ps1' -1

Function Invoke-RemoveExConnectorTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.Connector.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $Request.Query.ID ?? $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'ExConnectorTemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Exchange Connector Template with ID $ID."
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Exchange Connector Template $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveExConnectorTemplate.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveTransportRule.ps1' -1

Function Invoke-RemoveTransportRule {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.TransportRule.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $Identity = $Request.Query.guid ?? $Request.body.guid

    $Params = @{
        Identity = $Identity
    }

    try {
        $cmdlet = 'Remove-TransportRule'
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $cmdlet -cmdParams $Params -UseSystemMailbox $true
        $Result = "Deleted $($Identity)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Deleted transport rule $($Identity)" -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed deleting transport rule $($Identity). Error:$($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Result = $ErrorMessage.NormalizedError
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveTransportRule.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveTransportRuleTemplate.ps1' -1

Function Invoke-RemoveTransportRuleTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.TransportRule.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $User = $Request.Headers
    Write-LogMessage -Headers $User -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    $ID = $request.query.ID ?? $request.body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'TransportTemplate' and RowKey eq '$id'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Transport Rule Template with ID $ID."
        Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Transport Rule template with ID $ID. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Email-Exchange/Transport/Invoke-RemoveTransportRuleTemplate.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddChocoApp.ps1' -1

Function Invoke-AddChocoApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ChocoApp = $Request.Body
    $intuneBody = Get-Content 'AddChocoApp\Choco.app.json' | ConvertFrom-Json
    $AssignTo = $Request.Body.AssignTo -eq 'customGroup' ? $Request.Body.CustomGroup : $Request.Body.AssignTo
    $intuneBody.description = $ChocoApp.description
    $intuneBody.displayName = $ChocoApp.ApplicationName
    $intuneBody.installExperience.runAsAccount = if ($ChocoApp.InstallAsSystem) { 'system' } else { 'user' }
    $intuneBody.installExperience.deviceRestartBehavior = if ($ChocoApp.DisableRestart) { 'suppress' } else { 'allow' }
    $intuneBody.installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\Install.ps1 -InstallChoco -Packagename $($ChocoApp.PackageName)"
    if ($ChocoApp.customrepo) {
        $intuneBody.installCommandLine = $intuneBody.installCommandLine + " -CustomRepo $($ChocoApp.CustomRepo)"
    }
    if ($ChocoApp.customArguments) {
        $intuneBody.installCommandLine = $intuneBody.installCommandLine + " -CustomArguments '$($ChocoApp.customArguments)'"
    }
    $intuneBody.UninstallCommandLine = "powershell.exe -ExecutionPolicy Bypass .\Uninstall.ps1 -Packagename $($ChocoApp.PackageName)"
    $intuneBody.detectionRules[0].path = "$($ENV:SystemDrive)\programdata\chocolatey\lib"
    $intuneBody.detectionRules[0].fileOrFolderName = "$($ChocoApp.PackageName)"

    $Tenants = $Request.Body.selectedTenants.defaultDomainName
    $Results = foreach ($Tenant in $Tenants) {
        try {
            # Apply CIPP text replacement for tenant-specific variables
            $TenantIntuneBody = $intuneBody | ConvertTo-Json -Depth 15 | ConvertFrom-Json
            if ($TenantIntuneBody.installCommandLine -match '%') {
                $TenantIntuneBody.installCommandLine = Get-CIPPTextReplacement -TenantFilter $Tenant -Text $TenantIntuneBody.installCommandLine
            }

            $CompleteObject = [PSCustomObject]@{
                tenant             = $Tenant
                ApplicationName    = $ChocoApp.ApplicationName
                assignTo           = $AssignTo
                InstallationIntent = $Request.Body.InstallationIntent
                IntuneBody         = $TenantIntuneBody
            } | ConvertTo-Json -Depth 15
            $Table = Get-CippTable -tablename 'apps'
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$CompleteObject"
                RowKey       = "$((New-Guid).GUID)"
                PartitionKey = 'apps'
            }
            "Successfully added Choco App for $($Tenant) to queue."
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Successfully added Choco App $($intuneBody.DisplayName) to queue" -Sev 'Info'
        } catch {
            "Failed adding Choco App for $($Tenant) to queue"
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Failed to add Chocolatey Application $($intuneBody.DisplayName) to queue" -Sev 'Error'
        }
    }

    $body = [PSCustomObject]@{'Results' = $Results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddChocoApp.ps1' 71
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddMSPApp.ps1' -1

function Invoke-AddMSPApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $RMMApp = $Request.Body
    $AssignTo = $Request.Body.AssignTo
    $intuneBody = Get-Content "AddMSPApp\$($RMMApp.RMMName.value).app.json" | ConvertFrom-Json
    $intuneBody.displayName = $RMMApp.DisplayName

    $Tenants = $Request.Body.selectedTenants
    $Results = foreach ($Tenant in $Tenants) {
        $InstallParams = [PSCustomObject]$RMMApp.params
        switch ($RMMApp.RMMName.value) {
            'datto' {
                Write-Host 'Processing Datto installation'
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -URL $($InstallParams.DattoURL) -GUID $($InstallParams.DattoGUID."$($Tenant.customerId)")"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1'
            }
            'ninja' {
                Write-Host 'Processing Ninja installation'
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -InstallParam $($RMMApp.PackageName)"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1'
            }
            'Huntress' {
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -OrgKey $($InstallParams.Orgkey."$($Tenant.customerId)") -acctkey $($InstallParams.AccountKey)"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\install.ps1 -Uninstall'
            }
            'syncro' {
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -URL $($InstallParams.ClientURL."$($Tenant.customerId)")"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1'
            }
            'NCentral' {
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -InstallParam $($RMMApp.PackageName)"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1'
            }
            'automate' {
                $installCommandLine = "c:\windows\sysnative\windowspowershell\v1.0\powershell.exe -ExecutionPolicy Bypass .\install.ps1 -Server $($InstallParams.Server) -InstallerToken $($InstallParams.InstallerToken."$($Tenant.customerId)") -LocationID $($InstallParams.LocationID."$($Tenant.customerId)")"
                $uninstallCommandLine = "c:\windows\sysnative\windowspowershell\v1.0\powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1 -Server $($InstallParams.Server)"
                $DetectionScript = (Get-Content 'AddMSPApp\automate.detection.ps1' -Raw) -replace '##SERVER##', $InstallParams.Server
                $intuneBody.detectionRules[0].scriptContent = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($DetectionScript))
            }
            'cwcommand' {
                $installCommandLine = "powershell.exe -ExecutionPolicy Bypass .\install.ps1 -Url $($InstallParams.ClientURL."$($Tenant.customerId)")"
                $uninstallCommandLine = 'powershell.exe -ExecutionPolicy Bypass .\uninstall.ps1'
            }
        }
        $intuneBody.installCommandLine = $installCommandLine
        $intuneBody.UninstallCommandLine = $uninstallCommandLine


        try {
            $CompleteObject = [PSCustomObject]@{
                tenant          = $Tenant.defaultDomainName
                ApplicationName = $RMMApp.DisplayName
                assignTo        = $AssignTo
                IntuneBody      = $intuneBody
                type            = 'MSPApp'
                MSPAppName      = $RMMApp.RMMName.value
            } | ConvertTo-Json -Depth 15
            $Table = Get-CippTable -tablename 'apps'
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$CompleteObject"
                RowKey       = "$((New-Guid).GUID)"
                PartitionKey = 'apps'
                status       = 'Not Deployed yet'
            }
            "Successfully added MSP App for $($Tenant.defaultDomainName) to queue. "
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant.defaultDomainName -message "MSP Application $($intuneBody.DisplayName) added to queue" -Sev 'Info'
        } catch {
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant.defaultDomainName -message "Failed to add MSP Application $($intuneBody.DisplayName) to queue" -Sev 'Error'
            "Failed to add MSP app for $($Tenant.defaultDomainName) to queue"
        }
    }


    $body = [PSCustomObject]@{'Results' = $Results }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddMSPApp.ps1' 94
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddOfficeApp.ps1' -1

function Invoke-AddOfficeApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    # Input bindings are passed in via param block.
    $Tenants = $Request.Body.selectedTenants.defaultDomainName
    $Headers = $Request.Headers
    $APIName = $Request.Params.CIPPEndpoint
    if ('AllTenants' -in $Tenants) { $Tenants = (Get-Tenants).defaultDomainName }
    $AssignTo = if ($Request.Body.AssignTo -ne 'on') { $Request.Body.AssignTo }

    $Results = foreach ($Tenant in $Tenants) {
        try {
            $ExistingO365 = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/deviceAppManagement/mobileApps' -tenantid $Tenant | Where-Object { $_.displayName -eq 'Microsoft 365 Apps for Windows 10 and later' }
            if (!$ExistingO365) {
                # Check if custom XML is provided
                if ($Request.Body.useCustomXml -and $Request.Body.customXml) {
                    # Use custom XML configuration
                    $ObjBody = [pscustomobject]@{
                        '@odata.type'            = '#microsoft.graph.officeSuiteApp'
                        'displayName'            = 'Microsoft 365 Apps for Windows 10 and later'
                        'description'            = 'Microsoft 365 Apps for Windows 10 and later'
                        'informationUrl'         = 'https://products.office.com/en-us/explore-office-for-home'
                        'privacyInformationUrl'  = 'https://privacy.microsoft.com/en-us/privacystatement'
                        'isFeatured'             = $true
                        'publisher'              = 'Microsoft'
                        'notes'                  = ''
                        'owner'                  = 'Microsoft'
                        'officeConfigurationXml' = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($request.body.customXml))
                        'largeIcon'              = @{
                            '@odata.type' = 'microsoft.graph.mimeContent'
                            'type'        = 'image/png'
                            'value'       = 'iVBORw0KGgoAAAANSUhEUgAAAF0AAAAeCAMAAAEOZNKlAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJhUExURf////7z7/i9qfF1S/KCW/i+qv3q5P/9/PrQwfOMae1RG+s8AOxGDfBtQPWhhPvUx/759/zg1vWgg+9fLu5WIvKFX/rSxP728/nCr/FyR+tBBvOMaO1UH+1RHOs+AvSScP3u6f/+/v3s5vzg1+xFDO9kNPOOa/i7pvzj2/vWyes9Af76+Pzh2PrTxf/6+f7y7vOGYexHDv3t5+1SHfi8qPOIZPvb0O1NFuxDCe9hMPSVdPnFs/3q4/vaz/STcu5VIe5YJPWcfv718v/9/e1MFfF4T/F4TvF2TP3o4exECvF0SexIEPONavzn3/vZze1QGvF3Te5dK+5cKvrPwPrQwvKAWe1OGPexmexKEveulfezm/BxRfamiuxLE/apj/zf1e5YJfSXd/OHYv3r5feznPakiPze1P7x7f739f3w6+xJEfnEsvWdf/Wfge1LFPe1nu9iMvnDsfBqPOs/BPOIY/WZevJ/V/zl3fnIt/vTxuxHD+xEC+9mN+5ZJv749vBpO/KBWvBwRP/8+/SUc/etlPjArP/7+vOLZ/F7UvWae/708e1OF/aihvSWdvi8p+tABfSZefvVyPWihfSVde9lNvami+9jM/zi2fKEXvBuQvOKZvalifF5UPJ/WPSPbe9eLfrKuvvd0uxBB/7w7Pzj2vrRw/rOv+1PGfi/q/eymu5bKf3n4PnJuPBrPf3t6PWfgvWegOxCCO9nOO9oOfaskvSYePi5pPi2oPnGtO5eLPevlvKDXfrNvv739Pzd0/708O9gL+9lNfJ9VfrLu/OPbPnDsPBrPus+A/nArfarkQAAAGr5HKgAAADLdFJOU/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AvuakogAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAz5JREFUOE+tVTtu4zAQHQjppmWzwIJbEVCzpTpjbxD3grQHSOXKRXgCAT6EC7UBVAmp3KwBnmvfzNCyZTmxgeTZJsXx43B+HBHRE34ZkXgkerXFTheeiCkRrbB4UXmp4wSWz5raaQEMTM5TZwuiXoaKgV+6FsmkZQcSy0kA71yMTMGHanX+AzMMGLAQCxU1F/ZwjULPugazl82GM0NEKm/U8EqFwEkO3/EAT4grgl0nucwlk9pcpTTJ4VPA4g/Rb3yIRhhp507e9nTQmZ1OS5RO4sS7nIRPEeHXCHdkw9ZEW2yVE5oIS7peD58Avs7CN+PVCmHh21oOqBdjDzIs+FldPJ74TFESUSJEfVzy9U/dhu+AuOT6eBp6gGKyXEx8euO450ZE4CMfstMFT44broWw/itkYErWXRx+fFArt9Ca9os78TFed0LVIUsmIHrwbwaw3BEOnOk94qVpQ6Ka2HjxewJnfyd6jUtGDQLdWlzmYNYLeKbbGOucJsNabCq1Yub0o92rtR+i30V2dapxYVEePXcOjeCKPnYyit7BtKeNlZqHbr+gt7i+AChWA9RsRs03pxTQc67ouWpxyESvjK5Vs3DVSy3IpkxPm5X+wZoBi+MFHWW69/w8FRhc7VBe6HAhMB2b8Q0XqDzTNZtXUMnKMjwKVaCrB/CSUL7WSx/HsdJC86lFGXwnioTeOMPjV+szlFvrZLA5VMVK4y+41l4e1xfx7Z88o4hkilRUH/qKqwNVlgDgpvYCpH3XwAy5eMCRnezIUxffVXoDql2rTHFDO+pjWnTWzAfrYXn6BFECblUpWGrvPZvBipETjS5ydM7tdXpH41ZCEbBNy/+wFZu71QO2t9pgT+iZEf657Q1vpN94PQNDxUHeKR103LV9nPVOtDikcNKO+2naCw7yKBhOe9Hm79pe8C4/CfC2wDjXnqC94kEeBU3WwN7dt/2UScXas7zDl5GpkY+M8WKv2J7fd4Ib2rGTk+jsC2cleEM7jI9veF7B0MBJrsZqfKd/81q9pR2NZfwJK2JzsmIT1Ns8jUH0UusQBpU8d2JzsHiXg1zXGLqxfitUNTDT/nUUeqDBp2HZVr+Ocqi/Ty3Rf4Jn82xxfSNtAAAAAElFTkSuQmCC'
                        }
                    }
                } else {
                    # Use standard configuration
                    $Arch = if ($Request.Body.arch) { 'x64' } else { 'x86' }
                    $products = @('o365ProPlusRetail')
                    $ExcludedApps = [pscustomobject]@{
                        infoPath           = $true
                        sharePointDesigner = $true
                        excel              = $false
                        lync               = $false
                        oneNote            = $false
                        outlook            = $false
                        powerPoint         = $false
                        publisher          = $false
                        teams              = $false
                        word               = $false
                        access             = $false
                        bing               = $false
                    }
                    foreach ($ExcludedApp in $Request.Body.excludedApps.value) {
                        $ExcludedApps.$ExcludedApp = $true
                    }
                    $ObjBody = [pscustomobject]@{
                        '@odata.type'                          = '#microsoft.graph.officeSuiteApp'
                        'displayName'                          = 'Microsoft 365 Apps for Windows 10 and later'
                        'description'                          = 'Microsoft 365 Apps for Windows 10 and later'
                        'informationUrl'                       = 'https://products.office.com/en-us/explore-office-for-home'
                        'privacyInformationUrl'                = 'https://privacy.microsoft.com/en-us/privacystatement'
                        'isFeatured'                           = $true
                        'publisher'                            = 'Microsoft'
                        'notes'                                = ''
                        'owner'                                = 'Microsoft'
                        'autoAcceptEula'                       = [bool]$Request.Body.AcceptLicense
                        'excludedApps'                         = $ExcludedApps
                        'officePlatformArchitecture'           = $Arch
                        'officeSuiteAppDefaultFileFormat'      = 'OfficeOpenXMLFormat'
                        'localesToInstall'                     = @($Request.Body.languages.value)
                        'shouldUninstallOlderVersionsOfOffice' = [bool]$Request.Body.RemoveVersions
                        'updateChannel'                        = $Request.Body.updateChannel.value
                        'useSharedComputerActivation'          = [bool]$Request.Body.SharedComputerActivation
                        'productIds'                           = $products
                        'largeIcon'                            = @{
                            '@odata.type' = 'microsoft.graph.mimeContent'
                            'type'        = 'image/png'
                            'value'       = 'iVBORw0KGgoAAAANSUhEUgAAAF0AAAAeCAMAAAEOZNKlAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJhUExURf////7z7/i9qfF1S/KCW/i+qv3q5P/9/PrQwfOMae1RG+s8AOxGDfBtQPWhhPvUx/759/zg1vWgg+9fLu5WIvKFX/rSxP728/nCr/FyR+tBBvOMaO1UH+1RHOs+AvSScP3u6f/+/v3s5vzg1+xFDO9kNPOOa/i7pvzj2/vWyes9Af76+Pzh2PrTxf/6+f7y7vOGYexHDv3t5+1SHfi8qPOIZPvb0O1NFuxDCe9hMPSVdPnFs/3q4/vaz/STcu5VIe5YJPWcfv718v/9/e1MFfF4T/F4TvF2TP3o4exECvF0SexIEPONavzn3/vZze1QGvF3Te5dK+5cKvrPwPrQwvKAWe1OGPexmexKEveulfezm/BxRfamiuxLE/apj/zf1e5YJfSXd/OHYv3r5feznPakiPze1P7x7f739f3w6+xJEfnEsvWdf/Wfge1LFPe1nu9iMvnDsfBqPOs/BPOIY/WZevJ/V/zl3fnIt/vTxuxHD+xEC+9mN+5ZJv749vBpO/KBWvBwRP/8+/SUc/etlPjArP/7+vOLZ/F7UvWae/708e1OF/aihvSWdvi8p+tABfSZefvVyPWihfSVde9lNvami+9jM/zi2fKEXvBuQvOKZvalifF5UPJ/WPSPbe9eLfrKuvvd0uxBB/7w7Pzj2vrRw/rOv+1PGfi/q/eymu5bKf3n4PnJuPBrPf3t6PWfgvWegOxCCO9nOO9oOfaskvSYePi5pPi2oPnGtO5eLPevlvKDXfrNvv739Pzd0/708O9gL+9lNfJ9VfrLu/OPbPnDsPBrPus+A/nArfarkQAAAGr5HKgAAADLdFJOU/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AvuakogAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAz5JREFUOE+tVTtu4zAQHQjppmWzwIJbEVCzpTpjbxD3grQHSOXKRXgCAT6EC7UBVAmp3KwBnmvfzNCyZTmxgeTZJsXx43B+HBHRE34ZkXgkerXFTheeiCkRrbB4UXmp4wSWz5raaQEMTM5TZwuiXoaKgV+6FsmkZQcSy0kA71yMTMGHanX+AzMMGLAQCxU1F/ZwjULPugazl82GM0NEKm/U8EqFwEkO3/EAT4grgl0nucwlk9pcpTTJ4VPA4g/Rb3yIRhhp507e9nTQmZ1OS5RO4sS7nIRPEeHXCHdkw9ZEW2yVE5oIS7peD58Avs7CN+PVCmHh21oOqBdjDzIs+FldPJ74TFESUSJEfVzy9U/dhu+AuOT6eBp6gGKyXEx8euO450ZE4CMfstMFT44broWw/itkYErWXRx+fFArt9Ca9os78TFed0LVIUsmIHrwbwaw3BEOnOk94qVpQ6Ka2HjxewJnfyd6jUtGDQLdWlzmYNYLeKbbGOucJsNabCq1Yub0o92rtR+i30V2dapxYVEePXcOjeCKPnYyit7BtKeNlZqHbr+gt7i+AChWA9RsRs03pxTQc67ouWpxyESvjK5Vs3DVSy3IpkxPm5X+wZoBi+MFHWW69/w8FRhc7VBe6HAhMB2b8Q0XqDzTNZtXUMnKMjwKVaCrB/CSUL7WSx/HsdJC86lFGXwnioTeOMPjV+szlFvrZLA5VMVK4y+41l4e1xfx7Z88o4hkilRUH/qKqwNVlgDgpvYCpH3XwAy5eMCRnezIUxffVXoDql2rTHFDO+pjWnTWzAfrYXn6BFECblUpWGrvPZvBipETjS5ydM7tdXpH41ZCEbBNy/+wFZu71QO2t9pgT+iZEf657Q1vpN94PQNDxUHeKR103LV9nPVOtDikcNKO+2naCw7yKBhOe9Hm79pe8C4/CfC2wDjXnqC94kEeBU3WwN7dt/2UScXas7zDl5GpkY+M8WKv2J7fd4Ib2rGTk+jsC2cleEM7jI9veF7B0MBJrsZqfKd/81q9pR2NZfwJK2JzsmIT1Ns8jUH0UusQBpU8d2JzsHiXg1zXGLqxfitUNTDT/nUUeqDBp2HZVr+Ocqi/Ty3Rf4Jn82xxfSNtAAAAAElFTkSuQmCC'
                        }
                    }
                }
                Write-Host ($ObjBody | ConvertTo-Json -Compress)
                $OfficeAppID = New-graphPostRequest -Uri 'https://graph.microsoft.com/beta/deviceAppManagement/mobileApps' -tenantid $tenant -Body (ConvertTo-Json -InputObject $ObjBody -Depth 10) -type POST
            } else {
                "Office deployment already exists for $($Tenant)"
                continue
            }
            Write-LogMessage -headers $Headers -API $APIName -tenant $($Tenant) -message "Added Office profile to $($Tenant)" -Sev 'Info'
            if ($AssignTo) {
                $AssignO365 = if ($AssignTo -ne 'AllDevicesAndUsers') { '{"mobileAppAssignments":[{"@odata.type":"#microsoft.graph.mobileAppAssignment","target":{"@odata.type":"#microsoft.graph.' + $($AssignTo) + 'AssignmentTarget"},"intent":"Required"}]}' } else { '{"mobileAppAssignments":[{"@odata.type":"#microsoft.graph.mobileAppAssignment","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"},"intent":"Required"},{"@odata.type":"#microsoft.graph.mobileAppAssignment","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"},"intent":"Required"}]}' }           Write-Host ($AssignO365)
                New-GraphPOSTRequest -Uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$($OfficeAppID.id)/assign" -tenantid $Tenant -Body $AssignO365 -type POST
                Write-LogMessage -headers $Headers -API $APIName -tenant $($Tenant) -message "Assigned Office to $AssignTo" -Sev 'Info'
            }
            "Successfully added Office App for $($Tenant)"
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Failed to add Office App for $($Tenant): $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $($Tenant) -message "Failed to add Office App. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -Logdata $ErrorMessage
            continue
        }

    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddOfficeApp.ps1' 116
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddStoreApp.ps1' -1

Function Invoke-AddStoreApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $WinGetApp = $Request.Body
    $assignTo = $Request.body.AssignTo

    if ($ChocoApp.InstallAsSystem) { 'system' } else { 'user' }
    $WinGetData = [ordered]@{
        '@odata.type'       = '#microsoft.graph.winGetApp'
        'displayName'       = "$($WinGetApp.ApplicationName)"
        'description'       = "$($WinGetApp.description)"
        'packageIdentifier' = "$($WinGetApp.PackageName)"
        'installExperience' = @{
            '@odata.type'  = 'microsoft.graph.winGetAppInstallExperience'
            'runAsAccount' = 'system'
        }
    }

    $Tenants = $Request.body.selectedTenants.defaultDomainName
    $Results = foreach ($Tenant in $Tenants) {
        try {
            $CompleteObject = [PSCustomObject]@{
                tenant             = $Tenant
                ApplicationName    = $WinGetApp.ApplicationName
                assignTo           = $assignTo
                InstallationIntent = $Request.Body.InstallationIntent
                type               = 'WinGet'
                IntuneBody         = $WinGetData
            } | ConvertTo-Json -Depth 15
            $Table = Get-CippTable -tablename 'apps'
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$CompleteObject"
                RowKey       = "$((New-Guid).GUID)"
                PartitionKey = 'apps'
                status       = 'Not Deployed yet'
            }
            "Successfully added Store App for $($Tenant) to queue."
            Write-LogMessage -headers $Headers -API $APIName -tenant $tenant -message "Successfully added Store App $($IntuneBody.DisplayName) to queue" -Sev 'Info'
        } catch {
            Write-LogMessage -headers $Headers -API $APIName -tenant $tenant -message "Failed to add Store App $($IntuneBody.DisplayName) to queue" -Sev 'Error'
            "Failed to add Store App for $($Tenant) to queue"
        }
    }

    $body = [pscustomobject]@{'Results' = $Results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-AddStoreApp.ps1' 65
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecAppUpload.ps1' -1

function Invoke-ExecAppUpload {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $ConfigTable = Get-CIPPTable -tablename Config
    $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"

    if ($Config -and $Config.state -eq $true) {
        if ($env:CIPP_PROCESSOR -ne 'true') {
            $ProcessorFunction = [PSCustomObject]@{
                PartitionKey = 'Function'
                RowKey       = 'Start-ApplicationOrchestrator'
                FunctionName = 'Start-ApplicationOrchestrator'
            }
            $ProcessorQueue = Get-CIPPTable -TableName 'ProcessorQueue'
            Add-AzDataTableEntity @ProcessorQueue -Entity $ProcessorFunction -Force
            $Results = [pscustomobject]@{'Results' = 'Application upload job has started. Please check back in 15 minutes or track the logbook for results.' }
        }
    } else {
        try {
            Start-ApplicationOrchestrator
            $Results = [pscustomobject]@{'Results' = 'Started application upload' }
        } catch {
            $Results = [pscustomobject]@{'Results' = "Failed to start application upload. Error: $($_.Exception.Message)" }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecAppUpload.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecAssignApp.ps1' -1

function Invoke-ExecAssignApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $appFilter = $Request.Query.ID ?? $Request.Body.ID
    $AssignTo = $Request.Query.AssignTo ?? $Request.Body.AssignTo
    $Intent = $Request.Query.Intent ?? $Request.Body.Intent
    $AppType = $Request.Query.AppType ?? $Request.Body.AppType
    $GroupNamesRaw = $Request.Query.GroupNames ?? $Request.Body.GroupNames
    $GroupIdsRaw = $Request.Query.GroupIds ?? $Request.Body.GroupIds
    $AssignmentMode = $Request.Body.assignmentMode

    $Intent = if ([string]::IsNullOrWhiteSpace($Intent)) { 'Required' } else { $Intent }

    if ([string]::IsNullOrWhiteSpace($AssignmentMode)) {
        $AssignmentMode = 'replace'
    } else {
        $AssignmentMode = $AssignmentMode.ToLower()
        if ($AssignmentMode -notin @('replace', 'append')) {
            throw "Unsupported AssignmentMode value '$AssignmentMode'. Valid options are 'replace' or 'append'."
        }
    }

    function Get-StandardizedAssignmentList {
        param($InputObject)

        if ($null -eq $InputObject -or ($InputObject -is [string] -and [string]::IsNullOrWhiteSpace($InputObject))) {
            return @()
        }
        if ($InputObject -is [string]) {
            return ($InputObject -split ',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        }
        if ($InputObject -is [System.Collections.IEnumerable]) {
            return @($InputObject | Where-Object { $_ })
        }
        return @($InputObject)
    }

    $GroupNames = Get-StandardizedAssignmentList -InputObject $GroupNamesRaw
    $GroupIds = Get-StandardizedAssignmentList -InputObject $GroupIdsRaw

    if (-not $AssignTo -and $GroupIds.Count -eq 0 -and $GroupNames.Count -eq 0) {
        throw 'No assignment target provided. Supply AssignTo, GroupNames, or GroupIds.'
    }

    # Try to get the application type if not provided. Mostly just useful for ppl using the API that dont know the application type.
    if (-not $AppType) {
        try {
            $AppMetadata = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$appFilter" -tenantid $TenantFilter
            $odataType = $AppMetadata.'@odata.type'
            if ($odataType) {
                $AppType = ($odataType -replace '#microsoft.graph.', '') -replace 'App$'
            }
        } catch {
            Write-Warning "Unable to resolve application type for $appFilter. Continuing without assignment settings."
        }
    }

    $targetLabel = if ($AssignTo) {
        $AssignTo
    } elseif ($GroupNames.Count -gt 0) {
        ($GroupNames -join ', ')
    } elseif ($GroupIds.Count -gt 0) {
        "GroupIds: $($GroupIds -join ',')"
    } else {
        'CustomGroupAssignment'
    }

    $setParams = @{
        ApplicationId  = $appFilter
        TenantFilter   = $TenantFilter
        Intent         = $Intent
        APIName        = $APIName
        Headers        = $Headers
        GroupName      = ($AssignTo ? $AssignTo : $targetLabel)
        AssignmentMode = $AssignmentMode
    }

    if ($AppType) {
        $setParams.AppType = $AppType
    }

    if ($GroupIds.Count -gt 0) {
        $setParams.GroupIds = $GroupIds
    }

    try {
        $Result = Set-CIPPAssignedApplication @setParams
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecAssignApp.ps1' 113
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecSyncVPP.ps1' -1

function Invoke-ExecSyncVPP {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -message 'Accessed this API' -Sev Debug

    $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter
    try {
        # Get all VPP tokens and sync them
        $VppTokens = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceAppManagement/vppTokens' -tenantid $TenantFilter | Where-Object { $_.state -eq 'valid' }

        if ($null -eq $VppTokens -or $VppTokens.Count -eq 0) {
            $Result = 'No VPP tokens found'
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        } else {
            $SyncCount = 0
            foreach ($Token in $VppTokens) {
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/vppTokens/$($Token.id)/syncLicenses" -tenantid $TenantFilter
                $SyncCount++
            }
            $Result = "Successfully started VPP sync for $SyncCount tokens"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = 'Failed to start VPP sync'
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ExecSyncVPP.ps1' 45
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListApplicationQueue.ps1' -1

Function Invoke-ListApplicationQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'apps'
    $QueuedApps = (Get-CIPPAzDataTableEntity @Table)

    $CurrentApps = foreach ($QueueFile in $QueuedApps) {
        Write-Host $QueueFile
        $ApplicationFile = $QueueFile.JSON | ConvertFrom-Json -Depth 10
        [PSCustomObject]@{
            tenantName      = $ApplicationFile.tenant
            applicationName = $ApplicationFile.applicationName
            cmdLine         = $ApplicationFile.IntuneBody.installCommandLine
            assignTo        = $ApplicationFile.assignTo
            id              = $($QueueFile.RowKey)
            status          = $($QueueFile.status)
        }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($CurrentApps)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListApplicationQueue.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListApps.ps1' -1

function Invoke-ListApps {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        # Use bulk requests to get groups and apps with assignments
        $BulkRequests = @(
            @{
                id     = 'Groups'
                method = 'GET'
                url    = '/groups?$top=999&$select=id,displayName'
            }
            @{
                id     = 'Apps'
                method = 'GET'
                url    = "/deviceAppManagement/mobileApps?`$top=999&`$expand=assignments&`$filter=(microsoft.graph.managedApp/appAvailability%20eq%20null%20or%20microsoft.graph.managedApp/appAvailability%20eq%20%27lineOfBusiness%27%20or%20isAssigned%20eq%20true)&`$orderby=displayName"
            }
        )

        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

        # Extract groups for resolving assignment names
        $Groups = ($BulkResults | Where-Object { $_.id -eq 'Groups' }).body.value
        $Apps = ($BulkResults | Where-Object { $_.id -eq 'Apps' }).body.value

        $GraphRequest = foreach ($App in $Apps) {
            # Process assignments
            $AppAssignment = [System.Collections.Generic.List[string]]::new()
            $AppExclude = [System.Collections.Generic.List[string]]::new()

            if ($App.assignments) {
                foreach ($Assignment in $App.assignments) {
                    $target = $Assignment.target
                    $intent = $Assignment.intent
                    $intentSuffix = if ($intent) { " ($intent)" } else { '' }

                    switch ($target.'@odata.type') {
                        '#microsoft.graph.allDevicesAssignmentTarget' { $AppAssignment.Add("All Devices$intentSuffix") }
                        '#microsoft.graph.allLicensedUsersAssignmentTarget' { $AppAssignment.Add("All Licensed Users$intentSuffix") }
                        '#microsoft.graph.groupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $AppAssignment.Add("$groupName$intentSuffix") }
                        }
                        '#microsoft.graph.exclusionGroupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $AppExclude.Add($groupName) }
                        }
                    }
                }
            }

            $App | Add-Member -NotePropertyName 'AppAssignment' -NotePropertyValue ($AppAssignment -join ', ') -Force
            $App | Add-Member -NotePropertyName 'AppExclude' -NotePropertyValue ($AppExclude -join ', ') -Force
            $App
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListApps.ps1' 77
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListAppsRepository.ps1' -1

Function Invoke-ListAppsRepository {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Search = $Request.Body.Search
    $Repository = $Request.Body.Repository
    $Packages = @()
    $Message = ''
    $IsError = $false

    try {
        if (!([string]::IsNullOrEmpty($Search))) {
            if ([string]::IsNullOrEmpty($Repository)) {
                $Repository = 'https://chocolatey.org/api/v2'
            }

            # Latest version, top 30 results matching search term
            $SearchPath = "Search()?`$filter=IsLatestVersion&`$skip=0&`$top=30&searchTerm='$Search'&targetFramework=''&includePrerelease=false"

            $Url = "$Repository/$SearchPath"
            $RepoPackages = Invoke-RestMethod $Url -ErrorAction Stop

            if (($RepoPackages | Measure-Object).Count -gt 0) {
                $Packages = foreach ($RepoPackage in $RepoPackages) {
                    [PSCustomObject]@{
                        packagename     = $RepoPackage.title.'#text'
                        author          = $RepoPackage.author.Name
                        applicationName = $RepoPackage.properties.Title
                        version         = $RepoPackage.properties.Version
                        description     = $RepoPackage.summary.'#text'
                        customRepo      = $Repository
                        created         = Get-Date -Date $RepoPackage.properties.Created.'#text' -Format 'MM/dd/yyyy HH:mm:ss'
                    }
                }
            } else {
                $IsError = $true
                $Message = 'No results found'
            }
        } else {
            $IsError = $true
            $Message = 'No search terms specified'
        }
    } catch {
        $IsError = $true
        $Message = "Repository error: $($_.Exception.Message)"
    }

    $PackageSearch = @{
        Search  = $Search
        Results = @($Packages | Sort-Object -Property packagename)
        Message = $Message
        IsError = $IsError
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $PackageSearch
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-ListAppsRepository.ps1' 66
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-RemoveApp.ps1' -1

Function Invoke-RemoveApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $policyId = $Request.Query.ID ?? $Request.Body.ID

    if (!$policyId) { exit }
    try {
        #$unAssignRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($policyId)')/assign" -type POST -Body '{"assignments":[]}' -tenant $TenantFilter
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$($policyId)" -type DELETE -tenant $TenantFilter
        $Result = "Successfully deleted app with $policyId"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Info -tenant $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete app with $policyId. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-RemoveApp.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-RemoveQueuedApp.ps1' -1

#using namespace System.Net

function Invoke-RemoveQueuedApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $ID = $request.body.ID
    try {
        $Table = Get-CippTable -tablename 'apps'
        $Filter = "PartitionKey eq 'apps' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Message = "Removed application queue for $ID."
        Write-LogMessage -Headers $Request.Headers -API $APIName -message $Message -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to remove application queue for $ID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Request.Headers -API $APIName -message $Message -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $body = [pscustomobject]@{'Results' = $Message }
    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $body
    }


}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Applications/Invoke-RemoveQueuedApp.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddAPDevice.ps1' -1

function Invoke-AddAPDevice {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    .DESCRIPTION
        Adds Autopilot devices to a tenant via Partner Center API
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = (Get-Tenants | Where-Object { $_.defaultDomainName -eq $Request.Body.TenantFilter.value }).customerId
    $GroupName = if ($Request.Body.Groupname) { $Request.Body.Groupname } else { (New-Guid).GUID }
    Write-Host $GroupName

    $rawDevices = $Request.Body.autopilotData
    $Devices = ConvertTo-Json @($rawDevices)
    $Result = try {
        $CurrentStatus = (New-GraphGetRequest -uri "https://api.partnercenter.microsoft.com/v1/customers/$TenantFilter/DeviceBatches" -scope 'https://api.partnercenter.microsoft.com/user_impersonation')
        if ($GroupName -in $CurrentStatus.items.id) {
            Write-Host 'Gonna do an update!'
            $Body = $Request.Body.autopilotData | ForEach-Object {
                $Device = $_
                [pscustomobject]@{
                    deviceBatchId       = $GroupName
                    hardwareHash        = $Device.hardwareHash
                    serialNumber        = $Device.SerialNumber
                    productKey          = $Device.productKey
                    oemManufacturerName = $Device.oemManufacturerName
                    modelName           = $Device.modelName
                }
            }
            $Body = ConvertTo-Json -Depth 10 -Compress -InputObject @($Body)
            Write-Host $Body
            $GraphRequest = (New-GraphPOSTRequest -returnHeaders $true -uri "https://api.partnercenter.microsoft.com/v1/customers/$TenantFilter/deviceBatches/$GroupName/devices" -body $Body -scope 'https://api.partnercenter.microsoft.com/user_impersonation')
        } else {
            $Body = '{"batchId":"' + $($GroupName) + '","devices":' + $Devices + '}'
            $GraphRequest = (New-GraphPOSTRequest -returnHeaders $true -uri "https://api.partnercenter.microsoft.com/v1/customers/$TenantFilter/DeviceBatches" -body $Body -scope 'https://api.partnercenter.microsoft.com/user_impersonation')
        }
        $Amount = 0
        do {
            Write-Host "Checking status of import job for $GroupName"
            $Amount++
            Start-Sleep 1
            $NewStatus = New-GraphGetRequest -uri "https://api.partnercenter.microsoft.com/v1/$($GraphRequest.Location)" -scope 'https://api.partnercenter.microsoft.com/user_impersonation'
        } until ($NewStatus.status -eq 'finished' -or $Amount -eq 4)
        if ($NewStatus.status -ne 'finished') { throw 'Could not retrieve status of import - This job might still be running. Check the autopilot device list in 10 minutes for the latest status.' }
        Write-LogMessage -headers $Request.Headers -API $APIName -tenant $($Request.body.TenantFilter.value) -message "Created Autopilot devices group. Group ID is $GroupName" -Sev 'Info'

        [PSCustomObject]@{
            Status  = 'Import Job Completed'
            Devices = @($NewStatus.devicesStatus)
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $StatusCode = [HttpStatusCode]::InternalServerError
        [PSCustomObject]@{
            Status  = "$($Request.Body.TenantFilter.value): Failed to create autopilot devices. $($ErrorMessage.NormalizedError)"
            Devices = @()
        }
        Write-LogMessage -headers $Headers -API $APIName -tenant $($Request.Body.TenantFilter.value) -message "Failed to create autopilot devices. $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddAPDevice.ps1' 74
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddAutopilotConfig.ps1' -1

function Invoke-AddAutopilotConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Input bindings are passed in via param block.
    $Tenants = $Request.Body.selectedTenants.value
    $Profbod = [pscustomobject]$Request.Body
    $UserType = if ($Profbod.NotLocalAdmin -eq 'true') { 'standard' } else { 'administrator' }
    $DeploymentMode = if ($Profbod.DeploymentMode -eq 'true') { 'shared' } else { 'singleUser' }

    # If deployment mode is shared, disable white glove (pre-provisioning) as it's not supported
    $AllowWhiteGlove = if ($DeploymentMode -eq 'shared') { $false } else { $Profbod.allowWhiteGlove }

    $profileParams = @{
        DisplayName        = $Request.Body.DisplayName
        Description        = $Request.Body.Description
        UserType           = $UserType
        DeploymentMode     = $DeploymentMode
        AssignTo           = $Request.Body.Assignto
        DeviceNameTemplate = $Profbod.DeviceNameTemplate
        AllowWhiteGlove    = $AllowWhiteGlove
        CollectHash        = $Profbod.CollectHash
        HideChangeAccount  = $Profbod.HideChangeAccount
        HidePrivacy        = $Profbod.HidePrivacy
        HideTerms          = $Profbod.HideTerms
        Autokeyboard       = $Profbod.Autokeyboard
        Language           = $ProfBod.languages.value
    }
    $Results = foreach ($tenant in $Tenants) {
        $profileParams['tenantFilter'] = $tenant
        Set-CIPPDefaultAPDeploymentProfile @profileParams
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddAutopilotConfig.ps1' 44
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddEnrollment.ps1' -1

function Invoke-AddEnrollment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Input bindings are passed in via param block.
    $Tenants = $Request.Body.selectedTenants.value
    $Profbod = $Request.Body
    $Results = foreach ($Tenant in $Tenants) {
        $ParamSplat = @{
            TenantFilter          = $Tenant
            ShowProgress          = $Profbod.ShowProgress
            BlockDevice           = $Profbod.blockDevice
            AllowReset            = $Profbod.AllowReset
            EnableLog             = $Profbod.EnableLog
            ErrorMessage          = $Profbod.ErrorMessage
            TimeOutInMinutes      = $Profbod.TimeOutInMinutes
            AllowFail             = $Profbod.AllowFail
            OBEEOnly              = $Profbod.OBEEOnly
            InstallWindowsUpdates = $Profbod.InstallWindowsUpdates
        }
        Set-CIPPDefaultAPEnrollment @ParamSplat
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-AddEnrollment.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecAssignAPDevice.ps1' -1

Function Invoke-ExecAssignAPDevice {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $User = $Request.Headers
    Write-LogMessage -Headers $User -API $APINAME -message 'Accessed this API' -Sev 'Debug'
    $TenantFilter = $Request.body.tenantFilter


    try {
        $UserObject = $Request.body.user.addedFields
        $DeviceObject = $Request.body.device
        $SerialNumber = $Request.body.serialNumber
        $body = @{
            userPrincipalName   = $UserObject.userPrincipalName
            addressableUserName = $UserObject.addressableUserName
        } | ConvertTo-Json
        New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities/$($DeviceObject)/UpdateDeviceProperties" -tenantid $TenantFilter -body $body -method POST | Out-Null
        Write-LogMessage -Headers $User -API $APINAME -message "Successfully assigned device: $DeviceObject with Serial: $SerialNumber to $($UserObject.userPrincipalName) for $($TenantFilter)" -Sev Info
        $Results = "Successfully assigned device: $DeviceObject with Serial: $SerialNumber to  $($UserObject.userPrincipalName) for $($TenantFilter)"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $User -API $APINAME -message "Could not assign $($UserObject.userPrincipalName) to $($DeviceObject) for $($TenantFilter) Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Results = "Could not assign $($UserObject.userPrincipalName) to $($DeviceObject) for $($TenantFilter) Error: $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    $Results = [pscustomobject]@{'Results' = "$results" }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecAssignAPDevice.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecRenameAPDevice.ps1' -1

Function Invoke-ExecRenameAPDevice {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $Request.Body.tenantFilter


    try {
        $DeviceId = $Request.Body.deviceId
        $SerialNumber = $Request.Body.serialNumber
        $DisplayName = $Request.Body.displayName

        # Validation
        if ($DisplayName.Length -gt 15) {
            $ValidationError = 'Display name cannot exceed 15 characters.'
        } elseif ($DisplayName -notmatch '^[a-zA-Z0-9-]+$') {
            # This regex also implicitly checks for spaces
            $ValidationError = 'Display name can only contain letters (a-z, A-Z), numbers (0-9), and hyphens (-).'
        } elseif ($DisplayName -match '^\d+$') {
            $ValidationError = 'Display name cannot consist solely of numbers.'
        }

        if ($null -ne $ValidationError) {
            $Result = "Validation failed: $ValidationError"
            $StatusCode = [HttpStatusCode]::BadRequest
        } else {
            # Validation passed, proceed with Graph API call
            $body = @{
                displayName = $DisplayName
            } | ConvertTo-Json

            New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities/$($DeviceId)/UpdateDeviceProperties" -tenantid $TenantFilter -body $body -method POST | Out-Null
            $Result = "Successfully renamed device '$($DeviceId)' with serial number '$($SerialNumber)' to '$($DisplayName)'"
            Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev Info
            $StatusCode = [HttpStatusCode]::OK
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not rename device '$($DeviceId)' with serial number '$($SerialNumber)' to '$($DisplayName)'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::BadRequest
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecRenameAPDevice.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecSetAPDeviceGroupTag.ps1' -1

Function Invoke-ExecSetAPDeviceGroupTag {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Body.tenantFilter

    try {
        $DeviceId = $Request.Body.deviceId
        $SerialNumber = $Request.Body.serialNumber
        $GroupTag = $Request.Body.groupTag

        # Validation - GroupTag can be empty, but if provided, validate it
        if ($null -ne $GroupTag -and $GroupTag -ne '' -and $GroupTag.Length -gt 128) {
            $ValidationError = 'Group tag cannot exceed 128 characters.'
        }

        if ($null -ne $ValidationError) {
            $Result = "Validation failed: $ValidationError"
            $StatusCode = [HttpStatusCode]::BadRequest
        } else {
            # Validation passed, proceed with Graph API call
            $body = @{
                groupTag = $GroupTag
            } | ConvertTo-Json

            New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities/$($DeviceId)/UpdateDeviceProperties" -tenantid $TenantFilter -body $body -method POST | Out-Null
            $Result = "Successfully updated group tag for device '$($DeviceId)' with serial number '$($SerialNumber)' to '$($GroupTag)'"
            Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Info
            $StatusCode = [HttpStatusCode]::OK
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not update group tag for device '$($DeviceId)' with serial number '$($SerialNumber)' to '$($GroupTag)'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecSetAPDeviceGroupTag.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecSyncAPDevices.ps1' -1

Function Invoke-ExecSyncAPDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    try {
        $null = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotSettings/sync' -tenantid $TenantFilter
        $Results = "Successfully Started Sync for $($TenantFilter)"
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message 'Successfully started Autopilot sync' -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to start sync for $TenantFilter. Did you try syncing in the last 10 minutes?"
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $TenantFilter -message 'Failed to start Autopilot sync. Did you try syncing in the last 10 minutes?' -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $Results = [pscustomobject]@{'Results' = "$Results" }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ExecSyncAPDevices.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ListAPDevices.ps1' -1

Function Invoke-ListAPDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities?`$top=999" -tenantid $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ListAPDevices.ps1' 27
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ListAutopilotconfig.ps1' -1

function Invoke-ListAutopilotconfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        if ($Request.Query.type -eq 'ApProfile') {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles?`$expand=assignments" -tenantid $TenantFilter
        }

        if ($Request.Query.type -eq 'ESP') {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations?`$expand=assignments" -tenantid $TenantFilter |
                Where-Object -Property '@odata.type' -EQ '#microsoft.graph.windows10EnrollmentCompletionPageConfiguration'
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-ListAutopilotconfig.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-RemoveAPDevice.ps1' -1

Function Invoke-RemoveAPDevice {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $Deviceid = $Request.Query.ID ?? $Request.body.ID

    try {
        if ($null -eq $TenantFilter -or $TenantFilter -eq 'null') {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities/$Deviceid" -type DELETE
        } else {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeviceIdentities/$Deviceid" -tenantid $TenantFilter -type DELETE
        }
        $Result = "Deleted autopilot device $Deviceid"
        Write-LogMessage -headers $Request.Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete device $($Deviceid): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Request.Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    # Force a sync, this can give "too many requests" if deleting a bunch of devices though.
    $null = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotSettings/sync' -tenantid $TenantFilter -type POST -body '{}'

    $Body = [pscustomobject]@{'Results' = "$Result" }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-RemoveAPDevice.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-RemoveAutopilotConfig.ps1' -1

function Invoke-RemoveAutopilotConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Autopilot.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $ProfileId = $Request.Body.ID
    $DisplayName = $Request.Body.displayName
    $Assignments = $Request.Body.assignments

    try {
        # Validate required parameters
        if ([string]::IsNullOrEmpty($ProfileId)) {
            throw 'Profile ID is required'
        }

        if ([string]::IsNullOrEmpty($TenantFilter)) {
            throw 'Tenant filter is required'
        }

        # Call the helper function to delete the autopilot profile
        $params = @{
            ProfileId    = $ProfileId
            DisplayName  = $DisplayName
            TenantFilter = $TenantFilter
            Assignments  = $Assignments
            Headers      = $Headers
            APIName      = $APIName
        }
        $Result = Remove-CIPPAutopilotProfile @params
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = $_.Exception.Message
        $Result = $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Autopilot/Invoke-RemoveAutopilotConfig.ps1' 54
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddAssignmentFilter.ps1' -1

function Invoke-AddAssignmentFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $SelectedTenants = if ('AllTenants' -in $Request.body.tenantFilter) { (Get-Tenants).defaultDomainName } else { $Request.body.tenantFilter.value ? $Request.body.tenantFilter.value : $Request.body.tenantFilter }

    $FilterObject = $Request.body

    $Results = foreach ($tenant in $SelectedTenants) {
        try {
            # Use the centralized New-CIPPAssignmentFilter function
            $Result = New-CIPPAssignmentFilter -FilterObject $FilterObject -TenantFilter $tenant -APIName $APIName -ExecutingUser $Headers.'x-ms-client-principal-name'

            if ($Result.Success) {
                "Successfully created assignment filter $($FilterObject.displayName) for $($tenant)"
                $StatusCode = [HttpStatusCode]::OK
            } else {
                throw $Result.Message
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -headers $Headers -API $APIName -tenant $tenant -message "Assignment filter creation API failed. $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            "Failed to create assignment filter $($FilterObject.displayName) for $($tenant): $($ErrorMessage.NormalizedError)"
            $StatusCode = [HttpStatusCode]::InternalServerError
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddAssignmentFilter.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddAssignmentFilterTemplate.ps1' -1

function Invoke-AddAssignmentFilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $GUID = $Request.Body.GUID ?? (New-Guid).GUID
    try {
        if (!$Request.Body.displayName) {
            throw 'You must enter a displayname'
        }

        if (!$Request.Body.rule) {
            throw 'You must enter a filter rule'
        }

        if (!$Request.Body.platform) {
            throw 'You must select a platform'
        }

        # Normalize field names to handle different casing from various forms
        $displayName = $Request.Body.displayName ?? $Request.Body.Displayname ?? $Request.Body.displayname
        $description = $Request.Body.description ?? $Request.Body.Description
        $platform = $Request.Body.platform
        $rule = $Request.Body.rule
        $assignmentFilterManagementType = $Request.Body.assignmentFilterManagementType ?? 'devices'

        $object = [PSCustomObject]@{
            displayName                     = $displayName
            description                     = $description
            platform                        = $platform
            rule                            = $rule
            assignmentFilterManagementType  = $assignmentFilterManagementType
            GUID                            = $GUID
        } | ConvertTo-Json
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Force -Entity @{
            JSON         = "$object"
            RowKey       = "$GUID"
            PartitionKey = 'AssignmentFilterTemplate'
        }
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Created Assignment Filter template named $displayName with GUID $GUID" -Sev 'Debug'

        $body = [pscustomobject]@{'Results' = 'Successfully added template' }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Assignment Filter Template Creation failed: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Assignment Filter Template Creation failed: $($_.Exception.Message)" }
    }


    # Associate values to output bindings by calling 'Push-OutputBinding'.
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddAssignmentFilterTemplate.ps1' 66
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddDefenderDeployment.ps1' -1

function Invoke-AddDefenderDeployment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenants = ($Request.Body.selectedTenants).value
    if ('AllTenants' -in $Tenants) { $Tenants = (Get-Tenants -IncludeErrors).defaultDomainName }
    $Compliance = $Request.Body.Compliance
    $PolicySettings = $Request.Body.Policy
    $DefenderExclusions = $Request.Body.Exclusion
    $ASR = $Request.Body.ASR
    $EDR = $Request.Body.EDR
    $Results = foreach ($tenant in $Tenants) {
        try {
            if ($Compliance) {
                $SettingsObject = @{
                    id                                                  = 'fc780465-2017-40d4-a0c5-307022471b92'
                    androidEnabled                                      = [bool]$Compliance.ConnectAndroid
                    iosEnabled                                          = [bool]$Compliance.ConnectIos
                    windowsEnabled                                      = [bool]$Compliance.Connectwindows
                    macEnabled                                          = [bool]$Compliance.ConnectMac
                    partnerUnsupportedOsVersionBlocked                  = [bool]$Compliance.BlockunsupportedOS
                    partnerUnresponsivenessThresholdInDays              = 7
                    allowPartnerToCollectIOSApplicationMetadata         = [bool]$Compliance.ConnectIosCompliance
                    allowPartnerToCollectIOSPersonalApplicationMetadata = [bool]$Compliance.ConnectIosCompliance
                    androidMobileApplicationManagementEnabled           = [bool]$Compliance.ConnectAndroidCompliance
                    iosMobileApplicationManagementEnabled               = [bool]$Compliance.appSync
                    microsoftDefenderForEndpointAttachEnabled           = [bool]$true
                }
                $SettingsObj = $SettingsObject | ConvertTo-Json -Compress
                try {
                    $ExistingSettings = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/mobileThreatDefenseConnectors/fc780465-2017-40d4-a0c5-307022471b92' -tenantid $tenant

                    # Check if any setting doesn't match
                    foreach ($key in $SettingsObject.Keys) {
                        if ($ExistingSettings.$key -ne $SettingsObject[$key]) {
                            $ExistingSettings = $false
                            break
                        }
                    }
                } catch {
                    $ExistingSettings = $false
                }
                if ($ExistingSettings) {
                    "Defender Intune Configuration already correct and active for $($tenant). Skipping"
                } else {
                    $null = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/mobileThreatDefenseConnectors/' -tenantid $tenant -type POST -body $SettingsObj -AsApp $true
                    "$($tenant): Successfully set Defender Compliance and Reporting settings. Please remember to enable the Intune Connector in the Defender portal."
                }
            }


            if ($PolicySettings) {
                $Settings = switch ($PolicySettings) {
                    { $_.ScanArchives } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowarchivescanning'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_allowarchivescanning_1'; settingValueTemplateReference = @{settingValueTemplateId = '9ead75d4-6f30-4bc5-8cc5-ab0f999d79f0' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = '7c5c9cde-f74d-4d11-904f-de4c27f72d89' } } }
                    } { $_.AllowBehavior } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowbehaviormonitoring' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_allowbehaviormonitoring_1'; settingValueTemplateReference = @{settingValueTemplateId = '905921da-95e2-4a10-9e30-fe5540002ce1' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = '8eef615a-1aa0-46f4-a25a-12cbe65de5ab' } } }
                    } { $_.AllowCloudProtection } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowcloudprotection'; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowcloudprotection_1'; settingValueTemplateReference = @{settingValueTemplateId = '16fe8afd-67be-4c50-8619-d535451a500c' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = '7da139f1-9b7e-407d-853a-c2e5037cdc70' } } }
                    } { $_.AllowEmailScanning } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowemailscanning' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowemailscanning_1'; settingValueTemplateReference = @{settingValueTemplateId = 'fdf107fd-e13b-4507-9d8f-db4d93476af9' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'b0d9ee81-de6a-4750-86d7-9397961c9852' } } }
                    } { $_.AllowFullScanNetwork } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowfullscanonmappednetworkdrives' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowfullscanonmappednetworkdrives_1' ; settingValueTemplateReference = @{settingValueTemplateId = '3e920b10-3773-4ac5-957e-e5573aec6d04' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'dac47505-f072-48d6-9f23-8d93262d58ed' } } }
                    } { $_.AllowFullScanRemovable } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowfullscanremovabledrivescanning' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_allowfullscanremovabledrivescanning_1' ; settingValueTemplateReference = @{settingValueTemplateId = '366c5727-629b-4a81-b50b-52f90282fa2c' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'fb36e70b-5bc9-488a-a949-8ea3ac1634d5' } } }
                    } { $_.AllowDownloadable } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowioavprotection' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowioavprotection_1'; settingValueTemplateReference = @{settingValueTemplateId = 'df4e6cbd-f7ff-41c8-88cd-fa25264a237e' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'fa06231d-aed4-4601-b631-3a37e85b62a0' } } }
                    } { $_.AllowRealTime } {
                        @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowrealtimemonitoring'; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_allowrealtimemonitoring_1'; settingValueTemplateReference = @{settingValueTemplateId = '0492c452-1069-4b91-9363-93b8e006ab12' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'f0790e28-9231-4d37-8f44-84bb47ca1b3e' } } }
                    } { $_.AllowNetwork } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowscanningnetworkfiles' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_allowscanningnetworkfiles_1' ; settingValueTemplateReference = @{settingValueTemplateId = '7b8c858c-a17d-4623-9e20-f34b851670ce' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'f8f28442-0a6b-4b52-b42c-d31d9687c1cf' } } }
                    } { $_.AllowScriptScan } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowscriptscanning'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowscriptscanning_1'; settingValueTemplateReference = @{settingValueTemplateId = 'ab9e4320-c953-4067-ac9a-be2becd06b4a' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = '000cf176-949c-4c08-a5d4-90ed43718db7' } } }
                    } { $_.AllowUI } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowuseruiaccess' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_allowuseruiaccess_1' ; settingValueTemplateReference = @{settingValueTemplateId = '4b6c9739-4449-4006-8e5f-3049136470ea' } }; settingInstanceTemplateReference = @{settingInstanceTemplateId = '0170a900-b0bc-4ccc-b7ce-dda9be49189b' } } }
                    } { $_.CheckSigs } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_checkforsignaturesbeforerunningscan' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_checkforsignaturesbeforerunningscan_1' ; settingValueTemplateReference = @{settingValueTemplateId = '010779d1-edd4-441d-8034-89ad57a863fe' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = '4fea56e3-7bb6-4ad3-88c6-e364dd2f97b9' } } }
                    } { $_.DisableCatchupFullScan } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_disablecatchupfullscan'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_disablecatchupfullscan_1' ; settingValueTemplateReference = @{settingValueTemplateId = '1b26092f-48c4-447b-99d4-e9c501542f1c' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'f881b08c-f047-40d2-b7d9-3dde7ce9ef64' } } }
                    } { $_.DisableCatchupQuickScan } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_disablecatchupquickscan' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = 'device_vendor_msft_policy_config_defender_disablecatchupquickscan_1' ; settingValueTemplateReference = @{settingValueTemplateId = 'd263ced7-0d23-4095-9326-99c8b3f5d35b' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'dabf6781-9d5d-42da-822a-d4327aa2bdd1' } } }
                    } { $_.EnableNetworkProtection } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_enablenetworkprotection' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_enablenetworkprotection_$($_.EnableNetworkProtection.value)" ; settingValueTemplateReference = @{settingValueTemplateId = 'ee58fb51-9ae5-408b-9406-b92b643f388a' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'f53ab20e-8af6-48f5-9fa1-46863e1e517e' } } }
                    } { $_.LowCPU } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_enablelowcpupriority' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_policy_config_defender_enablelowcpupriority_1' ; settingValueTemplateReference = @{settingValueTemplateId = '045a4a13-deee-4e24-9fe4-985c9357680d' } } ; settingInstanceTemplateReference = @{settingInstanceTemplateId = 'cdeb96cf-18f5-4477-a710-0ea9ecc618af' } } }
                    } { $_.CloudBlockLevel } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_cloudblocklevel'; settingInstanceTemplateReference = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = 'c7a37009-c16e-4145-84c8-89a8c121fb15' }; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_cloudblocklevel_$($_.CloudBlockLevel.value ?? '0')"; settingValueTemplateReference = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '517b4e84-e933-42b9-b92f-00e640b1a82d' } } } }
                    } { $_.AvgCPULoadFactor } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_avgcpuloadfactor' ; settingInstanceTemplateReference = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference' ; settingInstanceTemplateId = '816cc03e-8f96-4cba-b14f-2658d031a79a' } ; simpleSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationIntegerSettingValue'; value = ($_.AvgCPULoadFactor ?? 50); settingValueTemplateReference = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '37195fb1-3743-4c8e-a0ce-b6fae6fa3acd' } } } }
                    } { $_.CloudExtendedTimeout } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting' ; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_cloudextendedtimeout'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = 'f61c2788-14e4-4e80-a5a7-bf2ff5052f63' }; simpleSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationIntegerSettingValue'; value = ($_.CloudExtendedTimeout ?? 50); settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '608f1561-b603-46bd-bf5f-0b9872002f75' } } } }
                    } { $_.SignatureUpdateInterval } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_signatureupdateinterval'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = '89879f27-6b7d-44d4-a08e-0a0de3e9663d' }; simpleSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationIntegerSettingValue'; value = ($_.SignatureUpdateInterval ?? 8); settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '0af6bbed-a74a-4d08-8587-b16b10b774cb' } } } }
                    } { $_.MeteredConnectionUpdates } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_defender_configuration_meteredconnectionupdates'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = '7e3aaffb-309f-46de-8cd7-25c1a3b19e5b' }; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_defender_configuration_meteredconnectionupdates_1'; settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '20cf972c-be3f-4bc1-93d3-781829d55233' } } } }
                    } { $_.AllowOnAccessProtection } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_allowonaccessprotection'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = 'afbc322b-083c-4281-8242-ebbb91398b41' }; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_allowonaccessprotection_$($_.AllowOnAccessProtection.value ?? '1')"; settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = 'ed077fee-9803-44f3-b045-aab34d8e6d52' } } } }
                    } { $_.DisableLocalAdminMerge } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_defender_configuration_disablelocaladminmerge'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = '5f9a9c65-dea7-4987-a5f5-b28cfd9762ba' }; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = 'device_vendor_msft_defender_configuration_disablelocaladminmerge_1'; settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '3a9774b2-3143-47eb-bbca-d73c0ace2b7e' } } } }
                    } { $_.SubmitSamplesConsent } {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_submitsamplesconsent'; settingInstanceTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = 'bc47ce7d-a251-4cae-a8a2-6e8384904ab7' }; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_submitsamplesconsent_$($_.SubmitSamplesConsent.value ?? '2')"; settingValueTemplateReference = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingValueTemplateReference'; settingValueTemplateId = '826ed4b6-e04f-4975-9d23-6f0904b0d87e' } } } }
                    } { $_.Remediation } {
                        @{
                            '@odata.type' = '#microsoft.graph.deviceManagementConfigurationSetting'; settingInstance = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_threatseveritydefaultaction'; settingInstanceTemplateReference = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSettingInstanceTemplateReference'; settingInstanceTemplateId = 'f6394bc5-6486-4728-b510-555f5c161f2b' }
                                groupSettingCollectionValue = @(@{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationGroupSettingValue'
                                        children                                = @(
                                            if ($_.Remediation.Low) { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_threatseveritydefaultaction_lowseveritythreats'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_threatseveritydefaultaction_lowseveritythreats_$($_.Remediation.Low.value)" } } }
                                            if ($_.Remediation.Moderate) { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_threatseveritydefaultaction_moderateseveritythreats'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_threatseveritydefaultaction_moderateseveritythreats_$($_.Remediation.Moderate.value)" } } }
                                            if ($_.Remediation.High) { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_threatseveritydefaultaction_highseveritythreats'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_threatseveritydefaultaction_highseveritythreats_$($_.Remediation.High.value)" } } }
                                            if ($_.Remediation.Severe) { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_threatseveritydefaultaction_severethreats'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_threatseveritydefaultaction_severethreats_$($_.Remediation.Severe.value)" } } }
                                        )
                                    }
                                )
                            }
                        }
                    }

                }
                $CheckExisting = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant
                Write-Host ($CheckExisting | ConvertTo-Json)
                if ('Default AV Policy' -in $CheckExisting.Name) {
                    "$($tenant): AV Policy already exists. Skipping"
                } else {
                    $PolBody = ConvertTo-Json -Depth 10 -Compress -InputObject @{
                        name              = 'Default AV Policy'
                        description       = ''
                        platforms         = 'windows10'
                        technologies      = 'mdm,microsoftSense'
                        roleScopeTagIds   = @('0')
                        templateReference = @{templateId = '804339ad-1553-4478-a742-138fb5807418_1' }
                        settings          = @($Settings)
                    }

                    Write-Information ($PolBody)

                    $PolicyRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant -type POST -body $PolBody
                    if ($PolicySettings.AssignTo -ne 'None') {
                        $AssignBody = if ($PolicySettings.AssignTo -ne 'AllDevicesAndUsers') { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.' + $($PolicySettings.AssignTo) + 'AssignmentTarget"}}]}' } else { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}},{"id":"","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"}}]}' }
                        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($PolicyRequest.id)')/assign" -tenantid $tenant -type POST -body $AssignBody
                        Write-LogMessage -headers $Headers -API $APINAME -tenant $($tenant) -message "Assigned policy $($DisplayName) to $($PolicySettings.AssignTo)" -Sev 'Info'
                    }
                    "$($tenant): Successfully set Default AV Policy settings"
                }
            }
            if ($ASR) {
                # Fallback to block mode
                $Mode = $ASR.Mode ?? 'block'
                $ASRSettings = switch ($ASR) {
                    { $_.BlockObfuscatedScripts } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutionofpotentiallyobfuscatedscripts' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutionofpotentiallyobfuscatedscripts_$Mode" } } }
                    { $_.BlockAdobeChild } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockadobereaderfromcreatingchildprocesses' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockadobereaderfromcreatingchildprocesses_$Mode" } } }
                    { $_.BlockWin32Macro } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockwin32apicallsfromofficemacros' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockwin32apicallsfromofficemacros_$Mode" } } }
                    { $_.BlockCredentialStealing } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockcredentialstealingfromwindowslocalsecurityauthoritysubsystem' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockcredentialstealingfromwindowslocalsecurityauthoritysubsystem_$Mode" } } }
                    { $_.BlockPSExec } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockprocesscreationsfrompsexecandwmicommands'; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockprocesscreationsfrompsexecandwmicommands_$Mode" } } }
                    { $_.WMIPersistence } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockpersistencethroughwmieventsubscription' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockpersistencethroughwmieventsubscription_$Mode" } } }
                    { $_.BlockOfficeExes } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficeapplicationsfromcreatingexecutablecontent' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficeapplicationsfromcreatingexecutablecontent_$Mode" } } }
                    { $_.BlockOfficeApps } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficeapplicationsfrominjectingcodeintootherprocesses' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficeapplicationsfrominjectingcodeintootherprocesses_$Mode" } } }
                    { $_.BlockYoungExe } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutablefilesrunningunlesstheymeetprevalenceagetrustedlistcriterion' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutablefilesrunningunlesstheymeetprevalenceagetrustedlistcriterion_$Mode" } } }
                    { $_.blockJSVB } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockjavascriptorvbscriptfromlaunchingdownloadedexecutablecontent' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockjavascriptorvbscriptfromlaunchingdownloadedexecutablecontent_$Mode" } } }
                    { $_.BlockWebshellForServers } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockwebshellcreationforservers' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockwebshellcreationforservers_$Mode" } } }
                    { $_.blockOfficeComChild } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficecommunicationappfromcreatingchildprocesses' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockofficecommunicationappfromcreatingchildprocesses_$Mode" } } }
                    { $_.BlockSystemTools } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockuseofcopiedorimpersonatedsystemtools' ; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockuseofcopiedorimpersonatedsystemtools_$Mode" } } }
                    { $_.blockOfficeChild } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockallofficeapplicationsfromcreatingchildprocesses' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockallofficeapplicationsfromcreatingchildprocesses_$Mode" } } }
                    { $_.BlockUntrustedUSB } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance' ; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockuntrustedunsignedprocessesthatrunfromusb'; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockuntrustedunsignedprocessesthatrunfromusb_$Mode" } } }
                    { $_.EnableRansomwareVac } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_useadvancedprotectionagainstransomware'; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_useadvancedprotectionagainstransomware_$Mode" } } }
                    { $_.BlockExesMail } { @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutablecontentfromemailclientandwebmail' ; choiceSettingValue = @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue' ; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockexecutablecontentfromemailclientandwebmail_$Mode" } } }
                    { $_.BlockUnsignedDrivers } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockabuseofexploitedvulnerablesigneddrivers'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockabuseofexploitedvulnerablesigneddrivers_$Mode" } } }
                    { $_.BlockSafeMode } { @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'; settingDefinitionId = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockrebootingmachineinsafemode'; choiceSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationchoiceSettingValue'; value = "device_vendor_msft_policy_config_defender_attacksurfacereductionrules_blockrebootingmachineinsafemode_$Mode" } } }

                }
                $ASRbody = ConvertTo-Json -Depth 15 -Compress -InputObject @{
                    name              = 'ASR Default rules'
                    description       = ''
                    platforms         = 'windows10'
                    technologies      = 'mdm,microsoftSense'
                    roleScopeTagIds   = @('0')
                    templateReference = @{templateId = 'e8c053d6-9f95-42b1-a7f1-ebfd71c67a4b_1' }
                    settings          = @(@{
                            '@odata.type'   = '#microsoft.graph.deviceManagementConfigurationSetting'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationGroupSettingCollectionInstance'
                                settingDefinitionId              = 'device_vendor_msft_policy_config_defender_attacksurfacereductionrules'
                                groupSettingCollectionValue      = @(@{children = $ASRSettings })
                                settingInstanceTemplateReference = @{settingInstanceTemplateId = '19600663-e264-4c02-8f55-f2983216d6d7' }
                            }
                        })
                }
                $CheckExististingASR = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant
                if ('ASR Default rules' -in $CheckExististingASR.Name) {
                    "$($tenant): ASR Policy already exists. Skipping"
                } else {
                    Write-Host $ASRbody
                    if (($ASRSettings | Measure-Object).Count -gt 0) {
                        $ASRRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant -type POST -body $ASRbody
                        Write-Host ($ASRRequest.id)
                        if ($ASR.AssignTo -and $ASR.AssignTo -ne 'none') {
                            $AssignBody = if ($ASR.AssignTo -ne 'AllDevicesAndUsers') { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.' + $($asr.AssignTo) + 'AssignmentTarget"}}]}' } else { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}},{"id":"","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"}}]}' }
                            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($ASRRequest.id)')/assign" -tenantid $tenant -type POST -body $AssignBody
                            Write-LogMessage -headers $Headers -API $APINAME -tenant $($tenant) -message "Assigned policy $($DisplayName) to $($ASR.AssignTo)" -Sev 'Info'
                        }
                        "$($tenant): Successfully added ASR Settings"
                    }
                }
            }
            if ($EDR) {
                $EDRSettings = switch ($EDR) {
                    { $_.SampleSharing } {
                        @{
                            '@odata.type'   = '#microsoft.graph.deviceManagementConfigurationSetting'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'
                                settingDefinitionId              = 'device_vendor_msft_windowsadvancedthreatprotection_configuration_samplesharing'
                                choiceSettingValue               = @{
                                    settingValueTemplateReference = @{settingValueTemplateId = 'f72c326c-7c5b-4224-b890-0b9b54522bd9' }
                                    '@odata.type'                 = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'
                                    'value'                       = 'device_vendor_msft_windowsadvancedthreatprotection_configuration_samplesharing_1'
                                }
                                settingInstanceTemplateReference = @{settingInstanceTemplateId = '6998c81e-2814-4f5e-b492-a6159128a97b' }
                            }
                        }
                    }

                    { $_.Config } {
                        @{
                            '@odata.type'   = '#microsoft.graph.deviceManagementConfigurationSetting'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance'
                                settingDefinitionId              = 'device_vendor_msft_windowsadvancedthreatprotection_configurationtype'
                                choiceSettingValue               = @{
                                    '@odata.type'                 = '#microsoft.graph.deviceManagementConfigurationChoiceSettingValue'
                                    'value'                       = 'device_vendor_msft_windowsadvancedthreatprotection_configurationtype_autofromconnector'
                                    settingValueTemplateReference = @{settingValueTemplateId = 'e5c7c98c-c854-4140-836e-bd22db59d651' }
                                    children                      = @(@{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSimpleSettingInstance' ; settingDefinitionId = 'device_vendor_msft_windowsadvancedthreatprotection_onboarding_fromconnector' ; simpleSettingValue = @{'@odata.type' = '#microsoft.graph.deviceManagementConfigurationSecretSettingValue' ; value = 'Microsoft ATP connector enabled'; valueState = 'NotEncrypted' } } )
                                }

                                settingInstanceTemplateReference = @{settingInstanceTemplateId = '23ab0ea3-1b12-429a-8ed0-7390cf699160' }
                            }
                        }

                    }
                }
                if (($EDRSettings | Measure-Object).Count -gt 0) {
                    $EDRbody = ConvertTo-Json -Depth 15 -Compress -InputObject @{
                        name              = 'EDR Configuration'
                        description       = ''
                        platforms         = 'windows10'
                        technologies      = 'mdm,microsoftSense'
                        roleScopeTagIds   = @('0')
                        templateReference = @{templateId = '0385b795-0f2f-44ac-8602-9f65bf6adede_1' }
                        settings          = @($EDRSettings)
                    }
                    Write-Host ( $EDRbody)
                    $CheckExististingEDR = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant | Where-Object -Property Name -EQ 'EDR Configuration'
                    if ('EDR Configuration' -in $CheckExististingEDR.Name) {
                        "$($tenant): EDR Policy already exists. Skipping"
                    } else {
                        $EDRRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant -type POST -body $EDRbody
                        # Assign if needed
                        if ($EDR.AssignTo -and $EDR.AssignTo -ne 'none') {
                            $AssignBody = if ($EDR.AssignTo -ne 'AllDevicesAndUsers') { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.' + $($EDR.AssignTo) + 'AssignmentTarget"}}]}' } else { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}},{"id":"","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"}}]}' }
                            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($EDRRequest.id)')/assign" -tenantid $tenant -type POST -body $AssignBody
                            Write-LogMessage -headers $Headers -API $APIName -tenant $($tenant) -message "Assigned EDR policy $($DisplayName) to $($EDR.AssignTo)" -Sev 'Info'
                        }
                        "$($tenant): Successfully added EDR Settings"
                    }
                }
            }
            # Exclusion Policy Section
            if ($DefenderExclusions) {
                $ExclusionAssignTo = $DefenderExclusions.AssignTo
                if ($DefenderExclusions.excludedExtensions) {
                    $ExcludedExtensions = $DefenderExclusions.excludedExtensions | Where-Object { $_ -and $_.Trim() } | ForEach-Object {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationStringSettingValue'; value = $_ }
                    }
                }
                if ($DefenderExclusions.excludedPaths) {
                    $ExcludedPaths = $DefenderExclusions.excludedPaths | Where-Object { $_ -and $_.Trim() } | ForEach-Object {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationStringSettingValue'; value = $_ }
                    }
                }
                if ($DefenderExclusions.excludedProcesses) {
                    $ExcludedProcesses = $DefenderExclusions.excludedProcesses | Where-Object { $_ -and $_.Trim() } | ForEach-Object {
                        @{ '@odata.type' = '#microsoft.graph.deviceManagementConfigurationStringSettingValue'; value = $_ }
                    }
                }
                $ExclusionSettings = [System.Collections.Generic.List[System.Object]]::new()
                if ($ExcludedExtensions.Count -gt 0) {
                    $ExclusionSettings.Add(@{
                            id              = '2'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationSimpleSettingCollectionInstance'
                                settingDefinitionId              = 'device_vendor_msft_policy_config_defender_excludedextensions'
                                settingInstanceTemplateReference = @{ settingInstanceTemplateId = 'c203725b-17dc-427b-9470-673a2ce9cd5e' }
                                simpleSettingCollectionValue     = @($ExcludedExtensions)
                            }
                        })
                }
                if ($ExcludedPaths.Count -gt 0) {
                    $ExclusionSettings.Add(@{
                            id              = '1'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationSimpleSettingCollectionInstance'
                                settingDefinitionId              = 'device_vendor_msft_policy_config_defender_excludedpaths'
                                settingInstanceTemplateReference = @{ settingInstanceTemplateId = 'aaf04adc-c639-464f-b4a7-152e784092e8' }
                                simpleSettingCollectionValue     = @($ExcludedPaths)
                            }
                        })
                }
                if ($ExcludedProcesses.Count -gt 0) {
                    $ExclusionSettings.Add(@{
                            id              = '0'
                            settingInstance = @{
                                '@odata.type'                    = '#microsoft.graph.deviceManagementConfigurationSimpleSettingCollectionInstance'
                                settingDefinitionId              = 'device_vendor_msft_policy_config_defender_excludedprocesses'
                                settingInstanceTemplateReference = @{ settingInstanceTemplateId = '96b046ed-f138-4250-9ae0-b0772a93d16f' }
                                simpleSettingCollectionValue     = @($ExcludedProcesses)
                            }
                        })
                }
                if ($ExclusionSettings.Count -gt 0) {
                    $ExclusionBody = ConvertTo-Json -Depth 15 -Compress -InputObject @{
                        name              = 'Default AV Exclusion Policy'
                        displayName       = 'Default AV Exclusion Policy'
                        settings          = @($ExclusionSettings)
                        platforms         = 'windows10'
                        technologies      = 'mdm,microsoftSense'
                        templateReference = @{
                            templateId             = '45fea5e9-280d-4da1-9792-fb5736da0ca9_1'
                            templateFamily         = 'endpointSecurityAntivirus'
                            templateDisplayName    = 'Microsoft Defender Antivirus exclusions'
                            templateDisplayVersion = 'Version 1'
                        }
                    }
                    $CheckExistingExclusion = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant
                    if ('Default AV Exclusion Policy' -in $CheckExistingExclusion.Name) {
                        "$($tenant): Exclusion Policy already exists. Skipping"
                    } else {
                        $ExclusionRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies' -tenantid $tenant -type POST -body $ExclusionBody
                        if ($ExclusionAssignTo -and $ExclusionAssignTo -ne 'none') {
                            $AssignBody = if ($ExclusionAssignTo -ne 'AllDevicesAndUsers') { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.' + $($ExclusionAssignTo) + 'AssignmentTarget"}}]}' } else { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}},{"id":"","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"}}]}' }
                            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($ExclusionRequest.id)')/assign" -tenantid $tenant -type POST -body $AssignBody
                            Write-LogMessage -headers $Headers -API $APIName -tenant $tenant -message "Assigned Exclusion policy to $($ExclusionAssignTo)" -Sev 'Info'
                        }
                        "$($tenant): Successfully set Default AV Exclusion Policy settings"
                    }
                }
            }
        } catch {
            "Failed to add policy for $($tenant): $($_.Exception.Message)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $tenant -message "Failed adding policy $($DisplayName). Error: $($_.Exception.Message)" -Sev 'Error'
            continue
        }

    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddDefenderDeployment.ps1' 372
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddIntuneTemplate.ps1' -1

function Invoke-AddIntuneTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $GUID = (New-Guid).GUID
    try {
        if ($Request.Body.RawJSON) {
            if (!$Request.Body.displayName) { throw 'You must enter a displayName' }
            if ($null -eq ($Request.Body.RawJSON | ConvertFrom-Json)) { throw 'the JSON is invalid' }


            $object = [PSCustomObject]@{
                Displayname = $Request.Body.displayName
                Description = $Request.Body.description
                RAWJson     = $Request.Body.RawJSON
                Type        = $Request.Body.TemplateType
                GUID        = $GUID
            } | ConvertTo-Json
            $Table = Get-CippTable -tablename 'templates'
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$object"
                RowKey       = "$GUID"
                PartitionKey = 'IntuneTemplate'
            }
            Write-LogMessage -headers $Headers -API $APIName -message "Created intune policy template named $($Request.Body.displayName) with GUID $GUID" -Sev 'Debug'

            $Result = 'Successfully added template'
            $StatusCode = [HttpStatusCode]::OK
        } else {
            $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter
            $URLName = $Request.Body.URLName ?? $Request.Query.URLName
            $ID = $Request.Body.ID ?? $Request.Query.ID
            $ODataType = $Request.Body.ODataType ?? $Request.Query.ODataType
            $Template = New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName $URLName -ID $ID -ODataType $ODataType
            Write-Host "Template: $Template"
            $object = [PSCustomObject]@{
                Displayname = $Template.DisplayName
                Description = $Template.Description
                RAWJson     = $Template.TemplateJson
                Type        = $Template.Type
                GUID        = $GUID
            } | ConvertTo-Json
            $Table = Get-CippTable -tablename 'templates'
            $Table.Force = $true
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$object"
                RowKey       = "$GUID"
                PartitionKey = 'IntuneTemplate'
            }
            Write-LogMessage -headers $Headers -API $APIName -message "Created intune policy template $($Request.Body.displayName) with GUID $GUID using an original policy from a tenant" -Sev 'Debug'

            $Result = 'Successfully added template'
            $StatusCode = [HttpStatusCode]::OK
        }
    } catch {
        $StatusCode = [HttpStatusCode]::InternalServerError
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Intune Template Deployment failed: $($ErrorMessage.NormalizedMessage)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddIntuneTemplate.ps1' 78
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddPolicy.ps1' -1

function Invoke-AddPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $Tenants = $Request.Body.tenantFilter.value ? $Request.Body.tenantFilter.value : $Request.Body.tenantFilter
    if ('AllTenants' -in $Tenants) { $Tenants = (Get-Tenants).defaultDomainName }

    $DisplayName = $Request.Body.displayName
    $description = $Request.Body.Description
    $AssignTo = if ($Request.Body.AssignTo -ne 'on') { $Request.Body.AssignTo }
    $ExcludeGroup = $Request.Body.excludeGroup
    $Request.Body.customGroup ? ($AssignTo = $Request.Body.customGroup) : $null
    $RawJSON = $Request.Body.RAWJson

    $Results = foreach ($Tenant in $Tenants) {
        if ($Request.Body.replacemap.$Tenant) {
            ([pscustomobject]$Request.Body.replacemap.$Tenant).PSObject.Properties | ForEach-Object { $RawJSON = $RawJSON -replace $_.name, $_.value }
        }
        try {
            Write-Host 'Calling Adding policy'
            $params = @{
                TemplateType = $Request.Body.TemplateType
                Description  = $description
                DisplayName  = $DisplayName
                RawJSON      = $RawJSON
                AssignTo     = $AssignTo
                ExcludeGroup = $ExcludeGroup
                tenantFilter = $Tenant
                Headers      = $Headers
                APIName      = $APIName
            }
            Set-CIPPIntunePolicy @params
        } catch {
            "$($_.Exception.Message)"
            continue
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-AddPolicy.ps1' 52
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditAssignmentFilter.ps1' -1

function Invoke-EditAssignmentFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Body.tenantFilter

    try {
        $FilterId = $Request.Body.filterId
        $DisplayName = $Request.Body.displayName
        $Description = $Request.Body.description
        $Rule = $Request.Body.rule

        if (!$FilterId) {
            throw 'Filter ID is required'
        }

        # Build the update body
        # Note: Platform and assignmentFilterManagementType cannot be changed after creation per Graph API restrictions
        $UpdateBody = @{}

        if (-not [string]::IsNullOrWhiteSpace($DisplayName)) {
            $UpdateBody.displayName = $DisplayName
        }

        if ($null -ne $Description) {
            $UpdateBody.description = $Description
        }

        if (-not [string]::IsNullOrWhiteSpace($Rule)) {
            $UpdateBody.rule = $Rule
        }

        # Update the assignment filter
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceManagement/assignmentFilters/$FilterId" -tenantid $TenantFilter -type PATCH -body (ConvertTo-Json -InputObject $UpdateBody -Depth 10)

        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Updated assignment filter $($DisplayName)" -Sev Info

        $Result = "Successfully updated assignment filter $($DisplayName)"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to update assignment filter: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Result = "Failed to update assignment filter: $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    # Associate values to output bindings by calling 'Push-OutputBinding'.
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditAssignmentFilter.ps1' 62
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditIntunePolicy.ps1' -1

Function Invoke-EditIntunePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.ID ?? $Request.Body.ID
    $DisplayName = $Request.Query.newDisplayName ?? $Request.Body.newDisplayName
    $PolicyType = $Request.Query.policyType ?? $Request.Body.policyType

    try {
        $properties = @{}

        # Only add displayName if it's provided
        if ($DisplayName) {
            $properties["displayName"] = $DisplayName
        }

        # Update the policy
        $Request = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$PolicyType/$ID" -tenantid $TenantFilter -type PATCH -body ($properties | ConvertTo-Json) -asapp $true

        $Result = "Successfully updated Intune policy $($ID)"
        if ($DisplayName) { $Result += " name to '$($DisplayName)'" }

        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to update Intune policy $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditIntunePolicy.ps1' 49
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditIntuneScript.ps1' -1

function Invoke-EditIntuneScript {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    $graphUrl = 'https://graph.microsoft.com/beta'

    # Define the endpoint based on script type
    function Get-ScriptEndpoint {
        param (
            [Parameter(Mandatory = $true)]
            [string]$ScriptType
        )

        switch ($ScriptType) {
            'Windows' { return 'deviceManagement/deviceManagementScripts' }
            'MacOS' { return 'deviceManagement/deviceShellScripts' }
            'Remediation' { return 'deviceManagement/deviceHealthScripts' }
            'Linux' { return 'deviceManagement/configurationPolicies' }
            default { return 'deviceManagement/deviceManagementScripts' }
        }
    }

    switch ($Request.Method) {
        'GET' {
            # First get the script type by querying the script ID
            $scriptId = $Request.Query.ScriptId
            $scriptTypeFound = $false

            # Try each endpoint to find the script
            foreach ($scriptType in @('Windows', 'MacOS', 'Remediation', 'Linux')) {
                $endpoint = Get-ScriptEndpoint -ScriptType $scriptType
                $parms = @{
                    uri      = "$graphUrl/$endpoint/$scriptId"
                    tenantid = $Request.Query.TenantFilter
                }

                try {
                    $intuneScript = New-GraphGetRequest @parms -ErrorAction Stop
                    if ($intuneScript) {
                        $intuneScript | Add-Member -MemberType NoteProperty -Name scriptType -Value $scriptType -Force
                        $scriptTypeFound = $true
                        break
                    }
                } catch {
                    # Script not found in this endpoint, try next one
                    continue
                }
            }

            if ($scriptTypeFound) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = $intuneScript
                    })
            } else {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::NotFound
                        Body       = "Script with ID $scriptId was not found in any endpoint."
                    })
            }
        }
        'PATCH' {
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::BadRequest
                    Body       = "Method $($Request.Method) is not supported."
                })
        }
        'POST' {
            # Parse the script data to determine type
            $scriptData = $Request.Body.IntuneScript | ConvertFrom-Json
            $scriptType = $Request.Body.ScriptType

            if (-not $scriptType) {
                # Try to determine script type from the request body
                if ($scriptData.PSObject.Properties.Name -contains '@odata.type') {
                    switch ($scriptData.'@odata.type') {
                        '#microsoft.graph.deviceManagementScript' { $scriptType = 'Windows' }
                        '#microsoft.graph.deviceShellScript' { $scriptType = 'MacOS' }
                        '#microsoft.graph.deviceHealthScript' { $scriptType = 'Remediation' }
                        default {
                            if ($scriptData.platforms -eq 'linux' -and $scriptData.templateReference.templateFamily -eq 'deviceConfigurationScripts') {
                                $scriptType = 'Linux'
                            } else {
                                $scriptType = 'Windows' # Default to Windows if no definitive type found
                            }
                        }
                    }
                }
            }

            $endpoint = Get-ScriptEndpoint -ScriptType $scriptType
            $parms = @{
                uri      = "$graphUrl/$endpoint/$($Request.Body.ScriptId)"
                tenantid = $Request.Body.TenantFilter
                body     = $Request.Body.IntuneScript
            }

            try {
                $patchResult = New-GraphPOSTRequest @parms -type 'PATCH'
                $body = [pscustomobject]@{'Results' = $patchResult }
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = $body
                    })
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = "Failed to update script: $($ErrorMessage.NormalizedError)"
                    })
            }
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditIntuneScript.ps1' 125
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditPolicy.ps1' -1

Function Invoke-EditPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    # Note, suspect this is deprecated - rvdwegen

    $APIName = $Request.Params.CIPPEndpoint
    $Tenant = $request.body.tenantid
    $ID = $request.body.groupid
    $displayname = $request.body.Displayname
    $description = $request.body.Description
    $AssignTo = if ($request.body.Assignto -ne 'on') { $request.body.Assignto }

    $results = try {
        $CreateBody = '{"description":"' + $description + '","displayName":"' + $displayname + '","roleScopeTagIds":["0"]}'
        $Request = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/groupPolicyConfigurations('$ID')" -tenantid $tenant -type PATCH -body $CreateBody
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($Tenant) -message "Edited policy $($Displayname)" -Sev 'Info'
        if ($AssignTo) {
            $AssignBody = if ($AssignTo -ne 'AllDevicesAndUsers') { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.' + $($AssignTo) + 'AssignmentTarget"}}]}' } else { '{"assignments":[{"id":"","target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}},{"id":"","target":{"@odata.type":"#microsoft.graph.allLicensedUsersAssignmentTarget"}}]}' }
            $assign = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/groupPolicyConfigurations('$($ID)')/assign" -tenantid $tenant -type POST -body $AssignBody
            Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($Tenant) -message "Assigned policy $($Displayname) to $AssignTo" -Sev 'Info'
        }
        "Successfully edited policy for $($Tenant)"
    }
    catch {
        "Failed to add policy for $($Tenant): $($_.Exception.Message)"
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($Tenant) -message "Failed editing policy $($Displayname). Error:$($_.Exception.Message)" -Sev 'Error'
        continue
    }

    $body = [pscustomobject]@{'Results' = $results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-EditPolicy.ps1' 45
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecAssignmentFilter.ps1' -1

function Invoke-ExecAssignmentFilter {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    $TenantFilter = $Request.Query.TenantFilter ?? $Request.Body.tenantFilter

    try {
        $FilterId = $Request.Body.ID
        $Action = $Request.Body.Action

        if (!$FilterId) {
            throw 'Filter ID is required'
        }

        switch ($Action) {
            'Delete' {
                # Delete the assignment filter
                $GraphRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceManagement/assignmentFilters/$FilterId" -tenantid $TenantFilter -type DELETE

                Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $TenantFilter -message "Deleted assignment filter with ID $FilterId" -Sev Info

                $Result = "Successfully deleted assignment filter"
                $StatusCode = [HttpStatusCode]::OK
            }
            default {
                throw "Unknown action: $Action"
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $TenantFilter -message "Failed to execute assignment filter action: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Result = "Failed to execute assignment filter action: $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    # Associate values to output bindings by calling 'Push-OutputBinding'.
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecAssignmentFilter.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecAssignPolicy.ps1' -1

function Invoke-ExecAssignPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # Interact with the body of the request
    $TenantFilter = $Request.Body.tenantFilter
    $ID = $request.Body.ID
    $Type = $Request.Body.Type
    $AssignTo = $Request.Body.AssignTo
    $PlatformType = $Request.Body.platformType
    $ExcludeGroup = $Request.Body.excludeGroup
    $GroupIdsRaw = $Request.Body.GroupIds
    $GroupNamesRaw = $Request.Body.GroupNames
    $AssignmentMode = $Request.Body.assignmentMode
    $AssignmentFilterName = $Request.Body.AssignmentFilterName
    $AssignmentFilterType = $Request.Body.AssignmentFilterType

    # Standardize GroupIds input (can be array or comma-separated string)
    function Get-StandardizedList {
        param($InputObject)
        if ($null -eq $InputObject -or ($InputObject -is [string] -and [string]::IsNullOrWhiteSpace($InputObject))) {
            return @()
        }
        if ($InputObject -is [string]) {
            return ($InputObject -split ',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        }
        if ($InputObject -is [System.Collections.IEnumerable]) {
            return @($InputObject | Where-Object { $_ })
        }
        return @($InputObject)
    }

    $GroupIds = Get-StandardizedList -InputObject $GroupIdsRaw
    $GroupNames = Get-StandardizedList -InputObject $GroupNamesRaw

    # Validate and default AssignmentMode
    if ([string]::IsNullOrWhiteSpace($AssignmentMode)) {
        $AssignmentMode = 'replace'
    }

    $AssignTo = if ($AssignTo -ne 'on') { $AssignTo }

    $Results = try {
        if ($AssignTo -or @($GroupIds).Count -gt 0) {
            $params = @{
                PolicyId       = $ID
                TenantFilter   = $TenantFilter
                GroupName      = $AssignTo
                Type           = $Type
                Headers        = $Headers
                AssignmentMode = $AssignmentMode
            }

            if (@($GroupIds).Count -gt 0) {
                $params.GroupIds = @($GroupIds)
            }

            if (@($GroupNames).Count -gt 0) {
                $params.GroupNames = @($GroupNames)
            }

            if (-not [string]::IsNullOrWhiteSpace($PlatformType)) {
                $params.PlatformType = $PlatformType
            }

            if (-not [string]::IsNullOrWhiteSpace($ExcludeGroup)) {
                $params.ExcludeGroup = $ExcludeGroup
            }

            if (-not [string]::IsNullOrWhiteSpace($AssignmentFilterName)) {
                $params.AssignmentFilterName = $AssignmentFilterName
            }

            if (-not [string]::IsNullOrWhiteSpace($AssignmentFilterType)) {
                $params.AssignmentFilterType = $AssignmentFilterType
            }

            Set-CIPPAssignedPolicy @params
            $StatusCode = [HttpStatusCode]::OK
        } else {
            'No assignments specified. No action taken.'
            $StatusCode = [HttpStatusCode]::OK
        }
    } catch {
        "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecAssignPolicy.ps1' 105
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecDeviceAction.ps1' -1

function Invoke-ExecDeviceAction {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with Body parameters or the body of the request.
    $Action = $Request.Body.Action
    $DeviceFilter = $Request.Body.GUID
    $TenantFilter = $Request.Body.tenantFilter

    try {
        switch ($Action) {
            'setDeviceName' {
                if ($Request.Body.input -match '%') {
                    $Device = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices/$DeviceFilter" -tenantid $TenantFilter
                    $Request.Body.input = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $Request.Body.input
                    $Request.Body.input = $Request.Body.input -replace '%SERIAL%', $Device.serialNumber
                    # limit to 15 characters
                    if ($Request.Body.input.Length -gt 15) {
                        $Request.Body.input = $Request.Body.input.Substring(0, 15)
                    }
                }

                $ActionBody = @{ deviceName = $Request.Body.input } | ConvertTo-Json -Compress
                break
            }
            'users' {
                $ActionBody = @{ '@odata.id' = "https://graph.microsoft.com/beta/users('$($Request.Body.user.value)')" } | ConvertTo-Json -Compress
                Write-Host "ActionBody: $ActionBody"
                break
            }
            default { $ActionBody = $Request.Body | ConvertTo-Json -Compress }
        }

        $cmdParams = @{
            Action       = $Action
            ActionBody   = $ActionBody
            DeviceFilter = $DeviceFilter
            TenantFilter = $TenantFilter
            Headers      = $Headers
            APINAME      = $APIName
        }
        $ActionResult = New-CIPPDeviceAction @cmdParams

        $StatusCode = [HttpStatusCode]::OK
        $Results = "$ActionResult"

    } catch {
        $StatusCode = [HttpStatusCode]::InternalServerError
        $Results = "$($_.Exception.Message)"
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecDeviceAction.ps1' 67
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecGetLocalAdminPassword.ps1' -1

Function Invoke-ExecGetLocalAdminPassword {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Device.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint

    try {
        $GraphRequest = Get-CIPPLapsPassword -device $($request.body.guid) -tenantFilter $Request.body.TenantFilter -APIName $APINAME -Headers $Request.Headers
        $Body = [pscustomobject]@{'Results' = $GraphRequest }

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $Body = [pscustomobject]@{'Results' = "Failed. $ErrorMessage" }

    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecGetLocalAdminPassword.ps1' 29
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecGetRecoveryKey.ps1' -1

function Invoke-ExecGetRecoveryKey {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Device.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $GUID = $Request.Query.GUID ?? $Request.Body.GUID
    $RecoveryKeyType = $Request.Body.RecoveryKeyType ?? 'BitLocker'

    try {
        switch ($RecoveryKeyType) {
            'BitLocker' { $Result = Get-CIPPBitLockerKey -Device $GUID -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers }
            'FileVault' { $Result = Get-CIPPFileVaultKey -Device $GUID -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers }
            default { throw "Invalid RecoveryKeyType specified: $RecoveryKeyType." }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ExecGetRecoveryKey.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAppProtectionPolicies.ps1' -1

function Invoke-ListAppProtectionPolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -headers $Headers -API $APIName -message 'Accessed this API' -Sev 'Debug'

    $TenantFilter = $Request.Query.tenantFilter

    try {
        # Use bulk requests to get groups, managed app policies and mobile app configurations
        $BulkRequests = @(
            @{
                id     = 'Groups'
                method = 'GET'
                url    = '/groups?$top=999&$select=id,displayName'
            }
            @{
                id     = 'ManagedAppPolicies'
                method = 'GET'
                url    = '/deviceAppManagement/managedAppPolicies?$expand=assignments&$orderby=displayName'
            }
            @{
                id     = 'MobileAppConfigurations'
                method = 'GET'
                url    = '/deviceAppManagement/mobileAppConfigurations?$expand=assignments&$orderby=displayName'
            }
        )

        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

        # Extract groups for resolving assignment names
        $Groups = ($BulkResults | Where-Object { $_.id -eq 'Groups' }).body.value

        $GraphRequest = [System.Collections.Generic.List[object]]::new()

        # Process Managed App Policies - these need separate assignment lookups
        $ManagedAppPolicies = ($BulkResults | Where-Object { $_.id -eq 'ManagedAppPolicies' }).body.value
        if ($ManagedAppPolicies) {
            # Build bulk requests for assignments of policies that support them
            $AssignmentRequests = [System.Collections.Generic.List[object]]::new()
            foreach ($Policy in $ManagedAppPolicies) {
                # Only certain policy types support assignments endpoint
                $odataType = $Policy.'@odata.type'
                if ($odataType -match 'androidManagedAppProtection|iosManagedAppProtection|windowsManagedAppProtection|targetedManagedAppConfiguration') {
                    $urlSegment = switch -Wildcard ($odataType) {
                        '*androidManagedAppProtection*' { 'androidManagedAppProtections' }
                        '*iosManagedAppProtection*' { 'iosManagedAppProtections' }
                        '*windowsManagedAppProtection*' { 'windowsManagedAppProtections' }
                        '*targetedManagedAppConfiguration*' { 'targetedManagedAppConfigurations' }
                    }
                    if ($urlSegment) {
                        $AssignmentRequests.Add(@{
                                id     = $Policy.id
                                method = 'GET'
                                url    = "/deviceAppManagement/$urlSegment('$($Policy.id)')/assignments"
                            })
                    }
                }
            }

            # Fetch assignments in bulk if we have any
            $AssignmentResults = @{}
            if ($AssignmentRequests.Count -gt 0) {
                $AssignmentBulkResults = New-GraphBulkRequest -Requests $AssignmentRequests -tenantid $TenantFilter
                foreach ($result in $AssignmentBulkResults) {
                    if ($result.body.value) {
                        $AssignmentResults[$result.id] = $result.body.value
                    }
                }
            }

            foreach ($Policy in $ManagedAppPolicies) {
                $policyType = switch -Wildcard ($Policy.'@odata.type') {
                    '*androidManagedAppProtection*' { 'Android App Protection' }
                    '*iosManagedAppProtection*' { 'iOS App Protection' }
                    '*windowsManagedAppProtection*' { 'Windows App Protection' }
                    '*mdmWindowsInformationProtectionPolicy*' { 'Windows Information Protection (MDM)' }
                    '*windowsInformationProtectionPolicy*' { 'Windows Information Protection' }
                    '*targetedManagedAppConfiguration*' { 'App Configuration (MAM)' }
                    '*defaultManagedAppProtection*' { 'Default App Protection' }
                    default { 'App Protection Policy' }
                }

                # Process assignments
                $PolicyAssignment = [System.Collections.Generic.List[string]]::new()
                $PolicyExclude = [System.Collections.Generic.List[string]]::new()
                $Assignments = $AssignmentResults[$Policy.id]
                if ($Assignments) {
                    foreach ($Assignment in $Assignments) {
                        $target = $Assignment.target
                        switch ($target.'@odata.type') {
                            '#microsoft.graph.allDevicesAssignmentTarget' { $PolicyAssignment.Add('All Devices') }
                            '#microsoft.graph.allLicensedUsersAssignmentTarget' { $PolicyAssignment.Add('All Licensed Users') }
                            '#microsoft.graph.groupAssignmentTarget' {
                                $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                                if ($groupName) { $PolicyAssignment.Add($groupName) }
                            }
                            '#microsoft.graph.exclusionGroupAssignmentTarget' {
                                $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                                if ($groupName) { $PolicyExclude.Add($groupName) }
                            }
                        }
                    }
                }

                $Policy | Add-Member -NotePropertyName 'PolicyTypeName' -NotePropertyValue $policyType -Force
                $Policy | Add-Member -NotePropertyName 'URLName' -NotePropertyValue 'managedAppPolicies' -Force
                $Policy | Add-Member -NotePropertyName 'PolicySource' -NotePropertyValue 'AppProtection' -Force
                $Policy | Add-Member -NotePropertyName 'PolicyAssignment' -NotePropertyValue ($PolicyAssignment -join ', ') -Force
                $Policy | Add-Member -NotePropertyName 'PolicyExclude' -NotePropertyValue ($PolicyExclude -join ', ') -Force
                $GraphRequest.Add($Policy)
            }
        }

        # Process Mobile App Configurations - assignments are already expanded
        $MobileAppConfigs = ($BulkResults | Where-Object { $_.id -eq 'MobileAppConfigurations' }).body.value
        if ($MobileAppConfigs) {
            foreach ($Config in $MobileAppConfigs) {
                $policyType = switch -Wildcard ($Config.'@odata.type') {
                    '*androidManagedStoreAppConfiguration*' { 'Android Enterprise App Configuration' }
                    '*androidForWorkAppConfigurationSchema*' { 'Android for Work Configuration' }
                    '*iosMobileAppConfiguration*' { 'iOS App Configuration' }
                    default { 'App Configuration Policy' }
                }

                # Process assignments
                $PolicyAssignment = [System.Collections.Generic.List[string]]::new()
                $PolicyExclude = [System.Collections.Generic.List[string]]::new()
                if ($Config.assignments) {
                    foreach ($Assignment in $Config.assignments) {
                        $target = $Assignment.target
                        switch ($target.'@odata.type') {
                            '#microsoft.graph.allDevicesAssignmentTarget' { $PolicyAssignment.Add('All Devices') }
                            '#microsoft.graph.allLicensedUsersAssignmentTarget' { $PolicyAssignment.Add('All Licensed Users') }
                            '#microsoft.graph.groupAssignmentTarget' {
                                $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                                if ($groupName) { $PolicyAssignment.Add($groupName) }
                            }
                            '#microsoft.graph.exclusionGroupAssignmentTarget' {
                                $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                                if ($groupName) { $PolicyExclude.Add($groupName) }
                            }
                        }
                    }
                }

                $Config | Add-Member -NotePropertyName 'PolicyTypeName' -NotePropertyValue $policyType -Force
                $Config | Add-Member -NotePropertyName 'URLName' -NotePropertyValue 'mobileAppConfigurations' -Force
                $Config | Add-Member -NotePropertyName 'PolicySource' -NotePropertyValue 'AppConfiguration' -Force
                $Config | Add-Member -NotePropertyName 'PolicyAssignment' -NotePropertyValue ($PolicyAssignment -join ', ') -Force
                $Config | Add-Member -NotePropertyName 'PolicyExclude' -NotePropertyValue ($PolicyExclude -join ', ') -Force

                # Ensure isAssigned property exists for consistency
                if (-not $Config.PSObject.Properties['isAssigned']) {
                    $Config | Add-Member -NotePropertyName 'isAssigned' -NotePropertyValue $false -Force
                }
                $GraphRequest.Add($Config)
            }
        }

        # Sort combined results by displayName
        $GraphRequest = $GraphRequest | Sort-Object -Property displayName

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAppProtectionPolicies.ps1' 184
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAssignmentFilters.ps1' -1

function Invoke-ListAssignmentFilters {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # Get the tenant filter
    $TenantFilter = $Request.Query.tenantFilter
    $FilterId = $Request.Query.filterId

    try {
        if ($FilterId) {
            # Get specific filter
            $AssignmentFilters = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/assignmentFilters/$($FilterId)" -tenantid $TenantFilter
        } else {
            # Get all filters
            $AssignmentFilters = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters' -tenantid $TenantFilter
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to retrieve assignment filters: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $AssignmentFilters = @()
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($AssignmentFilters)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAssignmentFilters.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAssignmentFilterTemplates.ps1' -1

function Invoke-ListAssignmentFilterTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $ID = $Request.Query.ID

    #List assignment filter templates
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'AssignmentFilterTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $data = $_.JSON | ConvertFrom-Json

        [PSCustomObject]@{
            displayName                    = $data.displayName
            description                    = $data.description
            platform                       = $data.platform
            rule                           = $data.rule
            assignmentFilterManagementType = $data.assignmentFilterManagementType
            GUID                           = $_.RowKey
        }
    } | Sort-Object -Property displayName

    if ($ID) { $Templates = $Templates | Where-Object -Property GUID -EQ $ID }


    # Associate values to output bindings by calling 'Push-OutputBinding'.
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListAssignmentFilterTemplates.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListCompliancePolicies.ps1' -1

function Invoke-ListCompliancePolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -headers $Headers -API $APIName -message 'Accessed this API' -Sev 'Debug'

    $TenantFilter = $Request.Query.tenantFilter

    try {
        # Use bulk requests to get groups and compliance policies
        $BulkRequests = @(
            @{
                id     = 'Groups'
                method = 'GET'
                url    = '/groups?$top=999&$select=id,displayName'
            }
            @{
                id     = 'CompliancePolicies'
                method = 'GET'
                url    = '/deviceManagement/deviceCompliancePolicies?$expand=assignments&$orderby=displayName'
            }
        )

        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

        # Extract results
        $Groups = ($BulkResults | Where-Object { $_.id -eq 'Groups' }).body.value
        $Policies = ($BulkResults | Where-Object { $_.id -eq 'CompliancePolicies' }).body.value

        $GraphRequest = [System.Collections.Generic.List[object]]::new()

        foreach ($Policy in $Policies) {
            # Determine policy type from @odata.type
            $policyType = switch -Wildcard ($Policy.'@odata.type') {
                '*windows10CompliancePolicy*' { 'Windows 10/11 Compliance' }
                '*windowsPhone81CompliancePolicy*' { 'Windows Phone 8.1 Compliance' }
                '*windows81CompliancePolicy*' { 'Windows 8.1 Compliance' }
                '*iosCompliancePolicy*' { 'iOS Compliance' }
                '*macOSCompliancePolicy*' { 'macOS Compliance' }
                '*androidCompliancePolicy*' { 'Android Compliance' }
                '*androidDeviceOwnerCompliancePolicy*' { 'Android Enterprise Compliance' }
                '*androidWorkProfileCompliancePolicy*' { 'Android Work Profile Compliance' }
                '*aospDeviceOwnerCompliancePolicy*' { 'AOSP Compliance' }
                default { 'Compliance Policy' }
            }

            # Process assignments
            $PolicyAssignment = [System.Collections.Generic.List[string]]::new()
            $PolicyExclude = [System.Collections.Generic.List[string]]::new()

            if ($Policy.assignments) {
                foreach ($Assignment in $Policy.assignments) {
                    $target = $Assignment.target
                    switch ($target.'@odata.type') {
                        '#microsoft.graph.allDevicesAssignmentTarget' { $PolicyAssignment.Add('All Devices') }
                        '#microsoft.graph.allLicensedUsersAssignmentTarget' { $PolicyAssignment.Add('All Licensed Users') }
                        '#microsoft.graph.groupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $PolicyAssignment.Add($groupName) }
                        }
                        '#microsoft.graph.exclusionGroupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $PolicyExclude.Add($groupName) }
                        }
                    }
                }
            }

            $Policy | Add-Member -NotePropertyName 'PolicyTypeName' -NotePropertyValue $policyType -Force
            $Policy | Add-Member -NotePropertyName 'PolicyAssignment' -NotePropertyValue ($PolicyAssignment -join ', ') -Force
            $Policy | Add-Member -NotePropertyName 'PolicyExclude' -NotePropertyValue ($PolicyExclude -join ', ') -Force

            $GraphRequest.Add($Policy)
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListCompliancePolicies.ps1' 96
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListDefenderState.ps1' -1

Function Invoke-ListDefenderState {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $StatusCode = [HttpStatusCode]::OK



    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -tenantid $TenantFilter -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices?`$expand=windowsProtectionState&`$select=id,deviceName,deviceType,operatingSystem,windowsProtectionState"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = "$($ErrorMessage)"
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListDefenderState.ps1' 30
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListDefenderTVM.ps1' -1

Function Invoke-ListDefenderTVM {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter
    # Interact with query parameters or the body of the request.
    try {
        $GraphRequest = New-GraphGetRequest -tenantid $TenantFilter -uri "https://api.securitycenter.microsoft.com/api/machines/SoftwareVulnerabilitiesByMachine?`$top=999" -scope 'https://api.securitycenter.microsoft.com/.default' | Group-Object cveId
        $GroupObj = foreach ($cve in $GraphRequest) {
            # Start with base properties
            $obj = [ordered]@{
                customerId           = $TenantFilter
                affectedDevicesCount = $cve.count
                cveId                = $cve.name
            }

            # Get all unique property names from the group
            $allProperties = $cve.group | Get-Member -MemberType Properties | Select-Object -ExpandProperty Name | Sort-Object -Unique

            # Add all properties from the group with appropriate processing
            foreach ($property in $allProperties) {
                if ($property -eq 'deviceName') {
                    # Special handling for deviceName - join with comma
                    $obj['affectedDevices'] = ($cve.group.$property -join ', ')
                } else {
                    # For all other properties, get unique values
                    $obj[$property] = ($cve.group.$property | Sort-Object -Unique) | Select-Object -First 1
                }
            }

            # Convert and output as PSCustomObject. Not really needed, but hey, why not.
            [pscustomobject]$obj
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GroupObj = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GroupObj)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListDefenderTVM.ps1' 52
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntunePolicy.ps1' -1


function Invoke-ListIntunePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    $id = $Request.Query.ID
    $URLName = $Request.Query.URLName
    try {
        if ($ID) {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($URLName)('$ID')" -tenantid $TenantFilter
        } else {
            $BulkRequests = [PSCustomObject]@(
                @{
                    id     = 'Groups'
                    method = 'GET'
                    url    = '/groups?$top=999&$select=id,displayName'
                }
                @{
                    id     = 'DeviceConfigurations'
                    method = 'GET'
                    url    = "/deviceManagement/deviceConfigurations?`$select=id,displayName,lastModifiedDateTime,roleScopeTagIds,microsoft.graph.unsupportedDeviceConfiguration/originalEntityTypeName,description&`$expand=assignments&top=1000"
                }
                @{
                    id     = 'WindowsDriverUpdateProfiles'
                    method = 'GET'
                    url    = "/deviceManagement/windowsDriverUpdateProfiles?`$expand=assignments&top=200"
                }
                @{
                    id     = 'WindowsFeatureUpdateProfiles'
                    method = 'GET'
                    url    = "/deviceManagement/windowsFeatureUpdateProfiles?`$expand=assignments&top=200"
                }
                @{
                    id     = 'windowsQualityUpdatePolicies'
                    method = 'GET'
                    url    = "/deviceManagement/windowsQualityUpdatePolicies?`$expand=assignments&top=200"
                }
                @{
                    id     = 'windowsQualityUpdateProfiles'
                    method = 'GET'
                    url    = "/deviceManagement/windowsQualityUpdateProfiles?`$expand=assignments&top=200"
                }
                @{
                    id     = 'GroupPolicyConfigurations'
                    method = 'GET'
                    url    = "/deviceManagement/groupPolicyConfigurations?`$expand=assignments&top=1000"
                }
                @{
                    id     = 'MobileAppConfigurations'
                    method = 'GET'
                    url    = "/deviceAppManagement/mobileAppConfigurations?`$expand=assignments&`$filter=microsoft.graph.androidManagedStoreAppConfiguration/appSupportsOemConfig%20eq%20true"
                }
                @{
                    id     = 'ConfigurationPolicies'
                    method = 'GET'
                    url    = "/deviceManagement/configurationPolicies?`$expand=assignments&top=1000"
                }
            )

            $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

            # Extract groups for resolving assignment names
            $Groups = ($BulkResults | Where-Object { $_.id -eq 'Groups' }).body.value

            $GraphRequest = $BulkResults | Where-Object { $_.id -ne 'Groups' } | ForEach-Object {
                $URLName = $_.Id
                $_.body.Value | ForEach-Object {
                    $policyTypeName = switch -Wildcard ($_.'assignments@odata.context') {
                        '*microsoft.graph.windowsIdentityProtectionConfiguration*' { 'Identity Protection' }
                        '*microsoft.graph.windows10EndpointProtectionConfiguration*' { 'Endpoint Protection' }
                        '*microsoft.graph.windows10CustomConfiguration*' { 'Custom' }
                        '*microsoft.graph.windows10DeviceFirmwareConfigurationInterface*' { 'Firmware Configuration' }
                        '*groupPolicyConfigurations*' { 'Administrative Templates' }
                        '*windowsDomainJoinConfiguration*' { 'Domain Join configuration' }
                        '*windowsUpdateForBusinessConfiguration*' { 'Update Configuration' }
                        '*windowsHealthMonitoringConfiguration*' { 'Health Monitoring' }
                        '*microsoft.graph.macOSGeneralDeviceConfiguration*' { 'MacOS Configuration' }
                        '*microsoft.graph.macOSEndpointProtectionConfiguration*' { 'MacOS Endpoint Protection' }
                        '*microsoft.graph.androidWorkProfileGeneralDeviceConfiguration*' { 'Android Configuration' }
                        '*windowsFeatureUpdateProfiles*' { 'Feature Update' }
                        '*windowsQualityUpdatePolicies*' { 'Quality Update' }
                        '*windowsQualityUpdateProfiles*' { 'Quality Update' }
                        '*iosUpdateConfiguration*' { 'iOS Update Configuration' }
                        '*windowsDriverUpdateProfiles*' { 'Driver Update' }
                        '*configurationPolicies*' { 'Device Configuration' }
                        default { $_.'assignments@odata.context' }
                    }
                    $Assignments = $_.assignments.target | Select-Object -Property '@odata.type', groupId
                    $PolicyAssignment = [System.Collections.Generic.List[string]]::new()
                    $PolicyExclude = [System.Collections.Generic.List[string]]::new()
                    foreach ($target in $Assignments) {
                        switch ($target.'@odata.type') {
                            '#microsoft.graph.allDevicesAssignmentTarget' { $PolicyAssignment.Add('All Devices') }
                            '#microsoft.graph.exclusionallDevicesAssignmentTarget' { $PolicyExclude.Add('All Devices') }
                            '#microsoft.graph.allUsersAssignmentTarget' { $PolicyAssignment.Add('All Users') }
                            '#microsoft.graph.allLicensedUsersAssignmentTarget' { $PolicyAssignment.Add('All Licenced Users') }
                            '#microsoft.graph.exclusionallUsersAssignmentTarget' { $PolicyExclude.Add('All Users') }
                            '#microsoft.graph.groupAssignmentTarget' { $PolicyAssignment.Add($Groups.Where({ $_.id -eq $target.groupId }).displayName) }
                            '#microsoft.graph.exclusionGroupAssignmentTarget' { $PolicyExclude.Add($Groups.Where({ $_.id -eq $target.groupId }).displayName) }
                            default {
                                $PolicyAssignment.Add($null)
                                $PolicyExclude.Add($null)
                            }
                        }
                    }
                    if ($null -eq $_.displayname) { $_ | Add-Member -NotePropertyName displayName -NotePropertyValue $_.name }
                    $_ | Add-Member -NotePropertyName PolicyTypeName -NotePropertyValue $policyTypeName
                    $_ | Add-Member -NotePropertyName URLName -NotePropertyValue $URLName
                    $_ | Add-Member -NotePropertyName PolicyAssignment -NotePropertyValue ($PolicyAssignment -join ', ')
                    $_ | Add-Member -NotePropertyName PolicyExclude -NotePropertyValue ($PolicyExclude -join ', ')
                    $_
                } | Where-Object { $null -ne $_.DisplayName }
            }
        }

        # Filter the results to sort out linux scripts
        $GraphRequest = $GraphRequest | Where-Object { $_.platforms -ne 'linux' -and $_.templateReference.templateFamily -ne 'deviceConfigurationScripts' }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntunePolicy.ps1' 136
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntuneScript.ps1' -1

function Invoke-ListIntuneScript {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -message 'Accessed this API' -Sev Debug

    $TenantFilter = $Request.Query.tenantFilter
    $Results = [System.Collections.Generic.List[System.Object]]::new()

    $BulkRequests = @(
        @{
            id     = 'Groups'
            method = 'GET'
            url    = '/groups?$top=999&$select=id,displayName'
        }
        @{
            id     = 'Windows'
            method = 'GET'
            url    = '/deviceManagement/deviceManagementScripts?$expand=assignments'
        }
        @{
            id     = 'MacOS'
            method = 'GET'
            url    = '/deviceManagement/deviceShellScripts?$expand=assignments'
        }
        @{
            id     = 'Remediation'
            method = 'GET'
            url    = '/deviceManagement/deviceHealthScripts?$expand=assignments'
        }
        @{
            id     = 'Linux'
            method = 'GET'
            url    = '/deviceManagement/configurationPolicies?$expand=assignments'
        }
    )

    try {
        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Host "Failed to retrieve scripts. Error: $($ErrorMessage.NormalizedError)"
    }

    # Extract groups for resolving assignment names
    $Groups = ($BulkResults | Where-Object { $_.id -eq 'Groups' }).body.value

    foreach ($scriptId in @('Windows', 'MacOS', 'Remediation', 'Linux')) {
        $BulkResult = ($BulkResults | Where-Object { $_.id -eq $scriptId })
        if ($BulkResult.status -ne 200) {
            $Results.Add(@{
                    'scriptType'  = $scriptId
                    'displayName' = if (Test-Json $BulkResult.body.error.message) {
                        ($BulkResult.body.error.message | ConvertFrom-Json).Message
                    } else {
                        $BulkResult.body.error.message
                    }
                })
            continue
        }
        $scripts = $BulkResult.body.value

        if ($scriptId -eq 'Linux') {
            $scripts = $scripts | Where-Object { $_.platforms -eq 'linux' -and $_.templateReference.templateFamily -eq 'deviceConfigurationScripts' }
            $scripts | ForEach-Object { $_ | Add-Member -MemberType NoteProperty -Name displayName -Value $_.name -Force }
        }

        # Process assignments for each script
        foreach ($script in $scripts) {
            $ScriptAssignment = [System.Collections.Generic.List[string]]::new()
            $ScriptExclude = [System.Collections.Generic.List[string]]::new()

            if ($script.assignments) {
                foreach ($Assignment in $script.assignments) {
                    $target = $Assignment.target
                    switch ($target.'@odata.type') {
                        '#microsoft.graph.allDevicesAssignmentTarget' { $ScriptAssignment.Add('All Devices') }
                        '#microsoft.graph.allLicensedUsersAssignmentTarget' { $ScriptAssignment.Add('All Licensed Users') }
                        '#microsoft.graph.groupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $ScriptAssignment.Add($groupName) }
                        }
                        '#microsoft.graph.exclusionGroupAssignmentTarget' {
                            $groupName = ($Groups | Where-Object { $_.id -eq $target.groupId }).displayName
                            if ($groupName) { $ScriptExclude.Add($groupName) }
                        }
                    }
                }
            }

            $script | Add-Member -NotePropertyName 'ScriptAssignment' -NotePropertyValue ($ScriptAssignment -join ', ') -Force
            $script | Add-Member -NotePropertyName 'ScriptExclude' -NotePropertyValue ($ScriptExclude -join ', ') -Force
        }

        $scripts | Add-Member -MemberType NoteProperty -Name scriptType -Value $scriptId
        Write-Host "$scriptId scripts count: $($scripts.Count)"
        $Results.AddRange(@($scripts))
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Results)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntuneScript.ps1' 115
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntuneTemplates.ps1' -1

function Invoke-ListIntuneTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'
    $Imported = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'settings'"
    if ($Imported.IntuneTemplate -ne $true) {
        $Templates = Get-ChildItem 'Config\*.IntuneTemplate.json' | ForEach-Object {
            $Entity = @{
                JSON         = "$(Get-Content $_)"
                RowKey       = "$($_.name)"
                PartitionKey = 'IntuneTemplate'
                GUID         = "$($_.name)"
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
        }
        Add-CIPPAzDataTableEntity @Table -Entity @{
            IntuneTemplate = $true
            RowKey         = 'IntuneTemplate'
            PartitionKey   = 'settings'
        } -Force
    }
    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'IntuneTemplate'"
    $RawTemplates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter)
    if ($Request.query.View) {
        $Templates = $RawTemplates | ForEach-Object {
            try {
                $JSONData = $_.JSON | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue
                $data = $JSONData.RAWJson | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue
                $data | Add-Member -NotePropertyName 'displayName' -NotePropertyValue $JSONData.Displayname -Force
                $data | Add-Member -NotePropertyName 'description' -NotePropertyValue $JSONData.Description -Force
                $data | Add-Member -NotePropertyName 'Type' -NotePropertyValue $JSONData.Type -Force
                $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.RowKey -Force
                $data | Add-Member -NotePropertyName 'package' -NotePropertyValue $_.Package -Force
                $data | Add-Member -NotePropertyName 'isSynced' -NotePropertyValue (![string]::IsNullOrEmpty($_.SHA))
                $data
            } catch {

            }

        } | Sort-Object -Property displayName
    } else {
        if ($Request.query.mode -eq 'Tag') {
            #when the mode is tag, show all the potential tags, return the object with: label: tag, value: tag, count: number of templates with that tag, unique only
            $Templates = $RawTemplates | Where-Object { $_.Package } | Select-Object -Property Package | ForEach-Object {
                $package = $_.Package
                [pscustomobject]@{
                    label         = "$($package) ($(($RawTemplates | Where-Object { $_.Package -eq $package }).Count) Templates)"
                    value         = $package
                    type          = 'tag'
                    templateCount = ($RawTemplates | Where-Object { $_.Package -eq $package }).Count
                    templates     = @($RawTemplates | Where-Object { $_.Package -eq $package } | ForEach-Object {
                            try {
                                $JSONData = $_.JSON | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue
                                $data = $JSONData.RAWJson | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue
                                $data | Add-Member -NotePropertyName 'displayName' -NotePropertyValue $JSONData.Displayname -Force
                                $data | Add-Member -NotePropertyName 'description' -NotePropertyValue $JSONData.Description -Force
                                $data | Add-Member -NotePropertyName 'Type' -NotePropertyValue $JSONData.Type -Force
                                $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.RowKey -Force
                                $data | Add-Member -NotePropertyName 'package' -NotePropertyValue $_.Package -Force
                                $data
                            } catch {

                            }
                        })
                }
            } | Sort-Object -Property label -Unique
        } else {
            $Templates = $RawTemplates.JSON | ForEach-Object { try { ConvertFrom-Json -InputObject $_ -Depth 100 -ErrorAction SilentlyContinue } catch {} }

        }
    }

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property guid -EQ $Request.query.id }

    # Sort all output regardless of view condition
    $Templates = $Templates | Sort-Object -Property displayName

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -Depth 100 -InputObject @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-ListIntuneTemplates.ps1' 92
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveAssignmentFilterTemplate.ps1' -1

Function Invoke-RemoveAssignmentFilterTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $request.Query.ID ?? $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        Write-Host $ID

        $Filter = "PartitionKey eq 'AssignmentFilterTemplate' and RowKey eq '$ID'"
        Write-Host $Filter
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Assignment Filter Template with ID $ID"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove assignment filter template $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    # Associate values to output bindings by calling 'Push-OutputBinding'.
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveAssignmentFilterTemplate.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveIntuneScript.ps1' -1

function Invoke-RemoveIntuneScript {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.TenantFilter
    $ID = $Request.Body.ID
    $ScriptType = $Request.Body.ScriptType
    $DisplayName = $Request.Body.DisplayName

    try {

        $URI = switch ($ScriptType) {
            'Windows' {
                "https://graph.microsoft.com/beta/deviceManagement/deviceManagementScripts/$($ID)"
            }
            'MacOS' {
                "https://graph.microsoft.com/beta/deviceManagement/deviceShellScripts/$($ID)"
            }
            'Remediation' {
                "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts/$($ID)"
            }
            'Linux' {
                "https://graph.microsoft.com/beta/deviceManagement/ConfigurationPolicies('$($ID)')"
            }
            default { $null }
        }

        $null = New-GraphPOSTRequest -uri $URI -type DELETE -tenantid $TenantFilter
        $Result = "Deleted $($ScriptType) script $($DisplayName) with ID: $($ID)"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $Tenant -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete $($ScriptType) script $($DisplayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $Tenant -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveIntuneScript.ps1' 56
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveIntuneTemplate.ps1' -1

function Invoke-RemoveIntuneTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $request.Query.ID ?? $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'

        $Filter = "PartitionKey eq 'IntuneTemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        if ($ClearRow) {
            Remove-AzDataTableEntity @Table -Entity $clearRow -Force
            $Result = "Removed Intune Template with ID $ID."
        } else {
            $Result = "The template with ID $ID has already been deleted."
        }
        Write-LogMessage -Headers $Headers -API $APINAME -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Intune template $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APINAME -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemoveIntuneTemplate.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemovePolicy.ps1' -1

function Invoke-RemovePolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.body.tenantFilter
    $PolicyId = $Request.Query.ID ?? $Request.body.ID
    $UrlName = $Request.Query.URLName ?? $Request.body.URLName
    $BaseEndpoint = switch ($UrlName) {
        'managedAppPolicies' { 'deviceAppManagement' }
        'mobileAppConfigurations' { 'deviceAppManagement' }
        default { 'deviceManagement' }
    }
    if (!$PolicyId) { exit }

    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/$($BaseEndpoint)/$($UrlName)('$($PolicyId)')" -type DELETE -tenant $TenantFilter

        $Results = "Successfully deleted the $UrlName policy with ID: $($PolicyId)"
        Write-LogMessage -headers $Headers -API $APINAME -message $Results -Sev Info -tenant $TenantFilter
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not delete policy: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APINAME -message $Results -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $Body = [pscustomobject]@{'Results' = "$Results" }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/MEM/Invoke-RemovePolicy.ps1' 48
#Region './Public/Entrypoints/HTTP Functions/Endpoint/Reports/Invoke-ListDevices.ps1' -1

Function Invoke-ListDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Device.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/managedDevices' -Tenantid $tenantfilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage

    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Endpoint/Reports/Invoke-ListDevices.ps1' 27
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Devices/Invoke-ExecDeviceDelete.ps1' -1

Function Invoke-ExecDeviceDelete {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Device.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with body parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter
    $Action = $Request.Body.action ?? $Request.Query.action
    $DeviceID = $Request.Body.ID ?? $Request.Query.ID

    try {
        $Results = Set-CIPPDeviceState -Action $Action -DeviceID $DeviceID -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Devices/Invoke-ExecDeviceDelete.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroup.ps1' -1

function Invoke-AddGroup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $SelectedTenants = if ('AllTenants' -in $SelectedTenants) { (Get-Tenants).defaultDomainName } else { $Request.body.tenantFilter.value ? $Request.body.tenantFilter.value : $Request.body.tenantFilter }


    $GroupObject = $Request.body

    $Results = foreach ($tenant in $SelectedTenants) {
        try {
            # Use the centralized New-CIPPGroup function
            $Result = New-CIPPGroup -GroupObject $GroupObject -TenantFilter $tenant -APIName $APIName -ExecutingUser $Request.Headers.'x-ms-client-principal-name'

            if ($Result.Success) {
                "Successfully created group $($GroupObject.displayName) for $($tenant)"
                $StatusCode = [HttpStatusCode]::OK
            } else {
                throw $Result.Message
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            "Failed to create group. $($GroupObject.displayName) for $($tenant) $($ErrorMessage.NormalizedError)"
            $StatusCode = [HttpStatusCode]::InternalServerError
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroup.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroupTeam.ps1' -1

function Invoke-AddGroupTeam {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $Request.Body.TenantFilter
    $GroupId = $Request.Body.GroupId

    $Results = [System.Collections.Generic.List[string]]@()

    try {
        # Default team settings - can be customized via request body
        $TeamSettings = if ($Request.Body.TeamSettings) {
            $Request.Body.TeamSettings
        } else {
            @{
                memberSettings    = @{
                    allowCreatePrivateChannels = $true
                    allowCreateUpdateChannels  = $true
                }
                messagingSettings = @{
                    allowUserEditMessages   = $true
                    allowUserDeleteMessages = $true
                }
                funSettings       = @{
                    allowGiphy         = $true
                    giphyContentRating = 'strict'
                }
            }
        }

        # Create team from group using PUT request
        $GraphParams = @{
            uri      = "https://graph.microsoft.com/beta/groups/$GroupId/team"
            tenantid = $TenantFilter
            type     = 'PUT'
            body     = ($TeamSettings | ConvertTo-Json -Depth 10)
            AsApp    = $true
        }
        $null = New-GraphPOSTRequest @GraphParams

        $Results.Add("Successfully created team from group $GroupId")
        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Created team from group $GroupId" -Sev 'Info'
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $RawMessage = $_.Exception.Message

        # Determine if this is a likely replication delay 404 (exclude owner/membership related 404s)
        $Is404 = ($RawMessage -match '404|Not Found' -or $ErrorMessage.NormalizedError -match '404|Not Found')
        $IsOwnerRelated = ($RawMessage -match 'owner' -or $ErrorMessage.NormalizedError -match 'owner')
        $IsMembershipRelated = ($RawMessage -match 'member' -or $ErrorMessage.NormalizedError -match 'member')

        $IsReplicationDelay = $Is404 -and -not ($IsOwnerRelated -or $IsMembershipRelated)

        if ($IsReplicationDelay) {
            $Results.Add('Failed to create team: The group may have been created too recently. If it was created less than 15 minutes ago, wait and retry. Groups need time to fully replicate before a team can be created.')
            Write-LogMessage -API $APIName -tenant $TenantFilter -message "Failed to create team from group $GroupId - probable replication delay (404). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        } else {
            $Results.Add("Failed to create team: $($ErrorMessage.NormalizedError)")
            Write-LogMessage -API $APIName -tenant $TenantFilter -message "Failed to create team from group $GroupId. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        }
    }

    $Body = @{
        Results = @($Results)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroupTeam.ps1' 79
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroupTemplate.ps1' -1

function Invoke-AddGroupTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $GUID = $Request.Body.GUID ?? (New-Guid).GUID
    try {
        if (!$Request.Body.displayName) {
            throw 'You must enter a displayname'
        }

        # Normalize group type to match New-CIPPGroup expectations
        # Handle values from ListGroups calculatedGroupType and frontend form values
        $groupType = switch -wildcard ($Request.Body.groupType.ToLower()) {
            # Values from ListGroups calculatedGroupType
            '*mail-enabled security*' { 'security'; break }
            '*microsoft 365*' { 'm365'; break }
            '*distribution list*' { 'distribution'; break }
            # Dynamic groups don't have a specific calculatedGroupType - they're detected by membershipRule
            # Frontend form values (camelCase and lowercase)
            '*dynamicdistribution*' { 'dynamicDistribution'; break }
            '*dynamic*' { 'dynamic'; break }
            '*azurerole*' { 'azureRole'; break }
            '*unified*' { 'm365'; break }
            '*m365*' { 'm365'; break }
            '*generic*' { 'generic'; break }
            '*security*' { 'security'; break }
            '*distribution*' { 'distribution'; break }
            '*mail*' { 'distribution'; break }
            default { $Request.Body.groupType }
        }

        # Override to dynamic if membership rules are provided (for backward compatibility)
        # but only if it's not already a dynamicDistribution group
        if ($Request.body.membershipRules -and ![string]::IsNullOrEmpty($Request.Body.membershipRules) -and $Request.Body.membershipRules -ne 'membershipRule' -and $groupType -notin @('dynamicDistribution')) {
            $groupType = 'dynamic'
        }
        # Normalize field names to handle different casing from various forms
        $displayName = $Request.Body.displayName ?? $Request.Body.Displayname ?? $Request.Body.displayname
        $description = $Request.Body.description ?? $Request.Body.Description
        $MembershipRules = ([string]::IsNullOrEmpty($Request.Body.membershipRules) -or $Request.Body.membershipRules -eq 'membershipRule') ? $null : $Request.Body.membershipRules

        $object = [PSCustomObject]@{
            displayName     = $displayName
            description     = $description
            groupType       = $groupType
            membershipRules = $MembershipRules
            allowExternal   = $Request.Body.allowExternal
            username        = $Request.Body.username  # Can contain variables like @%tenantfilter%
            GUID            = $GUID
        } | ConvertTo-Json
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Force -Entity @{
            JSON         = "$object"
            RowKey       = "$GUID"
            PartitionKey = 'GroupTemplate'
        }
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Created Group template named $displayName with GUID $GUID" -Sev 'Debug'

        $body = [pscustomobject]@{'Results' = 'Successfully added template' }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Group Template Creation failed: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Group Template Creation failed: $($_.Exception.Message)" }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-AddGroupTemplate.ps1' 79
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-EditGroup.ps1' -1

function Invoke-EditGroup {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Results = [System.Collections.Generic.List[string]]@()
    $UserObj = $Request.Body
    $GroupType = $UserObj.groupId.addedFields.groupType ? $UserObj.groupId.addedFields.groupType : $UserObj.groupType
    # groupName is used in the Add to Group user action, displayName is used in the Edit Group page
    $GroupName = $UserObj.groupName ?? $UserObj.displayName ?? $UserObj.groupId.addedFields.groupName
    $GroupId = $UserObj.groupId.value ?? $UserObj.groupId
    $OrgGroup = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups/$($GroupId)" -tenantid $UserObj.tenantFilter

    $AddMembers = $UserObj.AddMember

    $TenantId = $UserObj.tenantId ?? $UserObj.tenantFilter

    $MemberODataBindString = 'https://graph.microsoft.com/v1.0/directoryObjects/{0}'
    $BulkRequests = [System.Collections.Generic.List[object]]::new()
    $GraphLogs = [System.Collections.Generic.List[object]]::new()
    $ExoBulkRequests = [System.Collections.Generic.List[object]]::new()
    $ExoLogs = [System.Collections.Generic.List[object]]::new()

    if ($UserObj.displayName -or $UserObj.description -or $UserObj.mailNickname -or $UserObj.membershipRules) {
        #Edit properties:
        if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
            $Params = @{ Identity = $GroupId; DisplayName = $UserObj.displayName; Description = $UserObj.description; name = $UserObj.mailNickname }
            $ExoBulkRequests.Add(@{
                    CmdletInput = @{
                        CmdletName = 'Set-DistributionGroup'
                        Parameters = $Params
                    }
                })
            $ExoLogs.Add(@{
                    message = "Success - Edited group properties for $($GroupName) group. It might take some time to reflect the changes."
                    target  = $GroupId
                })
        } else {
            # Use new securityEnabled value if provided, otherwise keep original
            $SecurityEnabled = $null -ne $UserObj.securityEnabled ? $UserObj.securityEnabled : $OrgGroup.securityEnabled

            $PatchObj = @{
                displayName     = $UserObj.displayName
                description     = $UserObj.description
                mailNickname    = $UserObj.mailNickname
                mailEnabled     = $OrgGroup.mailEnabled
                securityEnabled = $SecurityEnabled
            }
            Write-Host "body: $($PatchObj | ConvertTo-Json -Depth 10 -Compress)" -ForegroundColor Yellow
            if ($UserObj.membershipRules) { $PatchObj | Add-Member -MemberType NoteProperty -Name 'membershipRule' -Value $UserObj.membershipRules -Force }
            try {
                $null = New-GraphPOSTRequest -type PATCH -uri "https://graph.microsoft.com/beta/groups/$($GroupId)" -tenantid $UserObj.tenantFilter -body ($PatchObj | ConvertTo-Json -Depth 10 -Compress)
                $Results.Add("Success - Edited group properties for $($GroupName) group. It might take some time to reflect the changes.")
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message "Edited group properties for $($GroupName) group" -Sev 'Info'

                # Log securityEnabled changes specifically
                if ($null -ne $UserObj.securityEnabled -and $UserObj.securityEnabled -ne $OrgGroup.securityEnabled) {
                    $securityStatusText = "Security capabilities $($UserObj.securityEnabled ? 'enabled' : 'disabled') for group $($GroupName)"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message $securityStatusText -Sev 'Info'
                    $Results.Add($securityStatusText)
                }
            } catch {
                $Results.Add("Error - Failed to edit group properties: $($_.Exception.Message)")
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message "Failed to patch group: $($_.Exception.Message)" -Sev 'Error'
            }
        }
    }

    if ($AddMembers) {
        $AddMembers | ForEach-Object {
            try {
                # Add to group user action and edit group page sends in different formats, so we need to handle both
                $Member = $_.addedFields.userPrincipalName ?? $_.value ?? $_
                $MemberID = $_.value
                if (!$MemberID) {
                    $MemberID = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$Member" -tenantid $TenantId).id
                }

                if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
                    $Params = @{ Identity = $GroupId; Member = $Member; BypassSecurityGroupManagerCheck = $true }
                    # Write-Host ($UserObj | ConvertTo-Json -Depth 10) #Debugging line
                    $ExoBulkRequests.Add(@{
                            CmdletInput = @{
                                CmdletName = 'Add-DistributionGroupMember'
                                Parameters = $Params
                            }
                        })
                    $ExoLogs.Add(@{
                            message = "Added member $Member to $($GroupName) group"
                            target  = $Member
                        })
                } else {
                    $MemberIDs = $MemberODataBindString -f $MemberID
                    $AddMemberBody = @{
                        'members@odata.bind' = @($MemberIDs)
                    }

                    $BulkRequests.Add(@{
                            id      = "addMember-$Member"
                            method  = 'PATCH'
                            url     = "groups/$($GroupId)"
                            body    = $AddMemberBody
                            headers = @{
                                'Content-Type' = 'application/json'
                            }
                        })
                    $GraphLogs.Add(@{
                            message = "Added member $Member to $($GroupName) group"
                            id      = "addMember-$Member"
                        })
                }
            } catch {
                Write-Warning "Error in AddMembers: $($_.Exception.Message)"
            }
        }
    }


    $AddContacts = $UserObj.AddContact
    if ($AddContacts) {
        $AddContacts | ForEach-Object {
            try {
                $Member = $_
                if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
                    $Params = @{ Identity = $GroupId; Member = $Member.value; BypassSecurityGroupManagerCheck = $true }
                    $ExoBulkRequests.Add(@{
                            CmdletInput = @{
                                CmdletName = 'Add-DistributionGroupMember'
                                Parameters = $Params
                            }
                        })
                    $ExoLogs.Add(@{
                            message = "Added contact $($Member.label) to $($GroupName) group"
                            target  = $Member.value
                        })
                } else {
                    Write-LogMessage -API $APIName -tenant $TenantId -headers $Headers -message 'You cannot add a Contact to a Security Group or a M365 Group' -Sev 'Error'
                    $Results.Add('Error - You cannot add a contact to a Security Group or a M365 Group')
                }
            } catch {
                Write-Warning "Error in AddContacts: $($_.Exception.Message)"
            }
        }
    }

    $RemoveContact = $UserObj.RemoveContact
    try {
        if ($RemoveContact) {
            $RemoveContact | ForEach-Object {
                $Member = $_.addedFields.userPrincipalName ?? $_.value
                $MemberID = $_.value
                if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
                    $Params = @{ Identity = $GroupId; Member = $MemberID ; BypassSecurityGroupManagerCheck = $true }
                    $ExoBulkRequests.Add(@{
                            CmdletInput = @{
                                CmdletName = 'Remove-DistributionGroupMember'
                                Parameters = $Params
                            }
                        })
                    $ExoLogs.Add(@{
                            message = "Removed contact $Member from $($GroupName) group"
                            target  = $MemberID
                        })
                } else {
                    Write-LogMessage -API $APIName-tenant $TenantId -headers $Headers -message 'You cannot remove a contact from a Security Group' -Sev 'Error'
                    $Results.Add('You cannot remove a contact from a Security Group')
                }
            }
        }
    } catch {
        Write-Warning "Error in RemoveContact: $($_.Exception.Message)"
    }

    $RemoveMembers = $UserObj.RemoveMember
    try {
        if ($RemoveMembers) {
            $RemoveMembers | ForEach-Object {
                $Member = $_.addedFields.userPrincipalName ?? $_.value
                $MemberID = $_.value
                if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
                    $Params = @{ Identity = $GroupId; Member = $Member ; BypassSecurityGroupManagerCheck = $true }
                    $ExoBulkRequests.Add(@{
                            CmdletInput = @{
                                CmdletName = 'Remove-DistributionGroupMember'
                                Parameters = $Params
                            }
                        })
                    $ExoLogs.Add(@{
                            message = "Removed member $Member from $($GroupName) group"
                            target  = $Member
                        })
                } else {
                    $BulkRequests.Add(@{
                            id     = "removeMember-$Member"
                            method = 'DELETE'
                            url    = "groups/$($GroupId)/members/$MemberID/`$ref"
                        })
                    $GraphLogs.Add(@{
                            message = "Removed member $Member from $($GroupName) group"
                            id      = "removeMember-$Member"
                        })
                }
            }
        }
    } catch {
        Write-Warning "Error in RemoveMembers: $($_.Exception.Message)"
    }

    $AddOwners = $UserObj.AddOwner
    try {
        if ($AddOwners) {
            if ($GroupType -notin @('Distribution List', 'Mail-Enabled Security')) {
                $AddOwners | ForEach-Object {
                    $Owner = $_.addedFields.userPrincipalName ?? $_.value
                    $ID = $_.value

                    $BulkRequests.Add(@{
                            id      = "addOwner-$Owner"
                            method  = 'POST'
                            url     = "groups/$($GroupId)/owners/`$ref"
                            body    = @{
                                '@odata.id' = $MemberODataBindString -f $ID
                            }
                            headers = @{
                                'Content-Type' = 'application/json'
                            }
                        })
                    $GraphLogs.Add(@{
                            message = "Added owner $($Owner) to $($GroupName) group"
                            id      = "addOwner-$Owner"
                        })
                }
            }
        }
    } catch {
        Write-Warning "Error in AddOwners: $($_.Exception.Message)"
    }

    $RemoveOwners = $UserObj.RemoveOwner
    try {
        if ($RemoveOwners) {
            if ($GroupType -notin @('Distribution List', 'Mail-Enabled Security')) {
                $RemoveOwners | ForEach-Object {
                    $ID = $_.value
                    $Owner = $_.addedFields.userPrincipalName ?? $_.value
                    $BulkRequests.Add(@{
                            id     = "removeOwner-$ID"
                            method = 'DELETE'
                            url    = "groups/$($GroupId)/owners/$ID/`$ref"
                        })
                    $GraphLogs.Add(@{
                            message = "Removed owner $($Owner) from $($GroupName) group"
                            id      = "removeOwner-$ID"
                        })
                }
            }
        }
    } catch {
        Write-Warning "Error in RemoveOwners: $($_.Exception.Message)"
    }

    if ($GroupType -in @( 'Distribution List', 'Mail-Enabled Security') -and ($AddOwners -or $RemoveOwners)) {
        $CurrentOwners = New-ExoRequest -tenantid $TenantId -cmdlet 'Get-DistributionGroup' -cmdParams @{ Identity = $GroupId } -UseSystemMailbox $true | Select-Object -ExpandProperty ManagedBy

        $NewManagedBy = [System.Collections.Generic.List[string]]::new()
        foreach ($CurrentOwner in $CurrentOwners) {
            if ($RemoveOwners -and $RemoveOwners.value -contains $CurrentOwner) {
                $OwnerToRemove = $RemoveOwners | Where-Object { $_.value -eq $CurrentOwner }
                $ExoLogs.Add(@{
                        message = "Removed owner $($OwnerToRemove.label) from $($GroupName) group"
                        target  = $GroupId
                    })
                continue
            }
            $NewManagedBy.Add($CurrentOwner)
        }
        if ($AddOwners) {
            foreach ($NewOwner in $AddOwners) {
                $NewManagedBy.Add($NewOwner.value)
                $ExoLogs.Add(@{
                        message = "Added owner $($NewOwner.label) to $($GroupName) group"
                        target  = $GroupId
                    })
            }
        }

        $NewManagedBy = $NewManagedBy | Sort-Object -Unique
        $Params = @{ Identity = $GroupId; ManagedBy = $NewManagedBy }
        $ExoBulkRequests.Add(@{
                CmdletInput = @{
                    CmdletName = 'Set-DistributionGroup'
                    Parameters = $Params
                }
            })
    }



    Write-Information "Graph Bulk Requests: $($BulkRequests.Count)"
    if ($BulkRequests.Count -gt 0) {
        #Write-Warning 'EditUser - Executing Graph Bulk Requests'
        #Write-Information ($BulkRequests | ConvertTo-Json -Depth 10)
        $RawGraphRequest = New-GraphBulkRequest -tenantid $TenantId -scope 'https://graph.microsoft.com/.default' -Requests @($BulkRequests) -asapp $true
        #Write-Warning 'EditUser - Executing Graph Bulk Requests - Completed'
        #Write-Information ($RawGraphRequest | ConvertTo-Json -Depth 10)

        foreach ($GraphLog in $GraphLogs) {
            $GraphError = $RawGraphRequest | Where-Object { $_.id -eq $GraphLog.id -and $_.status -notmatch '^2[0-9]+' }
            if ($GraphError) {
                $Message = Get-NormalizedError -message $GraphError.body.error
                $Sev = 'Error'
                $Results.Add("Error - $Message")
            } else {
                $Message = $GraphLog.message
                $Sev = 'Info'
                $Results.Add("Success - $Message")
            }
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message $Message -Sev $Sev
        }
    }

    Write-Information "Exo Bulk Requests: $($ExoBulkRequests.Count)"
    if ($ExoBulkRequests.Count -gt 0) {
        #Write-Warning 'EditUser - Executing Exo Bulk Requests'
        #Write-Information ($ExoBulkRequests | ConvertTo-Json -Depth 10)
        $RawExoRequest = New-ExoBulkRequest -tenantid $TenantId -cmdletArray @($ExoBulkRequests)
        #Write-Warning 'EditUser - Executing Exo Bulk Requests - Completed'
        #Write-Information ($RawExoRequest | ConvertTo-Json -Depth 10)

        $LastError = $RawExoRequest | Select-Object -Last 1

        foreach ($ExoError in $LastError.error) {
            $Sev = 'Error'
            $Results.Add("Error - $ExoError")
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message $ExoError -Sev $Sev
        }

        foreach ($ExoLog in $ExoLogs) {
            $ExoError = $LastError | Where-Object { $ExoLog.target -in $_.target -and $_.error }
            if (!$LastError -or ($LastError.error -and $LastError.target -notcontains $ExoLog.target)) {
                $Message = $ExoLog.message
                $Sev = 'Info'
                $Results.Add("Success - $Message")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message $Message -Sev $Sev
            }
        }
    }

    # Only process allowExternal if it was explicitly sent
    if ($null -ne $UserObj.allowExternal -and $GroupType -ne 'Security') {
        try {
            $OnlyAllowInternal = $UserObj.allowExternal -eq $true ? $false : $true
            Set-CIPPGroupAuthentication -ID $UserObj.mail -OnlyAllowInternal $OnlyAllowInternal -GroupType $GroupType -tenantFilter $TenantId -APIName $APIName -Headers $Headers
            if ($UserObj.allowExternal -eq $true) {
                $Results.Add("Allowed external senders to send to $($UserObj.mail).")
            } else {
                $Results.Add("Blocked external senders from sending to $($UserObj.mail).")
            }
        } catch {
            $action = if ($UserObj.allowExternal -eq $true) { 'allow' } else { 'block' }
            $Results.Add("Failed to $action external senders for $($UserObj.mail).")
        }
    }

    # Only process visibility if it was explicitly sent for Microsoft 365 groups
    if ($GroupType -eq 'Microsoft 365' -and -not [string]::IsNullOrWhiteSpace($UserObj.visibility)) {
        try {
            $VisibilityValue = $UserObj.visibility
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/groups/$($GroupID)" -type PATCH -tenantid $TenantId -body (@{'visibility' = $VisibilityValue } | ConvertTo-Json)

            $Results.Add("Set group visibility to $VisibilityValue for $($GroupName).")
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Warning "Error in visibility: $($ErrorMessage.NormalizedError) - $($_.InvocationInfo.ScriptLineNumber)"
            $Results.Add("Failed to set group visibility for $($GroupName): $($ErrorMessage.NormalizedError)")
        }
    }

    # Only process sendCopies if it was explicitly sent
    if ($null -ne $UserObj.sendCopies) {
        try {
            if ($UserObj.sendCopies -eq $true) {
                $Params = @{ Identity = $GroupId; subscriptionEnabled = $true; AutoSubscribeNewMembers = $true }
                New-ExoRequest -tenantid $TenantId -cmdlet 'Set-UnifiedGroup' -cmdParams $Params -useSystemMailbox $true

                $MemberParams = @{ Identity = $GroupId; LinkType = 'members' }
                $Members = New-ExoRequest -tenantid $TenantId -cmdlet 'Get-UnifiedGroupLinks' -cmdParams $MemberParams

                $MembershipIds = $Members | ForEach-Object { $_.ExternalDirectoryObjectId }
                if ($MembershipIds) {
                    $subscriberParams = @{ Identity = $GroupId; LinkType = 'subscribers'; Links = @($MembershipIds | Where-Object { $_ }) }

                    try {
                        New-ExoRequest -tenantid $TenantId -cmdlet 'Add-UnifiedGroupLinks' -cmdParams $subscriberParams -Anchor $UserObj.mail
                    } catch {
                        $ErrorMessage = Get-CippException -Exception $_
                        Write-Warning "Error in SendCopies: Add-UnifiedGroupLinks $($ErrorMessage.NormalizedError) - $($_.InvocationInfo.ScriptLineNumber)"
                        throw "Error in SendCopies: Add-UnifiedGroupLinks $($ErrorMessage.NormalizedError)"
                    }

                }

                $Results.Add("Send Copies of team emails and events to team members inboxes for $($UserObj.mail) enabled.")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Send Copies of team emails and events to team members inboxes for $($UserObj.mail) enabled." -Sev 'Info'
            } else {
                # Disable send copies. Has to be done in 2 calls, otherwise it fails saying AutoSubscribeNewMembers cannot be true when subscriptionEnabled is false.
                # Why this happens and can't be done in one call, only Bill Gates and the mystical gods of Exchange knows.
                $Params = @{ Identity = $GroupId; AutoSubscribeNewMembers = $false }
                $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-UnifiedGroup' -cmdParams $Params -useSystemMailbox $true
                $Params = @{ Identity = $GroupId; subscriptionEnabled = $false }
                $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-UnifiedGroup' -cmdParams $Params -useSystemMailbox $true

                $Results.Add("Send Copies of team emails and events to team members inboxes for $($UserObj.mail) disabled.")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Send Copies of team emails and events to team members inboxes for $($UserObj.mail) disabled." -Sev 'Info'
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Warning "Error in SendCopies: $($ErrorMessage.NormalizedError) - $($_.InvocationInfo.ScriptLineNumber)"
            $action = if ($UserObj.sendCopies -eq $true) { 'enable' } else { 'disable' }
            $Results.Add("Failed to $action Send Copies of team emails and events to team members inboxes for $($UserObj.mail).")
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to $action Send Copies of team emails and events to team members inboxes for $($UserObj.mail). Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        }
    }

    # Only process hideFromOutlookClients if it was explicitly sent and is a Microsoft 365 group
    if ($null -ne $UserObj.hideFromOutlookClients -and $GroupType -eq 'Microsoft 365') {
        try {
            $Params = @{ Identity = $GroupId; HiddenFromExchangeClientsEnabled = $UserObj.hideFromOutlookClients }
            $null = New-ExoRequest -tenantid $TenantId -cmdlet 'Set-UnifiedGroup' -cmdParams $Params -useSystemMailbox $true

            if ($UserObj.hideFromOutlookClients -eq $true) {
                $Results.Add("Successfully hidden group mailbox from Outlook for $($GroupName).")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Successfully hidden group mailbox from Outlook for $($GroupName)." -Sev 'Info'
            } else {
                $Results.Add("Successfully made group mailbox visible in Outlook for $($GroupName).")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Successfully made group mailbox visible in Outlook for $($GroupName)." -Sev 'Info'
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Warning "Error in hideFromOutlookClients: $($ErrorMessage.NormalizedError) - $($_.InvocationInfo.ScriptLineNumber)"
            $action = if ($UserObj.hideFromOutlookClients -eq $true) { 'hide' } else { 'show' }
            $Results.Add("Failed to $action group mailbox in Outlook for $($GroupName).")
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantId -message "Failed to $action group mailbox in Outlook for $($GroupName). Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        }
    }

    $body = @{'Results' = @($Results) }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-EditGroup.ps1' 463
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroups.ps1' -1

function Invoke-ListGroups {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Group.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter
    $GroupID = $Request.Query.groupID
    $GroupType = $Request.Query.groupType
    $Members = $Request.Query.members
    $Owners = $Request.Query.owners

    $ExpandMembers = $Request.Query.expandMembers ?? $false

    $SelectString = 'id,createdDateTime,displayName,description,mail,mailEnabled,mailNickname,resourceProvisioningOptions,securityEnabled,visibility,organizationId,onPremisesSamAccountName,membershipRule,groupTypes,onPremisesSyncEnabled,resourceProvisioningOptions,userPrincipalName'
    if ($ExpandMembers -ne $false) {
        $SelectString = '{0}&$expand=members($select=userPrincipalName)' -f $SelectString
    }


    $BulkRequestArrayList = [System.Collections.Generic.List[object]]::new()

    if ($Request.Query.GroupID) {
        $SelectString = 'id,createdDateTime,displayName,description,mail,mailEnabled,mailNickname,resourceProvisioningOptions,securityEnabled,visibility,organizationId,onPremisesSamAccountName,membershipRule,groupTypes,userPrincipalName,onPremisesSyncEnabled'
        $BulkRequestArrayList.add(@{
                id     = 1
                method = 'GET'
                url    = "groups/$($GroupID)?`$select=$SelectString"
            })
    }
    if ($Members) {
        $SelectString = 'id,userPrincipalName,displayName,hideFromOutlookClients,hideFromAddressLists,mail,mailEnabled,mailNickname,resourceProvisioningOptions,securityEnabled,visibility,organizationId,onPremisesSamAccountName,membershipRule'
        $BulkRequestArrayList.add(@{
                id     = 2
                method = 'GET'
                url    = "groups/$($GroupID)/members?`$top=999&select=$SelectString"
            })
    }

    if ($Owners) {
        if ($GroupType -ne 'Distribution List' -and $GroupType -ne 'Mail-Enabled Security') {
            $SelectString = 'id,userPrincipalName,displayName,hideFromOutlookClients,hideFromAddressLists,mail,mailEnabled,mailNickname,resourceProvisioningOptions,securityEnabled,visibility,organizationId,onPremisesSamAccountName,membershipRule'
            $BulkRequestArrayList.add(@{
                    id     = 3
                    method = 'GET'
                    url    = "groups/$($GroupID)/owners?`$top=999&select=$SelectString"
                })
        } else {
            $OwnerIds = New-ExoRequest -cmdlet 'Get-DistributionGroup' -tenantid $TenantFilter -cmdParams @{Identity = $GroupID } -Select 'ManagedBy' -useSystemMailbox $true | Select-Object -ExpandProperty ManagedBy

            $BulkRequestArrayList.add(@{
                    id      = 3
                    method  = 'POST'
                    url     = 'directoryObjects/getByIds'
                    body    = @{
                        ids = @($OwnerIds)
                    }
                    headers = @{
                        'Content-Type' = 'application/json'
                    }
                })
        }
    }

    if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
        # get the outside the organization RequireSenderAuthenticationEnabled setting
        $OnlyAllowInternal = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-DistributionGroup' -cmdParams @{Identity = $GroupID } -Select 'RequireSenderAuthenticationEnabled' -useSystemMailbox $true | Select-Object -ExpandProperty RequireSenderAuthenticationEnabled
    } elseif ($GroupType -eq 'Microsoft 365') {
        $UnifiedGroupInfo = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-UnifiedGroup' -cmdParams @{Identity = $GroupID } -Select 'RequireSenderAuthenticationEnabled,subscriptionEnabled,AutoSubscribeNewMembers,HiddenFromExchangeClientsEnabled' -useSystemMailbox $true
        $OnlyAllowInternal = $UnifiedGroupInfo.RequireSenderAuthenticationEnabled
    } else {
        $OnlyAllowInternal = $null
    }

    if ($GroupType -eq 'Microsoft 365') {
        if ($UnifiedGroupInfo.subscriptionEnabled -eq $true -and $UnifiedGroupInfo.AutoSubscribeNewMembers -eq $true) { $SendCopies = $true } else { $SendCopies = $false }
    } else {
        $SendCopies = $null
    }

    try {
        if ($BulkRequestArrayList.Count -gt 0) {
            $RawGraphRequest = New-GraphBulkRequest -tenantid $TenantFilter -scope 'https://graph.microsoft.com/.default' -Requests @($BulkRequestArrayList) -asapp $true
            $GraphRequest = [PSCustomObject]@{
                groupInfo              = ($RawGraphRequest | Where-Object { $_.id -eq 1 }).body | Select-Object *, @{ Name = 'primDomain'; Expression = { $_.mail -split '@' | Select-Object -Last 1 } },
                @{Name = 'teamsEnabled'; Expression = { if ($_.resourceProvisioningOptions -like '*Team*') { $true } else { $false } } },
                @{Name = 'groupType'; Expression = {
                        if ($_.groupTypes -contains 'Unified') { 'Microsoft 365' }
                        elseif ($_.mailEnabled -and $_.securityEnabled) { 'Mail-Enabled Security' }
                        elseif (-not $_.mailEnabled -and $_.securityEnabled) { 'Security' }
                        elseif (([string]::isNullOrEmpty($_.groupTypes)) -and ($_.mailEnabled) -and (-not $_.securityEnabled)) { 'Distribution List' }
                    }
                },
                @{Name = 'calculatedGroupType'; Expression = {
                        if ($_.groupTypes -contains 'Unified') { 'm365' }
                        elseif ($_.mailEnabled -and $_.securityEnabled) { 'security' }
                        elseif (-not $_.mailEnabled -and $_.securityEnabled) { 'generic' }
                        elseif (([string]::isNullOrEmpty($_.groupTypes)) -and ($_.mailEnabled) -and (-not $_.securityEnabled)) { 'distributionList' }
                    }
                },
                @{Name = 'dynamicGroupBool'; Expression = { if ($_.groupTypes -contains 'DynamicMembership') { $true } else { $false } } }
                members                = ($RawGraphRequest | Where-Object { $_.id -eq 2 }).body.value
                owners                 = ($RawGraphRequest | Where-Object { $_.id -eq 3 }).body.value
                allowExternal          = (!$OnlyAllowInternal)
                sendCopies             = $SendCopies
                hideFromOutlookClients = if ($GroupType -eq 'Microsoft 365') { $UnifiedGroupInfo.HiddenFromExchangeClientsEnabled } else { $null }
            }
        } else {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups/$($GroupID)/$($members)?`$top=999&select=$SelectString" -tenantid $TenantFilter | Select-Object *, @{ Name = 'primDomain'; Expression = { $_.mail -split '@' | Select-Object -Last 1 } },
            @{Name = 'membersCsv'; Expression = { $_.members.userPrincipalName -join ',' } },
            @{Name = 'teamsEnabled'; Expression = { if ($_.resourceProvisioningOptions -like '*Team*') { $true }else { $false } } },
            @{Name = 'groupType'; Expression = {
                    if ($_.groupTypes -contains 'Unified') { 'Microsoft 365' }
                    elseif ($_.mailEnabled -and $_.securityEnabled) { 'Mail-Enabled Security' }
                    elseif (-not $_.mailEnabled -and $_.securityEnabled) { 'Security' }
                    elseif (([string]::isNullOrEmpty($_.groupTypes)) -and ($_.mailEnabled) -and (-not $_.securityEnabled)) { 'Distribution List' }
                }
            },
            @{Name = 'calculatedGroupType'; Expression = {
                    if ($_.groupTypes -contains 'Unified') { 'm365' }
                    elseif ($_.mailEnabled -and $_.securityEnabled) { 'security' }
                    elseif (-not $_.mailEnabled -and $_.securityEnabled) { 'generic' }
                    elseif (([string]::isNullOrEmpty($_.groupTypes)) -and ($_.mailEnabled) -and (-not $_.securityEnabled)) { 'distributionList' }
                }
            },
            @{Name = 'dynamicGroupBool'; Expression = { if ($_.groupTypes -contains 'DynamicMembership') { $true } else { $false } } }
            $GraphRequest = @($GraphRequest | Sort-Object displayName)
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        Write-Warning $_.InvocationInfo.PositionMessage
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $GraphRequest
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroups.ps1' 146
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroupSenderAuthentication.ps1' -1

Function Invoke-ListGroupSenderAuthentication {
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    $groupid = $Request.query.groupid
    $GroupType = $Request.query.Type

    $params = @{
        Identity = $groupid
    }


    try {
        switch ($GroupType) {
            'Distribution List' {
                Write-Host 'Checking DL'
                $State = (New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-DistributionGroup' -cmdParams $params -UseSystemMailbox $true).RequireSenderAuthenticationEnabled
            }
            'Microsoft 365' {
                Write-Host 'Checking M365 Group'
                $State = (New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-UnifiedGroup' -cmdParams $params -UseSystemMailbox $true).RequireSenderAuthenticationEnabled

            }
            default { $state = $true }
        }

    } catch {
        $state = $true
    }

    # We flip the value because the API is asking if the group is allowed to receive external mail
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ allowedToReceiveExternal = !$state }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroupSenderAuthentication.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroupTemplates.ps1' -1

function Invoke-ListGroupTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.Group.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    Write-Host $Request.query.id

    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'GroupTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $data = $_.JSON | ConvertFrom-Json -ErrorAction SilentlyContinue
        # Normalize groupType to camelCase for consistent frontend handling
        # Handle both stored normalized values and legacy values
        $normalizedGroupType = switch -Wildcard ($data.groupType) {
            # Already normalized values (most common)
            'dynamicdistribution' { 'dynamicDistribution'; break }
            'azurerole' { 'azureRole'; break }
            # Legacy values that might exist in stored templates
            '*dynamicdistribution*' { 'dynamicDistribution'; break }
            '*dynamic*' { 'dynamic'; break }
            '*azurerole*' { 'azureRole'; break }
            '*unified*' { 'm365'; break }
            '*microsoft*' { 'm365'; break }
            '*m365*' { 'm365'; break }
            '*generic*' { 'generic'; break }
            '*security*' { 'security'; break }
            '*distribution*' { 'distribution'; break }
            '*mail*' { 'distribution'; break }
            default { $data.groupType }
        }

        [PSCustomObject]@{
            displayName     = $data.displayName
            description     = $data.description
            groupType       = $normalizedGroupType
            membershipRules = $data.membershipRules
            allowExternal   = $data.allowExternal
            username        = $data.username
            GUID            = $_.RowKey
        }
    } | Sort-Object -Property displayName

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property GUID -EQ $Request.query.id }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-ListGroupTemplates.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-RemoveGroupTemplate.ps1' -1

Function Invoke-RemoveGroupTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $request.Query.ID ?? $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        Write-Host $ID

        $Filter = "PartitionKey eq 'GroupTemplate' and RowKey eq '$ID'"
        Write-Host $Filter
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Group Template with ID $ID"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove group template $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Groups/Invoke-RemoveGroupTemplate.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddGuest.ps1' -1

Function Invoke-AddGuest {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Body.tenantFilter
    $UserObject = $Request.Body

    try {
        if ($UserObject.RedirectURL) {
            $BodyToShip = [pscustomobject] @{
                'InvitedUserDisplayName'  = $UserObject.DisplayName
                'InvitedUserEmailAddress' = $($UserObject.mail)
                'inviteRedirectUrl'       = $($UserObject.RedirectURL)
                'sendInvitationMessage'   = [bool]$UserObject.SendInvite
            }
        } else {
            $BodyToShip = [pscustomobject] @{
                'InvitedUserDisplayName'  = $UserObject.DisplayName
                'InvitedUserEmailAddress' = $($UserObject.mail)
                'sendInvitationMessage'   = [bool]$UserObject.SendInvite
                'inviteRedirectUrl'       = 'https://myapps.microsoft.com'
            }
        }
        $bodyToShip = ConvertTo-Json -Depth 10 -InputObject $BodyToShip -Compress
        $null = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/invitations' -tenantid $TenantFilter -type POST -body $BodyToShip -Verbose
        if ($UserObject.SendInvite -eq $true) {
            $Result = "Invited Guest $($UserObject.DisplayName) with Email Invite"
            Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        } else {
            $Result = "Invited Guest $($UserObject.DisplayName) with no Email Invite"
            Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to Invite Guest. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = @($Result) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddGuest.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUser.ps1' -1

function Invoke-AddUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $UserObj = $Request.Body

    if ($UserObj.Scheduled.Enabled) {
        $Username = $UserObj.username ?? $UserObj.mailNickname
        $TaskBody = [pscustomobject]@{
            TenantFilter  = $UserObj.tenantFilter
            Name          = "New user creation: $($Username)@$($UserObj.PrimDomain.value)"
            Command       = @{
                value = 'New-CIPPUserTask'
                label = 'New-CIPPUserTask'
            }
            Parameters    = [pscustomobject]@{ UserObj = $UserObj }
            ScheduledTime = $UserObj.Scheduled.date
            PostExecution = @{
                Webhook = [bool]$Request.Body.PostExecution.Webhook
                Email   = [bool]$Request.Body.PostExecution.Email
                PSA     = [bool]$Request.Body.PostExecution.PSA
            }
        }
        Add-CIPPScheduledTask -Task $TaskBody -hidden $false -DisallowDuplicateName $true -Headers $Headers
        $body = [pscustomobject] @{
            'Results' = @("Successfully created scheduled task to create user $($UserObj.DisplayName)")
        }
    } else {
        $CreationResults = New-CIPPUserTask -UserObj $UserObj -APIName $APIName -Headers $Headers
        $body = [pscustomobject] @{
            'Results'  = @(
                $CreationResults.Results[0],
                $CreationResults.Results[1],
                @{
                    'resultText' = $CreationResults.Results[2]
                    'copyField'  = $CreationResults.password
                    'state'      = 'success'
                }
            )
            'CopyFrom' = @{
                'Success' = $CreationResults.CopyFrom.Success
                'Error'   = $CreationResults.CopyFrom.Error
            }
            'User'     = $CreationResults.User
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUser.ps1' 63
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUserBulk.ps1' -1

function Invoke-AddUserBulk {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Interact with body parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter

    $BulkUsers = $Request.Body.BulkUser
    $AssignedLicenses = $Request.Body.licenses
    $UsageLocation = $Request.Body.usageLocation

    if (!$BulkUsers) {
        $Body = @{
            Results = @{
                resultText = 'No users specified to import'
                state      = 'error'
            }
        }
    } else {
        $BulkRequests = [System.Collections.Generic.List[object]]::new()
        $Results = [System.Collections.Generic.List[object]]::new()
        $Messages = [System.Collections.Generic.List[object]]::new()
        foreach ($User in $BulkUsers) {
            # User input validation
            $missingFields = [System.Collections.Generic.List[string]]::new()
            if (!$User.mailNickName) { $missingFields.Add('mailNickName') }
            if (!$User.domain) { $missingFields.Add('domain') }
            if (!$User.displayName -and !$User.givenName -and !$User.surname) { $missingFields.Add('displayName') }

            $Name = if ([string]::IsNullOrEmpty($User.displayName)) {
                '{0} {1}' -f $User.givenName, $User.surname
            } else {
                $User.displayName
            }

            # Check for missing required fields
            if ($missingFields.Count -gt 0) {
                $Results.Add(@{
                        resultText = "Required fields missing for $($User ?? 'No name specified'): $($missingFields -join ', ')"
                        state      = 'error'
                    })
            } else {
                Write-Information "## Creating user for $($Name) - $($User.mailNickName)@$($User.domain)"
                # Create user body with required properties
                $Password = if ($User.password) { $User.password } else { New-passwordString }
                $UserBody = @{
                    accountEnabled    = $true
                    displayName       = $Name
                    mailNickName      = $User.mailNickName
                    userPrincipalName = '{0}@{1}' -f $User.mailNickName, $User.domain
                    passwordProfile   = @{
                        password                      = $Password
                        forceChangePasswordNextSignIn = $true
                    }
                }

                # Usage location and licensing
                if ($UsageLocation) {
                    $UserBody.usageLocation = $UsageLocation.value ?? $UsageLocation
                    Write-Information "- Usage location set to $($UsageLocation.label ?? $UsageLocation)"
                }


                # Convert businessPhones to array if not null or empty
                if (![string]::IsNullOrEmpty($User.businessPhones)) {
                    $UserBody.businessPhones = @($User.businessPhones)
                }

                # Add all other properties
                foreach ($key in $User.PSObject.Properties.Name) {
                    if ($key -notin @('displayName', 'mailNickName', 'domain', 'password', 'usageLocation', 'businessPhones')) {
                        if (![string]::IsNullOrEmpty($User.$key) -and $null -eq $UserBody.$key) {
                            $UserBody.$key = $User.$key
                        }
                    }
                }

                # Build bulk request
                $BulkRequests.Add(@{
                        'id'      = $UserBody.userPrincipalName
                        'url'     = 'users'
                        'method'  = 'POST'
                        'body'    = $UserBody
                        'headers' = @{
                            'Content-Type' = 'application/json'
                        }
                    })

                # Create password link
                $PasswordLink = New-PwPushLink -Payload $password
                if ($PasswordLink) {
                    $password = $PasswordLink
                }

                # Set success messages
                $Messages.Add(@{
                        id         = $UserBody.userPrincipalName
                        resultText = "Created user for $($Name) with username $($UserBody.userPrincipalName)"
                        copyField  = $Password
                    })
            }
        }

        if ($BulkRequests.Count -gt 0) {
            Write-Warning "We have $($BulkRequests.Count) users to import"
            #Write-Information ($BulkRequests | ConvertTo-Json -Depth 5)
            $BulkResults = New-GraphBulkRequest -tenantid $TenantFilter -Requests $BulkRequests
            Write-Warning "We have $($BulkResults.Count) results"
            #Write-Information ($BulkResults | ConvertTo-Json -Depth 10)
            foreach ($BulkResult in $BulkResults) {
                if ($BulkResult.status -ne 201) {
                    Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $($TenantFilter) -message "Failed to create user $($BulkResult.id). Error:$($BulkResult.body.error.message)" -Sev 'Error'
                    $Results.Add(@{
                            resultText = "Failed to create user $($BulkResult.id). Error: $($BulkResult.body.error.message)"
                            state      = 'error'
                        })
                } else {
                    $Message = $Messages.Where({ $_.id -eq $BulkResult.id })
                    if ($AssignedLicenses) {
                        $GuidPattern = '([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})'
                        $LicenseSkus = $AssignedLicenses.value ?? $AssignedLicenses | Where-Object { $_ -match $GuidPattern }
                        Set-CIPPUserLicense -UserId $BulkResult.id -AddLicenses $LicenseSkus -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers
                    }
                    $Results.Add(@{
                            resultText = $Message.resultText
                            state      = 'success'
                            copyField  = $Message.copyField
                            username   = $BulkResult.body.userPrincipalName
                        })
                }
            }
        } else {
            $Results.Add(@{
                    resultText = 'No users to import'
                    state      = 'error'
                })
        }
        $Body = @{
            Results = @($Results)
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUserBulk.ps1' 156
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUserDefaults.ps1' -1

function Invoke-AddUserDefaults {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    try {
        # Extract data from request body - matching CippAddEditUser.jsx field names
        $TenantFilter = $Request.Body.tenantFilter
        $TemplateName = $Request.Body.templateName
        $DefaultForTenant = $Request.Body.defaultForTenant

        Write-Host "Creating template '$TemplateName' for tenant: $TenantFilter"

        # User fields
        $GivenName = $Request.Body.givenName
        $Surname = $Request.Body.surname
        $DisplayName = $Request.Body.displayName

        # Handle autocomplete fields - extract value if it's an object
        $UsernameFormat = if ($Request.Body.usernameFormat -is [string]) {
            $Request.Body.usernameFormat
        } else {
            $Request.Body.usernameFormat.value
        }

        $PrimDomain = if ($Request.Body.primDomain -is [string]) {
            $Request.Body.primDomain
        } else {
            $Request.Body.primDomain.value
        }

        $AddedAliases = $Request.Body.addedAliases

        # Settings
        $Autopassword = $Request.Body.Autopassword
        $Password = $Request.Body.password
        $MustChangePass = $Request.Body.MustChangePass

        $UsageLocation = if ($Request.Body.usageLocation -is [string]) {
            $Request.Body.usageLocation
        } else {
            $Request.Body.usageLocation.value
        }

        $Licenses = $Request.Body.licenses
        $RemoveLicenses = $Request.Body.removeLicenses

        # Job and Location fields
        $JobTitle = $Request.Body.jobTitle
        $StreetAddress = $Request.Body.streetAddress
        $City = $Request.Body.city
        $State = $Request.Body.state
        $PostalCode = $Request.Body.postalCode
        $Country = $Request.Body.country
        $CompanyName = $Request.Body.companyName
        $Department = $Request.Body.department

        # Contact fields
        $MobilePhone = $Request.Body.mobilePhone
        $BusinessPhones = $Request.Body.'businessPhones[0]'
        $OtherMails = $Request.Body.otherMails

        # User relations
        $SetManager = $Request.Body.setManager
        $SetSponsor = $Request.Body.setSponsor
        $CopyFrom = $Request.Body.copyFrom

        # Create template object with all fields from CippAddEditUser
        $TemplateObject = @{
            tenantFilter     = $TenantFilter
            templateName     = $TemplateName
            defaultForTenant = [bool]$DefaultForTenant
            givenName        = $GivenName
            surname          = $Surname
            displayName      = $DisplayName
            usernameFormat   = $UsernameFormat
            primDomain       = $PrimDomain
            addedAliases     = $AddedAliases
            Autopassword     = $Autopassword
            password         = $Password
            MustChangePass   = $MustChangePass
            usageLocation    = $UsageLocation
            licenses         = $Licenses
            removeLicenses   = $RemoveLicenses
            jobTitle         = $JobTitle
            streetAddress    = $StreetAddress
            city             = $City
            state            = $State
            postalCode       = $PostalCode
            country          = $Country
            companyName      = $CompanyName
            department       = $Department
            mobilePhone      = $MobilePhone
            businessPhones   = $BusinessPhones
            otherMails       = $OtherMails
            setManager       = $SetManager
            setSponsor       = $SetSponsor
            copyFrom         = $CopyFrom
        }

        # Generate GUID for the template
        $GUID = (New-Guid).GUID

        # Convert to JSON
        $JSON = ConvertTo-Json -InputObject $TemplateObject -Depth 100 -Compress

        # Store in table
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'UserDefaultTemplate'
            GUID         = "$GUID"
        }

        $Result = "Created User Default Template '$($TemplateName)' with GUID $GUID"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create User Default Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-AddUserDefaults.ps1' 141
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-CIPPOffboardingJob.ps1' -1

function Invoke-CIPPOffboardingJob {
    [CmdletBinding()]
    param (
        [string]$TenantFilter,
        [string]$Username,
        [switch]$RunScheduled,
        $Options,
        $APIName = 'Offboard user',
        $Headers
    )
    if ($Options -is [string]) {
        $Options = $Options | ConvertFrom-Json
    }
    $User = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Username)?`$select=id,displayName,onPremisesSyncEnabled,onPremisesImmutableId" -tenantid $TenantFilter
    $UserID = $User.id
    $DisplayName = $User.displayName
    Write-Host "Running offboarding job for $Username with options: $($Options | ConvertTo-Json -Depth 10)"
    $Return = switch ($Options) {
        { $_.ConvertToShared -eq $true } {
            try {
                Set-CIPPMailboxType -Headers $Headers -tenantFilter $TenantFilter -userid $UserID -username $Username -MailboxType 'Shared' -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RevokeSessions -eq $true } {
            try {
                Revoke-CIPPSessions -tenantFilter $TenantFilter -username $Username -userid $UserID -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.ResetPass -eq $true } {
            try {
                Set-CIPPResetPassword -tenantFilter $TenantFilter -DisplayName $DisplayName -UserID $username -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RemoveGroups -eq $true } {
            Remove-CIPPGroups -userid $UserID -tenantFilter $TenantFilter -Headers $Headers -APIName $APIName -Username $Username
        }
        { $_.HideFromGAL -eq $true } {
            try {
                Set-CIPPHideFromGAL -tenantFilter $TenantFilter -UserID $username -HideFromGAL $true -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.DisableSignIn -eq $true } {
            try {
                Set-CIPPSignInState -TenantFilter $TenantFilter -userid $username -AccountEnabled $false -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.OnedriveAccess } {
            $Options.OnedriveAccess | ForEach-Object {
                try {
                    Set-CIPPSharePointPerms -tenantFilter $TenantFilter -userid $username -OnedriveAccessUser $_.value -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            }
        }
        { $_.AccessNoAutomap } {
            $Options.AccessNoAutomap | ForEach-Object {
                try {
                    Set-CIPPMailboxAccess -tenantFilter $TenantFilter -userid $username -AccessUser $_.value -Automap $false -AccessRights @('FullAccess') -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            }
        }
        { $_.AccessAutomap } {
            $Options.AccessAutomap | ForEach-Object {
                try {
                    Set-CIPPMailboxAccess -tenantFilter $TenantFilter -userid $username -AccessUser $_.value -Automap $true -AccessRights @('FullAccess') -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            }
        }
        { $_.OOO } {
            try {
                Set-CIPPOutOfOffice -tenantFilter $TenantFilter -UserID $username -InternalMessage $Options.OOO -ExternalMessage $Options.OOO -Headers $Headers -APIName $APIName -state 'Enabled'
            } catch {
                $_.Exception.Message
            }
        }
        { $_.forward } {
            if (!$Options.KeepCopy) {
                try {
                    Set-CIPPForwarding -userid $userid -username $username -tenantFilter $TenantFilter -Forward $Options.forward.value -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            } else {
                $KeepCopy = [boolean]$Options.KeepCopy
                try {
                    Set-CIPPForwarding -userid $userid -username $username -tenantFilter $TenantFilter -Forward $Options.forward.value -KeepCopy $KeepCopy -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            }
        }
        { $_.disableForwarding } {
            try {
                Set-CIPPForwarding -userid $userid -username $username -tenantFilter $TenantFilter -Disable $true -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RemoveTeamsPhoneDID } {
            try {
                Remove-CIPPUserTeamsPhoneDIDs -userid $userid -username $username -tenantFilter $TenantFilter -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RemoveLicenses -eq $true } {
            Remove-CIPPLicense -userid $userid -username $Username -tenantFilter $TenantFilter -Headers $Headers -APIName $APIName -Schedule
        }
        { $_.DeleteUser -eq $true } {
            try {
                Remove-CIPPUser -UserID $userid -Username $Username -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RemoveRules -eq $true } {
            Write-Host "Removing rules for $username"
            try {
                Remove-CIPPMailboxRule -userid $userid -username $Username -tenantFilter $TenantFilter -Headers $Headers -APIName $APIName -RemoveAllRules
            } catch {
                $_.Exception.Message
            }
        }
        { $_.RemoveMobile -eq $true } {
            try {
                Remove-CIPPMobileDevice -userid $userid -username $Username -tenantFilter $TenantFilter -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.removeCalendarInvites -eq $true } {
            try {
                Remove-CIPPCalendarInvites -UserID $userid -Username $Username -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
            } catch {
                $_.Exception.Message
            }
        }
        { $_.removePermissions } {
            if ($RunScheduled) {
                Remove-CIPPMailboxPermissions -PermissionsLevel @('FullAccess', 'SendAs', 'SendOnBehalf') -userid 'AllUsers' -AccessUser $UserName -TenantFilter $TenantFilter -APIName $APINAME -Headers $Headers

            } else {
                $Queue = New-CippQueueEntry -Name "Offboarding - Mailbox Permissions: $Username" -TotalTasks 1
                $InputObject = [PSCustomObject]@{
                    Batch            = @(
                        [PSCustomObject]@{
                            'FunctionName' = 'ExecOffboardingMailboxPermissions'
                            'TenantFilter' = $TenantFilter
                            'User'         = $Username
                            'Headers'      = $Headers
                            'APINAME'      = $APINAME
                            'QueueId'      = $Queue.RowKey
                        }
                    )
                    OrchestratorName = "OffboardingMailboxPermissions_$Username"
                    SkipLog          = $true
                }
                $null = Start-NewOrchestration -FunctionName CIPPOrchestrator -InputObject ($InputObject | ConvertTo-Json -Depth 10)
                "Removal of permissions queued. This task will run in the background and send it's results to the logbook."
            }
        }
        { $_.RemoveMFADevices -eq $true } {
            try {
                Remove-CIPPUserMFA -UserPrincipalName $Username -TenantFilter $TenantFilter -Headers $Headers
            } catch {
                $_.Exception.Message
            }
        }
        { $_.ClearImmutableId -eq $true } {
            if ($User.onPremisesSyncEnabled -ne $true -and ![string]::IsNullOrEmpty($User.onPremisesImmutableId)) {
                Write-LogMessage -Message "User $Username has an ImmutableID set but is not synced from on-premises. Proceeding to clear the ImmutableID." -TenantFilter $TenantFilter -Severity 'Warning' -APIName $APIName -Headers $Headers
                try {
                    Clear-CIPPImmutableID -UserID $userid -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
                } catch {
                    $_.Exception.Message
                }
            } elseif ($User.onPremisesSyncEnabled -eq $true -and ![string]::IsNullOrEmpty($User.onPremisesImmutableId)) {
                Write-LogMessage -Message "User $Username is synced from on-premises. Scheduling an Immutable ID clear for when the user account has been soft deleted." -TenantFilter $TenantFilter -Severity 'Error' -APIName $APIName -Headers $Headers
                'Scheduling Immutable ID clear task for when the user account is no longer synced in the on-premises directory.'
                $ScheduledTask = @{
                    TenantFilter  = $TenantFilter
                    Name          = "Clear Immutable ID: $Username"
                    Command       = @{
                        value = 'Clear-CIPPImmutableID'
                    }
                    Parameters    = [pscustomobject]@{
                        userid  = $userid
                        APIName = $APIName
                        Headers = $Headers
                    }
                    Trigger       = @{
                        Type               = 'DeltaQuery'
                        DeltaResource      = 'users'
                        ResourceFilter     = @($UserID)
                        EventType          = 'deleted'
                        UseConditions      = $false
                        ExecutePerResource = $true
                        ExecutionMode      = 'once'
                    }
                    ScheduledTime = [int64](([datetime]::UtcNow).AddMinutes(5) - (Get-Date '1/1/1970')).TotalSeconds
                    Recurrence    = '15m'
                    PostExecution = @{
                        Webhook = $false
                        Email   = $false
                        PSA     = $false
                    }
                }
                Add-CIPPScheduledTask -Task $ScheduledTask -hidden $false
            }
        }
    }
    return $Return

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-CIPPOffboardingJob.ps1' 230
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-EditUser.ps1' -1

function Invoke-EditUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $UserObj = $Request.Body
    if ([string]::IsNullOrWhiteSpace($UserObj.id)) {
        $body = @{'Results' = @('Failed to edit user. No user ID provided') }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = $Body
            })
        return
    }
    $Results = [System.Collections.Generic.List[object]]::new()
    $licenses = ($UserObj.licenses).value
    $Aliases = if ($UserObj.AddedAliases) { ($UserObj.AddedAliases) -split '\s' }
    $AddToGroups = $Request.Body.AddToGroups
    $RemoveFromGroups = $Request.Body.RemoveFromGroups


    #Edit the user
    try {
        Write-Host "$([boolean]$UserObj.MustChangePass)"
        $UserPrincipalName = "$($UserObj.username)@$($UserObj.Domain ? $UserObj.Domain : $UserObj.primDomain.value)"
        $BodyToship = [pscustomobject] @{
            'givenName'         = $UserObj.givenName
            'surname'           = $UserObj.surname
            'displayName'       = $UserObj.displayName
            'department'        = $UserObj.department
            'mailNickname'      = $UserObj.username ? $UserObj.username : $UserObj.mailNickname
            'userPrincipalName' = $UserPrincipalName
            'usageLocation'     = $UserObj.usageLocation.value ? $UserObj.usageLocation.value : $UserObj.usageLocation
            'jobTitle'          = $UserObj.jobTitle
            'mobilePhone'       = $UserObj.mobilePhone
            'streetAddress'     = $UserObj.streetAddress
            'city'              = $UserObj.city
            'state'             = $UserObj.state
            'postalCode'        = $UserObj.postalCode
            'country'           = $UserObj.country
            'companyName'       = $UserObj.companyName
            'businessPhones'    = $UserObj.businessPhones ? @($UserObj.businessPhones) : @()
            'otherMails'        = $UserObj.otherMails ? @($UserObj.otherMails) : @()
            'passwordProfile'   = @{
                'forceChangePasswordNextSignIn' = [bool]$UserObj.MustChangePass
            }
        } | ForEach-Object {
            $NonEmptyProperties = $_.PSObject.Properties | Select-Object -ExpandProperty Name
            $_ | Select-Object -Property $NonEmptyProperties
        }
        if ($UserObj.defaultAttributes) {
            $UserObj.defaultAttributes | Get-Member -MemberType NoteProperty | ForEach-Object {
                if (-not [string]::IsNullOrWhiteSpace($UserObj.defaultAttributes.$($_.Name).value)) {
                    Write-Host "Editing user and adding $($_.Name) with value $($UserObj.defaultAttributes.$($_.Name).value)"
                    $BodyToShip | Add-Member -NotePropertyName $_.Name -NotePropertyValue $UserObj.defaultAttributes.$($_.Name).value -Force
                }
            }
        }
        if ($UserObj.customData) {
            $UserObj.customData | Get-Member -MemberType NoteProperty | ForEach-Object {
                if (-not [string]::IsNullOrWhiteSpace($UserObj.customData.$($_.Name))) {
                    Write-Host "Editing user and adding custom data $($_.Name) with value $($UserObj.customData.$($_.Name))"
                    $BodyToShip | Add-Member -NotePropertyName $_.Name -NotePropertyValue $UserObj.customData.$($_.Name) -Force
                }
            }
        }
        $bodyToShip = ConvertTo-Json -Depth 10 -InputObject $BodyToship -Compress
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $UserObj.tenantFilter -type PATCH -body $BodyToship -verbose
        $Results.Add( 'Success. The user has been edited.' )
        Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message "Edited user $($UserObj.DisplayName) with id $($UserObj.id)" -Sev Info
        if ($UserObj.password) {
            $passwordProfile = [pscustomobject]@{'passwordProfile' = @{ 'password' = $UserObj.password; 'forceChangePasswordNextSignIn' = [boolean]$UserObj.MustChangePass } } | ConvertTo-Json
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $UserObj.tenantFilter -type PATCH -body $PasswordProfile -Verbose
            $Results.Add("Success. The password has been set to $($UserObj.password)")
            Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message "Reset $($UserObj.DisplayName)'s Password" -Sev Info
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message "User edit API failed. $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Results.Add( "Failed to edit user. $($ErrorMessage.NormalizedError)")
    }


    #Reassign the licenses
    try {

        if ($licenses -or $UserObj.removeLicenses) {
            if ($UserObj.sherwebLicense.value) {
                $null = Set-SherwebSubscription -Headers $Headers -TenantFilter $UserObj.tenantFilter -SKU $UserObj.sherwebLicense.value -Add 1
                $Results.Add('Added Sherweb License, scheduling assignment')
                $taskObject = [PSCustomObject]@{
                    TenantFilter  = $UserObj.tenantFilter
                    Name          = "Assign License: $UserPrincipalName"
                    Command       = @{
                        value = 'Set-CIPPUserLicense'
                    }
                    Parameters    = [pscustomobject]@{
                        UserId      = $UserObj.id
                        APIName     = 'Sherweb License Assignment'
                        AddLicenses = $licenses
                    }
                    ScheduledTime = 0 #right now, which is in the next 15 minutes and should cover most cases.
                    PostExecution = @{
                        Webhook = [bool]$Request.Body.PostExecution.webhook
                        Email   = [bool]$Request.Body.PostExecution.email
                        PSA     = [bool]$Request.Body.PostExecution.psa
                    }
                }
                Add-CIPPScheduledTask -Task $taskObject -hidden $false -Headers $Headers
            } else {
                $CurrentLicenses = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $UserObj.tenantFilter
                #if the list of skuIds in $CurrentLicenses.assignedLicenses is EXACTLY the same as $licenses, we don't need to do anything, but the order in both can be different.
                if (($CurrentLicenses.assignedLicenses.skuId -join ',') -eq ($licenses -join ',') -and $UserObj.removeLicenses -eq $false) {
                    Write-Host "$($CurrentLicenses.assignedLicenses.skuId -join ',') $(($licenses -join ','))"
                    $Results.Add( 'Success. User license is already correct.' )
                } else {
                    if ($UserObj.removeLicenses) {
                        $licResults = Set-CIPPUserLicense -UserId $UserObj.id -TenantFilter $UserObj.tenantFilter -RemoveLicenses $CurrentLicenses.assignedLicenses.skuId -Headers $Headers -APIName $APIName
                        $Results.Add($licResults)
                    } else {
                        #Remove all objects from $CurrentLicenses.assignedLicenses.skuId that are in $licenses
                        $RemoveLicenses = $CurrentLicenses.assignedLicenses.skuId | Where-Object { $_ -notin $licenses }
                        $licResults = Set-CIPPUserLicense -UserId $UserObj.id -TenantFilter $UserObj.tenantFilter -RemoveLicenses $RemoveLicenses -AddLicenses $licenses -Headers $Headers -APIName $APIName
                        $Results.Add($licResults)
                    }

                }
            }
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message "License assign API failed. $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Results.Add( "We've failed to assign the license. $($ErrorMessage.NormalizedError)")
        Write-Warning "License assign API failed. $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }

    #Add Aliases, removal currently not supported.
    try {
        if ($Aliases) {
            Write-Host ($Aliases | ConvertTo-Json)
            foreach ($Alias in $Aliases) {
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $UserObj.tenantFilter -type 'patch' -body "{`"mail`": `"$Alias`"}" -Verbose
            }
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $UserObj.tenantFilter -type 'patch' -body "{`"mail`": `"$UserPrincipalName`"}" -Verbose
            Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message "Added Aliases to $($UserObj.DisplayName)" -Sev Info
            $Results.Add( 'Success. Added aliases to user.')
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to add aliases to user $($UserObj.DisplayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant ($UserObj.tenantFilter) -headers $Headers -message $Message -Sev Error -LogData $ErrorMessage
        $Results.Add($Message)
    }

    if ($Request.Body.CopyFrom.value) {
        $CopyFrom = Set-CIPPCopyGroupMembers -Headers $Headers -CopyFromId $Request.Body.CopyFrom.value -UserID $UserPrincipalName -TenantFilter $UserObj.tenantFilter
        $Results.AddRange(@($CopyFrom))
    }

    if ($AddToGroups) {
        $AddToGroups | ForEach-Object {

            $GroupType = $_.addedFields.calculatedGroupType
            $GroupID = $_.value
            $GroupName = $_.label
            Write-Host "About to add $($UserObj.userPrincipalName) to $GroupName. Group ID is: $GroupID and type is: $GroupType"

            try {
                if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
                    Write-Host 'Adding to group via Add-DistributionGroupMember'
                    $Params = @{ Identity = $GroupID; Member = $UserObj.id; BypassSecurityGroupManagerCheck = $true }
                    $null = New-ExoRequest -tenantid $UserObj.tenantFilter -cmdlet 'Add-DistributionGroupMember' -cmdParams $params -UseSystemMailbox $true
                } else {
                    Write-Host 'Adding to group via Graph'
                    $UserBody = [PSCustomObject]@{
                        '@odata.id' = "https://graph.microsoft.com/beta/directoryObjects/$($UserObj.id)"
                    }
                    $UserBodyJSON = ConvertTo-Json -Compress -Depth 10 -InputObject $UserBody
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/groups/$GroupID/members/`$ref" -tenantid $UserObj.tenantFilter -type POST -body $UserBodyJSON -Verbose
                }
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message "Added $($UserObj.DisplayName) to $GroupName group" -Sev Info
                $Results.Add("Success. $($UserObj.DisplayName) has been added to $GroupName")
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                $Message = "Failed to add member $($UserObj.DisplayName) to $GroupName. Error: $($ErrorMessage.NormalizedError)"
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message $Message -Sev Error -LogData $ErrorMessage
                $Results.Add($Message)
            }
        }
    }

    if ($RemoveFromGroups) {
        $RemoveFromGroups | ForEach-Object {

            $GroupType = $_.addedFields.calculatedGroupType
            $GroupID = $_.value
            $GroupName = $_.label
            Write-Host "About to remove $($UserObj.userPrincipalName) from $GroupName. Group ID is: $GroupID and type is: $GroupType"

            try {
                if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
                    Write-Host 'Removing From group via Remove-DistributionGroupMember'
                    $Params = @{ Identity = $GroupID; Member = $UserObj.id; BypassSecurityGroupManagerCheck = $true }
                    $null = New-ExoRequest -tenantid $UserObj.tenantFilter -cmdlet 'Remove-DistributionGroupMember' -cmdParams $params -UseSystemMailbox $true
                } else {
                    Write-Host 'Removing From group via Graph'
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/groups/$GroupID/members/$($UserObj.id)/`$ref" -tenantid $UserObj.tenantFilter -type DELETE
                }
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message "Removed $($UserObj.DisplayName) from $GroupName group" -Sev Info
                $Results.Add("Success. $($UserObj.DisplayName) has been removed from $GroupName")
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                $Message = "Failed to remove member $($UserObj.DisplayName) from $GroupName. Error: $($ErrorMessage.NormalizedError)"
                Write-LogMessage -headers $Headers -API $APIName -tenant $UserObj.tenantFilter -message $Message -Sev Error -LogData $ErrorMessage
                $Results.Add($Message)
            }
        }
    }

    if ($Request.body.setManager.value) {
        $ManagerResult = Set-CIPPManager -User $UserPrincipalName -Manager $Request.body.setManager.value -TenantFilter $UserObj.tenantFilter -Headers $Headers
        $Results.Add($ManagerResult)
    }

    if ($Request.body.setSponsor.value) {
        $SponsorResult = Set-CIPPSponsor -User $UserPrincipalName -Sponsor $Request.body.setSponsor.value -TenantFilter $UserObj.tenantFilter -Headers $Headers
        $Results.Add($SponsorResult)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-EditUser.ps1' 248
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-EditUserAliases.ps1' -1

Function Invoke-EditUserAliases {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $UserObj = $Request.Body
    $TenantFilter = $UserObj.tenantFilter

    if ([string]::IsNullOrWhiteSpace($UserObj.id)) {
        $body = @{'Results' = @('Failed to manage aliases. No user ID provided') }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = $Body
            })
        return
    }

    $Results = [System.Collections.Generic.List[object]]::new()
    $Aliases = if ($UserObj.AddedAliases) { ($UserObj.AddedAliases -split ',').ForEach({ $_.Trim() }) }
    $RemoveAliases = if ($UserObj.RemovedAliases) { ($UserObj.RemovedAliases -split ',').ForEach({ $_.Trim() }) }

    try {
        if ($Aliases -or $RemoveAliases -or $UserObj.MakePrimary) {
            # Get current mailbox
            $CurrentMailbox = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{ Identity = $UserObj.id } -UseSystemMailbox $true

            if (-not $CurrentMailbox) {
                throw 'Could not find mailbox for user'
            }

            $CurrentProxyAddresses = @($CurrentMailbox.EmailAddresses)
            Write-Host "Current proxy addresses: $($CurrentProxyAddresses -join ', ')"
            $NewProxyAddresses = @($CurrentProxyAddresses)

            # Handle setting primary address
            if ($UserObj.MakePrimary) {
                $PrimaryAddress = $UserObj.MakePrimary
                Write-Host "Attempting to set primary address: $PrimaryAddress"

                # Normalize the primary address format
                if ($PrimaryAddress -notlike 'SMTP:*') {
                    $PrimaryAddress = "SMTP:$($PrimaryAddress -replace '^smtp:', '')"
                }
                Write-Host "Normalized primary address: $PrimaryAddress"

                # Check if the address exists in the current addresses (case-insensitive)
                $ExistingAddress = $CurrentProxyAddresses | Where-Object {
                    $current = $_.ToLower()
                    $target = $PrimaryAddress.ToLower()
                    Write-Host "Comparing: '$current' with '$target'"
                    $current -eq $target
                }

                if (-not $ExistingAddress) {
                    Write-Host "Available addresses: $($CurrentProxyAddresses -join ', ')"
                    throw "Cannot set primary address. Address $($PrimaryAddress -replace '^SMTP:', '') not found in user's addresses."
                }

                # Convert all current SMTP addresses to lowercase (secondary)
                $NewProxyAddresses = $NewProxyAddresses | ForEach-Object {
                    if ($_ -like 'SMTP:*') {
                        $_.ToLower()
                    } else {
                        $_
                    }
                }

                # Remove any existing version of the address (case-insensitive)
                $NewProxyAddresses = $NewProxyAddresses | Where-Object {
                    $_.ToLower() -ne $PrimaryAddress.ToLower()
                }
                # Add the new primary address at the beginning
                $NewProxyAddresses = @($PrimaryAddress) + $NewProxyAddresses

                Write-LogMessage -API $APIName -tenant $TenantFilter -headers $Headers -message "Set primary address for $($CurrentMailbox.DisplayName)" -Sev Info
                $Results.Add('Success. Set new primary address.')
            }

            # Remove specified aliases
            if ($RemoveAliases) {
                foreach ($Alias in $RemoveAliases) {
                    # Normalize the alias format
                    if ($Alias -notlike 'smtp:*') {
                        $Alias = "smtp:$Alias"
                    }
                    # Remove the alias case-insensitively
                    $NewProxyAddresses = $NewProxyAddresses | Where-Object {
                        $_.ToLower() -ne $Alias.ToLower()
                    }
                }
                Write-LogMessage -API $ApiName -tenant $TenantFilter -headers $Headers -message "Removed Aliases from $($CurrentMailbox.DisplayName)" -Sev Info
                $Results.Add('Success. Removed specified aliases from user.')
            }

            # Add new aliases
            if ($Aliases) {
                $AliasesToAdd = @()
                foreach ($Alias in $Aliases) {
                    # Normalize the alias format
                    if ($Alias -notlike 'smtp:*') {
                        $Alias = "smtp:$Alias"
                    }
                    # Check if the alias exists case-insensitively
                    if (-not ($NewProxyAddresses | Where-Object { $_.ToLower() -eq $Alias.ToLower() })) {
                        $AliasesToAdd = $AliasesToAdd + $Alias
                    }
                }
                if ($AliasesToAdd.Count -gt 0) {
                    $NewProxyAddresses = $NewProxyAddresses + $AliasesToAdd
                    Write-LogMessage -API $ApiName -tenant ($TenantFilter) -headers $Headers -message "Added Aliases to $($CurrentMailbox.DisplayName)" -Sev Info
                    $Results.Add('Success. Added new aliases to user.')
                }
            }

            # Update the mailbox with new proxy addresses
            $Params = @{
                Identity       = $UserObj.id
                EmailAddresses = $NewProxyAddresses
            }
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams $Params -UseSystemMailbox $true
        } else {
            $Results.Add('No alias changes specified.')
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $ApiName -tenant ($TenantFilter) -headers $Headers -message "Alias management failed. $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $Results.Add("Failed to manage aliases: $($ErrorMessage.NormalizedError)")
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-EditUserAliases.ps1' 144
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBECCheck.ps1' -1

Function Invoke-ExecBECCheck {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CippTable -tablename 'cachebec'

    $UserId = $Request.Query.userid ?? $Request.Query.GUID
    $Filter = "PartitionKey eq 'bec' and RowKey eq '$UserId'"
    $JSONOutput = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    Write-Host ($Request.Query | ConvertTo-Json)

    $body = if (([string]::IsNullOrEmpty($JSONOutput.Results) -and $JSONOutput.Status -ne 'Waiting' ) -or $Request.Query.overwrite -eq $true) {
        $Batch = @{
            'FunctionName' = 'BECRun'
            'UserID'       = $Request.Query.userid
            'TenantFilter' = $Request.Query.tenantFilter
            'userName'     = $Request.Query.userName
        }

        $Table = Get-CippTable -tablename 'cachebec'

        $Entity = @{
            UserId       = $Request.Query.userid
            Results      = ''
            RowKey       = $Request.Query.userid
            Status       = 'Waiting'
            PartitionKey = 'bec'
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

        $InputObject = [PSCustomObject]@{
            OrchestratorName = 'BECRunOrchestrator'
            Batch            = @($Batch)
            SkipLog          = $true
        }
        #Write-Host ($InputObject | ConvertTo-Json)
        $null = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ( ConvertTo-Json -InputObject $InputObject -Depth 5 -Compress )

        @{ GUID = $Request.Query.userid }
    } else {
        if (!$Request.Query.GUID) {
            @{ GUID = $Request.Query.userid }
        } else {
            if (!$JSONOutput -or $JSONOutput.Status -eq 'Waiting') {
                @{ Waiting = $true }
            } else {
                $JSONOutput.Results
            }
        }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBECCheck.ps1' 65
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBECRemediate.ps1' -1

function Invoke-ExecBECRemediate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $TenantFilter = $Request.Body.tenantFilter
    $SuspectUser = $Request.Body.userid
    $Username = $Request.Body.username
    Write-Host $TenantFilter
    Write-Host $SuspectUser

    $Results = try {
        $AllResults = [System.Collections.Generic.List[object]]::new()

        # Step 1: Reset Password
        $Step = 'Reset Password'
        try {
            $PasswordResult = Set-CIPPResetPassword -UserID $Username -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers
            $AllResults.Add($PasswordResult)
        } catch {
            $AllResults.Add([pscustomobject]@{
                resultText = "Failed to reset password: $($_.Exception.Message)"
                state      = 'error'
            })
        }

        # Step 2: Disable Account
        $Step = 'Disable Account'
        try {
            $DisableResult = Set-CIPPSignInState -userid $Username -AccountEnabled $false -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers
            $AllResults.Add([pscustomobject]@{
                resultText = $DisableResult
                state      = if ($DisableResult -like "*WARNING*") { 'warning' } else { 'success' }
            })
        } catch {
            $AllResults.Add([pscustomobject]@{
                resultText = "Failed to disable account: $($_.Exception.Message)"
                state      = 'error'
            })
        }

        # Step 3: Revoke Sessions
        $Step = 'Revoke Sessions'
        try {
            $SessionResult = Revoke-CIPPSessions -userid $SuspectUser -username $Username -Headers $Headers -APIName $APIName -tenantFilter $TenantFilter
            $AllResults.Add([pscustomobject]@{
                resultText = $SessionResult
                state      = if ($SessionResult -like "*Failed*") { 'error' } else { 'success' }
            })
        } catch {
            $AllResults.Add([pscustomobject]@{
                resultText = "Failed to revoke sessions: $($_.Exception.Message)"
                state      = 'error'
            })
        }

        # Step 4: Remove MFA methods
        $Step = 'Remove MFA methods'
        try {
            $MFAResult = Remove-CIPPUserMFA -UserPrincipalName $Username -TenantFilter $TenantFilter -Headers $Headers
            $AllResults.Add([pscustomobject]@{
                resultText = $MFAResult
                state      = if ($MFAResult -like "*No MFA methods*") { 'info' } elseif ($MFAResult -like "*Successfully*") { 'success' } else { 'error' }
            })
        } catch {
            $AllResults.Add([pscustomobject]@{
                resultText = "Failed to remove MFA methods: $($_.Exception.Message)"
                state      = 'error'
            })
        }

        # Step 5: Disable Inbox Rules
        $Step = 'Disable Inbox Rules'
        try {
            Write-LogMessage -headers $Headers -API $APIName -message "Starting inbox rules processing for user: $Username" -Sev 'Info' -tenant $TenantFilter
            $Rules = New-ExoRequest -anchor $Username -tenantid $TenantFilter -cmdlet 'Get-InboxRule' -cmdParams @{Mailbox = $Username; IncludeHidden = $true }
            Write-LogMessage -headers $Headers -API $APIName -message "Retrieved $(($Rules | Measure-Object).Count) total rules for $Username" -Sev 'Info' -tenant $TenantFilter
            $RuleDisabled = 0
            $RuleFailed = 0
            $DelegateRulesSkipped = 0
            $RuleMessages = [System.Collections.Generic.List[string]]::new()

            if (($Rules | Measure-Object).Count -eq 0) {
                # No rules exist at all
                $AllResults.Add([pscustomobject]@{
                    resultText = "No Inbox Rules found for $Username."
                    state      = 'info'
                })
            } else {
                # Rules exist, filter and process them
                $ProcessableRules = $Rules | Where-Object {
                    $_.Name -ne 'Junk E-Mail Rule' -and
                    $_.Name -notlike 'Microsoft.Exchange.OOF.*'
                }

                if (($ProcessableRules | Measure-Object).Count -eq 0) {
                    # Rules exist but none are processable after filtering
                    $SystemRulesCount = ($Rules | Measure-Object).Count - $DelegateRulesSkipped
                    if ($SystemRulesCount -gt 0) {
                        $AllResults.Add([pscustomobject]@{
                            resultText = "Found $(($Rules | Measure-Object).Count) inbox rules for $Username, but none require disabling (only system rules found)."
                            state      = 'info'
                        })
                    }
                } else {
                    # Process the filterable rules
                    $ProcessableRules | ForEach-Object {
                        $CurrentRule = $_
                        Write-LogMessage -headers $Headers -API $APIName -message "Processing rule: Name='$($CurrentRule.Name)', Identity='$($CurrentRule.Identity)'" -Sev 'Info' -tenant $TenantFilter

                        try {
                            Set-CIPPMailboxRule -Username $Username -TenantFilter $TenantFilter -RuleId $CurrentRule.Identity -RuleName $CurrentRule.Name -Disable -APIName $APIName -Headers $Headers

                            Write-LogMessage -headers $Headers -API $APIName -message "Successfully disabled rule: $($CurrentRule.Name)" -Sev 'Info' -tenant $TenantFilter
                            $RuleDisabled++
                        } catch {
                            # Check if this is a system delegate rule, if so we can ignore the error
                            if ($CurrentRule.Name -match '^Delegate Rule -\d+$') {
                                Write-LogMessage -headers $Headers -API $APIName -message "Skipping delegate rule '$($CurrentRule.Name)' - unable to disable (expected behavior)" -Sev 'Info' -tenant $TenantFilter
                                $DelegateRulesSkipped++
                            } else {
                                # Handle as normal error
                                $ErrorMsg = "Could not disable rule '$($CurrentRule.Name)': $($_.Exception.Message)"
                                Write-LogMessage -headers $Headers -API $APIName -message $ErrorMsg -Sev 'Error' -tenant $TenantFilter
                                $RuleMessages.Add($ErrorMsg)
                                $RuleFailed++
                            }
                        }
                    }

                    # Report results
                    if ($RuleDisabled -gt 0) {
                        $AllResults.Add([pscustomobject]@{
                            resultText = "Successfully disabled $RuleDisabled inbox rules for $Username"
                            state      = 'success'
                        })
                    } elseif ($DelegateRulesSkipped -gt 0 -and $RuleDisabled -eq 0 -and $RuleFailed -eq 0) {
                        # Only system rules were found, report as no processable rules
                        $AllResults.Add([pscustomobject]@{
                            resultText = "No processable inbox rules found for $Username"
                            state      = 'info'
                        })
                    }

                    if ($RuleFailed -gt 0) {
                        $AllResults.Add([pscustomobject]@{
                            resultText = "Failed to process $RuleFailed inbox rules for $Username"
                            state      = 'warning'
                        })

                        # Add individual rule failure messages as objects
                        foreach ($RuleMessage in $RuleMessages) {
                            $AllResults.Add([pscustomobject]@{
                                resultText = $RuleMessage
                                state      = 'error'
                            })
                        }
                    }
                }
            }

            $TotalProcessed = $RuleDisabled + $RuleFailed + $DelegateRulesSkipped
            Write-LogMessage -headers $Headers -API $APIName -message "Completed inbox rules processing for $Username. Total rules: $(($Rules | Measure-Object).Count), Processed: $TotalProcessed, Disabled: $RuleDisabled, Failed: $RuleFailed, Delegate rules skipped: $DelegateRulesSkipped" -Sev 'Info' -tenant $TenantFilter

        } catch {
            $ErrorMsg = "Failed to process inbox rules: $($_.Exception.Message)"
            Write-LogMessage -headers $Headers -API $APIName -message $ErrorMsg -Sev 'Error' -tenant $TenantFilter
            $AllResults.Add([pscustomobject]@{
                resultText = $ErrorMsg
                state      = 'error'
            })
        }

        $StatusCode = [HttpStatusCode]::OK
        Write-LogMessage -API 'BECRemediate' -tenant $TenantFilter -message "Executed Remediation for $Username" -sev 'Info' -LogData @($AllResults)

        # Return the results array
        $AllResults.ToArray()

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $ErrorList = [System.Collections.Generic.List[object]]::new()
        $ErrorList.Add([pscustomobject]@{
            resultText = "Failed to execute remediation at step '$Step'. $($ErrorMessage.NormalizedError)"
            state      = 'error'
        })
        Write-LogMessage -API 'BECRemediate' -tenant $TenantFilter -message "Executed Remediation for $Username failed at the $Step step" -sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError

        # Return the error array
        $ErrorList.ToArray()
    }

    # Create the final response structure
    $ResponseBody = [pscustomobject]@{'Results' = @($Results) }

    # Associate values to output bindings
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $ResponseBody
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBECRemediate.ps1' 213
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBulkLicense.ps1' -1

function Invoke-ExecBulkLicense {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param (
        $Request,
        $TriggerMetadata
    )

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $Results = [System.Collections.Generic.List[string]]::new()
    $StatusCode = [HttpStatusCode]::OK

    try {
        $UserRequests = $Request.Body
        $TenantGroups = $UserRequests | Group-Object -Property tenantFilter

        foreach ($TenantGroup in $TenantGroups) {
            $TenantFilter = $TenantGroup.Name
            $TenantRequests = $TenantGroup.Group
            $AllUsers = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?&`$select=id,userPrincipalName,assignedLicenses" -tenantid $TenantFilter
            $UserLookup = @{}
            foreach ($User in $AllUsers) {
                $UserLookup[$User.id] = $User
            }

            # Process each user request
            foreach ($UserRequest in $TenantRequests) {
                try {
                    $UserId = $UserRequest.userIds
                    $User = $UserLookup[$UserId]
                    $UserPrincipalName = $User.userPrincipalName
                    $LicenseOperation = $UserRequest.LicenseOperation
                    $RemoveAllLicenses = [bool]$UserRequest.RemoveAllLicenses
                    $Licenses = $UserRequest.Licenses | ForEach-Object { $_.value }
                    # Handle license operations
                    if ($LicenseOperation -eq 'Add' -or $LicenseOperation -eq 'Replace') {
                        $AddLicenses = $Licenses
                    }

                    if ($LicenseOperation -eq 'Remove' -and $RemoveAllLicenses) {
                        $RemoveLicenses = $User.assignedLicenses.skuId
                    } elseif ($LicenseOperation -eq 'Remove') {
                        $RemoveLicenses = $Licenses
                    } elseif ($LicenseOperation -eq 'Replace') {
                        $RemoveReplace = $User.assignedLicenses.skuId
                        if ($RemoveReplace) { Set-CIPPUserLicense -UserId $UserId -TenantFilter $TenantFilter -RemoveLicenses $RemoveReplace -APIName $APIName -Headers $Headers }
                    } elseif ($RemoveAllLicenses) {
                        $RemoveLicenses = $User.assignedLicenses.skuId
                    }
                    #todo: Actually build bulk support into set-cippuserlicense.
                    $TaskResults = Set-CIPPUserLicense -UserId $UserId -TenantFilter $TenantFilter -AddLicenses $AddLicenses -RemoveLicenses $RemoveLicenses -APIName $APIName -Headers $Headers

                    $Results.Add($TaskResults)
                    Write-LogMessage -API $APIName -tenant $TenantFilter -message "Successfully processed licenses for user $UserPrincipalName" -Sev 'Info'
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    $Results.Add("Failed to process licenses for user $($UserRequest.userIds). Error: $($ErrorMessage.NormalizedError)")
                    Write-LogMessage -API $APIName -tenant $TenantFilter -message "Failed to process licenses for user $($UserRequest.userIds). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }

        $Body = @{
            Results = @($Results)
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $StatusCode = [HttpStatusCode]::BadRequest
        $Body = @{
            Results = @("Failed to process bulk license operation: $($ErrorMessage.NormalizedError)")
        }
        Write-LogMessage -API $APIName -message "Failed to process bulk license operation: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
    }

    # Return response
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecBulkLicense.ps1' 87
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecClrImmId.ps1' -1

Function Invoke-ExecClrImmId {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -headers $Headers -API $APIName -message 'Accessed this API' -Sev Debug

    # Interact with body parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.ID ?? $Request.Body.ID

    try {
        $Result = Clear-CIPPImmutableID -UserID $UserID -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecClrImmId.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecCreateTAP.ps1' -1

Function Invoke-ExecCreateTAP {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.ID ?? $Request.Body.ID
    $LifetimeInMinutes = $Request.Query.lifetimeInMinutes ?? $Request.Body.lifetimeInMinutes
    $IsUsableOnce = $Request.Query.isUsableOnce ?? $Request.Body.isUsableOnce
    $StartDateTime = $Request.Query.startDateTime ?? $Request.Body.startDateTime

    try {
        # Create parameter hashtable for splatting
        $TAPParams = @{
            UserID            = $UserID
            TenantFilter      = $TenantFilter
            APIName           = $APIName
            Headers           = $Headers
            LifetimeInMinutes = $LifetimeInMinutes
            IsUsableOnce      = $IsUsableOnce
            StartDateTime     = $StartDateTime
        }

        $TAPResult = New-CIPPTAP @TAPParams

        # Create results array with both TAP and UserID as separate items
        $Results = @(
            $TAPResult,
            @{
                resultText = "User ID: $UserID"
                copyField  = $UserID
                state      = 'success'
            }
        )

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecCreateTAP.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecDisableUser.ps1' -1

Function Invoke-ExecDisableUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.ID ?? $Request.Body.ID
    $Enable = $Request.Query.Enable ?? $Request.Body.Enable
    $Enable = [System.Convert]::ToBoolean($Enable)

    try {
        $Result = Set-CIPPSignInState -UserID $ID -TenantFilter $TenantFilter -APIName $APIName -Headers $Headers -AccountEnabled $Enable
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = "$Result" }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecDisableUser.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecDismissRiskyUser.ps1' -1

function Invoke-ExecDismissRiskyUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Interact with the query or body of the request
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $SuspectUser = $Request.Query.userId ?? $Request.Body.userId
    $userDisplayName = $Request.Query.userDisplayName ?? $Request.Body.userDisplayName

    $GraphRequest = @{
        'uri'         = 'https://graph.microsoft.com/beta/riskyUsers/dismiss'
        'tenantid'    = $TenantFilter
        'type'        = 'POST'
        'contentType' = 'application/json; charset=utf-8'
        'body'        = @{
            'userIds' = @($SuspectUser)
        } | ConvertTo-Json
    }

    try {
        $GraphResults = New-GraphPostRequest @GraphRequest
        $Result = "Successfully dismissed User Risk for user $userDisplayName. $GraphResults"
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Result -sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to dismiss user risk for $userDisplayName. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -API $APIName -tenant $TenantFilter -message $Result -sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecDismissRiskyUser.ps1' 44
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecJITAdmin.ps1' -1

function Invoke-ExecJITAdmin {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Role.ReadWrite

    .DESCRIPTION
        Just-in-time admin management API endpoint. This function can create users, add roles, remove roles, delete, or disable a user.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $TenantFilter = $Request.Body.tenantFilter.value ? $Request.Body.tenantFilter.value : $Request.Body.tenantFilter


    if ($Request.Body.existingUser.value -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$') {
        $Username = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($Request.Body.existingUser.value)" -tenantid $TenantFilter).userPrincipalName
    }

    $Start = ([System.DateTimeOffset]::FromUnixTimeSeconds($Request.Body.StartDate)).DateTime.ToLocalTime()
    $Expiration = ([System.DateTimeOffset]::FromUnixTimeSeconds($Request.Body.EndDate)).DateTime.ToLocalTime()
    $Results = [System.Collections.Generic.List[string]]::new()

    if ($Request.Body.userAction -eq 'create') {
        $Domain = $Request.Body.Domain.value ? $Request.Body.Domain.value : $Request.Body.Domain
        $Username = "$($Request.Body.Username)@$($Domain)"
        Write-Information "Creating JIT Admin user: $($Request.Body.username)"

        $JITAdmin = @{
            User         = @{
                'FirstName'         = $Request.Body.FirstName
                'LastName'          = $Request.Body.LastName
                'UserPrincipalName' = $Username
            }
            Expiration   = $Expiration
            Reason       = $Request.Body.reason
            Action       = 'Create'
            TenantFilter = $TenantFilter
        }
        $CreateResult = Set-CIPPUserJITAdmin @JITAdmin
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Created JIT Admin user: $Username. Reason: $($Request.Body.reason). Roles: $($Request.Body.adminRoles.label -join ', ')" -Sev 'Info' -LogData $JITAdmin
        $Results.Add("Created User: $Username")
        if (!$Request.Body.UseTAP) {
            $Results.Add("Password: $($CreateResult.password)")
        }
        $Results.Add("JIT Admin Expires: $($Expiration)")
        Start-Sleep -Seconds 1
    }

    #Region TAP creation
    if ($Request.Body.UseTAP) {
        try {
            if ($Start -gt (Get-Date)) {
                $TapParams = @{
                    startDateTime = [System.DateTimeOffset]::FromUnixTimeSeconds($Request.Body.StartDate).DateTime
                }
                $TapBody = ConvertTo-Json -Depth 5 -InputObject $TapParams
            } else {
                $TapBody = '{}'
            }
            # Write-Information "https://graph.microsoft.com/beta/users/$Username/authentication/temporaryAccessPassMethods"
            # Retry creating the TAP up to 10 times, since it can fail due to the user not being fully created yet. Sometimes it takes 2 reties, sometimes it takes 8+. Very annoying. -Bobby
            $Retries = 0
            $MAX_TAP_RETRIES = 10
            do {
                try {
                    $TapRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($Username)/authentication/temporaryAccessPassMethods" -tenantid $TenantFilter -type POST -body $TapBody
                } catch {
                    Start-Sleep -Seconds 2
                    Write-Information "ERROR: Run $Retries of $MAX_TAP_RETRIES : Failed to create TAP, retrying"
                    # Write-Information ( ConvertTo-Json -Depth 5 -InputObject (Get-CippException -Exception $_))
                }
                $Retries++
            } while ( $null -eq $TapRequest.temporaryAccessPass -and $Retries -le $MAX_TAP_RETRIES )

            $TempPass = $TapRequest.temporaryAccessPass
            $PasswordExpiration = $TapRequest.LifetimeInMinutes

            $PasswordLink = New-PwPushLink -Payload $TempPass
            $Password = $PasswordLink ? $PasswordLink : $TempPass

            $Results.Add("Temporary Access Pass: $Password")
            $Results.Add("This TAP is usable starting at $($TapRequest.startDateTime) UTC for the next $PasswordExpiration minutes")
        } catch {
            $Results.Add('Failed to create TAP, if this is not yet enabled, use the Standards to push the settings to the tenant.')
            Write-Information (Get-CippException -Exception $_ | ConvertTo-Json -Depth 5)
            if ($Password) {
                $Results.Add("Password: $Password")
            }
        }
    }
    #EndRegion TAP creation

    $Parameters = @{
        TenantFilter = $TenantFilter
        User         = @{
            'UserPrincipalName' = $Username
        }
        Roles        = $Request.Body.AdminRoles.value
        Action       = 'AddRoles'
        Reason       = $Request.Body.Reason
        Expiration   = $Expiration
    }
    if ($Start -gt (Get-Date)) {
        $TaskBody = @{
            TenantFilter  = $TenantFilter
            Name          = "JIT Admin (enable): $Username"
            Command       = @{
                value = 'Set-CIPPUserJITAdmin'
                label = 'Set-CIPPUserJITAdmin'
            }
            Parameters    = [pscustomobject]$Parameters
            ScheduledTime = $Request.Body.StartDate
            PostExecution = @{
                Webhook = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'webhook')
                Email   = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'email')
                PSA     = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'PSA')
            }
        }
        Add-CIPPScheduledTask -Task $TaskBody -hidden $false
        if ($Request.Body.userAction -ne 'create') {
            Set-CIPPUserJITAdminProperties -TenantFilter $TenantFilter -UserId $Request.Body.existingUser.value -Expiration $Expiration -Reason $Request.Body.Reason
        }
        $Results.Add("Scheduling JIT Admin enable task for $Username")
        Write-LogMessage -Headers $Headers -API $APIName -message "Scheduling JIT Admin for existing user: $Username. Reason: $($Request.Body.reason). Roles: $($Request.Body.adminRoles.label -join ', ') " -tenant $TenantFilter -Sev 'Info'
    } else {
        $Results.Add("Executing JIT Admin enable task for $Username")
        Set-CIPPUserJITAdmin @Parameters
        Write-LogMessage -Headers $Headers -API $APIName -message "Executing JIT Admin for existing user: $Username. Reason: $($Request.Body.reason). Roles: $($Request.Body.adminRoles.label -join ', ') " -tenant $TenantFilter -Sev 'Info'
    }

    $DisableTaskBody = [pscustomobject]@{
        TenantFilter  = $TenantFilter
        Name          = "JIT Admin ($($Request.Body.ExpireAction.value)): $Username"
        Command       = @{
            value = 'Set-CIPPUserJITAdmin'
            label = 'Set-CIPPUserJITAdmin'
        }
        Parameters    = [pscustomobject]@{
            TenantFilter = $TenantFilter
            User         = @{
                'UserPrincipalName' = $Username
            }
            Roles        = $Request.Body.AdminRoles.value
            Reason       = $Request.Body.Reason
            Action       = $Request.Body.ExpireAction.value
        }
        PostExecution = @{
            Webhook = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'webhook')
            Email   = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'email')
            PSA     = [bool]($Request.Body.PostExecution | Where-Object -Property value -EQ 'PSA')
        }
        ScheduledTime = $Request.Body.EndDate
    }
    $null = Add-CIPPScheduledTask -Task $DisableTaskBody -hidden $false
    $Results.Add("Scheduling JIT Admin $($Request.Body.ExpireAction.value) task for $Username")

    # TODO - We should find a way to have this return a HTTP status code based on the success or failure of the operation. This also doesn't return the results of the operation in a Results hash table, like most of the rest of the API.
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecJITAdmin.ps1' 168
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOffboardUser.ps1' -1

function Invoke-ExecOffboardUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $AllUsers = $Request.Body.user.value
    $TenantFilter = $request.Body.tenantFilter.value ? $request.Body.tenantFilter.value : $request.Body.tenantFilter
    $OffboardingOptions = $Request.Body | Select-Object * -ExcludeProperty user, tenantFilter, Scheduled
    $Results = foreach ($username in $AllUsers) {
        try {
            $APIName = 'ExecOffboardUser'
            $Headers = $Request.Headers


            if ($Request.Body.Scheduled.enabled) {
                $taskObject = [PSCustomObject]@{
                    TenantFilter  = $TenantFilter
                    Name          = "Offboarding: $Username"
                    Command       = @{
                        value = 'Invoke-CIPPOffboardingJob'
                    }
                    Parameters    = [pscustomobject]@{
                        Username     = $Username
                        APIName      = 'Scheduled Offboarding'
                        options      = $OffboardingOptions
                        RunScheduled = $true
                    }
                    ScheduledTime = $Request.Body.Scheduled.date
                    PostExecution = @{
                        Webhook = [bool]$Request.Body.PostExecution.webhook
                        Email   = [bool]$Request.Body.PostExecution.email
                        PSA     = [bool]$Request.Body.PostExecution.psa
                    }
                }
                Add-CIPPScheduledTask -Task $taskObject -hidden $false -Headers $Headers
            } else {
                Invoke-CIPPOffboardingJob -Username $Username -TenantFilter $TenantFilter -Options $OffboardingOptions -APIName $APIName -Headers $Headers
            }
            $StatusCode = [HttpStatusCode]::OK

        } catch {
            $StatusCode = [HttpStatusCode]::Forbidden
            $_.Exception.message
        }
    }
    $body = [pscustomobject]@{'Results' = @($Results) }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOffboardUser.ps1' 57
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOnedriveProvision.ps1' -1

Function Invoke-ExecOneDriveProvision {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $UserPrincipalName = $Request.Body.UserPrincipalName ?? $Request.Query.UserPrincipalName
    $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter

    try {
        $Result = Request-CIPPSPOPersonalSite -TenantFilter $TenantFilter -UserEmails $UserPrincipalName -Headers $Headers -APIName $APIName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOnedriveProvision.ps1' 31
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOneDriveShortCut.ps1' -1

Function Invoke-ExecOneDriveShortCut {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with the body of the request
    $TenantFilter = $Request.Body.tenantFilter
    $Username = $Request.Body.username
    $UserId = $Request.Body.userid
    $URL = $Request.Body.siteUrl.value

    Try {
        $Result = New-CIPPOneDriveShortCut -Username $Username -UserId $UserId -TenantFilter $TenantFilter -URL $URL -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecOneDriveShortCut.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecPasswordNeverExpires.ps1' -1

function Invoke-ExecPasswordNeverExpires {
    <#
    .FUNCTIONALITY
    Entrypoint

    .ROLE
    Identity.User.ReadWrite
    #>
    Param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $UserId = $Request.Body.userId
    $UserPrincipalName = $Request.Body.userPrincipalName # Only used for logging
    $PasswordPolicy = $Request.Body.PasswordPolicy.value ?? $Request.Body.PasswordPolicy ?? 'None'
    $PasswordPolicyName = $Request.Body.PasswordPolicy.label ?? $Request.Body.PasswordPolicy.value ?? $Request.Body.PasswordPolicy # Only used for logging

    if ([string]::IsNullOrWhiteSpace($UserId)) { exit }
    try {
        $Body = ConvertTo-Json -InputObject @{ passwordPolicies = $PasswordPolicy } -Depth 5 -Compress
        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/users/$UserId" -tenantid $TenantFilter -Body $Body -type PATCH
        $Result = "Successfully set PasswordPolicy for user $UserPrincipalName to $PasswordPolicyName"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to set PasswordPolicy for user $UserPrincipalName to $PasswordPolicyName. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = @($Result) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecPasswordNeverExpires.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecPerUserMFA.ps1' -1

function Invoke-ExecPerUserMFA {
    <#
    .FUNCTIONALITY
    Entrypoint

    .ROLE
    Identity.User.ReadWrite
    #>
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Guest user handling
    $UserId = $Request.Body.userPrincipalName -match '#EXT#' ? $Request.Body.userId : $Request.Body.userPrincipalName
    $TenantFilter = $Request.Body.tenantFilter
    $State = $Request.Body.State.value ?  $Request.Body.State.value : $Request.Body.State

    $Request = @{
        userId       = $UserId
        TenantFilter = $TenantFilter
        State        = $State
        Headers      = $Headers
        APIName      = $APIName
    }
    try {
        $Result = Set-CIPPPerUserMFA @Request
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = @($Result) }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecPerUserMFA.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecResetMFA.ps1' -1

Function Invoke-ExecResetMFA {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.ID ?? $Request.Body.ID
    try {
        $Result = Remove-CIPPUserMFA -UserPrincipalName $UserID -TenantFilter $TenantFilter -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecResetMFA.ps1' 30
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecResetPass.ps1' -1

Function Invoke-ExecResetPass {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.ID ?? $Request.Body.ID
    $DisplayName = $Request.Query.displayName ?? $Request.Body.displayName ?? $ID
    $MustChange = $Request.Query.MustChange ?? $Request.Body.MustChange
    $MustChange = [System.Convert]::ToBoolean($MustChange)

    try {
        $Result = Set-CIPPResetPassword -UserID $ID -tenantFilter $TenantFilter -APIName $APIName -Headers $Headers -forceChangePasswordNextSignIn $MustChange -DisplayName $DisplayName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecResetPass.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecRestoreDeleted.ps1' -1

function Invoke-ExecRestoreDeleted {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RequestID = $Request.Query.ID ?? $Request.Body.ID
    $UserPrincipalName = $Request.Body.userPrincipalName
    $DisplayName = $Request.Body.displayName

    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/directory/deletedItems/$($RequestID)/restore" -tenantid $TenantFilter -type POST -body '{}' -Verbose
        $Result = "Successfully restored deleted item with ID: '$($RequestID)'"
        if ($UserPrincipalName) { $Result += " User Principal Name: '$($UserPrincipalName)'" }
        if ($DisplayName) { $Result += " Display Name: '$($DisplayName)'" }

        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to restore deleted item with ID: '$($RequestID)'"
        if ($UserPrincipalName) { $Result += " User Principal Name: '$($UserPrincipalName)'" }
        if ($DisplayName) { $Result += " Display Name: '$($DisplayName)'" }
        $Result += " Error: $($ErrorMessage.NormalizedError)"

        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecRestoreDeleted.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecRevokeSessions.ps1' -1

Function Invoke-ExecRevokeSessions {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.id ?? $Request.Body.id
    $Username = $Request.Query.Username ?? $Request.Body.Username

    try {
        $Result = Revoke-CIPPSessions -UserID $ID -TenantFilter $TenantFilter -Username $Username -APIName $APIName -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecRevokeSessions.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecSendPush.ps1' -1

function Invoke-ExecSendPush {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $TenantFilter = $Request.body.TenantFilter
    $UserEmail = $Request.body.UserEmail
    $MFAAppID = '981f26a1-7f43-403b-a875-f8b09b8cd720'

    # Function to keep trying to get the access token while we wait for MS to actually set the temp password
    function Get-ClientAccess {
        param(
            $uri,
            $body,
            $count = 1
        )
        try {
            $ClientToken = Invoke-RestMethod -Method post -Uri $uri -Body $body -ea stop
        } catch {
            if ($count -lt 20) {

                $count++
                Start-Sleep 1
                $ClientToken = Get-ClientAccess -uri $uri -body $body -count $count
            } else {
                throw "Could not get Client Token: $_"
            }
        }
        return $ClientToken
    }


    # Get all service principals
    $SPResult = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$top=999&`$select=id,appId" -tenantid $TenantFilter -AsApp $true

    # Check if we have one for the MFA App
    $SPID = ($SPResult | Where-Object { $_.appId -eq $MFAAppID }).id

    # Create a service principal if needed
    if (!$SPID) {

        $SPBody = [pscustomobject]@{
            appId = $MFAAppID
        } | ConvertTo-Json -Depth 5
        $SPID = (New-GraphPostRequest -uri 'https://graph.microsoft.com/v1.0/servicePrincipals' -tenantid $TenantFilter -type POST -body $SPBody -AsApp $true).id
    }


    $PassReqBody = @{
        'passwordCredential' = @{
            'displayName'   = 'MFA Temporary Password'
            'endDateTime'   = $((Get-Date).AddMinutes(5))
            'startDateTime' = $((Get-Date).AddMinutes(-5))
        }
    } | ConvertTo-Json -Depth 5

    $TempPass = (New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/servicePrincipals/$SPID/addPassword" -tenantid $TenantFilter -type POST -body $PassReqBody -AsApp $true).secretText

    # Give it a chance to apply
    #Start-Sleep 5

    # Generate the XML for the push request
    $XML = @"
<BeginTwoWayAuthenticationRequest>
<Version>1.0</Version>
<UserPrincipalName>$UserEmail</UserPrincipalName>
<Lcid>en-us</Lcid><AuthenticationMethodProperties xmlns:a="http://schemas.microsoft.com/2003/10/Serialization/Arrays"><a:KeyValueOfstringstring><a:Key>OverrideVoiceOtp</a:Key><a:Value>false</a:Value></a:KeyValueOfstringstring></AuthenticationMethodProperties><ContextId>69ff05bf-eb61-47f7-a70e-e7d77b6d47d0</ContextId>
<SyncCall>true</SyncCall><RequireUserMatch>true</RequireUserMatch><CallerName>radius</CallerName><CallerIP>UNKNOWN:</CallerIP></BeginTwoWayAuthenticationRequest>
"@

    # Request to get client token
    $body = @{
        'resource'      = 'https://adnotifications.windowsazure.com/StrongAuthenticationService.svc/Connector'
        'client_id'     = $MFAAppID
        'client_secret' = $TempPass
        'grant_type'    = 'client_credentials'
        'scope'         = 'openid'
    }

    # Attempt to get a token using the temp password
    $ClientUri = "https://login.microsoftonline.com/$TenantFilter/oauth2/token"
    try {
        $ClientToken = Get-ClientAccess -Uri $ClientUri -Body $body
    } catch {
        $Body = 'Failed to create temporary token for MFA Application. Error: ' + $_.Exception.Message
    }

    # If we got a token send a push
    if ($ClientToken) {

        $ClientHeaders = @{ 'Authorization' = "Bearer $($ClientToken.access_token)" }

        $obj = Invoke-RestMethod -Uri 'https://adnotifications.windowsazure.com/StrongAuthenticationService.svc/Connector//BeginTwoWayAuthentication' -Method POST -Headers $ClientHeaders -Body $XML -ContentType 'application/xml'

        if ($obj.BeginTwoWayAuthenticationResponse.result) {
            $Body = "Received an MFA confirmation: $($obj.BeginTwoWayAuthenticationResponse.result.value | Out-String)"
            $State = 'success'
        }
        if ($obj.BeginTwoWayAuthenticationResponse.AuthenticationResult -ne $true) {
            $Body = "Authentication Failed! Does the user have Push/Phone call MFA configured? ErrorCode: $($obj.BeginTwoWayAuthenticationResponse.result.value | Out-String)"
            $State = 'error'
        }

    }

    $Results = [pscustomobject]@{'Results' = @{ resultText = $Body; state = $State } }
    Write-LogMessage -headers $Request.Headers -API $APINAME -message "Sent push request to $UserEmail - Result: $($obj.BeginTwoWayAuthenticationResponse.result.value | Out-String)" -Sev 'Info'

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecSendPush.ps1' 122
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecSetUserPhoto.ps1' -1

function Invoke-ExecSetUserPhoto {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $tenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $userId = $Request.Query.userId ?? $Request.Body.userId
    $action = $Request.Query.action ?? $Request.Body.action
    $photoData = $Request.Body.photoData

    $Results = [System.Collections.Generic.List[object]]::new()

    try {
        if ([string]::IsNullOrWhiteSpace($userId)) {
            throw 'User ID is required'
        }

        if ($action -eq 'remove') {
            # Remove the user's profile picture
            try {
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/users/$userId/photo/`$value" -tenantid $tenantFilter -type DELETE -NoAuthCheck $true
                $Results.Add('Successfully removed user profile picture.')
                Write-LogMessage -API $APIName -tenant $tenantFilter -headers $Headers -message "Removed profile picture for user $userId" -Sev Info
            } catch {
                # Check if the error is because there's no photo
                if ($_.Exception.Message -like '*does not exist*' -or $_.Exception.Message -like '*ResourceNotFound*') {
                    $Results.Add('User does not have a profile picture to remove.')
                    Write-LogMessage -API $APIName -tenant $tenantFilter -headers $Headers -message "No profile picture found for user $userId" -Sev Info
                } else {
                    throw $_
                }
            }
        } elseif ($action -eq 'set') {
            # Set the user's profile picture
            if ([string]::IsNullOrWhiteSpace($photoData)) {
                throw 'Photo data is required when setting a profile picture'
            }

            # Convert base64 string to byte array
            # The photoData should be in format: data:image/jpeg;base64,/9j/4AAQSkZJRg...
            # We need to strip the data URL prefix if present
            $base64Data = $photoData
            if ($photoData -match '^data:image/[^;]+;base64,(.+)$') {
                $base64Data = $Matches[1]
            }

            try {
                $photoBytes = [Convert]::FromBase64String($base64Data)
            } catch {
                throw "Invalid base64 photo data: $($_.Exception.Message)"
            }

            # Validate image size (Microsoft Graph has a 4MB limit)
            $maxSizeBytes = 4 * 1024 * 1024 # 4MB
            if ($photoBytes.Length -gt $maxSizeBytes) {
                throw "Photo size exceeds 4MB limit. Current size: $([math]::Round($photoBytes.Length / 1MB, 2))MB"
            }

            # Upload the photo using Graph API
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/users/$userId/photo/`$value" -tenantid $tenantFilter -type PATCH -body $photoBytes -ContentType 'image/jpeg' -NoAuthCheck $true

            $Results.Add('Successfully set user profile picture.')
            Write-LogMessage -API $APIName -tenant $tenantFilter -headers $Headers -message "Set profile picture for user $userId" -Sev Info
        } else {
            throw "Invalid action. Must be 'set' or 'remove'"
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{
                    'Results' = @($Results)
                }
            })
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant $tenantFilter -headers $Headers -message "Failed to $action user profile picture. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = @{
                    'Results' = @("Failed to $action user profile picture: $($ErrorMessage.NormalizedError)")
                }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ExecSetUserPhoto.ps1' 92
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListDeletedItems.ps1' -1

function Invoke-ListDeletedItems {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter

    $Types = @('administrativeUnit', 'application', 'externalUserProfile', 'pendingExternalUserProfile', 'user', 'group', 'servicePrincipal', 'certificateBasedAuthPki', 'certificateAuthorityDetail')
    $Requests = foreach ($Type in $Types) {
        [PSCustomObject]@{
            id     = $Type
            url    = "directory/deletedItems/microsoft.graph.$($Type)"
            method = 'GET'
        }
    }

    $BulkResults = New-GraphBulkRequest -Requests @($Requests) -tenantid $TenantFilter

    $GraphRequest = foreach ($Type in $Types) {
        # pretty format the type name
        $FormattedType = (Get-Culture).TextInfo.ToTitleCase(($Type -creplace '([A-Z])', ' $1').Trim())

        $Result = $BulkResults | Where-Object { $_.id -eq $Type }
        if ($Result.status -eq 200) {
            $Result.body.value | ForEach-Object {
                $_ | Add-Member -NotePropertyName 'TargetType' -NotePropertyValue $FormattedType
                $_
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListDeletedItems.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListJITAdmin.ps1' -1

function Invoke-ListJITAdmin {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Role.Read

    .DESCRIPTION
        List Just-in-time admin users for a tenant or all tenants.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1
    $TenantFilter = $Request.Query.TenantFilter

    if ($TenantFilter -ne 'AllTenants') {
        # Single tenant logic
        $Query = @{
            TenantFilter = $TenantFilter
            Endpoint     = 'users'
            Parameters   = @{
                '$count'  = 'true'
                '$select' = "id,accountEnabled,displayName,userPrincipalName,$($Schema.id)"
                '$filter' = "$($Schema.id)/jitAdminEnabled eq true or $($Schema.id)/jitAdminEnabled eq false"
            }
        }
        $Users = Get-GraphRequestList @Query | Where-Object { $_.id }
        $BulkRequests = $Users | ForEach-Object { @(
                @{
                    id     = $_.id
                    method = 'GET'
                    url    = "users/$($_.id)/memberOf/microsoft.graph.directoryRole/?`$select=id,displayName"
                }
            )
        }
        $RoleResults = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($BulkRequests)
        # Write-Information ($RoleResults | ConvertTo-Json -Depth 10 )
        $Results = $Users | ForEach-Object {
            $MemberOf = ($RoleResults | Where-Object -Property id -EQ $_.id).body.value | Select-Object displayName, id
            [PSCustomObject]@{
                id                 = $_.id
                displayName        = $_.displayName
                userPrincipalName  = $_.userPrincipalName
                accountEnabled     = $_.accountEnabled
                jitAdminEnabled    = $_.($Schema.id).jitAdminEnabled
                jitAdminExpiration = $_.($Schema.id).jitAdminExpiration
                jitAdminReason     = $_.($Schema.id).jitAdminReason
                memberOf           = $MemberOf
            }
        }

        # Write-Information ($Results | ConvertTo-Json -Depth 10)
        $Metadata = [PSCustomObject]@{Parameters = $Query.Parameters }
    } else {
        # AllTenants logic
        $Results = [System.Collections.Generic.List[object]]::new()
        $Metadata = @{}
        $Table = Get-CIPPTable -TableName CacheJITAdmin
        $PartitionKey = 'JITAdminUser'
        $Filter = "PartitionKey eq '$PartitionKey'"
        $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-60)

        $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey # $TenantFilter is 'AllTenants'
        Write-Information "QueueReference: $QueueReference"
        $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }

        if ($RunningQueue) {
            $Metadata = [PSCustomObject]@{
                QueueMessage = 'Still loading JIT Admin data for all tenants. Please check back in a few more minutes.'
                QueueId      = $RunningQueue.RowKey
            }
        } elseif (!$Rows -and !$RunningQueue) {
            $TenantList = Get-Tenants -IncludeErrors
            $Queue = New-CippQueueEntry -Name 'JIT Admin List - All Tenants' -Link '/identity/administration/jit-admin?tenantFilter=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count

            $Metadata = [PSCustomObject]@{
                QueueMessage = 'Loading JIT Admin data for all tenants. Please check back in a few minutes.'
                QueueId      = $Queue.RowKey
            }
            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'JITAdminOrchestrator'
                QueueFunction    = @{
                    FunctionName = 'GetTenants'
                    QueueId      = $Queue.RowKey
                    TenantParams = @{
                        IncludeErrors = $true
                    }
                    DurableName  = 'ExecJITAdminListAllTenants'
                }
                SkipLog          = $true
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
        } else {
            $Metadata = [PSCustomObject]@{
                QueueId = $RunningQueue.RowKey ?? $null
            }
            # There is data in the cache, so we will use that
            Write-Information "Found $($Rows.Count) rows in the cache"
            foreach ($row in $Rows) {
                $UserObject = $row.JITAdminUser | ConvertFrom-Json
                $Results.Add(
                    [PSCustomObject]@{
                        Tenant             = $row.Tenant
                        id                 = $UserObject.id
                        displayName        = $UserObject.displayName
                        userPrincipalName  = $UserObject.userPrincipalName
                        accountEnabled     = $UserObject.accountEnabled
                        jitAdminEnabled    = $UserObject.jitAdminEnabled
                        jitAdminExpiration = $UserObject.jitAdminExpiration
                        jitAdminReason     = $UserObject.jitAdminReason
                        memberOf           = $UserObject.memberOf
                    }
                )
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{
                Results  = @($Results)
                Metadata = $Metadata
            }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListJITAdmin.ps1' 128
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListNewUserDefaults.ps1' -1

function Invoke-ListNewUserDefaults {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    Write-Host 'Listing New User Default Templates'

    # Get the TenantFilter from query parameters
    $TenantFilter = $Request.Query.TenantFilter
    Write-Host "TenantFilter from request: $TenantFilter"

    # Get the templates table
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'UserDefaultTemplate'"

    # Retrieve all User Default templates
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        try {
            $row = $_
            $data = $row.JSON | ConvertFrom-Json -Depth 100 -ErrorAction Stop
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $row.GUID -Force
            $data | Add-Member -NotePropertyName 'RowKey' -NotePropertyValue $row.RowKey -Force
            Write-Host "Template found: $($data.templateName), tenantFilter: $($data.tenantFilter)"
            $data
        } catch {
            Write-Warning "Failed to process User Default template: $($row.RowKey) - $($_.Exception.Message)"
        }
    }

    Write-Host "Total templates before filtering: $($Templates.Count)"

    # Filter by tenant if TenantFilter is provided
    if ($TenantFilter) {
        $Templates = $Templates | Where-Object -Property tenantFilter -EQ $TenantFilter
        Write-Host "Templates after filtering: $($Templates.Count)"
    }

    # Sort by template name
    $Templates = $Templates | Sort-Object -Property templateName

    # If a specific ID is requested, filter to that template
    if ($Request.query.ID) {
        $Templates = $Templates | Where-Object -Property GUID -EQ $Request.query.ID
    }

    $Templates = ConvertTo-Json -InputObject @($Templates) -Depth 100

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Templates
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListNewUserDefaults.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListPerUserMFA.ps1' -1

function Invoke-ListPerUserMFA {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $User = $Request.Headers
    Write-LogMessage -Headers $User -API $APIName -message 'Accessed this API' -Sev 'Debug'

    # Parse query parameters
    $Tenant = $Request.query.tenantFilter
    try {
        $AllUsers = [System.Convert]::ToBoolean($Request.query.allUsers)
    } catch {
        $AllUsers = $false
    }
    $UserId = $Request.query.userId

    # Get the MFA state for the user/all users
    try {
        if ($AllUsers -eq $true) {
            $Results = Get-CIPPPerUserMFA -TenantFilter $Tenant -AllUsers $true
        } else {
            $Results = Get-CIPPPerUserMFA -TenantFilter $Tenant -UserId $UserId
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $Results = "Failed to get MFA State for $UserId : $ErrorMessage"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListPerUserMFA.ps1' 45
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserConditionalAccessPolicies.ps1' -1

Function Invoke-ListUserConditionalAccessPolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # XXX - Unused endpoint?

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.UserID

    try {
        $IncludeApplications = '67ad5377-2d78-4ac2-a867-6300cda00e85'
        $CAContext = @{
            '@odata.type'         = '#microsoft.graph.whatIfApplicationContext'
            'includeApplications' = @($IncludeApplications)
        }
        $ConditionalAccessWhatIfDefinition = @{
            'conditionalAccessWhatIfSubject'    = @{
                '@odata.type' = '#microsoft.graph.userSubject'
                'userId'      = "$UserID"
            }
            'conditionalAccessContext'          = $CAContext
            'conditionalAccessWhatIfConditions' = @{}
        }
        $JSONBody = ConvertTo-Json -Depth 10 -InputObject $ConditionalAccessWhatIfDefinition -Compress

        $GraphRequest = (New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/evaluate' -tenantid $TenantFilter -type POST -body $JsonBody -AsApp $true).value
    } catch {
        $GraphRequest = @{}
    }

    Write-Host $GraphRequest

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserConditionalAccessPolicies.ps1' 45
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserCounts.ps1' -1

Function Invoke-ListUserCounts {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    if ($Request.Query.TenantFilter -eq 'AllTenants') {
        $Users = 'Not Supported'
        $LicUsers = 'Not Supported'
        $GAs = 'Not Supported'
        $Guests = 'Not Supported'
    } else {
        try {
            # Build bulk requests array
            [System.Collections.Generic.List[PSCustomObject]]$BulkRequests = @(
                @{
                    id     = 'Users'
                    method = 'GET'
                    url    = "/users/`$count"
                    headers = @{
                        'ConsistencyLevel' = 'eventual'
                    }
                }
                @{
                    id     = 'LicUsers'
                    method = 'GET'
                    url    = "/users/`$count?`$top=1&`$filter=assignedLicenses/`$count ne 0"
                    headers = @{
                        'ConsistencyLevel' = 'eventual'
                    }
                }
                @{
                    id     = 'GAs'
                    method = 'GET'
                    url    = "/directoryRoles/roleTemplateId=62e90394-69f5-4237-9190-012177145e10/members/`$count"
                    headers = @{
                        'ConsistencyLevel' = 'eventual'
                    }
                }
                @{
                    id     = 'Guests'
                    method = 'GET'
                    url    = "/users/`$count?`$top=1&`$filter=userType eq 'Guest'"
                    headers = @{
                        'ConsistencyLevel' = 'eventual'
                    }
                }
            )

            # Execute bulk request
            $BulkResults = New-GraphBulkRequest -Requests @($BulkRequests) -noPaginateIds @('LicUsers') -tenantid $TenantFilter @('Users', 'LicUsers', 'GAs', 'Guests')

            # Check if any requests failed
            $FailedRequests = $BulkResults | Where-Object { $_.status -ne 200 }

            if ($FailedRequests) {
                # If any requests failed, return an error response
                $FailedIds = ($FailedRequests | ForEach-Object { $_.id }) -join ', '
                $ErrorMessage = "Failed to retrieve counts for: $FailedIds"

                return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::InternalServerError
                    Body       = @{
                        Error   = $ErrorMessage
                        Details = $FailedRequests
                    }
                })
            }

            # All requests succeeded, extract the counts
            $BulkResults | ForEach-Object {
                $UsersCount = $_.body

                switch ($_.id) {
                    'Users' { $Users = $UsersCount }
                    'LicUsers' { $LicUsers = $UsersCount }
                    'GAs' { $GAs = $UsersCount }
                    'Guests' { $Guests = $UsersCount }
                }
            }

        } catch {
            # Return error status on exception
            return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = @{
                    Error = "Failed to retrieve user counts: $($_.Exception.Message)"
                }
            })
        }
    }

    $Counts = @{
        Users    = $Users
        LicUsers = $LicUsers
        Gas      = $GAs
        Guests   = $Guests
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Counts
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserCounts.ps1' 112
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserDevices.ps1' -1

Function Invoke-ListUserDevices {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.UserID

    function Get-EPMID {
        param(
            $deviceID,
            $EPMDevices
        )
        try {
            return ($EPMDevices | Where-Object { $_.azureADDeviceId -eq $deviceID }).id
        } catch {
            return $null
        }
    }
    try {
        $EPMDevices = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$UserID/managedDevices" -Tenantid $TenantFilter
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$UserID/ownedDevices?`$top=999" -Tenantid $TenantFilter | Select-Object @{ Name = 'ID'; Expression = { $_.'id' } },
        @{ Name = 'accountEnabled'; Expression = { $_.'accountEnabled' } },
        @{ Name = 'approximateLastSignInDateTime'; Expression = { $_.'approximateLastSignInDateTime' | Out-String } },
        @{ Name = 'createdDateTime'; Expression = { $_.'createdDateTime' | Out-String } },
        @{ Name = 'deviceOwnership'; Expression = { $_.'deviceOwnership' } },
        @{ Name = 'displayName'; Expression = { $_.'displayName' } },
        @{ Name = 'enrollmentType'; Expression = { $_.'enrollmentType' } },
        @{ Name = 'isCompliant'; Expression = { $_.'isCompliant' } },
        @{ Name = 'managementType'; Expression = { $_.'managementType' } },
        @{ Name = 'manufacturer'; Expression = { $_.'manufacturer' } },
        @{ Name = 'model'; Expression = { $_.'model' } },
        @{ Name = 'operatingSystem'; Expression = { $_.'operatingSystem' } },
        @{ Name = 'onPremisesSyncEnabled'; Expression = { $(if ([string]::IsNullOrEmpty($_.'onPremisesSyncEnabled')) { $false }else { $true }) } },
        @{ Name = 'operatingSystemVersion'; Expression = { $_.'operatingSystemVersion' } },
        @{ Name = 'trustType'; Expression = { $_.'trustType' } },
        @{ Name = 'EPMID'; Expression = { $(Get-EPMID -deviceID $_.'deviceId' -EPMDevices $EPMDevices) } }
    } catch {
        $GraphRequest = @()
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserDevices.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserGroups.ps1' -1

function Invoke-ListUserGroups {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.userId
    $URI = "https://graph.microsoft.com/beta/users/$UserID/memberOf/$/microsoft.graph.group?`$select=id,displayName,mailEnabled,securityEnabled,groupTypes,onPremisesSyncEnabled,mail,isAssignableToRole&`$orderby=displayName asc"
    Write-Host $URI

    $GraphRequest = New-GraphGetRequest -uri $URI -tenantid $TenantFilter -noPagination $true -Verbose | Select-Object id,
    @{ Name = 'DisplayName'; Expression = { $_.displayName } },
    @{ Name = 'MailEnabled'; Expression = { $_.mailEnabled } },
    @{ Name = 'Mail'; Expression = { $_.mail } },
    @{ Name = 'SecurityGroup'; Expression = { $_.securityEnabled } },
    @{ Name = 'GroupTypes'; Expression = { $_.groupTypes -join ',' } },
    @{ Name = 'OnPremisesSync'; Expression = { $_.onPremisesSyncEnabled } },
    @{ Name = 'IsAssignableToRole'; Expression = { $_.isAssignableToRole } },
    @{ Name = 'calculatedGroupType'; Expression = {
            if ($_.groupTypes -contains 'Unified') { 'Microsoft 365' }
            elseif ($_.mailEnabled -and $_.securityEnabled) { 'Mail-Enabled Security' }
            elseif (-not $_.mailEnabled -and $_.securityEnabled) { 'Security' }
            elseif (([string]::isNullOrEmpty($_.groupTypes)) -and ($_.mailEnabled) -and (-not $_.securityEnabled)) { 'Distribution List' }
        }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserGroups.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserMailboxDetails.ps1' -1

function Invoke-ListUserMailboxDetails {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.UserID
    $UserMail = $Request.Query.userMail
    Write-Host "TenantFilter: $TenantFilter"
    Write-Host "UserID: $UserID"
    Write-Host "UserMail: $UserMail"

    try {
        $Requests = @(
            @{
                CmdletInput = @{
                    CmdletName = 'Get-Mailbox'
                    Parameters = @{ Identity = $UserID }
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-MailboxPermission'
                    Parameters = @{ Identity = $UserID }
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-CASMailbox'
                    Parameters = @{ Identity = $UserID }
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-OrganizationConfig'
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-MailboxStatistics'
                    Parameters = @{ Identity = $UserID; Archive = $true }
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-BlockedSenderAddress'
                    Parameters = @{ SenderAddress = $UserMail }
                }
            },
            @{
                CmdletInput = @{
                    CmdletName = 'Get-RecipientPermission'
                    Parameters = @{ Identity = $UserID }
                }
            }
        )
        $usernames = New-GraphGetRequest -tenantid $TenantFilter -uri 'https://graph.microsoft.com/beta/users?$select=id,userPrincipalName,displayName,mailNickname&$top=999'
        $Results = New-ExoBulkRequest -TenantId $TenantFilter -CmdletArray $Requests -returnWithCommand $true -Anchor $username
        Write-Host "First line of usernames is $($usernames[0] | ConvertTo-Json)"

        # Assign variables from $Results
        $MailboxDetailedRequest = $Results.'Get-Mailbox'
        $PermsRequest = $Results.'Get-MailboxPermission'
        $CASRequest = $Results.'Get-CASMailbox'
        $OrgConfig = $Results.'Get-OrganizationConfig'
        $ArchiveSizeRequest = $Results.'Get-MailboxStatistics'
        $BlockedSender = $Results.'Get-BlockedSenderAddress'
        $PermsRequest2 = $Results.'Get-RecipientPermission'

        $StatsRequest = New-GraphGetRequest -uri "https://outlook.office365.com/adminapi/beta/$($TenantFilter)/Mailbox('$($UserID)')/Exchange.GetMailboxStatistics()" -Tenantid $TenantFilter -scope ExchangeOnline -noPagination $true


        # Handle ArchiveEnabled and AutoExpandingArchiveEnabled
        try {
            if ($MailboxDetailedRequest.ArchiveGuid -ne '00000000-0000-0000-0000-000000000000') {
                $ArchiveEnabled = $true
            } else {
                $ArchiveEnabled = $false
            }

            # Get organization config of auto-expanding archive if it's disabled on user level
            if (-not $MailboxDetailedRequest.AutoExpandingArchiveEnabled -and $ArchiveEnabled) {
                $AutoExpandingArchiveEnabled = $OrgConfig.AutoExpandingArchiveEnabled
            } else {
                $AutoExpandingArchiveEnabled = $MailboxDetailedRequest.AutoExpandingArchiveEnabled
            }
        } catch {
            $ArchiveEnabled = $false
            $ArchiveSizeRequest = @{
                TotalItemSize = '0'
                ItemCount     = '0'
            }
        }


        # Determine if the user is blocked for spam
        if ($BlockedSender -and $BlockedSender.Count -gt 0) {
            $BlockedForSpam = $true
        } else {
            $BlockedForSpam = $false
        }
    } catch {
        Write-Error "Failed Fetching Data $($_.Exception.message): $($_.InvocationInfo.ScriptLineNumber)"
    }

    # Parse permissions

    #Implemented as an ArrayList that uses .add().
    $ParsedPerms = [System.Collections.ArrayList]::new()
    foreach ($PermSet in @($PermsRequest, $PermsRequest2)) {
        foreach ($Perm in $PermSet) {
            # Check if Trustee or User is not NT AUTHORITY\SELF
            $user = $Perm.Trustee ? $Perm.Trustee : $Perm.User
            if ($user -and $user -ne 'NT AUTHORITY\SELF') {
                $null = $ParsedPerms.Add([PSCustomObject]@{
                        User         = $user
                        AccessRights = ($Perm.AccessRights) -join ', '
                    })
            }
        }
    }
    if ($MailboxDetailedRequest.GrantSendOnBehalfTo) {
        $MailboxDetailedRequest.GrantSendOnBehalfTo | ForEach-Object {
            $id = $_
            $username = $usernames | Where-Object { $_.id -eq $id }

            $null = $ParsedPerms.Add([PSCustomObject]@{
                    User         = $username.UserPrincipalName ? $username.UserPrincipalName : $_
                    AccessRights = 'SendOnBehalf'
                })
        }
    }
    if ($ParsedPerms.Count -eq 0) {
        $ParsedPerms = @()
    }

    # Get forwarding address - lazy load contacts only if needed
    $ForwardingAddress = $null
    if ($MailboxDetailedRequest.ForwardingSmtpAddress) {
        # External forwarding
        $ForwardingAddress = $MailboxDetailedRequest.ForwardingSmtpAddress -replace '^smtp:', ''
    } elseif ($MailboxDetailedRequest.ForwardingAddress) {
        # Internal forwarding
        $rawAddress = $MailboxDetailedRequest.ForwardingAddress

        if ($rawAddress -match '@') {
            # Already an email address
            $ForwardingAddress = $rawAddress
        } else {
            # First try users array
            $matchedUser = $usernames | Where-Object {
                $_.id -eq $rawAddress -or
                $_.displayName -eq $rawAddress -or
                $_.mailNickname -eq $rawAddress
            }

            if ($matchedUser) {
                $ForwardingAddress = $matchedUser.userPrincipalName
            } else {
                # Query for the specific contact only
                try {
                    # Escape single quotes in the filter value
                    $escapedAddress = $rawAddress -replace "'", "''"
                    $filterQuery = "displayName eq '$escapedAddress' or mailNickname eq '$escapedAddress'"
                    $contactUri = "https://graph.microsoft.com/beta/contacts?`$filter=$filterQuery&`$select=displayName,mail,mailNickname"

                    $matchedContacts = New-GraphGetRequest -tenantid $TenantFilter -uri $contactUri

                    if ($matchedContacts -and $matchedContacts.Count -gt 0) {
                        $ForwardingAddress = $matchedContacts[0].mail
                    } else {
                        $ForwardingAddress = $rawAddress
                    }
                } catch {
                    $ForwardingAddress = $rawAddress
                }
            }
        }
    }

    $ProhibitSendQuotaString = $MailboxDetailedRequest.ProhibitSendQuota -split ' '
    $ProhibitSendReceiveQuotaString = $MailboxDetailedRequest.ProhibitSendReceiveQuota -split ' '
    $TotalItemSizeString = $StatsRequest.TotalItemSize -split ' '
    $TotalArchiveItemSizeString = (Get-ExoOnlineStringBytes -SizeString $ArchiveSizeRequest.TotalItemSize) / 1GB

    $ProhibitSendQuota = try { [math]::Round([float]($ProhibitSendQuotaString[0]), 2) } catch { 0 }
    $ProhibitSendReceiveQuota = try { [math]::Round([float]($ProhibitSendReceiveQuotaString[0]), 2) } catch { 0 }

    $ItemSizeType = '1{0}' -f ($TotalItemSizeString[1] ?? 'Gb')
    $TotalItemSize = try { [math]::Round([float]($TotalItemSizeString[0]) / $ItemSizeType, 2) } catch { 0 }

    if ($ArchiveEnabled -eq $true) {
        $TotalArchiveItemSize = try { [math]::Round([float]($TotalArchiveItemSizeString[0]), 2) } catch { 0 }
        $TotalArchiveItemCount = try { [math]::Round($ArchiveSizeRequest.ItemCount, 2) } catch { 0 }
    }

    # Parse InPlaceHolds to determine hold types if available
    $InPlaceHold = $false
    $EDiscoveryHold = $false
    $PurviewRetentionHold = $false
    $ExcludedFromOrgWideHold = $false

    # Check if InPlaceHolds property exists and has values
    if ($MailboxDetailedRequest.InPlaceHolds) {
        foreach ($hold in $MailboxDetailedRequest.InPlaceHolds) {
            # eDiscovery hold - starts with UniH
            if ($hold -like 'UniH*') {
                $EDiscoveryHold = $true
            }
            # In-Place Hold - no prefix or starts with cld
            # Check if it doesn't match any of the other known prefixes
            elseif (($hold -like 'cld*' -or
                    ($hold -notlike 'UniH*' -and
                    $hold -notlike 'mbx*' -and
                    $hold -notlike 'skp*' -and
                    $hold -notlike '-mbx*'))) {
                $InPlaceHold = $true
            }
            # Microsoft Purview retention policy - starts with mbx or skp
            elseif ($hold -like 'mbx*' -or $hold -like 'skp*') {
                $PurviewRetentionHold = $true
            }
            # Excluded from organization-wide Microsoft Purview retention policy - starts with -mbx
            elseif ($hold -like '-mbx*') {
                $ExcludedFromOrgWideHold = $true
            }
        }
    }

    # Build the GraphRequest object
    $GraphRequest = [ordered]@{
        ForwardAndDeliver        = $MailboxDetailedRequest.DeliverToMailboxAndForward
        ForwardingAddress        = $ForwardingAddress
        LitigationHold           = $MailboxDetailedRequest.LitigationHoldEnabled
        RetentionHold            = $MailboxDetailedRequest.RetentionHoldEnabled
        ComplianceTagHold        = $MailboxDetailedRequest.ComplianceTagHoldApplied
        InPlaceHold              = $InPlaceHold
        EDiscoveryHold           = $EDiscoveryHold
        PurviewRetentionHold     = $PurviewRetentionHold
        ExcludedFromOrgWideHold  = $ExcludedFromOrgWideHold
        HiddenFromAddressLists   = $MailboxDetailedRequest.HiddenFromAddressListsEnabled
        EWSEnabled               = $CASRequest.EwsEnabled
        MailboxMAPIEnabled       = $CASRequest.MAPIEnabled
        MailboxOWAEnabled        = $CASRequest.OWAEnabled
        MailboxImapEnabled       = $CASRequest.ImapEnabled
        MailboxPopEnabled        = $CASRequest.PopEnabled
        MailboxActiveSyncEnabled = $CASRequest.ActiveSyncEnabled
        Permissions              = @($ParsedPerms)
        ProhibitSendQuota        = $ProhibitSendQuota
        ProhibitSendReceiveQuota = $ProhibitSendReceiveQuota
        ItemCount                = [math]::Round($StatsRequest.ItemCount, 2)
        TotalItemSize            = $TotalItemSize
        TotalArchiveItemSize     = $TotalArchiveItemSize
        TotalArchiveItemCount    = $TotalArchiveItemCount
        BlockedForSpam           = $BlockedForSpam
        ArchiveMailBox           = $ArchiveEnabled
        AutoExpandingArchive     = $AutoExpandingArchiveEnabled
        RecipientTypeDetails     = $MailboxDetailedRequest.RecipientTypeDetails
        Mailbox                  = $MailboxDetailedRequest
        RetentionPolicy          = $MailboxDetailedRequest.RetentionPolicy
        MailboxActionsData       = ($MailboxDetailedRequest | Select-Object id, ExchangeGuid, ArchiveGuid, WhenSoftDeleted,
            @{ Name = 'UPN'; Expression = { $_.'UserPrincipalName' } },
            @{ Name = 'displayName'; Expression = { $_.'DisplayName' } },
            @{ Name = 'primarySmtpAddress'; Expression = { $_.'PrimarySMTPAddress' } },
            @{ Name = 'recipientType'; Expression = { $_.'RecipientType' } },
            @{ Name = 'recipientTypeDetails'; Expression = { $_.'RecipientTypeDetails' } },
            @{ Name = 'AdditionalEmailAddresses'; Expression = { ($_.'EmailAddresses' | Where-Object { $_ -clike 'smtp:*' }).Replace('smtp:', '') -join ', ' } },
            @{ Name = 'ForwardingSmtpAddress'; Expression = { $_.'ForwardingSmtpAddress' -replace 'smtp:', '' } },
            @{ Name = 'InternalForwardingAddress'; Expression = { $_.'ForwardingAddress' } },
            DeliverToMailboxAndForward,
            HiddenFromAddressListsEnabled,
            ExternalDirectoryObjectId,
            MessageCopyForSendOnBehalfEnabled,
            MessageCopyForSentAsEnabled,
            LitigationHoldEnabled,
            LitigationHoldDate,
            LitigationHoldDuration,
            @{ Name = 'LicensedForLitigationHold'; Expression = { ($_.PersistedCapabilities -contains 'EXCHANGE_S_ARCHIVE_ADDON' -or $_.PersistedCapabilities -contains 'EXCHANGE_S_ENTERPRISE') } },
            ComplianceTagHoldApplied,
            RetentionHoldEnabled,
            InPlaceHolds)
    } # Select statement taken from ListMailboxes to save a EXO request. If updated here, update in ListMailboxes as well.

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserMailboxDetails.ps1' 294
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserMailboxRules.ps1' -1

Function Invoke-ListUserMailboxRules {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.Mailbox.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.UserID
    try {
        $UserEmail = if ([string]::IsNullOrWhiteSpace($Request.Query.userEmail)) { $UserID } else { $Request.Query.userEmail }
        $Result = New-ExoRequest -Anchor $UserID -tenantid $TenantFilter -cmdlet 'Get-InboxRule' -cmdParams @{mailbox = $UserID; IncludeHidden = $true } |
            Where-Object { $_.Name -ne 'Junk E-Mail Rule' -and $_.Name -notlike 'Microsoft.Exchange.OOF.*' } | Select-Object * -ExcludeProperty RuleIdentity
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to retrieve mailbox rules for $UserEmail : Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Result)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserMailboxRules.ps1' 36
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserPhoto.ps1' -1

Function Invoke-ListUserPhoto {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $tenantFilter = $Request.Query.tenantFilter
    $userId = $Request.Query.UserID

    $URI = "/users/$userId/photo/`$value"

    $Requests = @(
        @{
            id     = 'photo'
            url    = $URI
            method = 'GET'
        }
    )

    $ImageData = New-GraphBulkRequest -Requests $Requests -tenantid $tenantFilter -NoAuthCheck $true
    #convert body from base64 to byte array
    $Body = [Convert]::FromBase64String($ImageData.body)

    return ([HttpResponseContext]@{
            StatusCode  = [HttpStatusCode]::OK
            ContentType = $ImageData.headers.'Content-Type'
            Body        = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserPhoto.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUsers.ps1' -1

Function Invoke-ListUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $ConvertTable = Import-Csv (Join-Path $ModuleBase 'lib\data\ConversionTable.csv') | Sort-Object -Property 'guid' -Unique
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $GraphFilter = $Request.Query.graphFilter
    $userid = $Request.Query.UserID

    $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
        New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($userid)?`$top=999&`$filter=$GraphFilter&`$count=true&`$expand=manager(`$select=id,userPrincipalName,displayName)" -tenantid $TenantFilter -ComplexFilter | ForEach-Object {
            $_ | Add-Member -MemberType NoteProperty -Name 'onPremisesSyncEnabled' -Value ([bool]($_.onPremisesSyncEnabled)) -Force
            $_ | Add-Member -MemberType NoteProperty -Name 'username' -Value ($_.userPrincipalName -split '@' | Select-Object -First 1) -Force
            $_ | Add-Member -MemberType NoteProperty -Name 'Aliases' -Value ($_.ProxyAddresses -join ', ') -Force
            $SkuID = $_.AssignedLicenses.skuid
            $_ | Add-Member -MemberType NoteProperty -Name 'LicJoined' -Value (($ConvertTable | Where-Object { $_.guid -in $SkuID }).'Product_Display_Name' -join ', ') -Force
            $_ | Add-Member -MemberType NoteProperty -Name 'primDomain' -Value @{value = ($_.userPrincipalName -split '@' | Select-Object -Last 1); label = ($_.userPrincipalName -split '@' | Select-Object -Last 1); } -Force
            $_
        }
    } else {
        $Table = Get-CIPPTable -TableName 'cacheusers'
        $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-1)
        if (!$Rows) {
            [PSCustomObject]@{
                Message = 'This function has been deprecated for all users, please use ListGraphRequest instead'
            }
        } else {
            $Rows.Data | ConvertFrom-Json | Select-Object $SelectList | ForEach-Object {
                $_.onPremisesSyncEnabled = [bool]($_.onPremisesSyncEnabled)
                $_.Aliases = $_.proxyAddresses -join ', '
                $SkuID = $_.AssignedLicenses.skuid
                $_.LicJoined = ($ConvertTable | Where-Object { $_.guid -in $SkuID }).'Product_Display_Name' -join ', '
                $_.primDomain = @{value = ($_.userPrincipalName -split '@' | Select-Object -Last 1) }
                $_
            }
        }
    }


    if ($userid -and $Request.query.IncludeLogonDetails) {
        $startDate = (Get-Date).AddDays(-7)
        $endDate = (Get-Date)
        $sessionid = Get-Random -Maximum 1000 -Minimum 1
        $SearchParam = @{
            SessionCommand = 'ReturnLargeSet'
            Operations     = @('UserLoggedIn', 'UserLoginFailed', 'TeamsSessionStarted', 'MailboxLogin')
            sessionid      = $sessionid
            startDate      = $startDate
            endDate        = $endDate
            UserIds        = @($GraphRequest.userPrincipalName)
        }
        $AuditlogsLogon = (New-ExoRequest -tenantid $TenantFilter -cmdlet 'Search-unifiedAuditLog' -cmdParams $SearchParam | Sort-Object -Property CreationDate | Select-Object -Last 1).auditdata | ConvertFrom-Json
        $AppName = '[{"Application Name":"ACOM Azure Website","Application IDs":"23523755-3a2b-41ca-9315-f81f3f566a95"},{"Application Name":"AEM-DualAuth","Application IDs":"69893ee3-dd10-4b1c-832d-4870354be3d8"},{"Application Name":"ASM Campaign Servicing","Application IDs":"0cb7b9ec-5336-483b-bc31-b15b5788de71"},{"Application Name":"Azure Advanced Threat Protection","Application IDs":"7b7531ad-5926-4f2d-8a1d-38495ad33e17"},{"Application Name":"Azure Data Lake","Application IDs":"e9f49c6b-5ce5-44c8-925d-015017e9f7ad"},{"Application Name":"Azure Lab Services Portal","Application IDs":"835b2a73-6e10-4aa5-a979-21dfda45231c"},{"Application Name":"Azure Portal","Application IDs":"c44b4083-3bb0-49c1-b47d-974e53cbdf3c"},{"Application Name":"AzureSupportCenter","Application IDs":"37182072-3c9c-4f6a-a4b3-b3f91cacffce"},{"Application Name":"Bing","Application IDs":"9ea1ad79-fdb6-4f9a-8bc3-2b70f96e34c7"},{"Application Name":"CPIM Service","Application IDs":"bb2a2e3a-c5e7-4f0a-88e0-8e01fd3fc1f4"},{"Application Name":"CRM Power BI Integration","Application IDs":"e64aa8bc-8eb4-40e2-898b-cf261a25954f"},{"Application Name":"Dataverse","Application IDs":"00000007-0000-0000-c000-000000000000"},{"Application Name":"Enterprise Roaming and Backup","Application IDs":"60c8bde5-3167-4f92-8fdb-059f6176dc0f"},{"Application Name":"IAM Supportability","Application IDs":"a57aca87-cbc0-4f3c-8b9e-dc095fdc8978"},{"Application Name":"IrisSelectionFrontDoor","Application IDs":"16aeb910-ce68-41d1-9ac3-9e1673ac9575"},{"Application Name":"MCAPI Authorization Prod","Application IDs":"d73f4b35-55c9-48c7-8b10-651f6f2acb2e"},{"Application Name":"Media Analysis and Transformation Service","Application IDs":"944f0bd1-117b-4b1c-af26-804ed95e767e<br>0cd196ee-71bf-4fd6-a57c-b491ffd4fb1e"},{"Application Name":"Microsoft 365 Support Service","Application IDs":"ee272b19-4411-433f-8f28-5c13cb6fd407"},{"Application Name":"Microsoft App Access Panel","Application IDs":"0000000c-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Approval Management","Application IDs":"65d91a3d-ab74-42e6-8a2f-0add61688c74<br>38049638-cc2c-4cde-abe4-4479d721ed44"},{"Application Name":"Microsoft Authentication Broker","Application IDs":"29d9ed98-a469-4536-ade2-f981bc1d605e"},{"Application Name":"Microsoft Azure CLI","Application IDs":"04b07795-8ddb-461a-bbee-02f9e1bf7b46"},{"Application Name":"Microsoft Azure PowerShell","Application IDs":"1950a258-227b-4e31-a9cf-717495945fc2"},{"Application Name":"Microsoft Bing Search","Application IDs":"cf36b471-5b44-428c-9ce7-313bf84528de"},{"Application Name":"Microsoft Bing Search for Microsoft Edge","Application IDs":"2d7f3606-b07d-41d1-b9d2-0d0c9296a6e8"},{"Application Name":"Microsoft Bing Default Search Engine","Application IDs":"1786c5ed-9644-47b2-8aa0-7201292175b6"},{"Application Name":"Microsoft Defender for Cloud Apps","Application IDs":"3090ab82-f1c1-4cdf-af2c-5d7a6f3e2cc7"},{"Application Name":"Microsoft Docs","Application IDs":"18fbca16-2224-45f6-85b0-f7bf2b39b3f3"},{"Application Name":"Microsoft Dynamics ERP","Application IDs":"00000015-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Edge Insider Addons Prod","Application IDs":"6253bca8-faf2-4587-8f2f-b056d80998a7"},{"Application Name":"Microsoft Exchange Online Protection","Application IDs":"00000007-0000-0ff1-ce00-000000000000"},{"Application Name":"Microsoft Forms","Application IDs":"c9a559d2-7aab-4f13-a6ed-e7e9c52aec87"},{"Application Name":"Microsoft Graph","Application IDs":"00000003-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Intune Web Company Portal","Application IDs":"74bcdadc-2fdc-4bb3-8459-76d06952a0e9"},{"Application Name":"Microsoft Intune Windows Agent","Application IDs":"fc0f3af4-6835-4174-b806-f7db311fd2f3"},{"Application Name":"Microsoft Learn","Application IDs":"18fbca16-2224-45f6-85b0-f7bf2b39b3f3"},{"Application Name":"Microsoft Office","Application IDs":"d3590ed6-52b3-4102-aeff-aad2292ab01c"},{"Application Name":"Microsoft Office 365 Portal","Application IDs":"00000006-0000-0ff1-ce00-000000000000"},{"Application Name":"Microsoft Office Web Apps Service","Application IDs":"67e3df25-268a-4324-a550-0de1c7f97287"},{"Application Name":"Microsoft Online Syndication Partner Portal","Application IDs":"d176f6e7-38e5-40c9-8a78-3998aab820e7"},{"Application Name":"Microsoft password reset service","Application IDs":"93625bc8-bfe2-437a-97e0-3d0060024faa"},{"Application Name":"Microsoft Power BI","Application IDs":"871c010f-5e61-4fb1-83ac-98610a7e9110"},{"Application Name":"Microsoft Storefronts","Application IDs":"28b567f6-162c-4f54-99a0-6887f387bbcc"},{"Application Name":"Microsoft Stream Portal","Application IDs":"cf53fce8-def6-4aeb-8d30-b158e7b1cf83"},{"Application Name":"Microsoft Substrate Management","Application IDs":"98db8bd6-0cc0-4e67-9de5-f187f1cd1b41"},{"Application Name":"Microsoft Support","Application IDs":"fdf9885b-dd37-42bf-82e5-c3129ef5a302"},{"Application Name":"Microsoft Teams","Application IDs":"1fec8e78-bce4-4aaf-ab1b-5451cc387264"},{"Application Name":"Microsoft Teams Services","Application IDs":"cc15fd57-2c6c-4117-a88c-83b1d56b4bbe"},{"Application Name":"Microsoft Teams Web Client","Application IDs":"5e3ce6c0-2b1f-4285-8d4b-75ee78787346"},{"Application Name":"Microsoft Whiteboard Services","Application IDs":"95de633a-083e-42f5-b444-a4295d8e9314"},{"Application Name":"O365 Suite UX","Application IDs":"4345a7b9-9a63-4910-a426-35363201d503"},{"Application Name":"Office 365 Exchange Online","Application IDs":"00000002-0000-0ff1-ce00-000000000000"},{"Application Name":"Office 365 Management","Application IDs":"00b41c95-dab0-4487-9791-b9d2c32c80f2"},{"Application Name":"Office 365 Search Service","Application IDs":"66a88757-258c-4c72-893c-3e8bed4d6899"},{"Application Name":"Office 365 SharePoint Online","Application IDs":"00000003-0000-0ff1-ce00-000000000000"},{"Application Name":"Office Delve","Application IDs":"94c63fef-13a3-47bc-8074-75af8c65887a"},{"Application Name":"Office Online Add-in SSO","Application IDs":"93d53678-613d-4013-afc1-62e9e444a0a5"},{"Application Name":"Office Online Client AAD- Augmentation Loop","Application IDs":"2abdc806-e091-4495-9b10-b04d93c3f040"},{"Application Name":"Office Online Client AAD- Loki","Application IDs":"b23dd4db-9142-4734-867f-3577f640ad0c"},{"Application Name":"Office Online Client AAD- Maker","Application IDs":"17d5e35f-655b-4fb0-8ae6-86356e9a49f5"},{"Application Name":"Office Online Client MSA- Loki","Application IDs":"b6e69c34-5f1f-4c34-8cdf-7fea120b8670"},{"Application Name":"Office Online Core SSO","Application IDs":"243c63a3-247d-41c5-9d83-7788c43f1c43"},{"Application Name":"Office Online Search","Application IDs":"a9b49b65-0a12-430b-9540-c80b3332c127"},{"Application Name":"Office.com","Application IDs":"4b233688-031c-404b-9a80-a4f3f2351f90"},{"Application Name":"Office365 Shell WCSS-Client","Application IDs":"89bee1f7-5e6e-4d8a-9f3d-ecd601259da7"},{"Application Name":"OfficeClientService","Application IDs":"0f698dd4-f011-4d23-a33e-b36416dcb1e6"},{"Application Name":"OfficeHome","Application IDs":"4765445b-32c6-49b0-83e6-1d93765276ca"},{"Application Name":"OfficeShredderWacClient","Application IDs":"4d5c2d63-cf83-4365-853c-925fd1a64357"},{"Application Name":"OMSOctopiPROD","Application IDs":"62256cef-54c0-4cb4-bcac-4c67989bdc40"},{"Application Name":"OneDrive SyncEngine","Application IDs":"ab9b8c07-8f02-4f72-87fa-80105867a763"},{"Application Name":"OneNote","Application IDs":"2d4d3d8e-2be3-4bef-9f87-7875a61c29de"},{"Application Name":"Outlook Mobile","Application IDs":"27922004-5251-4030-b22d-91ecd9a37ea4"},{"Application Name":"Partner Customer Delegated Admin Offline Processor","Application IDs":"a3475900-ccec-4a69-98f5-a65cd5dc5306"},{"Application Name":"Password Breach Authenticator","Application IDs":"bdd48c81-3a58-4ea9-849c-ebea7f6b6360"},{"Application Name":"Power BI Service","Application IDs":"00000009-0000-0000-c000-000000000000"},{"Application Name":"SharedWithMe","Application IDs":"ffcb16e8-f789-467c-8ce9-f826a080d987"},{"Application Name":"SharePoint Online Web Client Extensibility","Application IDs":"08e18876-6177-487e-b8b5-cf950c1e598c"},{"Application Name":"Signup","Application IDs":"b4bddae8-ab25-483e-8670-df09b9f1d0ea"},{"Application Name":"Skype for Business Online","Application IDs":"00000004-0000-0ff1-ce00-000000000000"},{"Application Name":"Sway","Application IDs":"905fcf26-4eb7-48a0-9ff0-8dcc7194b5ba"},{"Application Name":"Universal Store Native Client","Application IDs":"268761a2-03f3-40df-8a8b-c3db24145b6b"},{"Application Name":"Vortex [wsfed enabled]","Application IDs":"5572c4c0-d078-44ce-b81c-6cbf8d3ed39e"},{"Application Name":"Windows Azure Active Directory","Application IDs":"00000002-0000-0000-c000-000000000000"},{"Application Name":"Windows Azure Service Management API","Application IDs":"797f4846-ba00-4fd7-ba43-dac1f8f63013"},{"Application Name":"WindowsDefenderATP Portal","Application IDs":"a3b79187-70b2-4139-83f9-6016c58cd27b"},{"Application Name":"Windows Search","Application IDs":"26a7ee05-5602-4d76-a7ba-eae8b7b67941"},{"Application Name":"Windows Spotlight","Application IDs":"1b3c667f-cde3-4090-b60b-3d2abd0117f0"},{"Application Name":"Windows Store for Business","Application IDs":"45a330b1-b1ec-4cc1-9161-9f03992aa49f"},{"Application Name":"Yammer","Application IDs":"00000005-0000-0ff1-ce00-000000000000"},{"Application Name":"Yammer Web","Application IDs":"c1c74fed-04c9-4704-80dc-9f79a2e515cb"},{"Application Name":"Yammer Web Embed","Application IDs":"e1ef36fd-b883-4dbf-97f0-9ece4b576fc6"}]' |
            ConvertFrom-Json | Where-Object -Property 'Application IDs' -EQ $AuditlogsLogon.applicationId
        $LastSignIn = [PSCustomObject]@{
            AppDisplayName  = if ($AppName) { $AppName.'Application Name' } else { "$($AuditlogsLogon.Workload) - $($AuditlogsLogon.ApplicationId) " }
            CreatedDateTime = $AuditlogsLogon.CreationTime
            Id              = $AuditlogsLogon.errorNumber
            Status          = $AuditlogsLogon.ResultStatus
        }
        $GraphRequest = $GraphRequest | Select-Object *,
        @{ Name = 'LastSigninApplication'; Expression = { $LastSignIn.AppDisplayName } },
        @{ Name = 'LastSigninDate'; Expression = { $($LastSignIn.CreatedDateTime | Out-String) } },
        @{ Name = 'LastSigninStatus'; Expression = { $AuditlogsLogon.operation } },
        @{ Name = 'LastSigninResult'; Expression = { $LastSignIn.status } },
        @{ Name = 'LastSigninFailureReason'; Expression = { if ($LastSignIn.Id -eq 0) { 'Successfully signed in' } else { $LastSignIn.Id } } }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUsers.ps1' 81
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserSettings.ps1' -1

function Invoke-ListUserSettings {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Identity.User.Read
    #>
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $Username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails

    try {
        $Table = Get-CippTable -tablename 'UserSettings'
        $UserSettings = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'UserSettings' and RowKey eq 'allUsers'"
        if (!$UserSettings) { $UserSettings = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'UserSettings' and RowKey eq '$Username'" }

        try {
            $UserSettings = $UserSettings.JSON | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue
        } catch {
            Write-Warning "Failed to convert UserSettings JSON: $($_.Exception.Message)"
        }

        if (!$UserSettings) {
            $UserSettings = [pscustomobject]@{
                direction      = 'ltr'
                paletteMode    = 'light'
                currentTheme   = @{ value = 'light'; label = 'light' }
                pinNav         = $true
                showDevtools   = $false
                customBranding = @{
                    colour = '#F77F00'
                    logo   = $null
                }
            }
        }

        try {
            $UserSpecificSettings = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'UserSettings' and RowKey eq '$Username'"
            $UserSpecificSettings = $UserSpecificSettings.JSON | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue
        } catch {
            Write-Warning "Failed to convert UserSpecificSettings JSON: $($_.Exception.Message)"
        }

        #Get branding settings
        if ($UserSettings) {
            $brandingTable = Get-CippTable -tablename 'Config'
            $BrandingSettings = Get-CIPPAzDataTableEntity @brandingTable -Filter "PartitionKey eq 'BrandingSettings' and RowKey eq 'BrandingSettings'"
            if ($BrandingSettings) {
                $UserSettings | Add-Member -MemberType NoteProperty -Name 'customBranding' -Value $BrandingSettings -Force | Out-Null
            }
        }

        if ($UserSpecificSettings) {
            $UserSettings | Add-Member -MemberType NoteProperty -Name 'UserSpecificSettings' -Value $UserSpecificSettings -Force | Out-Null
        }

        $StatusCode = [HttpStatusCode]::OK
        $Results = $UserSettings
    } catch {
        $Results = "Function Error: $($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::BadRequest
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserSettings.ps1' 71
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserSigninLogs.ps1' -1

Function Invoke-ListUserSigninLogs {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $top = $Request.Query.top ? $Request.Query.top : 50


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $UserID = $Request.Query.UserID
    $URI = "https://graph.microsoft.com/beta/auditLogs/signIns?`$filter=(userId eq '$UserID')&`$top=$top&`$orderby=createdDateTime desc"

    try {
        $Result = New-GraphGetRequest -uri $URI -tenantid $TenantFilter -noPagination $true -verbose
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to retrieve Sign In report for user $UserID : Error: $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Result)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-ListUserSigninLogs.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-PatchUser.ps1' -1

function Invoke-PatchUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $HttpResponse = [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @{'Results' = @("Default response, you should never see this.") }
    }

    try {
        # Handle array of user objects or single user object
        $Users = if ($Request.Body -is [array]) {
            $Request.Body
        } else {
            @($Request.Body)
        }

        # Validate that all users have required properties
        $InvalidUsers = $Users | Where-Object {
            [string]::IsNullOrWhiteSpace($_.id) -or [string]::IsNullOrWhiteSpace($_.tenantFilter)
        }
        if ($InvalidUsers.Count -gt 0) {
            $HttpResponse.StatusCode = [HttpStatusCode]::BadRequest
            $HttpResponse.Body = @{'Results' = @('Failed to patch user(s). Some users are missing id or tenantFilter') }
        } else {
            # Group users by tenant filter
            $UsersByTenant = $Users | Group-Object -Property tenantFilter

            $TotalSuccessCount = 0
            $AllErrorMessages = @()

            # Process each tenant separately
            foreach ($TenantGroup in $UsersByTenant) {
                $tenantFilter = $TenantGroup.Name
                $TenantUsers = $TenantGroup.Group

                # Build bulk requests for this tenant
                $int = 0
                $BulkRequests = foreach ($User in $TenantUsers) {
                    # Remove the id and tenantFilter properties from the body since they're not user properties
                    $PatchBody = $User | Select-Object -Property * -ExcludeProperty id, tenantFilter

                    @{
                        id        = $int++
                        method    = 'PATCH'
                        url       = "users/$($User.id)"
                        body      = $PatchBody
                        'headers' = @{
                            'Content-Type' = 'application/json'
                        }
                    }
                }

                # Execute bulk request for this tenant
                $BulkResults = New-GraphBulkRequest -tenantid $tenantFilter -Requests @($BulkRequests)

                # Process results for this tenant
                for ($i = 0; $i -lt $BulkResults.Count; $i++) {
                    $result = $BulkResults[$i]
                    $user = $TenantUsers[$i]

                    if ($result.status -eq 200 -or $result.status -eq 204) {
                        $TotalSuccessCount++
                        Write-LogMessage -headers $Headers -API $APIName -tenant $tenantFilter -message "Successfully patched user $($user.id)" -Sev 'Info'
                    } else {
                        $errorMsg = if ($result.body.error.message) {
                            $result.body.error.message
                        } else {
                            "Unknown error (Status: $($result.status))"
                        }
                        $AllErrorMessages += "Failed to patch user $($user.id) in tenant $($tenantFilter): $errorMsg"
                        Write-LogMessage -headers $Headers -API $APIName -tenant $tenantFilter -message "Failed to patch user $($user.id). Error: $errorMsg" -Sev 'Error'
                    }
                }
            }

            # Build final response
            if ($AllErrorMessages.Count -eq 0) {
                $TenantCount = ($Users | Select-Object -Property tenantFilter -Unique).Count
                $HttpResponse.Body = @{'Results' = @("Successfully patched $TotalSuccessCount user$(if($TotalSuccessCount -ne 1){'s'}) across $TenantCount tenant$(if($TenantCount -ne 1){'s'})") }
            } else {
                $HttpResponse.StatusCode = [HttpStatusCode]::BadRequest
                $HttpResponse.Body = @{'Results' = $AllErrorMessages + @("Successfully patched $TotalSuccessCount of $($Users.Count) users") }
            }
        }

    } catch {
        $HttpResponse.StatusCode = [HttpStatusCode]::InternalServerError
        $HttpResponse.Body = @{'Results' = @("Failed to patch user(s). Error: $($_.Exception.Message)") }
    }

    return $HttpResponse
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-PatchUser.ps1' 104
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveDeletedObject.ps1' -1

Function Invoke-RemoveDeletedObject {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RequestID = $Request.Query.ID ?? $Request.Body.ID
    $UserPrincipalName = $Request.Body.userPrincipalName
    $DisplayName = $Request.Body.displayName

    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/directory/deletedItems/$($RequestID)" -tenantid $TenantFilter -type DELETE -body '{}' -Verbose
        $Result = "Successfully permanently deleted item with ID: '$($RequestID)'"
        if ($UserPrincipalName) { $Result += " User Principal Name: '$($UserPrincipalName)'" }
        if ($DisplayName) { $Result += " Display Name: '$($DisplayName)'" }

        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to permanently delete item with ID: $($RequestID)"
        if ($UserPrincipalName) { $Result += " User Principal Name: '$($UserPrincipalName)'" }
        if ($DisplayName) { $Result += " Display Name: '$($DisplayName)'" }
        $Result += " Error: $($ErrorMessage.NormalizedError)"

        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveDeletedObject.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveUser.ps1' -1

Function Invoke-RemoveUser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $UserID = $Request.Query.ID ?? $Request.Body.ID
    $Username = $Request.Query.userPrincipalName ?? $Request.Body.userPrincipalName

    if (!$UserID) { exit }
    try {
        $Result = Remove-CIPPUser -UserID $UserID -Username $Username -TenantFilter $TenantFilter -Headers $Headers -APIName $APIName
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveUser.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveUserDefaultTemplate.ps1' -1

function Invoke-RemoveUserDefaultTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    try {
        $ID = $Request.Query.ID ?? $Request.Body.ID
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'UserDefaultTemplate' and RowKey eq '$ID'"
        $Template = Get-CIPPAzDataTableEntity @Table -Filter $Filter

        if ($Template) {
            Remove-AzDataTableEntity @Table -Entity $Template
            $Result = "Successfully deleted User Default Template with ID: $ID"
            Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info'
            $StatusCode = [HttpStatusCode]::OK
        } else {
            $Result = "User Default Template with ID $ID not found"
            Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Warning'
            $StatusCode = [HttpStatusCode]::NotFound
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete User Default Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Administration/Users/Invoke-RemoveUserDefaultTemplate.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Identity/Invoke-ExecSetCloudManaged.ps1' -1

function Invoke-ExecSetCloudManaged {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.DirSync.ReadWrite
    .DESCRIPTION
        Sets the cloud-managed status of a user, group, or contact.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $GroupID = $Request.Body.ID
    $DisplayName = $Request.Body.displayName
    $Type = $Request.Body.type
    $IsCloudManaged = [System.Convert]::ToBoolean($Request.Body.isCloudManaged)

    try {
        $Params = @{
            Id             = $GroupID
            TenantFilter   = $TenantFilter
            DisplayName    = $DisplayName
            Type           = $Type
            IsCloudManaged = $IsCloudManaged
            APIName        = $APIName
            Headers        = $Headers
        }
        $Result = Set-CIPPCloudManaged @Params
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "$($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Invoke-ExecSetCloudManaged.ps1' 44
#Region './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListAzureADConnectStatus.ps1' -1

Function Invoke-ListAzureADConnectStatus {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.TenantFilter
    $DataToReturn = $Request.Query.DataToReturn
    Write-Host "DataToReturn: $DataToReturn"

    if (($DataToReturn -eq 'AzureADConnectSettings') -or ([string]::IsNullOrEmpty($DataToReturn)) ) {
        $ADConnectStatusGraph = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/organization' -tenantid $TenantFilter
        $AzureADConnectSettings = [PSCustomObject]@{
            dirSyncEnabled            = [boolean]$ADConnectStatusGraph.onPremisesSyncEnabled
            numberOfHoursFromLastSync = $ADConnectStatusGraph.onPremisesLastSyncDateTime
            raw                       = $ADConnectStatusGraph
        }
    }

    if (($DataToReturn -eq 'AzureADObjectsInError') -or ([string]::IsNullOrEmpty($DataToReturn)) ) {
        $SelectList = 'id,displayName,onPremisesProvisioningErrors,createdDateTime'
        $Types = 'Users', 'Contacts', 'Groups'

        $GraphRequest = @(
            foreach ($Type in $Types) {
                @{
                    id     = $Type.ToLower()
                    method = 'GET'
                    url    = "/$Type`?`$select=$SelectList"
                }
            }
        )

        $Results = New-GraphBulkRequest -Requests $GraphRequest -tenantid $TenantFilter -verbose
        $ObjectsInError = @(
            foreach ($Result in $Results) {
                $Type = $Result.id -replace 's$' # Remove the 's' from the end of the type name
                $Result.body.value | ForEach-Object {
                    if ($null -ne $_.id) {
                        $_ | Add-Member -NotePropertyName ObjectType -NotePropertyValue $Type -PassThru
                    }
                }
            }
        )
    }

    if ([string]::IsNullOrEmpty($DataToReturn)) {
        $FinalObject = [PSCustomObject]@{
            AzureADConnectSettings = $AzureADConnectSettings
            ObjectsInError         = $ObjectsInError
        }
    }
    if ($DataToReturn -eq 'AzureADConnectSettings') {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $AzureADConnectSettings
            })
    } elseif ($DataToReturn -eq 'AzureADObjectsInError') {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($ObjectsInError)
            })
    } else {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($FinalObject)
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListAzureADConnectStatus.ps1' 73
#Region './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListBasicAuth.ps1' -1

Function Invoke-ListBasicAuth {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.AuditLog.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # XXX; This function seems to be unused in the frontend. -Bobby


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $currentTime = Get-Date -Format 'yyyy-MM-ddTHH:MM:ss'
    $ts = (Get-Date).AddDays(-30)
    $endTime = $ts.ToString('yyyy-MM-ddTHH:MM:ss')
    ##Create Filter for basic auth sign-ins
    $filters = "createdDateTime ge $($endTime)Z and createdDateTime lt $($currentTime)Z and (clientAppUsed eq 'AutoDiscover' or clientAppUsed eq 'Exchange ActiveSync' or clientAppUsed eq 'Exchange Online PowerShell' or clientAppUsed eq 'Exchange Web Services' or clientAppUsed eq 'IMAP4' or clientAppUsed eq 'MAPI Over HTTP' or clientAppUsed eq 'Offline Address Book' or clientAppUsed eq 'Outlook Anywhere (RPC over HTTP)' or clientAppUsed eq 'Other clients' or clientAppUsed eq 'POP3' or clientAppUsed eq 'Reporting Web Services' or clientAppUsed eq 'Authenticated SMTP' or clientAppUsed eq 'Outlook Service')"
    if ($TenantFilter -ne 'AllTenants') {

        try {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/auditLogs/signIns?api-version=beta&filter=$($filters)" -tenantid $TenantFilter -ErrorAction Stop | Select-Object userPrincipalName, clientAppUsed, Status | Sort-Object -Unique -Property userPrincipalName
            $response = $GraphRequest
            Write-LogMessage -headers $Headers -API $APIName -message 'Retrieved basic authentication report' -Sev 'Debug' -tenant $TenantFilter

            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @($response)
                })
        } catch {
            Write-LogMessage -headers $Headers -API $APIName -message "Failed to retrieve basic authentication report: $($_.Exception.message) " -Sev 'Error' -tenant $TenantFilter
            return ([HttpResponseContext]@{
                    StatusCode = '500'
                    Body       = $(Get-NormalizedError -message $_.Exception.message)
                })
        }
    } else {
        $Table = Get-CIPPTable -TableName cachebasicauth
        $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-1)
        if (!$Rows) {
            $TenantList = Get-Tenants -IncludeErrors
            $Queue = New-CippQueueEntry -Name 'Basic Auth - All Tenants' -TotalTasks ($TenantList | Measure-Object).Count
            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'BasicAuthOrchestrator'
                QueueId          = $Queue.RowKey
                QueueFunction    = @{
                    FunctionName = 'GetTenants'
                    TenantParams = @{
                        IncludeErrors = $true
                    }
                    DurableName  = 'ListBasicAuthAllTenants'
                }
                SkipLog          = $true
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)

            $GraphRequest = [PSCustomObject]@{
                MetaData = 'Loading data for all tenants. Please check back in 10 minutes'
            }

            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @($GraphRequest)
                })
        } else {
            $GraphRequest = $Rows
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @($GraphRequest)
                })
        }
    }

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListBasicAuth.ps1' 81
#Region './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListInactiveAccounts.ps1' -1

Function Invoke-ListInactiveAccounts {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Convert the TenantFilter parameter to a list of tenant IDs for AllTenants or a single tenant ID
    $TenantFilter = $Request.Query.tenantFilter
    if ($TenantFilter -eq 'AllTenants') {
        $TenantFilter = (Get-Tenants).customerId
    } else {
        $TenantFilter = (Get-Tenants -TenantFilter $TenantFilter).customerId
    }

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/managedTenants/inactiveUsers?`$count=true" -tenantid $env:TenantID | Where-Object { $_.tenantId -in $TenantFilter }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = "Could not connect to Azure Lighthouse API: $($ErrorMessage)"
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListInactiveAccounts.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListMFAUsers.ps1' -1

Function Invoke-ListMFAUsers {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.User.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    if ($TenantFilter -ne 'AllTenants') {
        $GraphRequest = Get-CIPPMFAState -TenantFilter $TenantFilter
    } else {
        $Table = Get-CIPPTable -TableName cachemfa

        $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-2)
        if (!$Rows) {
            $TenantList = Get-Tenants -IncludeErrors
            $Queue = New-CippQueueEntry -Name 'MFA Users - All Tenants' -Link '/identity/reports/mfa-report?customerId=AllTenants' -TotalTasks ($TenantList | Measure-Object).Count
            Write-Information ($Queue | ConvertTo-Json)
            $GraphRequest = [PSCustomObject]@{
                UPN = 'Loading data for all tenants. Please check back in a few minutes'
            }
            $Batch = $TenantList | ForEach-Object {
                $_ | Add-Member -NotePropertyName FunctionName -NotePropertyValue 'ListMFAUsersQueue'
                $_ | Add-Member -NotePropertyName QueueId -NotePropertyValue $Queue.RowKey
                $_
            }
            if (($Batch | Measure-Object).Count -gt 0) {
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'ListMFAUsersOrchestrator'
                    Batch            = @($Batch)
                    SkipLog          = $true
                }
                #Write-Host ($InputObject | ConvertTo-Json)
                $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                Write-Host "Started permissions orchestration with ID = '$InstanceId'"
            }
        } else {
            $Rows = foreach ($Row in $Rows) {
                if ($Row.CAPolicies) {
                    $Row.CAPolicies = try { $Row.CAPolicies | ConvertFrom-Json } catch { $Row.CAPolicies }
                }
                if ($Row.MFAMethods) {
                    $Row.MFAMethods = try { $Row.MFAMethods | ConvertFrom-Json } catch { $Row.MFAMethods }
                }
                $Row
            }
            $GraphRequest = $Rows
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListMFAUsers.ps1' 60
#Region './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListSignIns.ps1' -1

Function Invoke-ListSignIns {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.AuditLog.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APINAME = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $Days = $Request.Query.Days ?? 7
    $FailedLogonsOnly = $Request.Query.failedLogonsOnly
    $FailureThreshold = $Request.Query.FailureThreshold
    $Filter = $Request.Query.Filter

    try {
        if ($FailedLogonsOnly -eq 'true' -or $FailedLogonsOnly -eq $true) {
            $FailedLogons = ' and (status/errorCode eq 50126)'
        }

        $Filters = if ($Filter) {
            $Filter
        } else {
            $ts = (Get-Date).AddDays(-$Days).ToUniversalTime()
            $endTime = $ts.ToString('yyyy-MM-dd')
            "createdDateTime ge $($endTime) and userDisplayName ne 'On-Premises Directory Synchronization Service Account' $FailedLogons"
        }
        Write-Host $Filters
        Write-LogMessage -headers $Headers -API $APINAME -message 'Retrieved sign in report' -Sev 'Debug' -tenant $TenantFilter

        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/auditLogs/signIns?api-version=beta&`$filter=$($Filters)" -tenantid $TenantFilter -ErrorAction Stop
        $response = $GraphRequest | Select-Object *,
        @{l = 'additionalDetails'; e = { $_.status.additionalDetails } } ,
        @{l = 'errorCode'; e = { $_.status.errorCode } },
        @{l = 'locationcipp'; e = { "$($_.location.city) - $($_.location.countryOrRegion)" } }

        if ($FailedLogonsOnly -and $FailureThreshold -and $FailureThreshold -gt 0) {
            $response = $response | Group-Object -Property userPrincipalName | Where-Object { $_.Count -ge $FailureThreshold } | Select-Object -ExpandProperty Group
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($response)
            })
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Failed to retrieve Sign In report: $($_.Exception.message) " -Sev 'Error' -tenant $TenantFilter
        return ([HttpResponseContext]@{
                StatusCode = '500'
                Body       = $(Get-NormalizedError -message $_.Exception.message)
            })
    }

}
#EndRegion './Public/Entrypoints/HTTP Functions/Identity/Reports/Invoke-ListSignIns.ps1' 60
#Region './Public/Entrypoints/HTTP Functions/New-CippCoreRequest.ps1' -1

#using namespace System.Net
#using namespace Microsoft.Azure.Functions.PowerShellWorker
function New-CippCoreRequest {
    <#
    .SYNOPSIS
        Main entrypoint for all HTTP triggered functions in CIPP
    .DESCRIPTION
        This function is the main entry point for all HTTP triggered functions in CIPP. It routes requests to the appropriate function based on the CIPPEndpoint parameter in the request.
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param($Request, $TriggerMetadata)

    # Initialize AsyncLocal storage for thread-safe per-invocation context
    if (-not $script:CippInvocationIdStorage) {
        $script:CippInvocationIdStorage = [System.Threading.AsyncLocal[string]]::new()
    }
    if (-not $script:CippAllowedTenantsStorage) {
        $script:CippAllowedTenantsStorage = [System.Threading.AsyncLocal[object]]::new()
    }
    if (-not $script:CippAllowedGroupsStorage) {
        $script:CippAllowedGroupsStorage = [System.Threading.AsyncLocal[object]]::new()
    }

    # Set InvocationId in AsyncLocal storage for console logging correlation
    if ($global:TelemetryClient -and $TriggerMetadata.InvocationId) {
        $script:CippInvocationIdStorage.Value = $TriggerMetadata.InvocationId
    }

    $FunctionName = 'Invoke-{0}' -f $Request.Params.CIPPEndpoint
    Write-Information "API Endpoint: $($Request.Params.CIPPEndpoint) | Frontend Version: $($Request.Headers.'X-CIPP-Version' ?? 'Not specified')"

    if ($Request.Headers.'X-CIPP-Version') {
        $Table = Get-CippTable -tablename 'Version'
        $FrontendVer = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Version' and RowKey eq 'frontend'"

        if (!$FrontendVer -or ([semver]$FrontendVer.Version -lt [semver]$Request.Headers.'X-CIPP-Version')) {
            Add-CIPPAzDataTableEntity @Table -Entity ([pscustomobject]@{
                    PartitionKey = 'Version'
                    RowKey       = 'frontend'
                    Version      = $Request.Headers.'X-CIPP-Version'
                }) -Force
        } elseif ([semver]$FrontendVer.Version -gt [semver]$Request.Headers.'X-CIPP-Version') {
            Write-Warning "Client version $($Request.Headers.'X-CIPP-Version') is older than the current frontend version $($FrontendVer.Version)"
        }
    }

    $HttpTrigger = @{
        Request         = [pscustomobject]($Request)
        TriggerMetadata = $TriggerMetadata
    }

    if ($PSCmdlet.ShouldProcess("Processing request for $($Request.Params.CIPPEndpoint)")) {
        # Set script scope variables for Graph API to indicate HTTP request/high priority
        $script:XMsThrottlePriority = 'high'

        if ((Get-Command -Name $FunctionName -ErrorAction SilentlyContinue) -or $FunctionName -eq 'Invoke-Me') {
            try {
                $Access = Test-CIPPAccess -Request $Request
                if ($FunctionName -eq 'Invoke-Me') {
                    return $Access
                }
            } catch {
                Write-Information "Access denied for $FunctionName : $($_.Exception.Message)"
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::Forbidden
                        Body       = $_.Exception.Message
                    })
            }

            $AllowedTenants = Test-CippAccess -Request $Request -TenantList
            $AllowedGroups = Test-CippAccess -Request $Request -GroupList

            if ($AllowedTenants -notcontains 'AllTenants') {
                Write-Warning 'Limiting tenant access'
                $script:CippAllowedTenantsStorage.Value = $AllowedTenants
            }
            if ($AllowedGroups -notcontains 'AllGroups') {
                Write-Warning 'Limiting group access'
                $script:CippAllowedGroupsStorage.Value = $AllowedGroups
            }

            try {
                Write-Information "Access: $Access"
                Write-LogMessage -headers $Headers -API $Request.Params.CIPPEndpoint -message 'Accessed this API' -Sev 'Debug'
                if ($Access) {
                    # Prepare telemetry metadata for HTTP API call
                    $metadata = @{
                        Endpoint     = $Request.Params.CIPPEndpoint
                        FunctionName = $FunctionName
                        Method       = $Request.Method
                        TriggerType  = 'HTTP'
                    }

                    # Add tenant filter if present
                    if ($Request.Query.TenantFilter) {
                        $metadata['Tenant'] = $Request.Query.TenantFilter
                    } elseif ($Request.Body.TenantFilter) {
                        $metadata['Tenant'] = $Request.Body.TenantFilter
                    }

                    # Add user info if available
                    if ($Request.Headers.'x-ms-client-principal-name') {
                        $metadata['User'] = $Request.Headers.'x-ms-client-principal-name'
                    }

                    # Wrap the API call execution with telemetry
                    $Response = Measure-CippTask -TaskName $Request.Params.CIPPEndpoint -Metadata $metadata -Script {
                        & $FunctionName @HttpTrigger
                    }

                    # Filter to only return HttpResponseContext objects
                    $HttpResponse = $Response | Where-Object { $_.PSObject.TypeNames -eq 'Microsoft.Azure.Functions.PowerShellWorker.HttpResponseContext' }
                    if ($HttpResponse) {
                        # Return the first valid HttpResponseContext found
                        return ([HttpResponseContext]($HttpResponse | Select-Object -First 1))
                    } else {
                        # If no valid response context found, create a default success response
                        if ($Response.PSObject.Properties.Name -contains 'StatusCode' -and $Response.PSObject.Properties.Name -contains 'Body') {
                            return ([HttpResponseContext]@{
                                    StatusCode = $Response.StatusCode
                                    Body       = $Response.Body
                                })
                        } else {
                            return ([HttpResponseContext]@{
                                    StatusCode = [HttpStatusCode]::OK
                                    Body       = $Response
                                })
                        }
                    }
                }
            } catch {
                Write-Warning "Exception occurred on HTTP trigger ($FunctionName): $($_.Exception.Message)"
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::InternalServerError
                        Body       = $_.Exception.Message
                    })
            }
        } else {
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::NotFound
                    Body       = 'Endpoint not found'
                })
        }
    } else {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::PreconditionFailed
                Body       = 'Request not processed'
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/New-CippCoreRequest.ps1' 153
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecAlertsList.ps1' -1

function Invoke-ExecAlertsList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    function New-FlatArray ([Array]$arr) {
        $arr | ForEach-Object {
            if ($_ -is 'Array') {
                New-FlatArray $_
            } else { $_ }
        }
    }
    try {
        # Interact with query parameters or the body of the request.
        $TenantFilter = $Request.Query.tenantFilter
        $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
            $Alerts = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/security/alerts' -tenantid $TenantFilter
            $AlertsObj = foreach ($Alert in $Alerts) {
                @{
                    Tenant        = $TenantFilter
                    GUID          = $GUID
                    Id            = $Alert.Id
                    Title         = $Alert.Title
                    Category      = $Alert.category
                    EventDateTime = $Alert.eventDateTime
                    Severity      = $Alert.Severity
                    Status        = $Alert.Status
                    RawResult     = $($Alerts | Where-Object { $_.Id -eq $Alert.Id })
                    InvolvedUsers = $($Alerts | Where-Object { $_.Id -eq $Alert.Id }).userStates
                }
            }

            $DisplayableAlerts = New-FlatArray $AlertsObj | Where-Object { $null -ne $_.Id } | Sort-Object -Property EventDateTime -Descending
            if (!$DisplayableAlerts) {
                $DisplayableAlerts = @()
            }
            $Metadata = [PSCustomObject]@{}

            [PSCustomObject]@{
                NewAlertsCount             = $DisplayableAlerts | Where-Object { $_.Status -eq 'newAlert' } | Measure-Object | Select-Object -ExpandProperty Count
                InProgressAlertsCount      = $DisplayableAlerts | Where-Object { $_.Status -eq 'inProgress' } | Measure-Object | Select-Object -ExpandProperty Count
                SeverityHighAlertsCount    = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'high' } | Measure-Object | Select-Object -ExpandProperty Count
                SeverityMediumAlertsCount  = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'medium' } | Measure-Object | Select-Object -ExpandProperty Count
                SeverityLowAlertsCount     = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'low' } | Measure-Object | Select-Object -ExpandProperty Count
                SeverityInformationalCount = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'informational' } | Measure-Object | Select-Object -ExpandProperty Count
                MSResults                  = @($DisplayableAlerts)
            }
        } else {
            $Table = Get-CIPPTable -TableName cachealertsandincidents
            $PartitionKey = 'alert'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-30)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            # If a queue is running, we will not start a new one
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
                [PSCustomObject]@{
                    Waiting = $true
                }
            } elseif (!$Rows -and !$RunningQueue) {
                # If no rows are found and no queue is running, we will start a new one
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'Alerts List - All Tenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'AlertsOrchestrator'
                    QueueFunction    = [PSCustomObject]@{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ExecAlertsListAllTenants'
                    }
                    SkipLog          = $true
                } | ConvertTo-Json -Depth 10
                $InstanceId = Start-NewOrchestration -FunctionName CIPPOrchestrator -InputObject $InputObject
                [PSCustomObject]@{
                    Waiting    = $true
                    InstanceId = $InstanceId
                }
            } else {
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }

                $Alerts = $Rows
                $AlertsObj = foreach ($Alert in $Alerts) {
                    $AlertInfo = $Alert.Alert | ConvertFrom-Json
                    @{
                        Tenant        = $Alert.Tenant
                        GUID          = $GUID
                        Id            = $AlertInfo.Id
                        Title         = $AlertInfo.Title
                        Category      = $AlertInfo.category
                        EventDateTime = $AlertInfo.eventDateTime
                        Severity      = $AlertInfo.Severity
                        Status        = $AlertInfo.Status
                        RawResult     = $AlertInfo
                        InvolvedUsers = $AlertInfo.userStates
                    }
                }
                $DisplayableAlerts = New-FlatArray $AlertsObj | Where-Object { $null -ne $_.Id } | Sort-Object -Property EventDateTime -Descending
                [PSCustomObject]@{
                    NewAlertsCount             = $DisplayableAlerts | Where-Object { $_.Status -eq 'newAlert' } | Measure-Object | Select-Object -ExpandProperty Count
                    InProgressAlertsCount      = $DisplayableAlerts | Where-Object { $_.Status -eq 'inProgress' } | Measure-Object | Select-Object -ExpandProperty Count
                    SeverityHighAlertsCount    = ($DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'high' } | Measure-Object | Select-Object -ExpandProperty Count)
                    SeverityMediumAlertsCount  = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'medium' } | Measure-Object | Select-Object -ExpandProperty Count
                    SeverityLowAlertsCount     = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'low' } | Measure-Object | Select-Object -ExpandProperty Count
                    SeverityInformationalCount = $DisplayableAlerts | Where-Object { ($_.Status -eq 'inProgress') -or ($_.Status -eq 'newAlert') } | Where-Object { $_.Severity -eq 'informational' } | Measure-Object | Select-Object -ExpandProperty Count
                    MSResults                  = ($DisplayableAlerts | Sort-Object -Property EventDateTime -Descending)
                }
            }
        }

    } catch {
        $StatusCode = [HttpStatusCode]::Forbidden
        $body = $_.Exception.message
    }
    if (!$body) {
        $StatusCode = [HttpStatusCode]::OK
        $body = @{
            Results  = $GraphRequest
            Metadata = $Metadata
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecAlertsList.ps1' 144
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecIncidentsList.ps1' -1

function Invoke-ExecIncidentsList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Incident.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
            # Single tenant functionality
            $Incidents = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/security/incidents' -tenantid $TenantFilter -AsApp $true

            foreach ($incident in $Incidents) {
                [PSCustomObject]@{
                    Tenant         = $TenantFilter
                    Id             = $incident.id
                    Status         = $incident.status
                    IncidentUrl    = $incident.incidentWebUrl
                    RedirectId     = $incident.redirectIncidentId
                    DisplayName    = $incident.displayName
                    Created        = $incident.createdDateTime
                    Updated        = $incident.lastUpdateDateTime
                    AssignedTo     = $incident.assignedTo
                    Classification = $incident.classification
                    Determination  = $incident.determination
                    Severity       = $incident.severity
                    Tags           = ($IncidentObj.tags -join ', ')
                    Comments       = $incident.comments
                }
            }
        } else {
            # AllTenants functionality
            $Table = Get-CIPPTable -TableName cachealertsandincidents
            $PartitionKey = 'Incident'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-30)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            # If a queue is running, we will not start a new one
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
            } elseif (!$Rows -and !$RunningQueue) {
                # If no rows are found and no queue is running, we will start a new one
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'Incidents - All Tenants' -Link '/security/reports/incident-report?customerId=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'IncidentOrchestrator'
                    QueueFunction    = @{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ExecIncidentsListAllTenants'
                    }
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress) | Out-Null
            } else {
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }
                $Incidents = $Rows
                foreach ($incident in $Incidents) {
                    $IncidentObj = $incident.Incident | ConvertFrom-Json
                    [PSCustomObject]@{
                        Tenant         = $incident.Tenant
                        Id             = $IncidentObj.id
                        Status         = $IncidentObj.status
                        IncidentUrl    = $IncidentObj.incidentWebUrl
                        RedirectId     = $IncidentObj.redirectIncidentId
                        DisplayName    = $IncidentObj.displayName
                        Created        = $IncidentObj.createdDateTime
                        Updated        = $IncidentObj.lastUpdateDateTime
                        AssignedTo     = $IncidentObj.assignedTo
                        Classification = $IncidentObj.classification
                        Determination  = $IncidentObj.determination
                        Severity       = $IncidentObj.severity
                        Tags           = ($IncidentObj.tags -join ', ')
                        Comments       = @($IncidentObj.comments)
                    }
                }
            }
        }
    } catch {
        $Body = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    if (!$Body) {
        $StatusCode = [HttpStatusCode]::OK
        $Body = [PSCustomObject]@{
            Results  = @($GraphRequest | Where-Object -Property id -NE $null | Sort-Object id -Descending)
            Metadata = $Metadata
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecIncidentsList.ps1' 114
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecMdoAlertsList.ps1' -1

function Invoke-ExecMDOAlertsList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
            # Single tenant functionality
            New-GraphGetRequest -uri "https://graph.microsoft.com/beta/security/alerts_v2?`$filter=serviceSource eq 'microsoftDefenderForOffice365'" -tenantid $TenantFilter
        } else {
            # AllTenants functionality
            $Table = Get-CIPPTable -TableName cachealertsandincidents
            $PartitionKey = 'MdoAlert'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-30)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            # If a queue is running, we will not start a new one
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
            } elseif (!$Rows -and !$RunningQueue) {
                # If no rows are found and no queue is running, we will start a new one
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'MDO Alerts - All Tenants' -Link '/security/reports/mdo-alerts?customerId=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'MdoAlertsOrchestrator'
                    QueueFunction    = @{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ExecMdoAlertsListAllTenants'
                    }
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress) | Out-Null
            } else {
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }
                $Alerts = $Rows
                foreach ($alert in $Alerts) {
                    ConvertFrom-Json -InputObject $alert.MdoAlert -Depth 10
                }
            }
        }
    } catch {
        $Body = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    if (!$Body) {
        $StatusCode = [HttpStatusCode]::OK
        $Body = [PSCustomObject]@{
            Results  = @($GraphRequest)
            Metadata = $Metadata
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecMdoAlertsList.ps1' 78
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetMdoAlert.ps1' -1

function Invoke-ExecSetMdoAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Incident.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $AlertId = $Request.Query.GUID ?? $Request.Body.GUID
    $Status = $Request.Query.Status ?? $Request.Body.Status
    $Assigned = $Request.Query.Assigned ?? $Request.Body.Assigned ?? ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails
    $Classification = $Request.Query.Classification ?? $Request.Body.Classification
    $Determination = $Request.Query.Determination ?? $Request.Body.Determination
    $Result = ''
    $AssignBody = @{}

    try {
        # Set received status
        if ($null -ne $Status) {
            $AssignBody.status = $Status
            $Result += 'Set status for incident ' + $AlertId + ' to ' + $Status
        }

        # Set received classification and determination
        if ($null -ne $Classification) {
            if ($null -eq $Determination) {
                # Maybe some poindexter tries to send a classification without a determination
                throw
            }

            $AssignBody.classification = $Classification
            $AssignBody.determination = $Determination
            $Result += 'Set classification & determination for incident ' + $AlertId + ' to ' + $Classification + ' ' + $Determination
        }

        # Set received assignee
        if ($null -ne $Assigned) {
            $AssignBody.assignedTo = $Assigned
            if ($null -eq $Status) {
                $Result += 'Set assigned for incident ' + $AlertId + ' to ' + $Assigned
            }
        }

        # Convert hashtable to JSON
        $AssignBodyJson = $AssignBody | ConvertTo-Json -Compress

        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/security/alerts_v2/$AlertId" -type PATCH -tenantid $TenantFilter -body $AssignBodyJson -asApp $true
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to update incident $AlertId : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetMdoAlert.ps1' 72
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetSecurityAlert.ps1' -1

Function Invoke-ExecSetSecurityAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $AlertFilter = $Request.Query.GUID ?? $Request.Body.GUID
    $Status = $Request.Query.Status ?? $Request.Body.Status
    $Vendor = $Request.Query.Vendor ?? $Request.Body.Vendor
    $Provider = $Request.Query.Provider ?? $Request.Body.Provider
    $AssignBody = '{"status":"' + $Status + '","vendorInformation":{"provider":"' + $Provider + '","vendor":"' + $Vendor + '"}}'

    try {
        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/security/alerts/$AlertFilter" -type PATCH -tenantid $TenantFilter -body $AssignBody
        $Result = "Set alert $AlertFilter to status $Status"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to update alert $($AlertFilter): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetSecurityAlert.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetSecurityIncident.ps1' -1

Function Invoke-ExecSetSecurityIncident {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.Incident.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $first = ''
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $IncidentFilter = $Request.Query.GUID ?? $Request.Body.GUID
    $Status = $Request.Query.Status ?? $Request.Body.Status
    # $Assigned = $Request.Query.Assigned ?? $Request.Body.Assigned ?? $Headers.'x-ms-client-principal'
    $Assigned = $Request.Query.Assigned ?? $Request.Body.Assigned ?? ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails
    $Classification = $Request.Query.Classification ?? $Request.Body.Classification
    $Determination = $Request.Query.Determination ?? $Request.Body.Determination
    $Redirected = $Request.Query.Redirected -as [int] ?? $Request.Body.Redirected -as [int]
    $BodyBuild
    $AssignBody = '{'

    try {
        # We won't update redirected incidents because the incident it is redirected to should instead be updated
        if ($Redirected -lt 1) {
            # Set received status
            if ($null -ne $Status) {
                $AssignBody += $first + '"status":"' + $Status + '"'
                $BodyBuild += $first + 'Set status for incident ' + $IncidentFilter + ' to ' + $Status
                $first = ', '
            }

            # Set received classification and determination
            if ($null -ne $Classification) {
                if ($null -eq $Determination) {
                    # Maybe some poindexter tries to send a classification without a determination
                    throw
                }

                $AssignBody += $first + '"classification":"' + $Classification + '", "determination":"' + $Determination + '"'
                $BodyBuild += $first + 'Set classification & determination for incident ' + $IncidentFilter + ' to ' + $Classification + ' ' + $Determination
                $first = ', '
            }

            # Set received assignee
            if ($null -ne $Assigned) {
                $AssignBody += $first + '"assignedTo":"' + $Assigned + '"'
                if ($null -eq $Status) {
                    $BodyBuild += $first + 'Set assigned for incident ' + $IncidentFilter + ' to ' + $Assigned
                }
                $first = ', '
            }

            $AssignBody += '}'

            $ResponseBody = [pscustomobject]@{'Results' = $BodyBuild }
            New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/security/incidents/$IncidentFilter" -type PATCH -tenantid $TenantFilter -body $AssignBody -asApp $true
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Update incident $IncidentFilter with values $AssignBody" -Sev 'Info'
        } else {
            $ResponseBody = [pscustomobject]@{'Results' = "Refused to update incident $IncidentFilter with values $AssignBody because it is redirected to another incident" }
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Refused to update incident $IncidentFilter with values $AssignBody because it is redirected to another incident" -Sev 'Info'
        }

        $body = $ResponseBody
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to update incident $IncidentFilter : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = $Result }
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Invoke-ExecSetSecurityIncident.ps1' 85
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-AddSafeLinksPolicyFromTemplate.ps1' -1

Function Invoke-AddSafeLinksPolicyFromTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SafeLinks.ReadWrite
    .DESCRIPTION
        This function deploys SafeLinks policies and rules from templates to selected tenants.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    try {
        $RequestBody = $Request.Body

        # Extract tenant IDs from selectedTenants
        $SelectedTenants = $RequestBody.selectedTenants | ForEach-Object { $_.value }
        if ('AllTenants' -in $SelectedTenants) {
            $SelectedTenants = (Get-Tenants).defaultDomainName
        }

        # Extract templates from TemplateList
        $Templates = $RequestBody.TemplateList | ForEach-Object { $_.value }

        if (-not $Templates -or $Templates.Count -eq 0) {
            throw "No templates provided in TemplateList"
        }

        # Helper function to process array fields with cleaner logic
        function ConvertTo-SafeArray {
            param($Field)

            if ($null -eq $Field) { return @() }

            # Handle arrays
            if ($Field -is [array]) {
                return $Field | ForEach-Object {
                    if ($_ -is [string]) { $_ }
                    elseif ($_.value) { $_.value }
                    elseif ($_.userPrincipalName) { $_.userPrincipalName }
                    elseif ($_.id) { $_.id }
                    else { $_.ToString() }
                }
            }

            # Handle single objects
            if ($Field -is [hashtable] -or $Field -is [PSCustomObject]) {
                if ($Field.value) { return @($Field.value) }
                if ($Field.userPrincipalName) { return @($Field.userPrincipalName) }
                if ($Field.id) { return @($Field.id) }
            }

            # Handle strings
            if ($Field -is [string]) { return @($Field) }

            return @($Field)
        }

        function Test-PolicyExists {
            param($TenantFilter, $PolicyName)

            $ExistingPolicies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeLinksPolicy' -useSystemMailbox $true
            return $ExistingPolicies | Where-Object { $_.Name -eq $PolicyName }
        }

        function Test-RuleExists {
            param($TenantFilter, $RuleName)

            $ExistingRules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeLinksRule' -useSystemMailbox $true
            return $ExistingRules | Where-Object { $_.Name -eq $RuleName }
        }

        function New-SafeLinksPolicyFromTemplate {
            param($TenantFilter, $Template)

            $PolicyName = $Template.PolicyName
            $RuleName = $Template.RuleName ?? "$($PolicyName)_Rule"

            # Check if policy already exists
            if (Test-PolicyExists -TenantFilter $TenantFilter -PolicyName $PolicyName) {
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Policy '$PolicyName' already exists" -Sev 'Warning'
                return "Policy '$PolicyName' already exists in tenant $TenantFilter"
            }

            # Check if rule already exists
            if (Test-RuleExists -TenantFilter $TenantFilter -RuleName $RuleName) {
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Rule '$RuleName' already exists" -Sev 'Warning'
                return "Rule '$RuleName' already exists in tenant $TenantFilter"
            }

            # Process array fields
            $DoNotRewriteUrls = ConvertTo-SafeArray -Field $Template.DoNotRewriteUrls
            $SentTo = ConvertTo-SafeArray -Field $Template.SentTo
            $SentToMemberOf = ConvertTo-SafeArray -Field $Template.SentToMemberOf
            $RecipientDomainIs = ConvertTo-SafeArray -Field $Template.RecipientDomainIs
            $ExceptIfSentTo = ConvertTo-SafeArray -Field $Template.ExceptIfSentTo
            $ExceptIfSentToMemberOf = ConvertTo-SafeArray -Field $Template.ExceptIfSentToMemberOf
            $ExceptIfRecipientDomainIs = ConvertTo-SafeArray -Field $Template.ExceptIfRecipientDomainIs

            # Create policy parameters
            $PolicyParams = @{ Name = $PolicyName }

            # Policy configuration mapping
            $PolicyMappings = @{
                'EnableSafeLinksForEmail' = 'EnableSafeLinksForEmail'
                'EnableSafeLinksForTeams' = 'EnableSafeLinksForTeams'
                'EnableSafeLinksForOffice' = 'EnableSafeLinksForOffice'
                'TrackClicks' = 'TrackClicks'
                'AllowClickThrough' = 'AllowClickThrough'
                'ScanUrls' = 'ScanUrls'
                'EnableForInternalSenders' = 'EnableForInternalSenders'
                'DeliverMessageAfterScan' = 'DeliverMessageAfterScan'
                'DisableUrlRewrite' = 'DisableUrlRewrite'
                'AdminDisplayName' = 'AdminDisplayName'
                'CustomNotificationText' = 'CustomNotificationText'
                'EnableOrganizationBranding' = 'EnableOrganizationBranding'
            }

            foreach ($templateKey in $PolicyMappings.Keys) {
                if ($null -ne $Template.$templateKey) {
                    $PolicyParams[$PolicyMappings[$templateKey]] = $Template.$templateKey
                }
            }

            if ($DoNotRewriteUrls.Count -gt 0) {
                $PolicyParams['DoNotRewriteUrls'] = $DoNotRewriteUrls
            }

            # Create SafeLinks Policy
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-SafeLinksPolicy' -cmdParams $PolicyParams -useSystemMailbox $true
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Created SafeLinks policy '$PolicyName'" -Sev 'Info'

            # Create rule parameters
            $RuleParams = @{
                Name = $RuleName
                SafeLinksPolicy = $PolicyName
            }

            # Rule configuration mapping
            $RuleMappings = @{
                'Priority' = 'Priority'
                'TemplateDescription' = 'Comments'
            }

            foreach ($templateKey in $RuleMappings.Keys) {
                if ($null -ne $Template.$templateKey) {
                    $RuleParams[$RuleMappings[$templateKey]] = $Template.$templateKey
                }
            }

            # Add array parameters if they have values
            $ArrayMappings = @{
                'SentTo' = $SentTo
                'SentToMemberOf' = $SentToMemberOf
                'RecipientDomainIs' = $RecipientDomainIs
                'ExceptIfSentTo' = $ExceptIfSentTo
                'ExceptIfSentToMemberOf' = $ExceptIfSentToMemberOf
                'ExceptIfRecipientDomainIs' = $ExceptIfRecipientDomainIs
            }

            foreach ($paramName in $ArrayMappings.Keys) {
                if ($ArrayMappings[$paramName].Count -gt 0) {
                    $RuleParams[$paramName] = $ArrayMappings[$paramName]
                }
            }

            # Create SafeLinks Rule
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-SafeLinksRule' -cmdParams $RuleParams -useSystemMailbox $true
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Created SafeLinks rule '$RuleName'" -Sev 'Info'

            # Handle rule state
            $StateMessage = ""
            if ($null -ne $Template.State) {
                $IsState = switch ($Template.State) {
                    "Enabled" { $true }
                    "Disabled" { $false }
                    $true { $true }
                    $false { $false }
                    default { $null }
                }

                if ($null -ne $IsState) {
                    $Cmdlet = $IsState ? 'Enable-SafeLinksRule' : 'Disable-SafeLinksRule'
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet $Cmdlet -cmdParams @{ Identity = $RuleName } -useSystemMailbox $true
                    $StateMessage = " (rule $($IsState ? 'enabled' : 'disabled'))"
                }
            }

            return "Successfully deployed SafeLinks policy '$PolicyName' and rule '$RuleName' to tenant $TenantFilter$StateMessage"
        }

        # Process each tenant and template combination
        $Results = foreach ($TenantFilter in $SelectedTenants) {
            foreach ($Template in $Templates) {
                try {
                    New-SafeLinksPolicyFromTemplate -TenantFilter $TenantFilter -Template $Template
                }
                catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    $ErrorDetail = "Failed to deploy template '$($Template.TemplateName)' to tenant $TenantFilter. Error: $($ErrorMessage.NormalizedError)"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ErrorDetail -Sev 'Error'
                    $ErrorDetail
                }
            }
        }

        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to process template deployment request. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    # Return response
    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body = @{ Results = $Results }
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-AddSafeLinksPolicyFromTemplate.ps1' 226
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-AddSafeLinksPolicyTemplate.ps1' -1

Function Invoke-AddSafeLinksPolicyTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    # Debug: Log the incoming request body
    Write-LogMessage -Headers $Headers -API $APINAME -message "Request body: $($Request.body | ConvertTo-Json -Depth 5 -Compress)" -Sev Debug

    try {
        $GUID = (New-Guid).GUID

        # Validate required fields
        if ([string]::IsNullOrEmpty($Request.body.Name)) {
            throw "Template name is required but was not provided"
        }

        if ([string]::IsNullOrEmpty($Request.body.PolicyName)) {
            throw "Policy name is required but was not provided"
        }

        # Create a new ordered hashtable to store selected properties
        $policyObject = [ordered]@{}

        # Set name and comments - prioritize template-specific fields
        $policyObject["TemplateName"] = $Request.body.TemplateName
        $policyObject["TemplateDescription"] = $Request.body.TemplateDescription

        # For templates, if no specific policy description is provided, use template description as default
        if ([string]::IsNullOrEmpty($Request.body.AdminDisplayName) -and -not [string]::IsNullOrEmpty($Request.body.Description)) {
            $Request.body.AdminDisplayName = $Request.body.Description
            Write-LogMessage -Headers $Headers -API $APINAME -message "Using template description as default policy description" -Sev Debug
        }

        # Log what we're using for template name and description
        Write-LogMessage -Headers $Headers -API $APINAME -message "Template Name: '$($policyObject.TemplateName)', Description: '$($policyObject.TemplateDescription)'" -Sev Debug

        # Copy specific properties we want to keep
        $propertiesToKeep = @(
            # Policy properties
            "PolicyName", "EnableSafeLinksForEmail", "EnableSafeLinksForTeams", "EnableSafeLinksForOffice",
            "TrackClicks", "AllowClickThrough", "ScanUrls", "EnableForInternalSenders",
            "DeliverMessageAfterScan", "DisableUrlRewrite", "DoNotRewriteUrls",
            "AdminDisplayName", "CustomNotificationText", "EnableOrganizationBranding",
            # Rule properties
            "RuleName", "Priority", "State", "Comments",
            "SentTo", "SentToMemberOf", "RecipientDomainIs",
            "ExceptIfSentTo", "ExceptIfSentToMemberOf", "ExceptIfRecipientDomainIs"
        )

        # Copy each property if it exists
        foreach ($prop in $propertiesToKeep) {
            if ($null -ne $Request.body.$prop) {
                $policyObject[$prop] = $Request.body.$prop
                Write-LogMessage -Headers $Headers -API $APINAME -message "Added property '$prop' with value '$($Request.body.$prop)'" -Sev Debug
            }
        }

        # Convert to JSON
        $JSON = $policyObject | ConvertTo-Json -Depth 10
        Write-LogMessage -Headers $Headers -API $APINAME -message "Final JSON: $JSON" -Sev Debug

        # Save the template to Azure Table Storage
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'SafeLinksTemplate'
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Created SafeLinks Policy Template '$($policyObject.TemplateName)' with GUID $GUID" -Sev Info
        $body = [pscustomobject]@{'Results' = "Created SafeLinks Policy Template '$($policyObject.TemplateName)' with GUID $GUID" }
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to create SafeLinks policy template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to create SafeLinks policy template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-AddSafeLinksPolicyTemplate.ps1' 95
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-CreateSafeLinksPolicyTemplate.ps1' -1

Function Invoke-CreateSafeLinksPolicyTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.ReadWrite
    .DESCRIPTION
        This function creates a new Safe Links policy template from scratch.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    try {
        $GUID = (New-Guid).GUID

        # Create a new ordered hashtable to store selected properties
        $policyObject = [ordered]@{}

        # Set name and comments first
        $policyObject["TemplateName"] = $Request.body.TemplateName
        $policyObject["TemplateDescription"] = $Request.body.TemplateDescription

        # Copy specific properties we want to keep
        $propertiesToKeep = @(
            # Policy properties
            "PolicyName", "EnableSafeLinksForEmail", "EnableSafeLinksForTeams", "EnableSafeLinksForOffice",
            "TrackClicks", "AllowClickThrough", "ScanUrls", "EnableForInternalSenders",
            "DeliverMessageAfterScan", "DisableUrlRewrite", "DoNotRewriteUrls",
            "AdminDisplayName", "CustomNotificationText", "EnableOrganizationBranding",

            # Rule properties
            "RuleName", "Priority", "State", "Comments",
            "SentTo", "SentToMemberOf", "RecipientDomainIs",
            "ExceptIfSentTo", "ExceptIfSentToMemberOf", "ExceptIfRecipientDomainIs"
        )

        # Copy each property if it exists
        foreach ($prop in $propertiesToKeep) {
            if ($null -ne $Request.body.$prop) {
                $policyObject[$prop] = $Request.body.$prop
            }
        }

        # Convert to JSON
        $JSON = $policyObject | ConvertTo-Json -Depth 10

        # Save the template to Azure Table Storage
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'SafeLinksTemplate'
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Created SafeLinks Policy Template $($policyObject.TemplateName) with GUID $GUID" -Sev Info
        $body = [pscustomobject]@{'Results' = "Created SafeLinks Policy Template $($policyObject.TemplateName) with GUID $GUID" }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to create SafeLinks policy template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to create SafeLinks policy template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-CreateSafeLinksPolicyTemplate.ps1' 75
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-EditSafeLinksPolicy.ps1' -1

function Invoke-EditSafeLinksPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    .DESCRIPTION
        This function modifies an existing Safe Links policy and its associated rule.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $PolicyName = $Request.Query.PolicyName ?? $Request.Body.PolicyName
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName

    # Helper function to process array fields
    function Process-ArrayField {
        param (
            [Parameter(Mandatory = $false)]
            $Field
        )

        if ($null -eq $Field) { return @() }

        # If already an array, process each item
        if ($Field -is [array]) {
            $result = [System.Collections.ArrayList]@()
            foreach ($item in $Field) {
                if ($item -is [string]) {
                    $result.Add($item) | Out-Null
                }
                elseif ($item -is [hashtable] -or $item -is [PSCustomObject]) {
                    # Extract value from object
                    if ($null -ne $item.value) {
                        $result.Add($item.value) | Out-Null
                    }
                    elseif ($null -ne $item.userPrincipalName) {
                        $result.Add($item.userPrincipalName) | Out-Null
                    }
                    elseif ($null -ne $item.id) {
                        $result.Add($item.id) | Out-Null
                    }
                    else {
                        $result.Add($item.ToString()) | Out-Null
                    }
                }
                else {
                    $result.Add($item.ToString()) | Out-Null
                }
            }
            return $result.ToArray()
        }

        # If it's a single object
        if ($Field -is [hashtable] -or $Field -is [PSCustomObject]) {
            if ($null -ne $Field.value) { return @($Field.value) }
            if ($null -ne $Field.userPrincipalName) { return @($Field.userPrincipalName) }
            if ($null -ne $Field.id) { return @($Field.id) }
        }

        # If it's a string, return as an array with one item
        if ($Field -is [string]) {
            return @($Field)
        }

        return @($Field)
    }

    # Extract policy parameters from body
    $EnableSafeLinksForEmail = $Request.Body.EnableSafeLinksForEmail
    $EnableSafeLinksForTeams = $Request.Body.EnableSafeLinksForTeams
    $EnableSafeLinksForOffice = $Request.Body.EnableSafeLinksForOffice
    $TrackClicks = $Request.Body.TrackClicks
    $AllowClickThrough = $Request.Body.AllowClickThrough
    $ScanUrls = $Request.Body.ScanUrls
    $EnableForInternalSenders = $Request.Body.EnableForInternalSenders
    $DeliverMessageAfterScan = $Request.Body.DeliverMessageAfterScan
    $DisableUrlRewrite = $Request.Body.DisableUrlRewrite
    $DoNotRewriteUrls = Process-ArrayField -Field $Request.Body.DoNotRewriteUrls
    $AdminDisplayName = $Request.Body.AdminDisplayName
    $CustomNotificationText = $Request.Body.CustomNotificationText
    $EnableOrganizationBranding = $Request.Body.EnableOrganizationBranding

    # Extract rule parameters from body
    $Priority = $Request.Body.Priority
    $Comments = $Request.Body.Comments
    $State = $Request.Body.State

    # Process recipient-related parameters
    $SentTo = Process-ArrayField -Field $Request.Body.SentTo
    $SentToMemberOf = Process-ArrayField -Field $Request.Body.SentToMemberOf
    $RecipientDomainIs = Process-ArrayField -Field $Request.Body.RecipientDomainIs
    $ExceptIfSentTo = Process-ArrayField -Field $Request.Body.ExceptIfSentTo
    $ExceptIfSentToMemberOf = Process-ArrayField -Field $Request.Body.ExceptIfSentToMemberOf
    $ExceptIfRecipientDomainIs = Process-ArrayField -Field $Request.Body.ExceptIfRecipientDomainIs

    $Results = [System.Collections.ArrayList]@()
    $hasPolicyParams = $false
    $hasRuleParams = $false
    $hasRuleOperation = $false
    $ruleMessages = [System.Collections.ArrayList]@()

    try {
        # Check which types of updates we need to perform
        # PART 1: Build and check policy parameters
        $policyParams = @{
            Identity = $PolicyName
        }

        # Only add parameters that are explicitly provided
        if ($null -ne $EnableSafeLinksForEmail) { $policyParams.Add('EnableSafeLinksForEmail', $EnableSafeLinksForEmail); $hasPolicyParams = $true }
        if ($null -ne $EnableSafeLinksForTeams) { $policyParams.Add('EnableSafeLinksForTeams', $EnableSafeLinksForTeams); $hasPolicyParams = $true }
        if ($null -ne $EnableSafeLinksForOffice) { $policyParams.Add('EnableSafeLinksForOffice', $EnableSafeLinksForOffice); $hasPolicyParams = $true }
        if ($null -ne $TrackClicks) { $policyParams.Add('TrackClicks', $TrackClicks); $hasPolicyParams = $true }
        if ($null -ne $AllowClickThrough) { $policyParams.Add('AllowClickThrough', $AllowClickThrough); $hasPolicyParams = $true }
        if ($null -ne $ScanUrls) { $policyParams.Add('ScanUrls', $ScanUrls); $hasPolicyParams = $true }
        if ($null -ne $EnableForInternalSenders) { $policyParams.Add('EnableForInternalSenders', $EnableForInternalSenders); $hasPolicyParams = $true }
        if ($null -ne $DeliverMessageAfterScan) { $policyParams.Add('DeliverMessageAfterScan', $DeliverMessageAfterScan); $hasPolicyParams = $true }
        if ($null -ne $DisableUrlRewrite) { $policyParams.Add('DisableUrlRewrite', $DisableUrlRewrite); $hasPolicyParams = $true }
        if ($null -ne $DoNotRewriteUrls -and $DoNotRewriteUrls.Count -gt 0) { $policyParams.Add('DoNotRewriteUrls', $DoNotRewriteUrls); $hasPolicyParams = $true }
        if ($null -ne $AdminDisplayName) { $policyParams.Add('AdminDisplayName', $AdminDisplayName); $hasPolicyParams = $true }
        if ($null -ne $CustomNotificationText) { $policyParams.Add('CustomNotificationText', $CustomNotificationText); $hasPolicyParams = $true }
        if ($null -ne $EnableOrganizationBranding) { $policyParams.Add('EnableOrganizationBranding', $EnableOrganizationBranding); $hasPolicyParams = $true }

        # PART 2: Build and check rule parameters
        $ruleParams = @{
            Identity = $RuleName
        }

        # Add parameters that are explicitly provided
        if ($null -ne $Comments) { $ruleParams.Add('Comments', $Comments); $hasRuleParams = $true }
        if ($null -ne $Priority) { $ruleParams.Add('Priority', $Priority); $hasRuleParams = $true }
        if ($SentTo.Count -gt 0) { $ruleParams.Add('SentTo', $SentTo); $hasRuleParams = $true }
        if ($SentToMemberOf.Count -gt 0) { $ruleParams.Add('SentToMemberOf', $SentToMemberOf); $hasRuleParams = $true }
        if ($RecipientDomainIs.Count -gt 0) { $ruleParams.Add('RecipientDomainIs', $RecipientDomainIs); $hasRuleParams = $true }
        if ($ExceptIfSentTo.Count -gt 0) { $ruleParams.Add('ExceptIfSentTo', $ExceptIfSentTo); $hasRuleParams = $true }
        if ($ExceptIfSentToMemberOf.Count -gt 0) { $ruleParams.Add('ExceptIfSentToMemberOf', $ExceptIfSentToMemberOf); $hasRuleParams = $true }
        if ($ExceptIfRecipientDomainIs.Count -gt 0) { $ruleParams.Add('ExceptIfRecipientDomainIs', $ExceptIfRecipientDomainIs); $hasRuleParams = $true }

        # Now perform only the necessary operations

        # PART 1: Update policy if needed
        if ($hasPolicyParams) {
            $ExoPolicyRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = 'Set-SafeLinksPolicy'
                cmdParams        = $policyParams
                useSystemMailbox = $true
            }

            $null = New-ExoRequest @ExoPolicyRequestParam
            $Results.Add("Successfully updated SafeLinks policy '$PolicyName'") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Updated SafeLinks policy '$PolicyName'" -Sev 'Info'
        }

        # PART 2: Update rule if needed
        if ($hasRuleParams) {
            $ExoRuleRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = 'Set-SafeLinksRule'
                cmdParams        = $ruleParams
                useSystemMailbox = $true
            }

            $null = New-ExoRequest @ExoRuleRequestParam
            $hasRuleOperation = $true
            $ruleMessages.Add("updated properties") | Out-Null
        }

        # Handle enable/disable if needed
        if ($null -ne $State) {
            $EnableCmdlet = $State ? 'Enable-SafeLinksRule' : 'Disable-SafeLinksRule'
            $EnableRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = $EnableCmdlet
                cmdParams        = @{
                    Identity = $RuleName
                }
                useSystemMailbox = $true
            }

            $null = New-ExoRequest @EnableRequestParam
            $hasRuleOperation = $true
            $State = $State ? "enabled" : "disabled"
            $ruleMessages.Add($State) | Out-Null
        }

        # Add combined rule message if any rule operations were performed
        if ($hasRuleOperation) {
            $ruleOperations = $ruleMessages -join " and "
            $Results.Add("Successfully $ruleOperations SafeLinks rule '$RuleName'") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "$ruleOperations SafeLinks rule '$RuleName'" -Sev 'Info'
        }

        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results.Add("Failed updating SafeLinks configuration '$PolicyName'. Error: $($ErrorMessage.NormalizedError)") | Out-Null
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed updating SafeLinks configuration '$PolicyName'. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Results }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-EditSafeLinksPolicy.ps1' 215
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-EditSafeLinksPolicyTemplate.ps1' -1

Function Invoke-EditSafeLinksPolicyTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.ReadWrite
    .DESCRIPTION
        This function updates an existing Safe Links policy template.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APINAME -message 'Accessed this API' -Sev Debug

    try {
        $ID = $Request.Body.ID

        if (-not $ID) {
            throw "Template ID is required"
        }

        # Check if template exists
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'SafeLinksTemplate' and RowKey eq '$ID'"
        $ExistingTemplate = Get-CIPPAzDataTableEntity @Table -Filter $Filter

        if (-not $ExistingTemplate) {
            throw "Template with ID '$ID' not found"
        }

        # Create a new ordered hashtable to store selected properties
        $policyObject = [ordered]@{}

        # Set name and comments
        $policyObject["TemplateName"] = $Request.body.TemplateName
        $policyObject["TemplateDescription"] = $Request.body.TemplateDescription

        # Copy specific properties we want to keep
        $propertiesToKeep = @(
            # Policy properties
            "PolicyName", "EnableSafeLinksForEmail", "EnableSafeLinksForTeams", "EnableSafeLinksForOffice",
            "TrackClicks", "AllowClickThrough", "ScanUrls", "EnableForInternalSenders",
            "DeliverMessageAfterScan", "DisableUrlRewrite", "DoNotRewriteUrls",
            "AdminDisplayName", "CustomNotificationText", "EnableOrganizationBranding",

            # Rule properties
            "RuleName", "Priority", "State", "Comments",
            "SentTo", "SentToMemberOf", "RecipientDomainIs",
            "ExceptIfSentTo", "ExceptIfSentToMemberOf", "ExceptIfRecipientDomainIs"
        )

        # Copy each property if it exists
        foreach ($prop in $propertiesToKeep) {
            if ($null -ne $Request.body.$prop) {
                $policyObject[$prop] = $Request.body.$prop
            }
        }

        # Convert to JSON
        $JSON = $policyObject | ConvertTo-Json -Depth 10

        # Update the template in Azure Table Storage
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$ID"
            PartitionKey = 'SafeLinksTemplate'
        }

        Write-LogMessage -Headers $Headers -API $APINAME -message "Updated SafeLinks Policy Template $($policyObject.TemplateName) with ID $ID" -Sev Info
        $body = [pscustomobject]@{'Results' = "Updated SafeLinks Policy Template $($policyObject.TemplateName) with ID $ID" }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APINAME -message "Failed to update SafeLinks policy template: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        $body = [pscustomobject]@{'Results' = "Failed to update SafeLinks policy template: $($ErrorMessage.NormalizedError)" }
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-EditSafeLinksPolicyTemplate.ps1' 87
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ExecDeleteSafeLinksPolicy.ps1' -1

function Invoke-ExecDeleteSafeLinksPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    .DESCRIPTION
        This function deletes a Safe Links rule and its associated policy.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName
    $PolicyName = $Request.Query.PolicyName ?? $Request.Body.PolicyName

    $ResultMessages = [System.Collections.ArrayList]@()

    try {
        # Only try to delete the rule if a name was provided
        if ($RuleName) {
            try {
                $ExoRequestRuleParam = @{
                    tenantid         = $TenantFilter
                    cmdlet           = 'Remove-SafeLinksRule'
                    cmdParams        = @{
                        Identity = $RuleName
                        Confirm  = $false
                    }
                    useSystemMailbox = $true
                }
                $null = New-ExoRequest @ExoRequestRuleParam
                $ResultMessages.Add("Successfully deleted SafeLinks rule '$RuleName'") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully deleted SafeLinks rule '$RuleName'" -Sev 'Info'
            }
            catch {
                $ErrorMessage = Get-CippException -Exception $_
                $ResultMessages.Add("Failed to delete SafeLinks rule '$RuleName'. Error: $($ErrorMessage.NormalizedError)") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to delete SafeLinks rule '$RuleName'. Error: $($ErrorMessage.NormalizedError)" -Sev 'Warning'
            }
        }
        else {
            $ResultMessages.Add("No rule name provided, skipping rule deletion") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "No rule name provided, skipping rule deletion" -Sev 'Info'
        }

        # Only try to delete the policy if a name was provided
        if ($PolicyName) {
            try {
                $ExoRequestPolicyParam = @{
                    tenantid         = $TenantFilter
                    cmdlet           = 'Remove-SafeLinksPolicy'
                    cmdParams        = @{
                        Identity = $PolicyName
                        Confirm  = $false
                    }
                    useSystemMailbox = $true
                }
                $null = New-ExoRequest @ExoRequestPolicyParam
                $ResultMessages.Add("Successfully deleted SafeLinks policy '$PolicyName'") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully deleted SafeLinks policy '$PolicyName'" -Sev 'Info'
            }
            catch {
                $ErrorMessage = Get-CippException -Exception $_
                $ResultMessages.Add("Failed to delete SafeLinks policy '$PolicyName'. Error: $($ErrorMessage.NormalizedError)") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to delete SafeLinks policy '$PolicyName'. Error: $($ErrorMessage.NormalizedError)" -Sev 'Warning'
            }
        }
        else {
            $ResultMessages.Add("No policy name provided, skipping policy deletion") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "No policy name provided, skipping policy deletion" -Sev 'Info'
        }

        # Combine all result messages
        $Result = $ResultMessages -join " | "
        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "An unexpected error occurred: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ExecDeleteSafeLinksPolicy.ps1' 93
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ExecNewSafeLinksPolicy.ps1' -1

function Invoke-ExecNewSafeLinksPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    .DESCRIPTION
        This function creates a new Safe Links policy and an associated rule.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter

    # Extract policy settings from body
    $PolicyName = $Request.Body.PolicyName
    $EnableSafeLinksForEmail = $Request.Body.EnableSafeLinksForEmail
    $EnableSafeLinksForTeams = $Request.Body.EnableSafeLinksForTeams
    $EnableSafeLinksForOffice = $Request.Body.EnableSafeLinksForOffice
    $TrackClicks = $Request.Body.TrackClicks
    $AllowClickThrough = $Request.Body.AllowClickThrough
    $ScanUrls = $Request.Body.ScanUrls
    $EnableForInternalSenders = $Request.Body.EnableForInternalSenders
    $DeliverMessageAfterScan = $Request.Body.DeliverMessageAfterScan
    $DisableUrlRewrite = $Request.Body.DisableUrlRewrite
    $DoNotRewriteUrls = $Request.Body.DoNotRewriteUrls
    $AdminDisplayName = $Request.Body.AdminDisplayName
    $CustomNotificationText = $Request.Body.CustomNotificationText
    $EnableOrganizationBranding = $Request.Body.EnableOrganizationBranding

    # Extract rule settings from body
    $Priority = $Request.Body.Priority
    $Comments = $Request.Body.Comments
    $State = $Request.Body.State
    $RuleName = $Request.Body.RuleName

    # Extract recipient fields and handle different input formats
    $SentTo = $Request.Body.SentTo
    $SentToMemberOf = $Request.Body.SentToMemberOf
    $RecipientDomainIs = $Request.Body.RecipientDomainIs
    $ExceptIfSentTo = $Request.Body.ExceptIfSentTo
    $ExceptIfSentToMemberOf = $Request.Body.ExceptIfSentToMemberOf
    $ExceptIfRecipientDomainIs = $Request.Body.ExceptIfRecipientDomainIs

    function Test-PolicyExists {
        param($TenantFilter, $PolicyName)
        $ExistingPolicies = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeLinksPolicy' -useSystemMailbox $true
        return $ExistingPolicies | Where-Object { $_.Name -eq $PolicyName }
    }

    function Test-RuleExists {
        param($TenantFilter, $RuleName)
        $ExistingRules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-SafeLinksRule' -useSystemMailbox $true
        return $ExistingRules | Where-Object { $_.Name -eq $RuleName }
    }

    # Helper function to process array fields
    function Process-ArrayField {
        param (
            [Parameter(Mandatory = $false)]
            $Field
        )

        if ($null -eq $Field) { return @() }

        # If already an array, process each item
        if ($Field -is [array]) {
            $result = [System.Collections.ArrayList]@()
            foreach ($item in $Field) {
                if ($item -is [string]) {
                    $result.Add($item) | Out-Null
                }
                elseif ($item -is [hashtable] -or $item -is [PSCustomObject]) {
                    # Extract value from object
                    if ($null -ne $item.value) {
                        $result.Add($item.value) | Out-Null
                    }
                    elseif ($null -ne $item.userPrincipalName) {
                        $result.Add($item.userPrincipalName) | Out-Null
                    }
                    elseif ($null -ne $item.id) {
                        $result.Add($item.id) | Out-Null
                    }
                    else {
                        $result.Add($item.ToString()) | Out-Null
                    }
                }
                else {
                    $result.Add($item.ToString()) | Out-Null
                }
            }
            return $result.ToArray()
        }

        # If it's a single object
        if ($Field -is [hashtable] -or $Field -is [PSCustomObject]) {
            if ($null -ne $Field.value) { return @($Field.value) }
            if ($null -ne $Field.userPrincipalName) { return @($Field.userPrincipalName) }
            if ($null -ne $Field.id) { return @($Field.id) }
        }

        # If it's a string, return as an array with one item
        if ($Field -is [string]) {
            return @($Field)
        }

        return @($Field)
    }

    # Process all array fields
    $SentTo = Process-ArrayField -Field $SentTo
    $SentToMemberOf = Process-ArrayField -Field $SentToMemberOf
    $RecipientDomainIs = Process-ArrayField -Field $RecipientDomainIs
    $ExceptIfSentTo = Process-ArrayField -Field $ExceptIfSentTo
    $ExceptIfSentToMemberOf = Process-ArrayField -Field $ExceptIfSentToMemberOf
    $ExceptIfRecipientDomainIs = Process-ArrayField -Field $ExceptIfRecipientDomainIs
    $DoNotRewriteUrls = Process-ArrayField -Field $DoNotRewriteUrls

    try {
        # Check if policy already exists
        if (Test-PolicyExists -TenantFilter $TenantFilter -PolicyName $PolicyName) {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Policy '$PolicyName' already exists" -Sev 'Warning'
            return "Policy '$PolicyName' already exists in tenant $TenantFilter"
        }

        # Check if rule already exists
        if (Test-RuleExists -TenantFilter $TenantFilter -RuleName $RuleName) {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Rule '$RuleName' already exists" -Sev 'Warning'
            return "Rule '$RuleName' already exists in tenant $TenantFilter"
        }

        # Build command parameters for policy
        $policyParams = @{
            Name = $PolicyName
        }

        # Only add parameters that are explicitly provided
        if ($null -ne $EnableSafeLinksForEmail) { $policyParams.Add('EnableSafeLinksForEmail', $EnableSafeLinksForEmail) }
        if ($null -ne $EnableSafeLinksForTeams) { $policyParams.Add('EnableSafeLinksForTeams', $EnableSafeLinksForTeams) }
        if ($null -ne $EnableSafeLinksForOffice) { $policyParams.Add('EnableSafeLinksForOffice', $EnableSafeLinksForOffice) }
        if ($null -ne $TrackClicks) { $policyParams.Add('TrackClicks', $TrackClicks) }
        if ($null -ne $AllowClickThrough) { $policyParams.Add('AllowClickThrough', $AllowClickThrough) }
        if ($null -ne $ScanUrls) { $policyParams.Add('ScanUrls', $ScanUrls) }
        if ($null -ne $EnableForInternalSenders) { $policyParams.Add('EnableForInternalSenders', $EnableForInternalSenders) }
        if ($null -ne $DeliverMessageAfterScan) { $policyParams.Add('DeliverMessageAfterScan', $DeliverMessageAfterScan) }
        if ($null -ne $DisableUrlRewrite) { $policyParams.Add('DisableUrlRewrite', $DisableUrlRewrite) }
        if ($null -ne $DoNotRewriteUrls -and $DoNotRewriteUrls.Count -gt 0) { $policyParams.Add('DoNotRewriteUrls', $DoNotRewriteUrls) }
        if ($null -ne $AdminDisplayName) { $policyParams.Add('AdminDisplayName', $AdminDisplayName) }
        if ($null -ne $CustomNotificationText) { $policyParams.Add('CustomNotificationText', $CustomNotificationText) }
        if ($null -ne $EnableOrganizationBranding) { $policyParams.Add('EnableOrganizationBranding', $EnableOrganizationBranding) }

        $ExoPolicyRequestParam = @{
            tenantid         = $TenantFilter
            cmdlet           = 'New-SafeLinksPolicy'
            cmdParams        = $policyParams
            useSystemMailbox = $true
        }

        $null = New-ExoRequest @ExoPolicyRequestParam
        $PolicyResult = "Successfully created new SafeLinks policy '$PolicyName'"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $PolicyResult -Sev 'Info'

        # Build command parameters for rule
        $ruleParams = @{
            Name = $RuleName
            SafeLinksPolicy = $PolicyName
        }

        # Only add parameters that are explicitly provided
        if ($null -ne $Priority) { $ruleParams.Add('Priority', $Priority) }
        if ($null -ne $Comments) { $ruleParams.Add('Comments', $Comments) }
        if ($null -ne $SentTo -and $SentTo.Count -gt 0) { $ruleParams.Add('SentTo', $SentTo) }
        if ($null -ne $SentToMemberOf -and $SentToMemberOf.Count -gt 0) { $ruleParams.Add('SentToMemberOf', $SentToMemberOf) }
        if ($null -ne $RecipientDomainIs -and $RecipientDomainIs.Count -gt 0) { $ruleParams.Add('RecipientDomainIs', $RecipientDomainIs) }
        if ($null -ne $ExceptIfSentTo -and $ExceptIfSentTo.Count -gt 0) { $ruleParams.Add('ExceptIfSentTo', $ExceptIfSentTo) }
        if ($null -ne $ExceptIfSentToMemberOf -and $ExceptIfSentToMemberOf.Count -gt 0) { $ruleParams.Add('ExceptIfSentToMemberOf', $ExceptIfSentToMemberOf) }
        if ($null -ne $ExceptIfRecipientDomainIs -and $ExceptIfRecipientDomainIs.Count -gt 0) { $ruleParams.Add('ExceptIfRecipientDomainIs', $ExceptIfRecipientDomainIs) }

        $ExoRuleRequestParam = @{
            tenantid         = $TenantFilter
            cmdlet           = 'New-SafeLinksRule'
            cmdParams        = $ruleParams
            useSystemMailbox = $true
        }

        $null = New-ExoRequest @ExoRuleRequestParam

        # If State is specified, enable or disable the rule
        if ($null -ne $State) {
            $EnableCmdlet = $State ? 'Enable-SafeLinksRule' : 'Disable-SafeLinksRule'
            $EnableRequestParam = @{
                tenantid         = $TenantFilter
                cmdlet           = $EnableCmdlet
                cmdParams        = @{
                    Identity = $RuleName
                }
                useSystemMailbox = $true
            }

            $null = New-ExoRequest @EnableRequestParam
        }

        $RuleResult = "Successfully created new SafeLinks rule '$RuleName'"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $RuleResult -Sev 'Info'

        $Result = "Successfully created new SafeLinks policy '$PolicyName'and rule '$RuleName'"
        $StatusCode = [HttpStatusCode]::OK
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed creating new SafeLinks policy '$PolicyName'and rule '$RuleName'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ExecNewSafeLinksPolicy.ps1' 226
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicy.ps1' -1

Function Invoke-ListSafeLinksPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Security.SafeLinksPolicy.Read
    .DESCRIPTION
        This function is used to list the Safe Links policies in the tenant, including unmatched rules and policies.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $Tenantfilter = $request.Query.tenantfilter

    try {
        $Policies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-SafeLinksPolicy' | Select-Object -Property * -ExcludeProperty '*@odata.type' , '*@data.type'
        $Rules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-SafeLinksRule' | Select-Object -Property * -ExcludeProperty '*@odata.type' , '*@data.type'
        $BuiltInRules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-EOPProtectionPolicyRule' | Select-Object -Property * -ExcludeProperty '*@odata.type' , '*@data.type'

        # Track matched items to identify orphans
        $MatchedRules = [System.Collections.Generic.HashSet[string]]::new()
        $MatchedPolicies = [System.Collections.Generic.HashSet[string]]::new()
        $MatchedBuiltInRules = [System.Collections.Generic.HashSet[string]]::new()
        $Output = [System.Collections.Generic.List[PSCustomObject]]::new()

        # First pass: Process policies with their associated rules
        foreach ($policy in $Policies) {
            $policyName = $policy.Name
            $MatchedPolicies.Add($policyName) | Out-Null

            # Find associated rule (single lookup per policy)
            $associatedRule = $null
            foreach ($rule in $Rules) {
                if ($rule.SafeLinksPolicy -eq $policyName) {
                    $associatedRule = $rule
                    $MatchedRules.Add($rule.Name) | Out-Null
                    break
                }
            }

            # Find matching built-in rule (single lookup per policy)
            $matchingBuiltInRule = $null
            foreach ($builtInRule in $BuiltInRules) {
                if ($policyName -like "$($builtInRule.Name)*") {
                    $matchingBuiltInRule = $builtInRule
                    $MatchedBuiltInRules.Add($builtInRule.Name) | Out-Null
                    break
                }
            }

            # Create output object for matched policy
            $OutputItem = [PSCustomObject]@{
                # Copy all original policy properties
                Name = $policy.Name
                AdminDisplayName = $policy.AdminDisplayName
                EnableSafeLinksForEmail = $policy.EnableSafeLinksForEmail
                EnableSafeLinksForTeams = $policy.EnableSafeLinksForTeams
                EnableSafeLinksForOffice = $policy.EnableSafeLinksForOffice
                TrackClicks = $policy.TrackClicks
                AllowClickThrough = $policy.AllowClickThrough
                ScanUrls = $policy.ScanUrls
                EnableForInternalSenders = $policy.EnableForInternalSenders
                DeliverMessageAfterScan = $policy.DeliverMessageAfterScan
                DisableUrlRewrite = $policy.DisableUrlRewrite
                DoNotRewriteUrls = $policy.DoNotRewriteUrls
                CustomNotificationText = $policy.CustomNotificationText
                EnableOrganizationBranding = $policy.EnableOrganizationBranding

                # Calculated properties
                PolicyName = $policyName
                RuleName = $associatedRule.Name
                Priority = if ($matchingBuiltInRule) { $matchingBuiltInRule.Priority } else { $associatedRule.Priority }
                State = if ($matchingBuiltInRule) { $matchingBuiltInRule.State } else { $associatedRule.State }
                SentTo = $associatedRule.SentTo
                SentToMemberOf = $associatedRule.SentToMemberOf
                RecipientDomainIs = $associatedRule.RecipientDomainIs
                ExceptIfSentTo = $associatedRule.ExceptIfSentTo
                ExceptIfSentToMemberOf = $associatedRule.ExceptIfSentToMemberOf
                ExceptIfRecipientDomainIs = $associatedRule.ExceptIfRecipientDomainIs
                Description = $policy.AdminDisplayName
                IsBuiltIn = ($matchingBuiltInRule -ne $null)
                IsValid = $policy.IsValid
                ConfigurationStatus = if ($associatedRule) { "Complete" } else { "Policy Only (Missing Rule)" }
            }
            $Output.Add($OutputItem)
        }

        # Second pass: Add unmatched rules (orphaned rules without policies)
        foreach ($rule in $Rules) {
            if (-not $MatchedRules.Contains($rule.Name)) {
                # This rule doesn't have a matching policy
                $OutputItem = [PSCustomObject]@{
                    # Policy properties (null since no policy exists)
                    Name = $null
                    AdminDisplayName = $null
                    EnableSafeLinksForEmail = $null
                    EnableSafeLinksForTeams = $null
                    EnableSafeLinksForOffice = $null
                    TrackClicks = $null
                    AllowClickThrough = $null
                    ScanUrls = $null
                    EnableForInternalSenders = $null
                    DeliverMessageAfterScan = $null
                    DisableUrlRewrite = $null
                    DoNotRewriteUrls = $null
                    CustomNotificationText = $null
                    EnableOrganizationBranding = $null

                    # Rule properties
                    PolicyName = $rule.SafeLinksPolicy
                    RuleName = $rule.Name
                    Priority = $rule.Priority
                    State = $rule.State
                    SentTo = $rule.SentTo
                    SentToMemberOf = $rule.SentToMemberOf
                    RecipientDomainIs = $rule.RecipientDomainIs
                    ExceptIfSentTo = $rule.ExceptIfSentTo
                    ExceptIfSentToMemberOf = $rule.ExceptIfSentToMemberOf
                    ExceptIfRecipientDomainIs = $rule.ExceptIfRecipientDomainIs
                    Description = $rule.Comments
                    IsBuiltIn = $false
                    ConfigurationStatus = "Rule Only (Missing Policy: $($rule.SafeLinksPolicy))"
                }
                $Output.Add($OutputItem)
            }
        }

        # Third pass: Add unmatched built-in rules
        foreach ($builtInRule in $BuiltInRules) {
            if (-not $MatchedBuiltInRules.Contains($builtInRule.Name)) {
                # Check if this built-in rule might be SafeLinks related
                if ($builtInRule.Name -like "*SafeLinks*" -or $builtInRule.Name -like "*Safe*Links*") {
                    $OutputItem = [PSCustomObject]@{
                        # Policy properties (null since no policy exists)
                        Name = $null
                        AdminDisplayName = $null
                        EnableSafeLinksForEmail = $null
                        EnableSafeLinksForTeams = $null
                        EnableSafeLinksForOffice = $null
                        TrackClicks = $null
                        AllowClickThrough = $null
                        ScanUrls = $null
                        EnableForInternalSenders = $null
                        DeliverMessageAfterScan = $null
                        DisableUrlRewrite = $null
                        DoNotRewriteUrls = $null
                        CustomNotificationText = $null
                        EnableOrganizationBranding = $null

                        # Built-in rule properties
                        PolicyName = $null
                        RuleName = $builtInRule.Name
                        Priority = $builtInRule.Priority
                        State = $builtInRule.State
                        SentTo = $builtInRule.SentTo
                        SentToMemberOf = $builtInRule.SentToMemberOf
                        RecipientDomainIs = $builtInRule.RecipientDomainIs
                        ExceptIfSentTo = $builtInRule.ExceptIfSentTo
                        ExceptIfSentToMemberOf = $builtInRule.ExceptIfSentToMemberOf
                        ExceptIfRecipientDomainIs = $builtInRule.ExceptIfRecipientDomainIs
                        Description = $builtInRule.Comments
                        IsBuiltIn = $true
                        ConfigurationStatus = "Built-In Rule Only (No Associated Policy)"
                    }
                    $Output.Add($OutputItem)
                }
            }
        }

        # Sort output by ConfigurationStatus and Name for better organization
        $SortedOutput = $Output.ToArray() | Sort-Object ConfigurationStatus, Name, RuleName

        # Generate summary statistics
        $CompleteConfigs = ($SortedOutput | Where-Object { $_.ConfigurationStatus -eq "Complete" }).Count
        $PolicyOnlyConfigs = ($SortedOutput | Where-Object { $_.ConfigurationStatus -like "*Policy Only*" }).Count
        $RuleOnlyConfigs = ($SortedOutput | Where-Object { $_.ConfigurationStatus -like "*Rule Only*" }).Count
        $BuiltInOnlyConfigs = ($SortedOutput | Where-Object { $_.ConfigurationStatus -like "*Built-In Rule Only*" }).Count

        if ($PolicyOnlyConfigs -gt 0 -or $RuleOnlyConfigs -gt 0) {
            Write-LogMessage -headers $Headers -API $APIName -message "Found $($PolicyOnlyConfigs + $RuleOnlyConfigs) orphaned SafeLinks configurations that may need attention" -Sev 'Warning'
        }

        $StatusCode = [HttpStatusCode]::OK
        $FinalOutput = $SortedOutput
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -headers $Headers -API $APIName -message "Error retrieving Safe Links policies: $ErrorMessage" -Sev 'Error'
        $StatusCode = [HttpStatusCode]::Forbidden
        $FinalOutput = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $FinalOutput
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicy.ps1' 200
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyDetails.ps1' -1

function Invoke-ListSafeLinksPolicyDetails {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    .DESCRIPTION
        This function retrieves details for a specific Safe Links policy and rule.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $PolicyName = $Request.Query.PolicyName ?? $Request.Body.PolicyName
    $RuleName = $Request.Query.RuleName ?? $Request.Body.RuleName

    $Result = @{}
    $LogMessages = [System.Collections.ArrayList]@()

    try {
        # Get policy details if PolicyName is provided
        if ($PolicyName) {
            try {
                $PolicyRequestParam = @{
                    tenantid         = $TenantFilter
                    cmdlet           = 'Get-SafeLinksPolicy'
                    cmdParams        = @{
                        Identity = $PolicyName
                    }
                    useSystemMailbox = $true
                }
                $PolicyDetails = New-ExoRequest @PolicyRequestParam
                $Result.Policy = $PolicyDetails
                $Result.PolicyName = $PolicyDetails.Name
                $LogMessages.Add("Successfully retrieved details for SafeLinks policy '$PolicyName'") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully retrieved details for SafeLinks policy '$PolicyName'" -Sev 'Info'
            }
            catch {
                $ErrorMessage = Get-CippException -Exception $_
                $LogMessages.Add("Failed to retrieve details for SafeLinks policy '$PolicyName'. Error: $($ErrorMessage.NormalizedError)") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to retrieve details for SafeLinks policy '$PolicyName'. Error: $($ErrorMessage.NormalizedError)" -Sev 'Warning'
                $Result.PolicyError = "Failed to retrieve: $($ErrorMessage.NormalizedError)"
            }
        }
        else {
            $LogMessages.Add("No policy name provided, skipping policy retrieval") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "No policy name provided, skipping policy retrieval" -Sev 'Info'
        }

        # Get rule details if RuleName is provided
        if ($RuleName) {
            try {
                $RuleRequestParam = @{
                    tenantid         = $TenantFilter
                    cmdlet           = 'Get-SafeLinksRule'
                    cmdParams        = @{
                        Identity = $RuleName
                    }
                    useSystemMailbox = $true
                }
                $RuleDetails = New-ExoRequest @RuleRequestParam
                $Result.Rule = $RuleDetails
                $Result.RuleName = $RuleDetails.Name
                $LogMessages.Add("Successfully retrieved details for SafeLinks rule '$RuleName'") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Successfully retrieved details for SafeLinks rule '$RuleName'" -Sev 'Info'
            }
            catch {
                $ErrorMessage = Get-CippException -Exception $_
                $LogMessages.Add("Failed to retrieve details for SafeLinks rule '$RuleName'. Error: $($ErrorMessage.NormalizedError)") | Out-Null
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to retrieve details for SafeLinks rule '$RuleName'. Error: $($ErrorMessage.NormalizedError)" -Sev 'Warning'
                $Result.RuleError = "Failed to retrieve: $($ErrorMessage.NormalizedError)"
            }
        }
        else {
            $LogMessages.Add("No rule name provided, skipping rule retrieval") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "No rule name provided, skipping rule retrieval" -Sev 'Info'
        }

        # If no valid retrievals were performed, throw an error
        if (-not ($Result.Policy -or $Result.Rule)) {
            throw "No valid policy or rule details could be retrieved"
        }

        # Set success status
        $StatusCode = [HttpStatusCode]::OK
        $Result.Message = $LogMessages -join " | "
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Operation failed: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyDetails.ps1' 105
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyTemplateDetails.ps1' -1

Function Invoke-ListSafeLinksPolicyTemplateDetails {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.Read
    .DESCRIPTION
        This function retrieves details for a specific Safe Links policy template.
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Get the template ID from query parameters
    $ID = $Request.Query.ID ?? $Request.Body.ID

    $Result = @{}

    try {
        if (-not $ID) {
            throw "Template ID is required"
        }

        # Get the specific template from Azure Table Storage
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'SafeLinksTemplate' and RowKey eq '$ID'"
        $Template = Get-CIPPAzDataTableEntity @Table -Filter $Filter

        if (-not $Template) {
            throw "Template with ID '$ID' not found"
        }

        # Parse the JSON data and add metadata
        $TemplateData = $Template.JSON | ConvertFrom-Json
        $TemplateData | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $Template.RowKey -Force

        $Result = $TemplateData
        $StatusCode = [HttpStatusCode]::OK
        Write-LogMessage -headers $Headers -API $APIName -message "Successfully retrieved template details for ID '$ID'" -Sev 'Info'
    }
    catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to retrieve template details for ID '$ID'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error'
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyTemplateDetails.ps1' 56
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyTemplates.ps1' -1

Function Invoke-ListSafeLinksPolicyTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'
    $Templates = Get-ChildItem 'Config\*.SafeLinksTemplate.json' | ForEach-Object {
        $Entity = @{
            JSON         = "$(Get-Content $_)"
            RowKey       = "$($_.name)"
            PartitionKey = 'SafeLinksTemplate'
            GUID         = "$($_.name)"
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
    }
    #List policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'SafeLinksTemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $GUID = $_.RowKey
        $data = $_.JSON | ConvertFrom-Json
        $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
        $data
    }
    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property RowKey -EQ $Request.query.id }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-ListSafeLinksPolicyTemplates.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-RemoveSafeLinksPolicyTemplate.ps1' -1

Function Invoke-RemoveSafeLinksPolicyTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Exchange.SafeLinks.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $User = $Request.Headers
    Write-LogMessage -Headers $User -API $APINAME -message 'Accessed this API' -Sev 'Debug'
    $ID = $request.query.ID ?? $request.body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'SafeLinksTemplate' and RowKey eq '$id'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed SafeLinks Policy Template with ID $ID."
        Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove SafeLinks Policy template with ID $ID. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $User -API $APINAME -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Security/Safe-Links-Policy/Invoke-RemoveSafeLinksPolicyTemplate.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddSite.ps1' -1

function Invoke-AddSite {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Site.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers



    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $SharePointObj = $Request.Body

    try {
        $Result = New-CIPPSharepointSite -Headers $Headers -SiteName $SharePointObj.siteName -SiteDescription $SharePointObj.siteDescription -SiteOwner $SharePointObj.siteOwner.value -TemplateName $SharePointObj.templateName.value -SiteDesign $SharePointObj.siteDesign.value -SensitivityLabel $SharePointObj.sensitivityLabel -TenantFilter $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $StatusCode = [HttpStatusCode]::InternalServerError
        $Result = $_.Exception.Message
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddSite.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddSiteBulk.ps1' -1

Function Invoke-AddSiteBulk {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Site.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers



    $Results = [System.Collections.Generic.List[System.Object]]::new()

    foreach ($sharePointObj in $Request.Body.bulkSites) {
        try {
            $SharePointSite = New-CIPPSharepointSite -Headers $Headers -SiteName $sharePointObj.siteName -SiteDescription $sharePointObj.siteDescription -SiteOwner $sharePointObj.siteOwner -TemplateName $sharePointObj.templateName -SiteDesign $sharePointObj.siteDesign -SensitivityLabel $sharePointObj.sensitivityLabel -TenantFilter $Request.body.tenantFilter
            $Results.Add($SharePointSite)
        } catch {
            $Results.Add("Failed to create $($sharePointObj.siteName) Error message: $($_.Exception.Message)")
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddSiteBulk.ps1' 30
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddTeam.ps1' -1

Function Invoke-AddTeam {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Group.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with the body of the request
    $TeamObj = $Request.Body
    $TenantID = $TeamObj.tenantid

    $Owners = ($TeamObj.owner)
    try {
        if ($null -eq $Owners) {
            throw 'You have to add at least one owner to the team'
        }
        $Owners = $Owners | ForEach-Object {
            $OwnerID = "https://graph.microsoft.com/beta/users('$($_)')"
            @{
                '@odata.type'     = '#microsoft.graph.aadUserConversationMember'
                'roles'           = @('owner')
                'user@odata.bind' = $OwnerID
            }
        }

        $TeamsSettings = [PSCustomObject]@{
            'template@odata.bind' = "https://graph.microsoft.com/v1.0/teamsTemplates('standard')"
            'visibility'          = $TeamObj.visibility
            'displayName'         = $TeamObj.displayName
            'description'         = $TeamObj.description
            'members'             = @($Owners)

        } | ConvertTo-Json -Depth 10
        # Write-Host $TeamsSettings

        $null = New-GraphPostRequest -AsApp $true -uri 'https://graph.microsoft.com/beta/teams' -tenantid $TenantID -type POST -body $TeamsSettings -Verbose
        $Message = "Successfully created Team: '$($TeamObj.displayName)'"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $TenantID -message $Message -Sev Info
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to create Team: '$($TeamObj.displayName)'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APINAME -tenant $TenantID -message $Message -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = $Message }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-AddTeam.ps1' 62
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-DeleteSharepointSite.ps1' -1

function Invoke-DeleteSharepointSite {
    <#
    .FUNCTIONALITY
     Entrypoint
    .ROLE
     Sharepoint.Site.ReadWrite
     #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $SiteId = $Request.Body.SiteId

    try {
        # Validate required parameters
        if (-not $SiteId) {
            throw "SiteId is required"
        }
        if (-not $TenantFilter) {
            throw "TenantFilter is required"
        }

        # Validate SiteId format (GUID)
        if ($SiteId -notmatch '^(\{)?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}(\})?$') {
            throw "SiteId must be a valid GUID"
        }

        $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter

        # Get site information using SharePoint admin API
        $SiteInfoUri = "$($SharePointInfo.AdminUrl)/_api/SPO.Tenant/sites('$SiteId')"

        # Add the headers that SharePoint REST API expects
        $ExtraHeaders = @{
            'accept' = 'application/json'
            'content-type' = 'application/json'
            'odata-version' = '4.0'
        }

        $SiteInfo = New-GraphGETRequest -scope "$($SharePointInfo.AdminUrl)/.default" -uri $SiteInfoUri -tenantid $TenantFilter -extraHeaders $ExtraHeaders

        if (-not $SiteInfo) {
            throw "Could not retrieve site information from SharePoint Admin API"
        }

        # Determine if site is group-connected based on GroupId
        $IsGroupConnected = $SiteInfo.GroupId -and $SiteInfo.GroupId -ne "00000000-0000-0000-0000-000000000000"

        if ($IsGroupConnected) {
            # Use GroupSiteManager/Delete for group-connected sites
            $body = @{
                siteUrl = $SiteInfo.Url
            }
            $DeleteUri = "$($SharePointInfo.AdminUrl)/_api/GroupSiteManager/Delete"
        } else {
            # Use SPSiteManager/delete for regular sites
            $body = @{
                siteId = $SiteId
            }
            $DeleteUri = "$($SharePointInfo.AdminUrl)/_api/SPSiteManager/delete"
        }

        # Execute the deletion
        $DeleteResult = New-GraphPOSTRequest -scope "$($SharePointInfo.AdminUrl)/.default" -uri $DeleteUri -body (ConvertTo-Json -Depth 10 -InputObject $body) -tenantid $TenantFilter -extraHeaders $ExtraHeaders

        $SiteTypeMsg = if ($IsGroupConnected) { "group-connected" } else { "regular" }
        $Results = "Successfully initiated deletion of $SiteTypeMsg SharePoint site with ID $SiteId, this process can take some time to complete in the background"

        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -sev Info
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Failed to delete SharePoint site with ID $SiteId. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    # Associate values to output bindings
    return ([HttpResponseContext]@{
        StatusCode = $StatusCode
        Body = @{ 'Results' = $Results }
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-DeleteSharepointSite.ps1' 90
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecRemoveTeamsVoicePhoneNumberAssignment.ps1' -1

Function Invoke-ExecRemoveTeamsVoicePhoneNumberAssignment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Voice.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $AssignedTo = $Request.Body.AssignedTo
    $PhoneNumber = $Request.Body.PhoneNumber
    $PhoneNumberType = $Request.Body.PhoneNumberType

    try {
        $null = New-TeamsRequest -TenantFilter $TenantFilter -Cmdlet 'Remove-CsPhoneNumberAssignment' -CmdParams @{Identity = $AssignedTo; PhoneNumber = $PhoneNumber; PhoneNumberType = $PhoneNumberType; ErrorAction = 'Stop' }
        $Result = "Successfully unassigned $PhoneNumber from $AssignedTo"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to unassign $PhoneNumber from $AssignedTo. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecRemoveTeamsVoicePhoneNumberAssignment.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecSetSharePointMember.ps1' -1

function Invoke-ExecSetSharePointMember {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Site.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter

    try {
        if ($Request.Body.SharePointType -eq 'Group') {
            if ($Request.Body.GroupID -match '^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$') {
                $GroupId = $Request.Body.GroupID
            } else {
                $GroupId = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups?`$filter=mail eq '$($Request.Body.GroupID)' or proxyAddresses/any(x:endsWith(x,'$($Request.Body.GroupID)')) or mailNickname eq '$($Request.Body.GroupID)'" -ComplexFilter -tenantid $TenantFilter).id
            }

            if ($Request.Body.Add -eq $true) {
                $Results = Add-CIPPGroupMember -GroupType 'Team' -GroupID $GroupID -Member $Request.Body.user.value -TenantFilter $TenantFilter -Headers $Headers
            } else {
                $UserID = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($Request.Body.user.value)" -tenantid $TenantFilter).id
                $Results = Remove-CIPPGroupMember -GroupType 'Team' -GroupID $GroupID -Member $UserID -TenantFilter $TenantFilter -Headers $Headers
            }
            $StatusCode = [HttpStatusCode]::OK
        } else {
            $StatusCode = [HttpStatusCode]::BadRequest
            $Results = 'This type of SharePoint site is not supported.'
        }
    } catch {
        $Results = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecSetSharePointMember.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecSharePointPerms.ps1' -1

Function Invoke-ExecSharePointPerms {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Site.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    Write-LogMessage -Headers $Headers -API $APIName -message 'Accessed this API' -Sev Debug

    $TenantFilter = $Request.Body.tenantFilter

    Write-Host '===================================='
    Write-Host 'Request Body:'
    Write-Host (ConvertTo-Json $Request.body -Depth 10)
    Write-Host '===================================='


    # The UPN or ID of the users OneDrive we are changing permissions on
    $UserId = $Request.Body.UPN
    # The UPN of the user we are adding or removing permissions for
    $OnedriveAccessUser = $Request.Body.onedriveAccessUser.value ?? $Request.Body.user.value
    $URL = $Request.Body.URL
    $RemovePermission = $Request.Body.RemovePermission

    try {

        $State = Set-CIPPSharePointPerms -tenantFilter $TenantFilter `
            -UserId $UserId `
            -OnedriveAccessUser $OnedriveAccessUser `
            -Headers $Headers `
            -APIName $APIName `
            -RemovePermission $RemovePermission `
            -URL $URL
        $Result = "$State"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = $_.Exception.Message
        $Result = "Failed. Error: $ErrorMessage"
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecSharePointPerms.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecTeamsVoicePhoneNumberAssignment.ps1' -1

Function Invoke-ExecTeamsVoicePhoneNumberAssignment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Voice.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $Identity = $Request.Body.input.value

    $tenantFilter = $Request.Body.TenantFilter
    try {
        if ($Request.Body.locationOnly) {
            $null = New-TeamsRequest -TenantFilter $TenantFilter -Cmdlet 'Set-CsPhoneNumberAssignment' -CmdParams @{LocationId = $Identity; PhoneNumber = $Request.Body.PhoneNumber; ErrorAction = 'stop' }
            $Results = [pscustomobject]@{'Results' = "Successfully assigned emergency location to $($Request.Body.PhoneNumber)" }
        } else {
            $null = New-TeamsRequest -TenantFilter $TenantFilter -Cmdlet 'Set-CsPhoneNumberAssignment' -CmdParams @{Identity = $Identity; PhoneNumber = $Request.Body.PhoneNumber; PhoneNumberType = $Request.Body.PhoneNumberType; ErrorAction = 'stop' }
            $Results = [pscustomobject]@{'Results' = "Successfully assigned $($Request.Body.PhoneNumber) to $($Identity)" }
        }
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $($TenantFilter) -message $($Results.Results) -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = [pscustomobject]@{'Results' = $ErrorMessage.NormalizedError }
        Write-LogMessage -Headers $Headers -API $APINAME -tenant $($TenantFilter) -message $($Results.Results) -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ExecTeamsVoicePhoneNumberAssignment.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointAdminUrl.ps1' -1

function Invoke-ListSharepointAdminUrl {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param(
        $Request,
        $TriggerMetadata
    )

    if ($Request.Query.TenantFilter) {
        $TenantFilter = $Request.Query.TenantFilter

        $Tenant = Get-Tenants -TenantFilter $TenantFilter

        if ($Tenant.SharepointAdminUrl) {
            $AdminUrl = $Tenant.SharepointAdminUrl
        } else {
            $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
            $Tenant | Add-Member -MemberType NoteProperty -Name SharepointAdminUrl -Value $SharePointInfo.AdminUrl
            $Table = Get-CIPPTable -TableName 'Tenants'
            Add-CIPPAzDataTableEntity @Table -Entity $Tenant -Force
            $AdminUrl = $SharePointInfo.AdminUrl
        }

        if ($Request.Query.ReturnUrl) {
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @{
                        AdminUrl = $AdminUrl
                    }
                })
        } else {
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::Found
                    Headers    = @{
                        Location = $AdminUrl
                    }
                })
        }
    } else {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'TenantFilter is required'
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointAdminUrl.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointQuota.ps1' -1

Function Invoke-ListSharepointQuota {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Admin.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    if ($TenantFilter -eq 'AllTenants') {
        $UsedStoragePercentage = 'Not Supported'
    } else {
        try {
            $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
            $extraHeaders = @{
                'Accept' = 'application/json'
            }
            $SharePointQuota = (New-GraphGetRequest -extraHeaders $extraHeaders -scope "$($SharePointInfo.AdminUrl)/.default" -tenantid $TenantFilter -uri "$($SharePointInfo.AdminUrl)/_api/StorageQuotas()?api-version=1.3.2") | Sort-Object -Property GeoUsedStorageMB -Descending | Select-Object -First 1

            if ($SharePointQuota) {
                $UsedStoragePercentage = [int](($SharePointQuota.GeoUsedStorageMB / $SharePointQuota.TenantStorageMB) * 100)
            }
        } catch {
            $UsedStoragePercentage = 'Not available'
        }
    }

    $SharePointQuotaDetails = @{
        GeoUsedStorageMB = $SharePointQuota.GeoUsedStorageMB
        TenantStorageMB  = $SharePointQuota.TenantStorageMB
        Percentage       = $UsedStoragePercentage
        Dashboard        = "$($UsedStoragePercentage) / 100"
    }

    $StatusCode = [HttpStatusCode]::OK

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $SharePointQuotaDetails
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointQuota.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointSettings.ps1' -1

Function Invoke-ListSharepointSettings {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Admin.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    #  XXX - Seems to be an unused endpoint? -Bobby


    # Interact with query parameters or the body of the request.
    $Tenant = $Request.Query.tenantFilter
    $Request = New-GraphGetRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings'

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Request)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSharepointSettings.ps1' 23
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSites.ps1' -1

function Invoke-ListSites {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Sharepoint.Site.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $TenantFilter = $Request.Query.TenantFilter
    $Type = $Request.Query.Type
    $UserUPN = $Request.Query.UserUPN

    if (!$TenantFilter) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'TenantFilter is required'
            })
    }

    if (!$Type) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'Type is required'
            })
    }

    $Tenant = Get-Tenants -TenantFilter $TenantFilter
    $TenantId = $Tenant.customerId

    if ($Type -eq 'SharePointSiteUsage') {
        $Filter = 'isPersonalSite eq false'
    } else {
        $Filter = 'isPersonalSite eq true'
    }

    try {
        $BulkRequests = @(
            @{
                id     = 'listAllSites'
                method = 'GET'
                url    = "sites/getAllSites?`$filter=$($Filter)&`$select=id,createdDateTime,description,name,displayName,isPersonalSite,lastModifiedDateTime,webUrl,siteCollection,sharepointIds&`$top=999"
            }
            @{
                id     = 'usage'
                method = 'GET'
                url    = "reports/get$($type)Detail(period='D7')?`$format=application/json&`$top=999"
            }
        )

        $Result = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($BulkRequests) -asapp $true
        $Sites = ($Result | Where-Object { $_.id -eq 'listAllSites' }).body.value
        $UsageBase64 = ($Result | Where-Object { $_.id -eq 'usage' }).body
        $UsageJson = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($UsageBase64))
        $Usage = ($UsageJson | ConvertFrom-Json).value

        $GraphRequest = foreach ($Site in $Sites) {
            $SiteUsage = $Usage | Where-Object { $_.siteId -eq $Site.sharepointIds.siteId }
            [PSCustomObject]@{
                siteId                      = $Site.sharepointIds.siteId
                webId                       = $Site.sharepointIds.webId
                createdDateTime             = $Site.createdDateTime
                displayName                 = $Site.displayName
                webUrl                      = $Site.webUrl
                ownerDisplayName            = $SiteUsage.ownerDisplayName
                ownerPrincipalName          = $SiteUsage.ownerPrincipalName
                lastActivityDate            = $SiteUsage.lastActivityDate
                fileCount                   = $SiteUsage.fileCount
                storageUsedInGigabytes      = [math]::round($SiteUsage.storageUsedInBytes / 1GB, 2)
                storageAllocatedInGigabytes = [math]::round($SiteUsage.storageAllocatedInBytes / 1GB, 2)
                storageUsedInBytes          = $SiteUsage.storageUsedInBytes
                storageAllocatedInBytes     = $SiteUsage.storageAllocatedInBytes
                rootWebTemplate             = $SiteUsage.rootWebTemplate
                reportRefreshDate           = $SiteUsage.reportRefreshDate
                AutoMapUrl                  = ''
            }
        }

        $int = 0
        if ($Type -eq 'SharePointSiteUsage') {
            $Requests = foreach ($Site in $GraphRequest) {
                @{
                    id     = $int++
                    method = 'GET'
                    url    = "sites/$($Site.siteId)/lists?`$select=id,name,list,parentReference"
                }
            }
            try {
                $Requests = (New-GraphBulkRequest -tenantid $TenantFilter -scope 'https://graph.microsoft.com/.default' -Requests @($Requests) -asapp $true).body.value | Where-Object { $_.list.template -eq 'DocumentLibrary' }
            } catch {
                Write-LogMessage -Headers $Headers -Message "Error getting auto map urls: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter -API 'ListSites' -LogData (Get-CippException -Exception $_)
            }
            $GraphRequest = foreach ($Site in $GraphRequest) {
                $ListId = ($Requests | Where-Object { $_.parentReference.siteId -like "*$($Site.siteId)*" }).id
                $site.AutoMapUrl = "tenantId=$($TenantId)&webId={$($Site.webId)}&siteid={$($Site.siteId)}&webUrl=$($Site.webUrl)&listId={$($ListId)}"
                $site
            }
        }
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    if ($Request.query.URLOnly -eq 'true') {
        $GraphRequest = $GraphRequest | Where-Object { $null -ne $_.webUrl }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest | Sort-Object -Property displayName)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListSites.ps1' 119
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeams.ps1' -1

Function Invoke-ListTeams {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Group.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    if ($request.query.type -eq 'List') {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups?`$filter=resourceProvisioningOptions/Any(x:x eq 'Team')&`$select=id,displayName,description,visibility,mailNickname" -tenantid $TenantFilter | Sort-Object -Property displayName
    }
    $TeamID = $request.query.ID
    Write-Host $TeamID
    if ($request.query.type -eq 'Team') {
        $Team = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/teams/$($TeamID)" -tenantid $TenantFilter -asapp $true
        $Channels = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/teams/$($TeamID)/Channels" -tenantid $TenantFilter -asapp $true
        $UserList = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/teams/$($TeamID)/Members" -tenantid $TenantFilter -asapp $true
        $AppsList = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/teams/$($TeamID)/installedApps?`$expand=teamsAppDefinition" -tenantid $TenantFilter -asapp $true

        $Owners = $UserList | Where-Object -Property Roles -EQ 'Owner'
        $Members = $UserList | Where-Object -Property email -NotIn $owners.email
        $GraphRequest = [PSCustomObject]@{
            Name          = $team.DisplayName
            TeamInfo      = @($team)
            ChannelInfo   = @($channels)
            Members       = @($Members)
            Owners        = @($owners)
            InstalledApps = @($AppsList)
        }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeams.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsActivity.ps1' -1

Function Invoke-ListTeamsActivity {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Activity.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $type = $request.Query.Type
    $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/reports/get$($type)Detail(period='D30')" -tenantid $TenantFilter | ConvertFrom-Csv | Select-Object @{ Name = 'UPN'; Expression = { $_.'User Principal Name' } },
    @{ Name = 'LastActive'; Expression = { $_.'Last Activity Date' } },
    @{ Name = 'TeamsChat'; Expression = { $_.'Team Chat Message Count' } },
    @{ Name = 'CallCount'; Expression = { $_.'Call Count' } },
    @{ Name = 'MeetingCount'; Expression = { $_.'Meeting Count' } }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsActivity.ps1' 25
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsLisLocation.ps1' -1

Function Invoke-ListTeamsLisLocation {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Voice.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $EmergencyLocations = New-TeamsRequest -TenantFilter $TenantFilter -Cmdlet 'Get-CsOnlineLisLocation'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $EmergencyLocations = $ErrorMessage
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($EmergencyLocations)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsLisLocation.ps1' 25
#Region './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsVoice.ps1' -1

function Invoke-ListTeamsVoice {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Teams.Voice.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $TenantId = (Get-Tenants -TenantFilter $TenantFilter).customerId
    try {
        $Users = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$top=999&`$select=id,userPrincipalName,displayName" -tenantid $TenantFilter)
        $Skip = 0
        $GraphRequest = do {
            Write-Host "Getting page $Skip"
            $Results = New-TeamsAPIGetRequest -uri "https://api.interfaces.records.teams.microsoft.com/Skype.TelephoneNumberMgmt/Tenants/$($TenantId)/telephone-numbers?skip=$($Skip)&locale=en-US&top=999" -tenantid $TenantFilter
            #Write-Information ($Results | ConvertTo-Json -Depth 10)
            $data = $Results.TelephoneNumbers | ForEach-Object {
                $CompleteRequest = $_ | Select-Object *, @{Name = 'AssignedTo'; Expression = { $users | Where-Object -Property id -EQ $_.TargetId } }
                if ($CompleteRequest.AcquisitionDate) {
                    $CompleteRequest.AcquisitionDate = $_.AcquisitionDate -split 'T' | Select-Object -First 1
                } else {
                    $CompleteRequest | Add-Member -NotePropertyName 'AcquisitionDate' -NotePropertyValue 'Unknown' -Force
                }
                $CompleteRequest.AssignedTo ? $null : ($CompleteRequest | Add-Member -NotePropertyName 'AssignedTo' -NotePropertyValue 'Unassigned' -Force)
                $CompleteRequest
            }
            $Skip = $Skip + 999
            $Data
        } while ($data.Count -eq 999)
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    Write-Host "Graph request is: $($GraphRequest)"
    Write-Host 'Returning the response'
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest | Where-Object { $_.TelephoneNumber })
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Teams-Sharepoint/Invoke-ListTeamsVoice.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-AddAlert.ps1' -1

Function Invoke-AddAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $Tenants = $Request.Body.tenantFilter
    $Conditions = $Request.Body.conditions | ConvertTo-Json -Compress -Depth 10 | Out-String
    $TenantsJson = $Tenants | ConvertTo-Json -Compress -Depth 10 | Out-String
    $excludedTenantsJson = $Request.Body.excludedTenants | ConvertTo-Json -Compress -Depth 10 | Out-String
    $Actions = $Request.Body.actions | ConvertTo-Json -Compress -Depth 10 | Out-String
    $RowKey = $Request.Body.RowKey ? $Request.Body.RowKey : (New-Guid).ToString()
    $CompleteObject = @{
        Tenants         = [string]$TenantsJson
        excludedTenants = [string]$excludedTenantsJson
        Conditions      = [string]$Conditions
        Actions         = [string]$Actions
        type            = $Request.Body.logbook.value
        RowKey          = $RowKey
        PartitionKey    = 'Webhookv2'
        AlertComment    = [string]$Request.Body.AlertComment
    }
    $WebhookTable = Get-CippTable -TableName 'WebhookRules'
    Add-CIPPAzDataTableEntity @WebhookTable -Entity $CompleteObject -Force
    $Results = "Added Audit Log Alert for $($Tenants.count) tenants. It may take up to four hours before Microsoft starts delivering these alerts."

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ 'Results' = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-AddAlert.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ExecAuditLogSearch.ps1' -1

function Invoke-ExecAuditLogSearch {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    $Action = $Request.Query.Action ?? $Request.Body.Action



    switch ($Action) {
        'ProcessLogs' {
            $Table = Get-CIPPTable -TableName 'AuditLogSearches'

            $SearchId = $Request.Query.SearchId ?? $Request.Body.SearchId
            $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
            if (!$SearchId) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = 'SearchId is required'
                    })
                return
            }

            $Existing = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Search' and RowKey eq '$SearchId' and Tenant eq '$TenantFilter'"
            if (!$Existing) {
                $Search = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/security/auditLog/queries/$SearchId" -AsApp $true -TenantId $TenantFilter
                Write-Information ($Search | ConvertTo-Json -Depth 10)

                $Entity = [PSCustomObject]@{
                    PartitionKey = [string]'Search'
                    RowKey       = [string]$SearchId
                    Tenant       = [string]$TenantFilter
                    DisplayName  = [string]$Search.displayName
                    StartTime    = [datetime]$Search.filterStartDateTime
                    EndTime      = [datetime]$Search.filterEndDateTime
                    Query        = [string]($Search | ConvertTo-Json -Compress)
                    CippStatus   = [string]'Pending'
                }
            } else {
                $Existing.CippStatus = 'Pending'
            }

            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force | Out-Null

            Write-LogMessage -headers $Headers -API $APIName -message "Queued search for processing: $($Search.displayName)" -Sev 'Info' -tenant $TenantFilter

            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::OK
                    Body       = @{
                        resultText = "Search '$($Search.displayName)' queued for processing."
                        state      = 'success'
                    } | ConvertTo-Json -Depth 10 -Compress
                })
        }
        default {
            $Query = $Request.Body
            if (!$Query.TenantFilter) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = 'TenantFilter is required'
                    })
                return
            }
            if (!$Query.StartTime -or !$Query.EndTime) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = 'StartTime and EndTime are required'
                    })
                return
            }

            # Convert StartTime and EndTime to DateTime from unixtime
            if ($Query.StartTime -match '^\d+$') {
                $Query.StartTime = [DateTime]::UnixEpoch.AddSeconds([long]$Query.StartTime)
            } else {
                $Query.StartTime = [DateTime]$Query.StartTime
            }

            if ($Query.EndTime -match '^\d+$') {
                $Query.EndTime = [DateTime]::UnixEpoch.AddSeconds([long]$Query.EndTime)
            } else {
                $Query.EndTime = [DateTime]$Query.EndTime
            }

            $Command = Get-Command New-CippAuditLogSearch
            $AvailableParameters = $Command.Parameters.Keys
            $BadProps = foreach ($Prop in $Query.PSObject.Properties.Name) {
                if ($AvailableParameters -notcontains $Prop) {
                    $Prop
                }
            }
            if ($BadProps) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = "Invalid parameters: $($BadProps -join ', ')"
                    })
                return
            }

            try {
                Write-Information "Executing audit log search with parameters: $($Query | ConvertTo-Json -Depth 10)"

                $Query = $Query | ConvertTo-Json -Depth 10 | ConvertFrom-Json -AsHashtable
                $NewSearch = New-CippAuditLogSearch @Query

                if ($NewSearch) {
                    Write-LogMessage -headers $Headers -API $APIName -message "Created audit log search: $($NewSearch.displayName)" -Sev 'Info' -tenant $TenantFilter
                    $Results = @{
                        resultText = "Created audit log search: $($NewSearch.displayName)"
                        state      = 'success'
                        details    = $NewSearch
                    }
                } else {
                    Write-LogMessage -headers $Headers -API $APIName -message 'Failed to create audit log search' -Sev 'Error' -tenant $TenantFilter
                    $Results = @{
                        resultText = 'Failed to initiate search'
                        state      = 'error'
                    }
                }
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::OK
                        Body       = $Results
                    })
            } catch {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = $_.Exception.Message
                    })
            }
        }
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ExecAuditLogSearch.ps1' 140
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAlertsQueue.ps1' -1

function Invoke-ListAlertsQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $WebhookTable = Get-CIPPTable -TableName 'WebhookRules'
    $WebhookRules = Get-CIPPAzDataTableEntity @WebhookTable

    $ScheduledTasks = Get-CIPPTable -TableName 'ScheduledTasks'
    $ScheduledTasks = Get-CIPPAzDataTableEntity @ScheduledTasks | Where-Object { $_.hidden -eq $true -and $_.command -like 'Get-CippAlert*' }

    $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList
    $TenantList = Get-Tenants -IncludeErrors
    $AllTasksArrayList = [system.collections.generic.list[object]]::new()

    foreach ($Task in $WebhookRules) {
        $Conditions = $Task.Conditions | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue
        $TranslatedConditions = ($Conditions | ForEach-Object { "When $($_.Property.label) is $($_.Operator.label) $($_.input.value)" }) -join ' and '
        $TranslatedActions = ($Task.Actions | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue).label -join ','
        $Tenants = ($Task.Tenants | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue)
        $TaskEntry = [PSCustomObject]@{
            Tenants         = @($Tenants.label)
            Conditions      = $TranslatedConditions
            excludedTenants = @($Task.excludedTenants | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue)
            Actions         = $TranslatedActions
            LogType         = $Task.type
            EventType       = 'Audit log Alert'
            RowKey          = $Task.RowKey
            PartitionKey    = $Task.PartitionKey
            RepeatsEvery    = 'When received'
            AlertComment    = $Task.AlertComment
            RawAlert        = @{
                Conditions   = @($Conditions)
                Actions      = @($($Task.Actions | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue))
                Tenants      = @($Tenants)
                type         = $Task.type
                RowKey       = $Task.RowKey
                PartitionKey = $Task.PartitionKey
                AlertComment = $Task.AlertComment
            }
        }

        if ($AllowedTenants -notcontains 'AllTenants') {
            foreach ($Tenant in $Tenants) {
                if ($AllowedTenants -contains $Tenant.customerId) {
                    $AllTasksArrayList.Add($TaskEntry)
                    break
                }
            }
        } else {
            $AllTasksArrayList.Add($TaskEntry)
        }
    }

    foreach ($Task in $ScheduledTasks) {
        if ($Task.excludedTenants) {
            $ExcludedTenants = @($Task.excludedTenants)
        } else {
            $ExcludedTenants = @()
        }

        # Handle tenant group display information for alerts
        $TenantsForDisplay = @()
        if ($Task.TenantGroup) {
            try {
                $TenantGroupObject = $Task.TenantGroup | ConvertFrom-Json -ErrorAction SilentlyContinue
                if ($TenantGroupObject) {
                    # Create a tenant group object for display
                    $TenantGroupForDisplay = [PSCustomObject]@{
                        label = $TenantGroupObject.label
                        value = $TenantGroupObject.value
                        type  = 'Group'
                    }
                    $TenantsForDisplay = @($TenantGroupForDisplay)
                }
            } catch {
                Write-Warning "Failed to parse tenant group information for alert task $($Task.RowKey): $($_.Exception.Message)"
                # Fall back to regular tenant display
                $TenantsForDisplay = @($Task.Tenant)
            }
        } else {
            # For regular tenants, create a tenant object for consistent formatting
            $TenantForDisplay = [PSCustomObject]@{
                label = $Task.Tenant
                value = $Task.Tenant
                type  = 'Tenant'
            }
            $TenantsForDisplay = @($TenantForDisplay)
        }

        $TaskEntry = [PSCustomObject]@{
            RowKey          = $Task.RowKey
            PartitionKey    = $Task.PartitionKey
            excludedTenants = @($ExcludedTenants)
            Tenants         = $TenantsForDisplay
            Conditions      = $Task.Name
            Actions         = $Task.PostExecution
            LogType         = 'Scripted'
            EventType       = 'Scheduled Task'
            RepeatsEvery    = $Task.Recurrence
            AlertComment    = $Task.AlertComment
            RawAlert        = $Task
        }

        if ($AllowedTenants -notcontains 'AllTenants') {
            # For tenant groups, we need to expand and check access
            if ($Task.TenantGroup) {
                try {
                    $TenantGroupObject = $Task.TenantGroup | ConvertFrom-Json -ErrorAction SilentlyContinue
                    if ($TenantGroupObject) {
                        # Create a tenant filter object for expansion
                        $TenantFilterForExpansion = @([PSCustomObject]@{
                                type  = 'Group'
                                value = $TenantGroupObject.value
                                label = $TenantGroupObject.label
                            })

                        # Expand the tenant group to individual tenants
                        $ExpandedTenants = Expand-CIPPTenantGroups -TenantFilter $TenantFilterForExpansion

                        # Check if user has access to any tenant in the group
                        $HasAccess = $false
                        foreach ($ExpandedTenant in $ExpandedTenants) {
                            $TenantInfo = $TenantList | Where-Object -Property defaultDomainName -EQ $ExpandedTenant.value
                            if ($TenantInfo -and $AllowedTenants -contains $TenantInfo.customerId) {
                                $HasAccess = $true
                                break
                            }
                        }

                        if ($HasAccess) {
                            $AllTasksArrayList.Add($TaskEntry)
                        }
                    }
                } catch {
                    Write-Warning "Failed to expand tenant group for access check: $($_.Exception.Message)"
                }
            } else {
                # Regular tenant access check
                $Tenant = $TenantList | Where-Object -Property defaultDomainName -EQ $Task.Tenant
                if ($AllowedTenants -contains $Tenant.customerId) {
                    $AllTasksArrayList.Add($TaskEntry)
                }
            }
        } else {
            $AllTasksArrayList.Add($TaskEntry)
        }
    }

    $finalList = ConvertTo-Json -InputObject @($AllTasksArrayList) -Depth 10
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $finalList
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAlertsQueue.ps1' 161
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogs.ps1' -1

function Invoke-ListAuditLogs {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $LogID = $Request.Query.LogId
    $StartDate = $Request.Query.StartDate
    $EndDate = $Request.Query.EndDate
    $RelativeTime = $Request.Query.RelativeTime
    $FilterConditions = [System.Collections.Generic.List[string]]::new()

    if ($LogID) {
        $FilterConditions.Add("RowKey eq '$($LogID)'")
    } else {
        if ($TenantFilter -and $TenantFilter -ne 'AllTenants') {
            $FilterConditions.Add("Tenant eq '$TenantFilter'")
        }

        if (!$StartDate -and !$EndDate -and !$RelativeTime) {
            $StartDate = (Get-Date).AddDays(-7).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
            $EndDate = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        }

        if ($RelativeTime) {

            if ($RelativeTime -match '(\d+)([dhm])') {
                $EndDate = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                $Interval = [Int32]$Matches[1]
                switch ($Matches[2]) {
                    'd' { $StartDate = (Get-Date).AddDays(-$Interval).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ') }
                    'h' { $StartDate = (Get-Date).AddHours(-$Interval).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ') }
                    'm' { $StartDate = (Get-Date).AddMinutes(-$Interval).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ') }
                }
            }
            $FilterConditions.Add("Timestamp ge datetime'$StartDate' and Timestamp le datetime'$EndDate'")
        } else {
            if ($StartDate) {
                if ($StartDate -match '^\d+$') {
                    $StartDate = [DateTimeOffset]::FromUnixTimeSeconds([int]$StartDate).DateTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                } else {
                    $StartDate = (Get-Date $StartDate).ToString('yyyy-MM-ddTHH:mm:ssZ')
                }
                $FilterConditions.Add("Timestamp ge datetime'$StartDate'")

                if ($EndDate) {
                    if ($EndDate -match '^\d+$') {
                        $EndDate = [DateTimeOffset]::FromUnixTimeSeconds([int]$EndDate).DateTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                    } else {
                        $EndDate = (Get-Date $EndDate).ToString('yyyy-MM-ddTHH:mm:ssZ')
                    }
                    $FilterConditions.Add("Timestamp le datetime'$EndDate'")
                }
            }
        }
    }

    $Table = Get-CIPPTable -TableName 'AuditLogs'
    if ($FilterConditions) {
        $Table.Filter = $FilterConditions -join ' and '
    }

    $Tenants = Get-Tenants -IncludeErrors

    $AuditLogs = Get-CIPPAzDataTableEntity @Table | Where-Object { $Tenants.defaultDomainName -contains $_.Tenant } | ForEach-Object {
        $_.Data = try { $_.Data | ConvertFrom-Json } catch { $_.AuditData }
        $_ | Select-Object @{n = 'LogId'; exp = { $_.RowKey } }, @{ n = 'Timestamp'; exp = { $_.Data.RawData.CreationTime } }, Tenant, Title, Data
    }

    $Body = @{
        Results  = @($AuditLogs | Sort-Object -Property Timestamp -Descending)
        Metadata = @{
            Count  = $AuditLogs.Count
            Filter = $Table.Filter ?? ''
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogs.ps1' 88
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogSearches.ps1' -1

function Invoke-ListAuditLogSearches {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Alert.Read
    #>
    Param($Request, $TriggerMetadata)
    # Interact with the query parameters
    $TenantFilter = $Request.Query.tenantFilter
    $SearchId = $Request.Query.SearchId
    $Days = $Request.Query.Days
    $Type = $Request.Query.Type

    if ($TenantFilter) {
        switch ($Type) {
            'Searches' {
                $Results = Get-CippAuditLogSearches -TenantFilter $TenantFilter
                $Body = @{
                    Results  = @($Results)
                    Metadata = @{
                        TenantFilter  = $TenantFilter
                        TotalSearches = $Results.Count
                    }
                } | ConvertTo-Json -Depth 10 -Compress
            }
            'SearchResults' {
                try {
                    $Results = Get-CippAuditLogSearchResults -TenantFilter $TenantFilter -QueryId $SearchId
                } catch {
                    $Results = @{ Error = $_.Exception.Message }
                }
                $Body = @{
                    Results  = @($Results)
                    Metadata = @{
                        SearchId     = $SearchId
                        TenantFilter = $TenantFilter
                        TotalResults = $Results.Count
                    }
                } | ConvertTo-Json -Depth 10 -Compress
            }
            default {
                if ($Days) {
                    $Days = $Days
                } else {
                    $Days = 1
                }
                $StartTime = (Get-Date).AddDays(-$Days).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')

                $Table = Get-CIPPTable -TableName 'AuditLogSearches'
                $Results = Get-CIPPAzDataTableEntity @Table -Filter "StartTime ge datetime'$StartTime'" | ForEach-Object {
                    $Query = try { $_.Query | ConvertFrom-Json } catch { $_.Query }
                    $MatchedRules = try { $_.MatchedRules | ConvertFrom-Json } catch { $_.MatchedRules }
                    [PSCustomObject]@{
                        SearchId     = $_.RowKey
                        StartTime    = $_.StartTime.DateTime
                        EndTime      = $_.EndTime.DateTime
                        Query        = $Query
                        MatchedRules = $MatchedRules
                        TotalLogs    = $_.TotalLogs
                        MatchedLogs  = $_.MatchedLogs
                        CippStatus   = $_.CippStatus
                    }
                }

                $Body = @{
                    Results  = @($Results)
                    Metadata = @{
                        StartTime    = $StartTime
                        TenantFilter = $TenantFilter
                    }
                } | ConvertTo-Json -Depth 10 -Compress
            }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Body
            })
    } else {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = 'TenantFilter is required'
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogSearches.ps1' 87
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogTest.ps1' -1

function Invoke-ListAuditLogTest {
    <#
    .FUNCTIONALITY
    Entrypoint,AnyTenant

    .ROLE
    Tenant.Alert.Read
    #>
    Param($Request, $TriggerMetadata)
    $AuditLogQuery = @{
        TenantFilter = $Request.Query.TenantFilter
        SearchId     = $Request.Query.SearchId
    }
    try {
        $TestResults = Test-CIPPAuditLogRules @AuditLogQuery
    } catch {
        $Body = Get-CippException -Exception $_
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $Body
            })
        return
    }
    $Body = @{
        Results  = @($TestResults.DataToProcess)
        Metadata = @{
            TenantFilter = $AuditLogQuery.TenantFilter
            LogType      = $AuditLogQuery.LogType
            TotalLogs    = $TestResults.TotalLogs
            MatchedLogs  = $TestResults.MatchedLogs
            MatchedRules = $TestResults.MatchedRules
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListAuditLogTest.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListWebhookAlert.ps1' -1

Function Invoke-ListWebhookAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $Table = Get-CippTable -TableName 'SchedulerConfig'
    $WebhookRow = foreach ($Webhook in (Get-CIPPAzDataTableEntity @Table | Where-Object -Property PartitionKey -EQ 'WebhookAlert')) {
        $Webhook.If = $Webhook.If | ConvertFrom-Json
        $Webhook.execution = $Webhook.execution | ConvertFrom-Json
        $Webhook
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($WebhookRow)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-ListWebhookAlert.ps1' 23
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-PublicWebhooks.ps1' -1

function Invoke-PublicWebhooks {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Public
    #>
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    Set-Location (Get-Item $PSScriptRoot).Parent.FullName
    $WebhookTable = Get-CIPPTable -TableName webhookTable
    $WebhookIncoming = Get-CIPPTable -TableName WebhookIncoming
    $Webhooks = Get-CIPPAzDataTableEntity @WebhookTable
    Write-Host 'Received request'
    $url = ($Headers.'x-ms-original-url').split('/API') | Select-Object -First 1
    $CIPPURL = [string]$url
    Write-Host $url
    if ($Webhooks.Resource -eq 'M365AuditLogs') {
        Write-Host "Found M365AuditLogs - This is an old entry, we'll deny so Microsoft stops sending it."
        $body = 'This webhook is not authorized, its an old entry.'
        $StatusCode = [HttpStatusCode]::Forbidden
    }
    if ($Request.Query.ValidationToken) {
        Write-Host 'Validation token received - query ValidationToken'
        $body = $Request.Query.ValidationToken
        $StatusCode = [HttpStatusCode]::OK
    } elseif ($Request.Body.validationCode) {
        Write-Host 'Validation token received - body validationCode'
        $body = $Request.Body.validationCode
        $StatusCode = [HttpStatusCode]::OK
    } elseif ($Request.Query.validationCode) {
        Write-Host 'Validation token received - query validationCode'
        $body = $Request.Query.validationCode
        $StatusCode = [HttpStatusCode]::OK
    } elseif ($Request.Query.CIPPID -in $Webhooks.RowKey) {
        Write-Host 'Found matching CIPPID'
        $url = ($Headers.'x-ms-original-url').split('/API') | Select-Object -First 1
        $Webhookinfo = $Webhooks | Where-Object -Property RowKey -EQ $Request.Query.CIPPID

        if ($Request.Query.Type -eq 'GraphSubscription') {
            # Graph Subscriptions
            [pscustomobject]$ReceivedItem = $Request.Body.value
            $Entity = [PSCustomObject]@{
                PartitionKey = 'Webhook'
                RowKey       = [string](New-Guid).Guid
                Type         = $Request.Query.Type
                Data         = [string]($ReceivedItem | ConvertTo-Json -Depth 10)
                CIPPID       = $Request.Query.CIPPID
                WebhookInfo  = [string]($WebhookInfo | ConvertTo-Json -Depth 10)
                FunctionName = 'PublicWebhookProcess'
            }
            Add-CIPPAzDataTableEntity @WebhookIncoming -Entity $Entity
            ## Push webhook data to queue
            #Invoke-CippGraphWebhookProcessing -Data $ReceivedItem -CIPPID $request.Query.CIPPID -WebhookInfo $Webhookinfo

        } elseif ($Request.Query.Type -eq 'PartnerCenter') {
            [pscustomobject]$ReceivedItem = $Request.Body
            $Entity = [PSCustomObject]@{
                PartitionKey = 'Webhook'
                RowKey       = [string](New-Guid).Guid
                Type         = $Request.Query.Type
                Data         = [string]($ReceivedItem | ConvertTo-Json -Depth 10)
                CIPPID       = $Request.Query.CIPPID
                WebhookInfo  = [string]($WebhookInfo | ConvertTo-Json -Depth 10)
                FunctionName = 'PublicWebhookProcess'
            }
            Add-CIPPAzDataTableEntity @WebhookIncoming -Entity $Entity
        } else {
            $Body = 'This webhook is not authorized.'
            $StatusCode = [HttpStatusCode]::Forbidden
        }
        $Body = 'Webhook Received'
        $StatusCode = [HttpStatusCode]::OK

    } else {
        $Body = 'This webhook is not authorized.'
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-PublicWebhooks.ps1' 87
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-RemoveQueuedAlert.ps1' -1

Function Invoke-RemoveQueuedAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with the query or body of the request
    $EventType = $Request.Query.EventType ?? $Request.Body.EventType
    $ID = $Request.Query.ID ?? $Request.Body.ID

    if ($EventType -eq 'Audit log Alert') {
        $Table = 'WebhookRules'
    } else {
        $Table = 'ScheduledTasks'
    }

    $Table = Get-CIPPTable -TableName $Table
    try {
        $Filter = "RowKey eq '{0}'" -f $ID
        $Alert = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $Alert
        $Result = "Successfully removed alert $ID from queue"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove alert from queue $ID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Alerts/Invoke-RemoveQueuedAlert.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAddMultiTenantApp.ps1' -1

function Invoke-ExecAddMultiTenantApp {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Application.ReadWrite
    #>
    param($Request, $TriggerMetadata)
    if ($Request.Body.configMode -eq 'manual') {
        $DelegateResources = $request.body.permissions | Where-Object -Property origin -EQ 'Delegated' | ForEach-Object { @{ id = $_.id; type = 'Scope' } }
        $DelegateResourceAccess = @{ ResourceAppId = '00000003-0000-0000-c000-000000000000'; resourceAccess = $DelegateResources }
        $ApplicationResources = $request.body.permissions | Where-Object -Property origin -EQ 'Application' | ForEach-Object { @{ id = $_.id; type = 'Role' } }
        $ApplicationResourceAccess = @{ ResourceAppId = '00000003-0000-0000-c000-000000000000'; resourceAccess = $ApplicationResources }

        $Results = try {
            if ($Request.Body.CopyPermissions -eq $true) {
                $Command = 'ExecApplicationCopy'
            } else {
                $Command = 'ExecAddMultiTenantApp'
            }
            if ('allTenants' -in $Request.Body.tenantFilter.value) {
                $TenantFilter = (Get-Tenants).defaultDomainName
            } else {
                $TenantFilter = $Request.Body.tenantFilter.value
            }

            $TenantCount = ($TenantFilter | Measure-Object).Count
            $Queue = New-CippQueueEntry -Name 'Application Approval' -TotalTasks $TenantCount
            $Batch = foreach ($Tenant in $TenantFilter) {
                [pscustomobject]@{
                    FunctionName              = $Command
                    Tenant                    = $tenant
                    AppId                     = $Request.Body.AppId
                    applicationResourceAccess = $ApplicationResourceAccess
                    delegateResourceAccess    = $DelegateResourceAccess
                    QueueId                   = $Queue.RowKey
                }
            }

            try {
                $InputObject = @{
                    OrchestratorName = 'ExecMultiTenantAppOrchestrator'
                    Batch            = @($Batch)
                    SkipLog          = $true
                }
                $null = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                $Results = 'Deploying {0} to {1}, see the logbook for details' -f $Request.Body.AppId, ($Request.Body.tenantFilter.label -join ', ')
            } catch {
                $ErrorMsg = Get-NormalizedError -message $($_.Exception.Message)
                $Results = "Function Error: $ErrorMsg"
            }

            $StatusCode = [HttpStatusCode]::OK
        } catch {
            $ErrorMsg = Get-NormalizedError -message $($_.Exception.Message)
            $Results = "Function Error: $ErrorMsg"
            $StatusCode = [HttpStatusCode]::BadRequest
        }
    } elseif ($Request.Body.configMode -eq 'template') {
        Write-Information 'Application Approval - Template Mode'
        if ('allTenants' -in $Request.Body.tenantFilter.value) {
            $TenantFilter = (Get-Tenants).defaultDomainName
        } else {
            $TenantFilter = $Request.Body.tenantFilter.value
        }
        $TenantCount = ($TenantFilter | Measure-Object).Count
        $Queue = New-CippQueueEntry -Name 'Application Approval (Template)' -TotalTasks $TenantCount

        $Batch = foreach ($Tenant in $TenantFilter) {
            [pscustomobject]@{
                FunctionName = 'ExecAppApprovalTemplate'
                Tenant       = $tenant
                TemplateId   = $Request.Body.selectedTemplate.value
                AppId        = $Request.Body.selectedTemplate.addedFields.AppId
                QueueId      = $Queue.RowKey
            }
        }
        try {
            $InputObject = @{
                OrchestratorName = 'ExecMultiTenantAppOrchestrator'
                Batch            = @($Batch)
                SkipLog          = $true
            }
            $null = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
            $Results = 'Deploying {0} to {1}, see the logbook for details' -f $Request.Body.selectedTemplate.label, ($Request.Body.tenantFilter.label -join ', ')
        } catch {
            $Results = "Error queuing application - $($_.Exception.Message)"
        }
        $StatusCode = [HttpStatusCode]::OK
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ Results = @($Results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAddMultiTenantApp.ps1' 98
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppApproval.ps1' -1

function Invoke-ExecAppApproval {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Seems to be an unused endpoint? -Bobby

    $ApplicationId = if ($Request.Query.ApplicationId) { $Request.Query.ApplicationId } else { $env:ApplicationID }
    $Results = Get-Tenants | ForEach-Object {
        [PSCustomObject]@{
            defaultDomainName = $_.defaultDomainName
            link              = "https://login.microsoftonline.com/$($_.customerId)/v2.0/adminconsent?client_id=$ApplicationId&scope=$ApplicationId/.default"
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppApproval.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppApprovalTemplate.ps1' -1

function Invoke-ExecAppApprovalTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Table = Get-CIPPTable -TableName 'templates'
    $User = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json

    $Action = $Request.Query.Action ?? $Request.Body.Action

    switch ($Action) {
        'Save' {
            try {
                $GUID = $Request.Body.TemplateId ?? (New-Guid).GUID

                # Create structured object for the template
                $templateObject = $Request.Body | Select-Object -Property * -ExcludeProperty Action, TemplateId

                # Add additional metadata
                $templateObject | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID
                $templateObject | Add-Member -NotePropertyName 'CreatedBy' -NotePropertyValue ($User.UserDetails ?? 'CIPP-API')
                $templateObject | Add-Member -NotePropertyName 'CreatedOn' -NotePropertyValue (Get-Date).ToString('o')

                # If updating an existing template, add UpdatedBy and UpdatedOn
                if ($Request.Body.TemplateId) {
                    $templateObject | Add-Member -NotePropertyName 'UpdatedBy' -NotePropertyValue ($User.UserDetails ?? 'CIPP-API')
                    $templateObject | Add-Member -NotePropertyName 'UpdatedOn' -NotePropertyValue (Get-Date).ToString('o')
                }

                # Convert to JSON, preserving the original structure
                $templateJson = $templateObject | ConvertTo-Json -Depth 10 -Compress

                # Add to templates table with AppApprovalTemplate partition key
                $Table.Force = $true
                Add-CIPPAzDataTableEntity @Table -Entity @{
                    JSON         = [string]$templateJson
                    RowKey       = "$GUID"
                    PartitionKey = 'AppApprovalTemplate'
                }

                # Return a proper array with ONE element containing the TemplateId
                $Body = @(
                    [PSCustomObject]@{
                        'Results'  = 'Template Saved'
                        'Metadata' = @{
                            'TemplateName' = $Request.Body.TemplateName
                            'TemplateId'   = $GUID
                        }
                    }
                )

                Write-LogMessage -headers $Headers -API $APIName -message "App Deployment Template Saved: $($Request.Body.TemplateName)" -Sev 'Info'
            } catch {
                $Body = @{
                    'Results' = $_.Exception.Message
                }
                Write-LogMessage -headers $Headers -API $APIName -message "App Deployment Template Save failed: $($_.Exception.Message)" -Sev 'Error'
            }
        }
        'Delete' {
            try {
                $TemplateId = $Request.Body.TemplateId

                # Get the template to delete
                $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$TemplateId'"

                if ($Template) {
                    $TemplateData = $Template.JSON | ConvertFrom-Json
                    $TemplateName = $TemplateData.TemplateName

                    # Remove the template
                    $null = Remove-AzDataTableEntity @Table -Entity $Template -Force

                    $Body = @{
                        'Results' = "Successfully deleted template '$TemplateName'"
                    }
                    Write-LogMessage -headers $Headers -API $APIName -message "App Deployment Template deleted: $TemplateName" -Sev 'Info'
                } else {
                    $Body = @{
                        'Results' = 'No template found with the provided ID'
                    }
                }
            } catch {
                $Body = @{
                    'Results' = "Failed to delete template: $($_.Exception.Message)"
                }
                Write-LogMessage -headers $Headers -API $APIName -message "App Deployment Template Delete failed: $($_.Exception.Message)" -Sev 'Error'
            }
        }
        'Get' {
            # Check if TemplateId is provided to filter results
            $filter = "PartitionKey eq 'AppApprovalTemplate'"
            if ($Request.Query.TemplateId) {
                $templateId = $Request.Query.TemplateId
                $filter = "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$templateId'"
            }

            $Templates = Get-CIPPAzDataTableEntity @Table -Filter $filter

            $Body = $Templates | ForEach-Object {
                # Parse the JSON
                $templateData = $_.JSON | ConvertFrom-Json

                # Create output object preserving original structure
                $outputObject = $templateData | Select-Object -Property *

                # Add the TemplateId (RowKey) to the output
                $outputObject | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $_.RowKey -Force

                # Add timestamp from the table entity
                $outputObject | Add-Member -NotePropertyName 'Timestamp' -NotePropertyValue $_.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ') -Force

                return $outputObject
            }
        }
        default {
            # Default action - list all templates
            $filter = "PartitionKey eq 'AppApprovalTemplate'"

            $Templates = Get-CIPPAzDataTableEntity @Table -Filter $filter

            $Body = $Templates | ForEach-Object {
                # Parse the JSON
                $templateData = $_.JSON | ConvertFrom-Json

                # Create output object preserving original structure
                $outputObject = $templateData | Select-Object -Property *

                # Add the TemplateId (RowKey) to the output
                $outputObject | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $_.RowKey -Force

                # Add timestamp from the table entity
                $outputObject | Add-Member -NotePropertyName 'Timestamp' -NotePropertyValue $_.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ') -Force

                return $outputObject
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -Depth 10 -InputObject @($Body)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppApprovalTemplate.ps1' 154
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecApplication.ps1' -1

function Invoke-ExecApplication {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $ValidTypes = @('applications', 'servicePrincipals')
    $ValidActions = @('Update', 'Upsert', 'Delete', 'RemoveKey', 'RemovePassword')

    $Id = $Request.Query.Id ?? $Request.Body.Id
    $Type = $Request.Query.Type ?? $Request.Body.Type
    if (-not $Id) {
        $AppId = $Request.Query.AppId ?? $Request.Body.AppId
        if (-not $AppId) {
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::BadRequest
                    Body       = "Required parameter 'Id' or 'AppId' is missing"
                })
            return
        }
        $IdPath = "(appId='$AppId')"
    } else {
        $IdPath = "/$Id"
    }
    if ($Type -and $ValidTypes -notcontains $Type) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = "Invalid Type specified. Valid types are: $($ValidTypes -join ', ')"
            })
        return
    }

    $Uri = "https://graph.microsoft.com/beta/$($Type)$($IdPath)"
    $Action = $Request.Query.Action ?? $Request.Body.Action

    if ($ValidActions -notcontains $Action) {
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = "Invalid Action specified. Valid actions are: $($ValidActions -join ', ')"
            })
        return
    }

    $PostParams = @{
        Uri = $Uri
    }

    if ($Action -eq 'Delete') {
        $PostParams.Type = 'DELETE'
    }
    if ($Action -eq 'Update' -or $Action -eq 'Upsert') {
        $PostParams.Type = 'PATCH'
    }

    if ($Action -eq 'Upsert') {
        $PostParams.AddedHeaders = @{
            'Prefer' = 'create-if-missing'
        }
    }

    if ($Request.Body) {
        $PostParams.Body = $Request.Body.Payload | ConvertTo-Json -Compress
    }

    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter

    try {
        if ($Action -eq 'RemoveKey' -or $Action -eq 'RemovePassword') {
            # Handle credential removal
            $KeyIds = $Request.Body.KeyIds.value ?? $Request.Body.KeyIds
            if (-not $KeyIds -or $KeyIds.Count -eq 0) {
                return ([HttpResponseContext]@{
                        StatusCode = [HttpStatusCode]::BadRequest
                        Body       = "KeyIds parameter is required for $Action action"
                    })
                return
            }

            if ($Action -eq 'RemoveKey') {
                # For key credentials, use a single PATCH request
                $CurrentObject = New-GraphGetRequest -Uri $Uri -tenantid $TenantFilter -AsApp $true
                $UpdatedKeyCredentials = $CurrentObject.keyCredentials | Where-Object { $_.keyId -notin $KeyIds }
                $PatchBody = @{
                    keyCredentials = @($UpdatedKeyCredentials)
                }

                $Response = New-GraphPOSTRequest -Uri $Uri -Type 'PATCH' -Body ($PatchBody | ConvertTo-Json -Depth 10) -tenantid $TenantFilter -AsApp $true

                $Results = @{
                    resultText = "Successfully removed $($KeyIds.Count) key credential(s) from $Type"
                    state      = 'success'
                    details    = @($Response)
                }
            } else {
                # For password credentials, use bulk removePassword requests
                $BulkRequests = foreach ($KeyId in $KeyIds) {
                    $RemoveBody = @{
                        keyId = $KeyId
                    }

                    @{
                        id      = $KeyId
                        method  = 'POST'
                        url     = "$($Type)$($IdPath)/removePassword"
                        body    = $RemoveBody
                        headers = @{
                            'Content-Type' = 'application/json'
                        }
                    }
                }

                $BulkResults = New-GraphBulkRequest -Requests @($BulkRequests) -tenantid $TenantFilter -AsApp $true

                $SuccessCount = ($BulkResults | Where-Object { $_.status -eq 204 }).Count
                $FailureCount = ($BulkResults | Where-Object { $_.status -ne 204 }).Count

                $Results = @{
                    resultText = "Bulk RemovePassword completed. Success: $SuccessCount, Failures: $FailureCount"
                    state      = if ($FailureCount -eq 0) { 'success' } else { 'error' }
                    details    = @($BulkResults)
                }
            }
        } else {
            # Handle regular actions
            $null = New-GraphPOSTRequest @PostParams -tenantid $TenantFilter -AsApp $true
            $Results = @{
                resultText = "Successfully executed $Action on $Type with Id: $Id"
                state      = 'success'
            }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{ Results = $Results }
            })
    } catch {
        $Results = @{
            resultText = "Failed to execute $Action on $Type with Id: $Id. Error: $($_.Exception.Message)"
            state      = 'error'
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = @{ Results = @($Results) }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecApplication.ps1' 151
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppPermissionTemplate.ps1' -1

function Invoke-ExecAppPermissionTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.ApplicationTemplates.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $Table = Get-CIPPTable -TableName 'AppPermissions'

    $User = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json

    $Action = $Request.Query.Action ?? $Request.Body.Action

    switch ($Action) {
        'Save' {
            try {
                $RowKey = $Request.Body.TemplateId ?? [guid]::NewGuid().ToString()
                $Permissions = $Request.Body.Permissions
                $Entity = @{
                    'PartitionKey' = 'Templates'
                    'RowKey'       = [string]$RowKey
                    'TemplateName' = [string]$Request.Body.TemplateName
                    'Permissions'  = [string]($Permissions | ConvertTo-Json -Depth 10 -Compress)
                    'UpdatedBy'    = $User.UserDetails ?? 'CIPP-API'
                }
                $null = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
                $Body = @{
                    'Results'  = 'Template Saved'
                    'Metadata' = @{
                        'TemplateName' = $Entity.TemplateName
                        'TemplateId'   = $RowKey
                    }
                }
                Write-LogMessage -headers $Headers -API 'ExecAppPermissionTemplate' -message "Permissions Saved for template: $($Request.Body.TemplateName)" -Sev 'Info' -LogData $Permissions
            } catch {
                Write-Information "Failed to save template: $($_.Exception.Message) - $($_.InvocationInfo.PositionMessage)"
                $Body = @{
                    'Results' = $_.Exception.Message
                }
            }
        }
        'Delete' {
            try {
                $TemplateId = $Request.Body.TemplateId
                $Template = (Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Templates' and RowKey eq '$TemplateId'")
                $TemplateName = $Template.TemplateName

                if ($TemplateId) {
                    $null = Remove-AzDataTableEntity @Table -Entity $Template -Force
                    $Body = @{
                        'Results' = "Successfully deleted template '$TemplateName'"
                    }
                    Write-LogMessage -headers $Headers -API 'ExecAppPermissionTemplate' -message "Permission template deleted: $TemplateName" -Sev 'Info'
                } else {
                    $Body = @{
                        'Results' = 'No Template ID provided for deletion'
                    }
                }
            } catch {
                $Body = @{
                    'Results' = "Failed to delete template: $($_.Exception.Message)"
                }
            }
        }
        default {
            # Check if TemplateId is provided to filter results
            $filter = "PartitionKey eq 'Templates'"
            if ($Request.Query.TemplateId) {
                $templateId = $Request.Query.TemplateId
                $filter = "PartitionKey eq 'Templates' and RowKey eq '$templateId'"
                Write-LogMessage -headers $Headers -API 'ExecAppPermissionTemplate' -message "Retrieved specific template: $templateId" -Sev 'Info'
            }

            $Body = Get-CIPPAzDataTableEntity @Table -Filter $filter | ForEach-Object {
                [PSCustomObject]@{
                    TemplateId   = $_.RowKey
                    TemplateName = $_.TemplateName
                    Permissions  = $_.Permissions | ConvertFrom-Json
                    UpdatedBy    = $_.UpdatedBy
                    Timestamp    = $_.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ')
                }
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -Depth 10 -InputObject @($Body)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecAppPermissionTemplate.ps1' 97
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecCreateAppTemplate.ps1' -1

#using namespace System.Net

function Invoke-ExecCreateAppTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Application.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $TriggerMetadata.FunctionName
    Write-LogMessage -headers $Request.headers -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    try {
        $TenantFilter = $Request.Body.TenantFilter
        $AppId = $Request.Body.AppId
        $DisplayName = $Request.Body.DisplayName
        $Type = $Request.Body.Type # 'servicePrincipal' or 'application'

        if ([string]::IsNullOrWhiteSpace($AppId)) {
            throw 'AppId is required'
        }

        if ([string]::IsNullOrWhiteSpace($DisplayName)) {
            throw 'DisplayName is required'
        }

        # Get the app details based on type
        if ($Type -eq 'servicePrincipal') {
            # For enterprise apps (service principals)
            $AppDetails = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$filter=appId eq '$AppId'&`$select=id,appId,displayName,appRoles,oauth2PermissionScopes,requiredResourceAccess" -tenantid $TenantFilter

            if (-not $AppDetails -or $AppDetails.Count -eq 0) {
                throw "Service principal not found for AppId: $AppId"
            }

            $App = $AppDetails[0]

            # Get the application registration to access requiredResourceAccess
            try {
                $AppRegistration = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications?`$filter=appId eq '$AppId'&`$select=id,appId,displayName,requiredResourceAccess" -tenantid $TenantFilter
                if ($AppRegistration -and $AppRegistration.Count -gt 0) {
                    $RequiredResourceAccess = $AppRegistration[0].requiredResourceAccess
                } else {
                    $RequiredResourceAccess = @()
                }
            } catch {
                Write-LogMessage -headers $Request.headers -API $APINAME -message "Could not retrieve app registration for $AppId - will extract from service principal" -Sev 'Warning'
                $RequiredResourceAccess = @()
            }

            # Use requiredResourceAccess if available, otherwise we can't create a proper template
            if ($RequiredResourceAccess -and $RequiredResourceAccess.Count -gt 0) {
                $Permissions = $RequiredResourceAccess
            } else {
                # No permissions found - warn the user
                Write-LogMessage -headers $Request.headers -API $APINAME -message "No permissions found for $AppId. The app registration may not have configured API permissions." -Sev 'Warning'
                $Permissions = @()
            }
        } else {
            # For app registrations (applications)
            $App = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications(appId='$AppId')" -tenantid $TenantFilter
            if (-not $App -or $App.Count -eq 0) {
                throw "App registration not found for AppId: $AppId"
            }

            $Tenant = Get-Tenants -TenantFilter $TenantFilter
            if ($Tenant.customerId -ne $env:TenantID) {
                $ExistingApp = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications?`$filter=displayName eq '$DisplayName'" -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true

                if ($ExistingApp) {
                    Write-Information "App Registration $AppId already exists in partner tenant"
                    $AppId = $ExistingApp.appId
                    $App = $ExistingApp
                    Write-LogMessage -headers $Request.headers -API $APINAME -message "App Registration $($AppDetails.displayName) already exists in partner tenant" -Sev 'Info'
                } else {
                    Write-Information "Copying App Registration $AppId from customer tenant $TenantFilter to partner tenant"
                    $PropertiesToRemove = @(
                        'appId'
                        'id'
                        'createdDateTime'
                        'deletedDateTime'
                        'publisherDomain'
                        'servicePrincipalLockConfiguration'
                        'identifierUris'
                        'applicationIdUris'
                        'keyCredentials'
                        'passwordCredentials'
                        'isDisabled'
                    )
                    $AppCopyBody = $App | Select-Object -Property * -ExcludeProperty $PropertiesToRemove
                    # Remove any null properties
                    $NullProperties = [System.Collections.Generic.List[string]]::new()
                    foreach ($Property in $AppCopyBody.PSObject.Properties.Name) {
                        if ($null -eq $AppCopyBody.$Property -or $AppCopyBody.$Property -eq '' -or !$AppCopyBody.$Property) {
                            Write-Information "Removing null property $Property from app copy body"
                            $NullProperties.Add($Property)
                        }
                    }
                    $AppCopyBody = $AppCopyBody | Select-Object -Property * -ExcludeProperty $NullProperties
                    if ($AppCopyBody.signInAudience -eq 'AzureADMyOrg') {
                        # Enterprise apps cannot be copied to another tenant
                        $AppCopyBody.signInAudience = 'AzureADMultipleOrgs'
                    }
                    if ($AppCopyBody.web -and $AppCopyBody.web.redirectUris) {
                        # Remove redirect URI settings if property exists
                        $AppCopyBody.web.PSObject.Properties.Remove('redirectUriSettings')
                    }
                    if ($AppCopyBody.api.oauth2PermissionScopes) {
                        $AppCopyBody.api.oauth2PermissionScopes = @(foreach ($Scope in $AppCopyBody.api.oauth2PermissionScopes) {
                                $Scope | Select-Object * -ExcludeProperty 'isPrivate'
                            })
                    }
                    if ($AppCopyBody.appRoles) {
                        $AppCopyBody.appRoles = @(foreach ($Role in $AppCopyBody.api.appRoles) {
                                $Role | Select-Object * -ExcludeProperty 'isPreAuthorizationRequired', 'isPrivate'
                            })
                    }
                    if ($AppCopyBody.api -and $AppCopyBody.api.tokenEncryptionSetting) {
                        # Remove token encryption settings if property exists
                        $AppCopyBody.api.PSObject.Properties.Remove('tokenEncryptionSetting')
                    }

                    $NewApp = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/applications' -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true -type POST -body ($AppCopyBody | ConvertTo-Json -Depth 10)

                    if (-not $NewApp) {
                        throw 'Failed to copy app registration to partner tenant'
                    }

                    Write-Information "App Registration copied. New AppId: $($NewApp.appId)"
                    $App = $NewApp
                    $AppId = $NewApp.appId
                    Write-Information "Creating service principal for AppId: $AppId in partner tenant"
                    $Body = @{
                        appId = $AppId
                    }
                    $NewSP = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/v1.0/servicePrincipals' -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true -type POST -body ($Body | ConvertTo-Json -Depth 10)
                    Write-LogMessage -headers $Request.headers -API $APINAME -message "App Registration $($AppDetails.displayName) copied to partner tenant" -Sev 'Info'
                }
            }

            $Permissions = if ($App.requiredResourceAccess) { $App.requiredResourceAccess } else { @() }
        }

        # Transform requiredResourceAccess to the CIPP permission format
        # CIPP expects: { "resourceAppId": { "applicationPermissions": [], "delegatedPermissions": [] } }
        # Graph returns: [ { "resourceAppId": "...", "resourceAccess": [ { "id": "...", "type": "Role|Scope" } ] } ]
        $CIPPPermissions = @{}
        $PermissionSetId = $null
        $PermissionSetName = "$DisplayName (Auto-created)"

        if ($Permissions -and $Permissions.Count -gt 0) {
            foreach ($Resource in $Permissions) {
                $ResourceAppId = $Resource.resourceAppId
                $AppPerms = [System.Collections.ArrayList]::new()
                $DelegatedPerms = [System.Collections.ArrayList]::new()

                foreach ($Access in $Resource.resourceAccess) {
                    $PermObj = [PSCustomObject]@{
                        id    = $Access.id
                        value = $Access.id  # In the permission set format, both id and value are the permission ID
                    }

                    if ($Access.type -eq 'Role') {
                        [void]$AppPerms.Add($PermObj)
                    } elseif ($Access.type -eq 'Scope') {
                        [void]$DelegatedPerms.Add($PermObj)
                    }
                }

                $CIPPPermissions[$ResourceAppId] = [PSCustomObject]@{
                    applicationPermissions = @($AppPerms)
                    delegatedPermissions   = @($DelegatedPerms)
                }
            }

            # Create the permission set in AppPermissions table
            $PermissionSetId = (New-Guid).Guid
            $PermissionsTable = Get-CIPPTable -TableName 'AppPermissions'

            $PermissionEntity = @{
                'PartitionKey' = 'Templates'
                'RowKey'       = [string]$PermissionSetId
                'TemplateName' = [string]$PermissionSetName
                'Permissions'  = [string]($CIPPPermissions | ConvertTo-Json -Depth 10 -Compress)
                'UpdatedBy'    = [string]'CIPP-API'
            }

            Add-CIPPAzDataTableEntity @PermissionsTable -Entity $PermissionEntity -Force
            Write-LogMessage -headers $Request.headers -API $APINAME -message "Permission set created with ID: $PermissionSetId for $($Permissions.Count) resource(s)" -Sev 'Info'
        }

        # Create the template
        $Table = Get-CIPPTable -TableName 'templates'
        $TemplateId = (New-Guid).Guid

        $TemplateJson = @{
            TemplateName      = "$DisplayName (Auto-created)"
            AppId             = $AppId
            AppName           = $DisplayName
            AppType           = 'EnterpriseApp'
            Permissions       = $CIPPPermissions
            PermissionSetId   = $PermissionSetId
            PermissionSetName = $PermissionSetName
            AutoCreated       = $true
            SourceTenant      = $TenantFilter
            CreatedDate       = (Get-Date).ToString('yyyy-MM-ddTHH:mm:ss')
        } | ConvertTo-Json -Depth 10 -Compress

        $Entity = @{
            JSON         = "$TemplateJson"
            RowKey       = "$TemplateId"
            PartitionKey = 'AppApprovalTemplate'
        }

        Add-CIPPAzDataTableEntity @Table -Entity $Entity

        $PermissionCount = 0
        if ($CIPPPermissions -and $CIPPPermissions.Count -gt 0) {
            foreach ($ResourceAppId in $CIPPPermissions.Keys) {
                $Resource = $CIPPPermissions[$ResourceAppId]
                if ($Resource.applicationPermissions) {
                    $PermissionCount = $PermissionCount + $Resource.applicationPermissions.Count
                }
                if ($Resource.delegatedPermissions) {
                    $PermissionCount = $PermissionCount + $Resource.delegatedPermissions.Count
                }
            }
        }

        $Message = "Template created: $DisplayName with $PermissionCount permission(s)"
        Write-LogMessage -headers $Request.headers -API $APINAME -message $Message -Sev 'Info'

        $Body = @{
            Results  = @{'resultText' = $Message; 'state' = 'success' }
            Metadata = @{
                TemplateId   = $TemplateId
                SourceTenant = $TenantFilter
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -headers $Request.headers -API $APINAME -message "Failed to create template: $ErrorMessage" -Sev 'Error' -LogData (Get-CippException -Exception $_)
        Write-Warning "Failed to create template: $ErrorMessage"
        Write-Information $_.InvocationInfo.PositionMessage

        $Body = @{
            Results = @(@{
                    resultText = "Failed to create template: $ErrorMessage"
                    state      = 'error'
                    details    = Get-CippException -Exception $_
                })
        }
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = ($Body | ConvertTo-Json -Depth 10)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ExecCreateAppTemplate.ps1' 265
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ListAppApprovalTemplates.ps1' -1

function Invoke-ListAppApprovalTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Table = Get-CIPPTable -TableName 'templates'

    try {
        # Use the templates table with AppApprovalTemplate partition key
        $filter = "PartitionKey eq 'AppApprovalTemplate'"

        $Templates = Get-CIPPAzDataTableEntity @Table -Filter $filter

        $Body = $Templates | ForEach-Object {
            try {
                # Safely parse the JSON data - handle potential invalid JSON format
                $TemplateData = $null
                if ($_.JSON) {
                    $TemplateData = $_.JSON | ConvertFrom-Json -ErrorAction Stop
                }

                # Create a base object with properties directly from the table entity
                $templateObject = [PSCustomObject]@{
                    TemplateId = $_.RowKey
                    Timestamp  = $_.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ')
                }

                # Add all properties from the JSON data if available
                if ($TemplateData) {
                    foreach ($property in $TemplateData.PSObject.Properties) {
                        $templateObject | Add-Member -NotePropertyName $property.Name -NotePropertyValue $property.Value -Force
                    }
                }

                return $templateObject
            } catch {
                Write-LogMessage -headers $Headers -API $APIName -message "Error processing template $($_.RowKey): $($_.Exception.Message)" -Sev 'Error'
                return [PSCustomObject]@{
                    TemplateId   = $_.RowKey
                    TemplateName = 'Error parsing template data'
                    Error        = $_.Exception.Message
                    Timestamp    = $_.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ')
                }
            }
        }

    } catch {
        $Body = @{
            Results = "Failed to list app deployment templates: $($_.Exception.Message)"
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ConvertTo-Json -Depth 10 -InputObject @($Body)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Application Approval/Invoke-ListAppApprovalTemplates.ps1' 67
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecAddSPN.ps1' -1

Function Invoke-ExecAddSPN {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    try {
        $null = New-GraphPostRequest -uri 'https://graph.microsoft.com/v1.0/servicePrincipals' -tenantid $env:TenantID -type POST -Body "{ `"appId`": `"2832473f-ec63-45fb-976f-5d45a7d4bb91`" }" -NoAuthCheck $true
        $Result = "Successfully completed request. Add your GDAP migration permissions to your SAM application here: https://portal.azure.com/#view/Microsoft_AAD_RegisteredApps/ApplicationMenuBlade/~/CallAnAPI/appId/$($env:ApplicationID)/isMSAApp/ "
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to add SPN. The error was: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $env:TenantID -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecAddSPN.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecOffboardTenant.ps1' -1

function Invoke-ExecOffboardTenant {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    try {
        $TenantQuery = $Request.Body.TenantFilter.value ?? $Request.Body.TenantFilter

        $Tenant = Get-Tenants -IncludeAll -TenantFilter $TenantQuery
        $TenantId = $Tenant.customerId
        $TenantFilter = $Tenant.defaultDomainName

        $Results = [System.Collections.Generic.List[object]]::new()
        $Errors = [System.Collections.Generic.List[object]]::new()

        if (!$Tenant) {
            $Results.Add('Tenant has already been offboarded')
        } elseif ($TenantId -eq $env:TenantID) {
            $Errors.Add('You cannot offboard the CSP tenant')
        } else {
            if ($request.body.RemoveCSPGuestUsers -eq $true) {
                # Delete guest users who's domains match the CSP tenants
                try {
                    try {
                        $domains = (New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/domains?`$select=id" -tenantid $env:TenantID -NoAuthCheck:$true).id
                        $DomainFilter = ($Domains | ForEach-Object { "endswith(mail, '$_')" }) -join ' or '
                        $CSPGuestUsers = (New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/users?`$select=id,mail&`$filter=userType eq 'Guest' and ($DomainFilter)&`$count=true" -tenantid $TenantFilter -ComplexFilter)
                    } catch {
                        $Errors.Add("Failed to retrieve guest users: $($_.Exception.message)")
                    }

                    if ($CSPGuestUsers) {
                        [System.Collections.Generic.List[PSCustomObject]]$BulkRequests = @($CSPGuestUsers | ForEach-Object {
                                @{
                                    id     = $($_.id)
                                    method = 'DELETE'
                                    url    = "/users/$($_.id)"
                                }
                            })

                        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

                        $results.Add('Successfully removed guest users')
                        Write-LogMessage -headers $Request.Headers -API $APIName -message 'CSP Guest users were removed' -Sev 'Info' -tenant $TenantFilter
                    } else {
                        $results.Add('No guest users found to remove')
                    }
                } catch {
                    $errors.Add("Something went wrong while deleting guest users: $($_.Exception.message)")
                }
            }

            if ($request.body.RemoveCSPnotificationContacts -eq $true) {
                # Remove all email addresses that match the CSP tenants domains from the contact properties in /organization
                try {
                    try {
                        $domains = (New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/domains?`$select=id" -tenantid $env:TenantID -NoAuthCheck:$true).id
                    } catch {
                        throw "Failed to retrieve CSP domains: $($_.Exception.message)"
                    }

                    try {
                        # Get /organization data
                        $orgContacts = New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/organization?`$select=id,marketingNotificationEmails,securityComplianceNotificationMails,technicalNotificationMails" -tenantid $TenantFilter

                    } catch {
                        throw "Failed to retrieve CSP domains: $($_.Exception.message)"
                    }
                } catch {
                    $errors.Add("$($_.Exception.message)")
                }

                # foreach through the properties we want to check/update
                @('marketingNotificationEmails', 'securityComplianceNotificationMails', 'technicalNotificationMails') | ForEach-Object {
                    $property = $_
                    $propertyContacts = $orgContacts.($($property))

                    if ($propertyContacts -and ($domains -notcontains ($propertyContacts | ForEach-Object { $_.Split('@')[1] }))) {
                        $newPropertyContent = [System.Collections.Generic.List[object]]($propertyContacts | Where-Object { $domains -notcontains $_.Split('@')[1] })

                        $patchContactBody = if (!($newPropertyContent)) { "{ `"$($property)`" : [] }" } else { [pscustomobject]@{ $property = $newPropertyContent } | ConvertTo-Json }

                        try {
                            New-GraphPostRequest -type PATCH -body $patchContactBody -Uri "https://graph.microsoft.com/v1.0/organization/$($orgContacts.id)" -tenantid $TenantFilter -ContentType 'application/json'
                            $Results.Add("Successfully removed notification contacts from $($property): $(($propertyContacts | Where-Object { $domains -contains $_.Split('@')[1] }))")
                            Write-LogMessage -headers $Request.Headers -API $APIName -message "Contacts were removed from $($property)" -Sev 'Info' -tenant $TenantFilter
                        } catch {
                            $Errors.Add("Failed to update property $($property): $($_.Exception.message)")
                        }
                    } else {
                        $results.Add("No notification contacts found in $($property)")
                    }
                }
                # TODO Add logic for privacyProfile later - rvdwegen

            }

            if ($request.body.RemoveDomainAnalyserData -eq $true) {
                # Remove all Domain Analyser data for this tenant
                try {
                    $DomainTable = Get-CIPPTable -Table 'Domains'
                    $Filter = "TenantGUID eq '{0}'" -f $TenantId
                    $DomainEntries = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter
                    
                    if ($DomainEntries) {
                        $DomainCount = ($DomainEntries | Measure-Object).Count
                        foreach ($Domain in $DomainEntries) {
                            Remove-AzDataTableEntity @DomainTable -Entity $Domain
                        }
                        $Results.Add("Successfully removed $DomainCount Domain Analyser entries")
                        Write-LogMessage -headers $Request.Headers -API $APIName -message "Removed $DomainCount Domain Analyser entries" -Sev 'Info' -tenant $TenantFilter
                    } else {
                        $Results.Add('No Domain Analyser data found for this tenant')
                    }
                } catch {
                    $Errors.Add("Failed to remove Domain Analyser data: $($_.Exception.message)")
                }
            }

            $VendorApps = $Request.Body.vendorApplications
            if ($VendorApps) {
                $VendorApps | ForEach-Object {
                    try {
                        $null = (New-GraphPostRequest -type 'DELETE' -Uri "https://graph.microsoft.com/v1.0/serviceprincipals/$($_.value)" -tenantid $TenantFilter)
                        $Results.Add("Successfully removed app $($_.label)")
                        Write-LogMessage -headers $Headers -API $APIName -message "App $($_.label) was removed" -Sev 'Info' -tenant $TenantFilter
                    } catch {
                        $Errors.Add("Failed to removed app $($_.label)")
                    }
                }
            }

            # All customer tenant specific actions ALWAYS have to be completed before this action!
            if ($request.body.RemoveMultitenantCSPApps -eq $true) {
                # Remove multi-tenant apps with the CSP tenant as origin
                try {
                    $MultiTenantCSPApps = (New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/servicePrincipals?`$count=true&`$select=displayName,appId,id,appOwnerOrganizationId&`$filter=appOwnerOrganizationId eq $($env:TenantID)" -tenantid $TenantFilter -ComplexFilter)
                    $sortedArray = $MultiTenantCSPApps | Sort-Object @{Expression = { if ($_.appId -eq $env:ApplicationID) { 1 } else { 0 } }; Ascending = $true }
                    $sortedArray | ForEach-Object {
                        try {
                            $null = (New-GraphPostRequest -type 'DELETE' -Uri "https://graph.microsoft.com/v1.0/serviceprincipals/$($_.id)" -tenantid $TenantFilter)
                            $Results.Add("Successfully removed app $($_.displayName)")
                            Write-LogMessage -headers $Request.Headers -API $APIName -message "App $($_.displayName) was removed" -Sev 'Info' -tenant $TenantFilter
                        } catch {
                            #$Results.Add("Failed to removed app $($_.displayName)")
                            $Errors.Add("Failed to removed app $($_.displayName)")
                        }
                    }
                } catch {
                    #$Results.Add("Failed to retrieve multi-tenant apps, no apps have been removed: $($_.Exception.message)")
                    $Errors.Add("Failed to retrieve multi-tenant CSP apps, no apps have been removed: $($_.Exception.message)")
                }
            }
            $ClearCache = $false
            if ($request.body.TerminateGDAP -eq $true) {
                # Terminate GDAP relationships
                $ClearCache = $true
                try {
                    $delegatedAdminRelationships = (New-GraphGETRequest -Uri "https://graph.microsoft.com/v1.0/tenantRelationships/delegatedAdminRelationships?`$filter=(status eq 'active') AND (customer/tenantId eq '$tenantid')" -tenantid $env:TenantID)
                    $delegatedAdminRelationships | ForEach-Object {
                        try {
                            $null = (New-GraphPostRequest -type 'POST' -Uri "https://graph.microsoft.com/v1.0/tenantRelationships/delegatedAdminRelationships/$($_.id)/requests" -body '{"action":"terminate"}' -ContentType 'application/json' -tenantid $env:TenantID)
                            $Results.Add("Successfully terminated GDAP relationship $($_.displayName) from tenant $TenantFilter")
                            Write-LogMessage -headers $Request.Headers -API $APIName -message "GDAP Relationship $($_.displayName) has been terminated" -Sev 'Info' -tenant $TenantFilter

                        } catch {
                            $($_.Exception.message)
                            #$results.Add("Failed to terminate GDAP relationship $($_.displayName): $($_.Exception.message)")
                            $errors.Add("Failed to terminate GDAP relationship $($_.displayName): $($_.Exception.message)")
                        }
                    }
                } catch {
                    $($_.Exception.message)
                    #$Results.Add("Failed to retrieve GDAP relationships, no relationships have been terminated: $($_.Exception.message)")
                    $Errors.Add("Failed to retrieve GDAP relationships, no relationships have been terminated: $($_.Exception.message)")
                }
            }

            if ($request.body.TerminateContract -eq $true) {
                # Terminate contract relationship
                try {
                    $null = (New-GraphPostRequest -type 'PATCH' -body '{ "relationshipToPartner": "none" }' -Uri "https://api.partnercenter.microsoft.com/v1/customers/$TenantFilter" -ContentType 'application/json' -scope 'https://api.partnercenter.microsoft.com/user_impersonation' -tenantid $env:TenantID)
                    $Results.Add('Successfully terminated contract relationship')
                    Write-LogMessage -headers $Headers -API $APIName -message 'Contract relationship terminated' -Sev 'Info' -tenant $TenantFilter
                } catch {
                    #$Results.Add("Failed to terminate contract relationship: $($_.Exception.message)")
                    $Errors.Add("Failed to terminate contract relationship: $($_.Exception.message)")
                }
            }
        }

        if ($ClearCache) {
            $null = Get-Tenants -CleanOld
            $Results.Add('Tenant cache has been cleared')
        }

        Write-LogMessage -headers $Headers -API $APIName -message 'Offboarding completed' -Sev 'Info' -tenant $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
        $body = [pscustomobject]@{
            'Results' = @($Results)
            'Errors'  = @($Errors)
        }
    } catch {
        $StatusCode = [HttpStatusCode]::OK
        $body = $_.Exception.message
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecOffboardTenant.ps1' 222
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecOnboardTenant.ps1' -1

function Invoke-ExecOnboardTenant {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $Id = $Request.Body.id
    if ($Id) {
        try {
            $OnboardTable = Get-CIPPTable -TableName 'TenantOnboarding'

            if ($Request.Body.Cancel -eq $true) {
                $TenantOnboarding = Get-CIPPAzDataTableEntity @OnboardTable -Filter "RowKey eq '$Id'"
                if ($TenantOnboarding) {
                    Remove-AzDataTableEntity -Force @OnboardTable -Entity $TenantOnboarding
                    $Results = @{'Results' = 'Onboarding job canceled' }
                    $StatusCode = [HttpStatusCode]::OK
                } else {
                    $Results = 'Onboarding job not found'
                    $StatusCode = [HttpStatusCode]::NotFound
                }
            } else {
                $TenMinutesAgo = (Get-Date).AddMinutes(-10).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                $TenantOnboarding = Get-CIPPAzDataTableEntity @OnboardTable -Filter "RowKey eq '$Id' and Timestamp ge datetime'$TenMinutesAgo'"
                if (!$TenantOnboarding -or [bool]$Request.Body.Retry) {
                    $OnboardingSteps = [PSCustomObject]@{
                        'Step1' = @{
                            'Status'  = 'pending'
                            'Title'   = 'Step 1: GDAP Invite'
                            'Message' = 'Waiting for onboarding job to start'
                        }
                        'Step2' = @{
                            'Status'  = 'pending'
                            'Title'   = 'Step 2: GDAP Role Test'
                            'Message' = 'Waiting for Step 1'
                        }
                        'Step3' = @{
                            'Status'  = 'pending'
                            'Title'   = 'Step 3: GDAP Group Mapping'
                            'Message' = 'Waiting for Step 2'
                        }
                        'Step4' = @{
                            'Status'  = 'pending'
                            'Title'   = 'Step 4: CPV Refresh'
                            'Message' = 'Waiting for Step 3'
                        }
                        'Step5' = @{
                            'Status'  = 'pending'
                            'Title'   = 'Step 5: Graph API Test'
                            'Message' = 'Waiting for Step 4'
                        }
                    }
                    $TenantOnboarding = [PSCustomObject]@{
                        PartitionKey    = 'Onboarding'
                        RowKey          = [string]$Id
                        CustomerId      = ''
                        Status          = 'queued'
                        OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                        Relationship    = ''
                        Logs            = ''
                        Exception       = ''
                    }
                    Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

                    $Item = [pscustomobject]@{
                        FunctionName               = 'ExecOnboardTenantQueue'
                        id                         = $Id
                        Roles                      = $Request.Body.gdapRoles
                        AddMissingGroups           = $Request.Body.addMissingGroups
                        IgnoreMissingRoles         = $Request.Body.ignoreMissingRoles
                        AutoMapRoles               = $Request.Body.autoMapRoles
                        StandardsExcludeAllTenants = $Request.Body.standardsExcludeAllTenants
                    }

                    $InputObject = @{
                        OrchestratorName = 'OnboardingOrchestrator'
                        Batch            = @($Item)
                    }
                    $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                    Write-LogMessage -headers $Headers -API $APIName -message "Onboarding job $Id started" -Sev 'Info' -LogData @{ 'InstanceId' = $InstanceId }
                }

                $Steps = $TenantOnboarding.OnboardingSteps | ConvertFrom-Json
                $OnboardingSteps = foreach ($Step in $Steps.PSObject.Properties.Name) { $Steps.$Step }
                $Relationship = try { $TenantOnboarding.Relationship | ConvertFrom-Json -ErrorAction Stop } catch { @{} }
                $Logs = try { $TenantOnboarding.Logs | ConvertFrom-Json -ErrorAction Stop } catch { @{} }
                $TenantOnboarding.OnboardingSteps = $OnboardingSteps
                $TenantOnboarding.Relationship = $Relationship
                $TenantOnboarding.Logs = $Logs
                $Results = $TenantOnboarding
                $StatusCode = [HttpStatusCode]::OK
            }
        } catch {
            $ErrorMsg = Get-NormalizedError -message $($_.Exception.Message)
            $Results = "Function Error: $($_.InvocationInfo.ScriptLineNumber) - $ErrorMsg"
            $StatusCode = [HttpStatusCode]::BadRequest
        }
    } else {
        $StatusCode = [HttpStatusCode]::NotFound
        $Results = 'Relationship not found'
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecOnboardTenant.ps1' 116
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecUpdateSecureScore.ps1' -1

function Invoke-ExecUpdateSecureScore {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.TenantFilter
    $ControlName = $Request.Body.ControlName

    if ($ControlName -match '^scid_') {
        $Result = 'Defender controls cannot be updated via this API. Please use the Microsoft 365 Defender portal to update these controls.'
        $StatusCode = [HttpStatusCode]::BadRequest
    } else {
        $Body = @{
            comment           = $Request.Body.reason
            state             = $Request.Body.resolutionType.value
            vendorInformation = $Request.Body.vendorInformation
        }
        try {
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/security/secureScoreControlProfiles/$ControlName" -tenantid $TenantFilter -type PATCH -Body (ConvertTo-Json -InputObject $Body -Compress)
            $StatusCode = [HttpStatusCode]::OK
            $Result = "Successfully set control $ControlName to $($Body.state)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Result = "Failed to set control $ControlName to $($Body.state). Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
            $StatusCode = [HttpStatusCode]::InternalServerError
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ExecUpdateSecureScore.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListAppConsentRequests.ps1' -1

function Invoke-ListAppConsentRequests {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.Read
    #>
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $RequestStatus = $Request.Query.RequestStatus
    $Filter = $Request.Query.Filter

    try {
        if ($TenantFilter -eq 'AllTenants') {
            throw 'AllTenants is not yet supported'
        }

        # Apply server-side filtering if requested
        $Uri = 'https://graph.microsoft.com/beta/identityGovernance/appConsent/appConsentRequests' # Need the beta endpoint to get consentType
        if ($Filter -eq $true -and $RequestStatus) {
            switch ($RequestStatus) {
                'InProgress' {
                    $FilterQuery = "userConsentRequests/any (u:u/status eq '$RequestStatus')"
                    $Uri = "$Uri`?`$filter=$([System.Web.HttpUtility]::UrlEncode($FilterQuery))"
                    Write-Host "Applying server-side filter for RequestStatus: $RequestStatus"
                    $ServerSideFilteringApplied = $true
                }
                default {
                    # All the other values are not supported yet even if the Graph API docs say they are. -Bobby
                    $ServerSideFilteringApplied = $false
                }
            }
        }

        $appConsentRequests = New-GraphGetRequest -Uri $Uri -tenantid $TenantFilter

        $Results = foreach ($app in $appConsentRequests) {
            $userConsentRequests = New-GraphGetRequest -Uri "https://graph.microsoft.com/v1.0/identityGovernance/appConsent/appConsentRequests/$($app.id)/userConsentRequests" -tenantid $TenantFilter
            $userConsentRequests | ForEach-Object {
                [pscustomobject]@{
                    appId                 = $app.appId
                    appDisplayName        = $app.appDisplayName
                    requestUser           = $_.createdBy.user.userPrincipalName
                    requestReason         = $_.reason
                    requestDate           = $_.createdDateTime
                    requestStatus         = $_.status
                    reviewedBy            = $_.approval.stages.reviewedBy.userPrincipalName
                    reviewedJustification = $_.approval.stages.justification
                    reviewedDate          = $_.approval.stages.reviewedDateTime
                    reviewedStatus        = $_.approval.stages.status
                    scopes                = $app.pendingScopes.displayName
                    consentUrl            = if ($app.consentType -eq 'Static') {
                        # if something is going wrong here you've probably stumbled on a fourth variation - rvdwegen
                        "https://login.microsoftonline.com/$($TenantFilter)/adminConsent?client_id=$($app.appId)&bf_id=$($app.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    } elseif ($app.pendingScopes.displayName) {
                        "https://login.microsoftonline.com/$($TenantFilter)/v2.0/adminConsent?client_id=$($app.appId)&scope=$($app.pendingScopes.displayName -Join(' '))&bf_id=$($app.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    } else {
                        "https://login.microsoftonline.com/$($TenantFilter)/adminConsent?client_id=$($app.appId)&bf_id=$($app.id)&redirect_uri=https://entra.microsoft.com/TokenAuthorize"
                    }
                }
            }
        }

        # Apply filtering if requested. Has to be done before and after the foreach loop, as the serverside filter is only supported for InProgress.
        if ($Filter -eq $true -and $ServerSideFilteringApplied -eq $false) {
            if ($RequestStatus) {
                Write-Host "Filtering by RequestStatus: $RequestStatus"
                $Results = $Results | Where-Object { $_.requestStatus -eq $RequestStatus }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $StatusCode = [HttpStatusCode]::InternalServerError
        $Results = "Error: $($ErrorMessage.NormalizedError)"
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListAppConsentRequests.ps1' 84
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListDomains.ps1' -1

Function Invoke-ListDomains {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $Result = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/domains' -tenantid $TenantFilter | Select-Object id, isdefault, isinitial | Sort-Object isdefault -Descending
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Result)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListDomains.ps1' 26
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListTenantOnboarding.ps1' -1

function Invoke-ListTenantOnboarding {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.Read
    #>
    Param($Request, $TriggerMetadata)
    try {
        $OnboardTable = Get-CIPPTable -TableName 'TenantOnboarding'
        $TenantOnboardings = Get-CIPPAzDataTableEntity @OnboardTable
        $Results = @(foreach ($TenantOnboarding in $TenantOnboardings) {
                $Steps = $TenantOnboarding.OnboardingSteps | ConvertFrom-Json
                $OnboardingSteps = foreach ($Step in $Steps.PSObject.Properties.Name) { $Steps.$Step }
                $Relationship = try { $TenantOnboarding.Relationship | ConvertFrom-Json -ErrorAction Stop } catch { @{} }
                $Logs = try { $TenantOnboarding.Logs | ConvertFrom-Json -ErrorAction Stop } catch { @{} }
                $TenantOnboarding.OnboardingSteps = $OnboardingSteps
                $TenantOnboarding.Relationship = $Relationship
                $TenantOnboarding.Logs = $Logs
                $TenantOnboarding
            })
        $Results = $Results | Sort-Object Timestamp -Descending
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Function Error: $($ErrorMessage.LineNumber) - $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::BadRequest
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-ListTenantOnboarding.ps1' 34
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-SetAuthMethod.ps1' -1

function Invoke-SetAuthMethod {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    Param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $State = if ($Request.Body.state -eq 'enabled') { $true } else { $false }
    $TenantFilter = $Request.Body.tenantFilter
    $AuthenticationMethodId = $Request.Body.Id


    try {
        $Result = Set-CIPPAuthenticationPolicy -Tenant $TenantFilter -APIName $APIName -AuthenticationMethodId $AuthenticationMethodId -Enabled $State -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = [pscustomobject]@{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Invoke-SetAuthMethod.ps1' 33
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-AddTenant.ps1' -1

function Invoke-AddTenant {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Config.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $Action = $Request.Body.Action ?? $Request.Query.Action
    $TenantName = $Request.Body.TenantName ?? $Request.Query.TenantName
    $StatusCode = [HttpStatusCode]::OK

    switch ($Action) {
        'ValidateDomain' {
            # Validate the onmicrosoft.com domain
            $Domain = "$($TenantName).onmicrosoft.com"
            $DomainCheckUri = "https://api.partnercenter.microsoft.com/v1/domains/$Domain"

            Write-Information "Checking $Domain"
            try {

                $null = New-GraphPOSTRequest -type HEAD -uri $DomainCheckUri -scope 'https://api.partnercenter.microsoft.com/.default' -NoAuthCheck $true -AddedHeaders $Headers

                $Body = @{
                    Success = $false
                    Message = "The domain '$Domain' is already in use."
                }
            } catch {
                $Body = @{
                    Success = $true
                }
            }

        }
        'GetOrganizationProfile' {
            $OrganizationProfileUri = 'https://api.partnercenter.microsoft.com/v1/profiles/organization'
            try {
                $OrgResponse = New-GraphGetRequest -uri $OrganizationProfileUri -scope 'https://api.partnercenter.microsoft.com/.default' -NoAuthCheck $true -AddedHeaders $Headers
                # remove the first character from the response and then convert from JSON
                if (!$OrgResponse.id -and $OrgResponse -notmatch '^{') {
                    $OrgResponse = $OrgResponse.Substring(1) | ConvertFrom-Json
                }

                $Body = @{
                    Results = $OrgResponse
                }
            } catch {
                $Body = @{
                    Results = @(@{
                            state      = 'error'
                            resultText = "Failed to retrieve organization profile: $($_.Exception.Message)"
                        })
                }
                $StatusCode = [HttpStatusCode]::BadRequest
            }
        }
        'AddTenant' {
            # Get organization profile from graph.microsoft.com
            $Org = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/organization' -NoAuthCheck $true

            $CanCreateCustomers = $false
            $PartnerType = $Org.partnerTenantType
            if ($PartnerType -eq 'valueAddedResellerPartnerDelegatedAdmin') {
                # Tier 2 CSP - Get MPN id from partner center
                $PartnerCenterUri = 'https://api.partnercenter.microsoft.com/accountenrollments/v1/accountexternalresourcekeys?accountIds={0}&keyType=mpnId' -f $env:TenantID
                $MPNId = New-GraphGetRequest -uri $PartnerCenterUri -scope 'https://api.partnercenter.microsoft.com/.default' -NoAuthCheck $true
                $AssociatedPartnerId = $MpnId.items[0].keyValue
                Write-Host "Tier 2 CSP - Associated Partner ID: $AssociatedPartnerId"
                $CanCreateCustomers = $true
            } elseif ($PartnerType -eq 'resellerPartnerDelegatedAdmin') {
                # Tier 1 CSP
                $CanCreateCustomers = $true
            }

            if (!$CanCreateCustomers) {
                $Body = @{
                    $Results = @(@{
                            state      = 'error'
                            resultText = 'You do not have permission to create customers. You must be a Tier 1 or Tier 2 CSP.'
                        })
                }
            } else {
                $Payload = @{
                    enableGDAPByDefault   = $false
                    Id                    = $null
                    CommerceId            = $null
                    CompanyProfile        = @{
                        TenantId    = $null
                        Domain      = '{0}.onmicrosoft.com' -f $TenantName
                        CompanyName = $Request.Body.CompanyName
                        Attributes  = @{ ObjectType = 'CustomerCompanyProfile' }
                    }
                    BillingProfile        = @{
                        Id             = $null
                        FirstName      = $Request.Body.FirstName
                        LastName       = $Request.Body.LastName
                        Email          = $Request.Body.Email
                        Culture        = 'EN-US'
                        Language       = 'En'
                        CompanyName    = $Request.Body.CompanyName
                        DefaultAddress = @{
                            Country      = $Request.Body.Country
                            Region       = $null
                            City         = $Request.Body.City
                            State        = $Request.Body.State
                            AddressLine1 = $Request.Body.AddressLine1
                            AddressLine2 = $Request.Body.AddressLine2
                            PostalCode   = $Request.Body.PostalCode
                            FirstName    = $Request.Body.FirstName
                            LastName     = $Request.Body.LastName
                            PhoneNumber  = $Request.Body.PhoneNumber
                        }
                        Attributes     = @{ ObjectType = 'CustomerBillingProfile' }
                    }
                    RelationshipToPartner = 'none'
                    AllowDelegatedAccess  = $null
                    UserCredentials       = $null
                    CustomDomains         = $null
                    Attributes            = @{ ObjectType = 'Customer' }
                }

                if ($AssociatedPartnerId) {
                    $Payload.AssociatedPartnerId = $AssociatedPartnerId
                }

                $CustomerCreationUri = 'https://api.partnercenter.microsoft.com/v1/customers'
                Write-Warning "Posting to $CustomerCreationUri"
                Write-Information ($Payload | ConvertTo-Json -Depth 10)

                try {
                    # not doing this yet

                    #$Response = New-GraphPOSTRequest -type POST -uri $CustomerCreationUri -scope 'https://api.partnercenter.microsoft.com/.default' -Body ($Payload | ConvertTo-Json -Depth 10) -NoAuthCheck $true -AddedHeaders $Headers

                    # Sample response
                    $Response = @{
                        userCredentials = @{
                            userName = 'test'
                            password = 'this_is_not_a_real_password'
                        }
                    }
                    ####


                    $Body = @{
                        Results = @(@{
                                state      = 'success'
                                resultText = "Tenant created successfully. 'Username is $($Response.userCredentials.userName)@{0}.onmicrosoft.com'. Click copy to retrieve the password." -f $TenantName
                                copyField  = $Response.userCredentials.password
                            })
                    }
                } catch {
                    $Body = @{
                        Results = @(@{
                                state      = 'error'
                                resultText = "Failed to create tenant: $($_.Exception.Message)"
                            })
                    }
                    $StatusCode = [HttpStatusCode]::BadRequest
                }
            }
        }
        'ValidateAddress' {
            $AddressPayload = @{
                AddressLine1 = $Request.Body.AddressLine1
                AddressLine2 = $Request.Body.AddressLine2
                City         = $Request.Body.City
                State        = $Request.Body.State
                PostalCode   = $Request.Body.PostalCode
                Country      = $Request.Body.Country
            }

            $AddressValidationUri = 'https://api.partnercenter.microsoft.com/v1/validations/address'
            try {
                $Response = New-GraphPOSTRequest -type POST -uri $AddressValidationUri -scope 'https://api.partnercenter.microsoft.com/.default' -Body ($AddressPayload | ConvertTo-Json -Depth 10) -NoAuthCheck $true

                return @{
                    Status             = 'Success'
                    OriginalAddress    = $Response.originalAddress
                    SuggestedAddresses = $Response.suggestedAddresses
                    ValidationStatus   = $Response.status
                }
            } catch {
                return @{
                    state      = 'Error'
                    resultText = "Address validation failed: $($_.Exception.Message)"
                }
            }
        }
        default {
            return @{
                state      = 'Error'
                resultText = "Invalid action specified: $($Request.Body.Action)"
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-AddTenant.ps1' 208
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-EditTenant.ps1' -1

function Invoke-EditTenant {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Config.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $customerId = $Request.Body.customerId
    $tenantAlias = $Request.Body.tenantAlias
    $tenantGroups = $Request.Body.tenantGroups

    $PropertiesTable = Get-CippTable -TableName 'TenantProperties'
    $Existing = Get-CIPPAzDataTableEntity @PropertiesTable -Filter "PartitionKey eq '$customerId'"
    $Tenant = Get-Tenants -TenantFilter $customerId
    $TenantTable = Get-CippTable -TableName 'Tenants'
    $GroupMembersTable = Get-CippTable -TableName 'TenantGroupMembers'

    try {
        $AliasEntity = $Existing | Where-Object { $_.RowKey -eq 'Alias' }
        if (!$tenantAlias) {
            if ($AliasEntity) {
                Write-Host 'Removing alias'
                Remove-AzDataTableEntity @PropertiesTable -Entity $AliasEntity
                $null = Get-Tenants -TenantFilter $customerId -TriggerRefresh
            }
        } else {
            $aliasEntity = @{
                PartitionKey = $customerId
                RowKey       = 'Alias'
                Value        = $tenantAlias
            }
            $null = Add-CIPPAzDataTableEntity @PropertiesTable -Entity $aliasEntity -Force
            Write-Host "Setting alias to $tenantAlias"
            $Tenant | Add-Member -NotePropertyName 'originalDisplayName' -NotePropertyValue $tenant.displayName -Force
            $Tenant.displayName = $tenantAlias
            $null = Add-CIPPAzDataTableEntity @TenantTable -Entity $Tenant -Force
        }

        # Update tenant groups
        $CurrentGroupMemberships = Get-CIPPAzDataTableEntity @GroupMembersTable -Filter "customerId eq '$customerId'"
        foreach ($Group in $tenantGroups) {
            $GroupEntity = $CurrentGroupMemberships | Where-Object { $_.GroupId -eq $Group.groupId }
            if (!$GroupEntity) {
                $GroupEntity = @{
                    PartitionKey = 'Member'
                    RowKey       = '{0}-{1}' -f $Group.groupId, $customerId
                    GroupId      = $Group.groupId
                    customerId   = $customerId
                }
                Add-CIPPAzDataTableEntity @GroupMembersTable -Entity $GroupEntity -Force
            }
        }

        # Remove any groups that are no longer selected
        foreach ($Group in $CurrentGroupMemberships) {
            if ($tenantGroups.GroupId -notcontains $Group.GroupId) {
                Remove-AzDataTableEntity @GroupMembersTable -Entity $Group
            }
        }
        $DomainBasedEntries = Get-CIPPAzDataTableEntity @GroupMembersTable -Filter "customerId eq '$($Tenant.defaultDomainName)'"
            if ($DomainBasedEntries) {
                foreach ($Entry in $DomainBasedEntries) {
                    try {
                        # Add corrected GUID-based entry using the actual GUID
                        $NewEntry = @{
                            PartitionKey = 'Member'
                            RowKey       = '{0}-{1}' -f $Entry.GroupId, $Tenant.customerId
                            GroupId      = $Entry.GroupId
                            customerId   = $Tenant.customerId
                        }
                        Add-CIPPAzDataTableEntity @GroupMembersTable -Entity $NewEntry -Force
                        Remove-AzDataTableEntity @GroupMembersTable -Entity $Entry
                    } catch {
                        Write-Host "Error migrating entry: $($_.Exception.Message)"
                    }
                }
            }

        $response = @{
            state      = 'success'
            resultText = 'Tenant details updated successfully'
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $response
            })
    } catch {
        Write-LogMessage -headers $Headers -tenant $customerId -API $APINAME -message "Edit Tenant failed. The error is: $($_.Exception.Message)" -Sev 'Error'
        $response = @{
            state      = 'error'
            resultText = $_.Exception.Message
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $response
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-EditTenant.ps1' 107
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-EditTenantOffboardingDefaults.ps1' -1

function Invoke-EditTenantOffboardingDefaults {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Config.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $customerId = $Request.Body.customerId
    $offboardingDefaults = $Request.Body.offboardingDefaults

    if (!$customerId) {
        $response = @{
            state      = 'error'
            resultText = 'Customer ID is required'
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = $response
            })
        return
    }

    $PropertiesTable = Get-CippTable -TableName 'TenantProperties'

    try {
        # Convert the offboarding defaults to JSON string and ensure it's treated as a string
        $jsonValue = [string]($offboardingDefaults | ConvertTo-Json -Compress)

        if ($jsonValue -and $jsonValue -ne '{}' -and $jsonValue -ne 'null' -and $jsonValue -ne '') {
            # Save offboarding defaults
            $offboardingEntity = @{
                PartitionKey = [string]$customerId
                RowKey       = [string]'OffboardingDefaults'
                Value        = [string]$jsonValue
            }
            $null = Add-CIPPAzDataTableEntity @PropertiesTable -Entity $offboardingEntity -Force
            Write-LogMessage -headers $Headers -tenant $customerId -API $APIName -message "Updated tenant offboarding defaults" -Sev 'Info'

            $resultText = 'Tenant offboarding defaults updated successfully'
        } else {
            # Remove offboarding defaults if empty or null
            $Existing = Get-CIPPAzDataTableEntity @PropertiesTable -Filter "PartitionKey eq '$customerId' and RowKey eq 'OffboardingDefaults'"
            if ($Existing) {
                Remove-AzDataTableEntity @PropertiesTable -Entity $Existing
                Write-LogMessage -headers $Headers -tenant $customerId -API $APIName -message "Removed tenant offboarding defaults" -Sev 'Info'
            }

            $resultText = 'Tenant offboarding defaults cleared successfully'
        }

        $response = @{
            state      = 'success'
            resultText = $resultText
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $response
            })
    } catch {
        Write-LogMessage -headers $Headers -tenant $customerId -API $APINAME -message "Edit Tenant Offboarding Defaults failed. The error is: $($_.Exception.Message)" -Sev 'Error'
        $response = @{
            state      = 'error'
            resultText = $_.Exception.Message
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $response
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-EditTenantOffboardingDefaults.ps1' 80
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-ListTenantDetails.ps1' -1

Function Invoke-ListTenantDetails {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $org = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/organization' -tenantid $TenantFilter | Select-Object displayName, id, city, country, countryLetterCode, street, state, postalCode,
        @{ Name = 'businessPhones'; Expression = { $_.businessPhones -join ', ' } },
        @{ Name = 'technicalNotificationMails'; Expression = { $_.technicalNotificationMails -join ', ' } },
        tenantType, createdDateTime, onPremisesLastPasswordSyncDateTime, onPremisesLastSyncDateTime, onPremisesSyncEnabled, assignedPlans

        $customProperties = Get-TenantProperties -customerId $TenantFilter
        $org | Add-Member -MemberType NoteProperty -Name 'customProperties' -Value $customProperties

        $Groups = (Get-TenantGroups -TenantFilter $TenantFilter) ?? @()
        $org | Add-Member -MemberType NoteProperty -Name 'Groups' -Value @($Groups)
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $org = "Failed to retrieve tenant details: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $org -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $org
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-ListTenantDetails.ps1' 43
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-ListTenants.ps1' -1

function Invoke-ListTenants {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantAccess = Test-CIPPAccess -Request $Request -TenantList
    Write-Host "Tenant Access: $TenantAccess"

    $AllTenantSelector = $Request.Query.AllTenantSelector

    $IncludeOffboardingDefaults = $Request.Query.IncludeOffboardingDefaults

    # Clear Cache
    if ($Request.Body.ClearCache -eq $true) {
        $Results = Remove-CIPPCache -tenantsOnly $Request.Body.TenantsOnly

        $InputObject = [PSCustomObject]@{
            Batch            = @(
                @{
                    FunctionName = 'UpdateTenants'
                }
            )
            OrchestratorName = 'UpdateTenants'
            SkipLog          = $true
        }
        Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)

        $GraphRequest = [pscustomobject]@{'Results' = 'Cache has been cleared and a tenant refresh is queued.' }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @{
                    Results  = @($GraphRequest)
                    Metadata = @{
                        Details = $Results
                    }
                }
            })
        #Get-Tenants -IncludeAll -TriggerRefresh
        return
    }
    if ($Request.Query.TriggerRefresh) {
        if ($Request.Query.TenantFilter -and $Request.Query.TenantFilter -ne 'AllTenants') {
            Get-Tenants -TriggerRefresh -TenantFilter $Request.Query.TenantFilter
        } else {
            $InputObject = [PSCustomObject]@{
                Batch            = @(
                    @{
                        FunctionName = 'UpdateTenants'
                    }
                )
                OrchestratorName = 'UpdateTenants'
                SkipLog          = $true
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
        }
    }
    try {
        $TenantFilter = $Request.Query.tenantFilter
        $tenantParams = @{
            IncludeErrors = $true
            SkipDomains   = $true
        }
        if ($TenantFilter -and $TenantFilter -ne 'AllTenants') {
            $tenantParams['TenantFilter'] = $TenantFilter
        }

        $Tenants = Get-Tenants @tenantParams

        if ($TenantAccess -notcontains 'AllTenants') {
            $Tenants = $Tenants | Where-Object -Property customerId -In $TenantAccess
        }

        # If offboarding defaults are requested, fetch them
        if ($IncludeOffboardingDefaults -eq 'true' -and $Tenants) {
            $PropertiesTable = Get-CippTable -TableName 'TenantProperties'

            # Get all offboarding defaults for all tenants in one query for performance
            $AllOffboardingDefaults = Get-CIPPAzDataTableEntity @PropertiesTable -Filter "RowKey eq 'OffboardingDefaults'"

            # Add offboarding defaults to each tenant
            foreach ($Tenant in $Tenants) {
                $TenantDefaults = $AllOffboardingDefaults | Where-Object { $_.PartitionKey -eq $Tenant.customerId }
                if ($TenantDefaults) {
                    try {
                        $Tenant | Add-Member -MemberType NoteProperty -Name 'offboardingDefaults' -Value ($TenantDefaults.Value | ConvertFrom-Json) -Force
                    } catch {
                        Write-LogMessage -headers $Headers -API $APIName -message "Failed to parse offboarding defaults for tenant $($Tenant.customerId): $($_.Exception.Message)" -Sev 'Warning'
                        $Tenant | Add-Member -MemberType NoteProperty -Name 'offboardingDefaults' -Value $null -Force
                    }
                } else {
                    $Tenant | Add-Member -MemberType NoteProperty -Name 'offboardingDefaults' -Value $null -Force
                }
            }
        }

        if (($null -eq $TenantFilter -or $TenantFilter -eq 'null') -or $Request.Query.Mode -eq 'TenantList') {
            $TenantList = [system.collections.generic.list[object]]::new()
            if ($AllTenantSelector -eq $true) {
                $AllTenantsObject = @{
                    customerId        = 'AllTenants'
                    defaultDomainName = 'AllTenants'
                    displayName       = '*All Tenants'
                    domains           = 'AllTenants'
                    GraphErrorCount   = 0
                }

                # Add offboarding defaults to AllTenants object if requested
                if ($IncludeOffboardingDefaults -eq 'true') {
                    $AllTenantsObject.offboardingDefaults = $null
                }

                $TenantList.Add($AllTenantsObject) | Out-Null

                if (($Tenants).length -gt 1) {
                    $TenantList.AddRange($Tenants) | Out-Null
                } elseif ($Tenants) {
                    $TenantList.Add($Tenants) | Out-Null
                }
                $body = $TenantList
            } else {
                $Body = $Tenants
            }
            if ($Request.Query.Mode -eq 'TenantList') {
                # add portal link properties
                $Body = $Body | Select-Object *, @{Name = 'portal_m365'; Expression = { "https://admin.cloud.microsoft/?delegatedOrg=$($_.initialDomainName)" } },
                @{Name = 'portal_exchange'; Expression = { "https://admin.cloud.microsoft/exchange?delegatedOrg=$($_.initialDomainName)" } },
                @{Name = 'portal_entra'; Expression = { "https://entra.microsoft.com/$($_.defaultDomainName)" } },
                @{Name = 'portal_teams'; Expression = { "https://admin.teams.microsoft.com?delegatedOrg=$($_.initialDomainName)" } },
                @{Name = 'portal_azure'; Expression = { "https://portal.azure.com/$($_.defaultDomainName)" } },
                @{Name = 'portal_intune'; Expression = { "https://intune.microsoft.com/$($_.defaultDomainName)" } },
                @{Name = 'portal_security'; Expression = { "https://security.microsoft.com/?tid=$($_.customerId)" } },
                @{Name = 'portal_compliance'; Expression = { "https://purview.microsoft.com/?tid=$($_.customerId)" } },
                @{Name = 'portal_sharepoint'; Expression = { "/api/ListSharePointAdminUrl?tenantFilter=$($_.defaultDomainName)" } },
                @{Name = 'portal_platform'; Expression = { "https://admin.powerplatform.microsoft.com/account/login/$($_.customerId)" } },
                @{Name = 'portal_bi'; Expression = { "https://app.powerbi.com/admin-portal?ctid=$($_.customerId)" } }
            }

        } else {
            $body = $Tenants
        }

        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message 'Listed Tenant Details' -Sev 'Debug'
    } catch {
        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message "List Tenant failed. The error is: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{
            'Results'         = "Failed to retrieve tenants: $($_.Exception.Message)"
            defaultDomainName = ''
            displayName       = 'Failed to retrieve tenants. Perform a permission check.'
            customerId        = ''

        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Body)
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-ListTenants.ps1' 171
#Region './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-RemoveTenantCapabilitiesCache.ps1' -1

function Invoke-RemoveTenantCapabilitiesCache {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Administration.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Get the tenant identifier from query parameters
    $DefaultDomainName = $Request.Query.defaultDomainName
    if (-not $DefaultDomainName) {
        $body = [pscustomobject]@{'Results' = 'Missing required parameter: defaultDomainName' }
        $StatusCode = [HttpStatusCode]::BadRequest
        return ([HttpResponseContext]@{
                StatusCode = $StatusCode
                Body       = $body
            })
        return
    }

    try {
        # Get the CacheCapabilities table
        $Table = Get-CippTable -tablename 'CacheCapabilities'

        # Find the cache entry for this tenant
        $Filter = "PartitionKey eq 'Capabilities' and RowKey eq '$DefaultDomainName'"
        $CacheEntry = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey

        if ($CacheEntry) {
            # Remove the cache entry
            Remove-AzDataTableEntity -Force @Table -Entity $CacheEntry
            Write-LogMessage -Headers $Headers -API $APIName -message "Removed capabilities cache for tenant $DefaultDomainName." -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "Successfully removed capabilities cache for tenant $DefaultDomainName" }
            $StatusCode = [HttpStatusCode]::OK
        } else {
            Write-LogMessage -Headers $Headers -API $APIName -message "No capabilities cache found for tenant $DefaultDomainName." -Sev 'Info'
            $body = [pscustomobject]@{'Results' = "No capabilities cache found for tenant $DefaultDomainName" }
            $StatusCode = [HttpStatusCode]::OK
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APIName -message "Failed to remove capabilities cache for tenant $DefaultDomainName. $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
        $body = [pscustomobject]@{'Results' = "Failed to remove capabilities cache: $($ErrorMessage.NormalizedError)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Administration/Tenant/Invoke-RemoveTenantCapabilitiesCache.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddCAPolicy.ps1' -1

function Invoke-AddCAPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Tenants = $Request.body.tenantFilter.value
    if ('AllTenants' -in $Tenants) { $Tenants = (Get-Tenants).defaultDomainName }

    $results = foreach ($Tenant in $tenants) {
        try {
            $CAPolicy = New-CIPPCAPolicy -replacePattern $Request.Body.replacename -Overwrite $request.Body.overwrite -TenantFilter $Tenant -state $Request.Body.NewState -DisableSD $Request.Body.DisableSD -RawJSON $Request.Body.RawJSON -APIName $APIName -Headers $Headers
            "$CAPolicy"
        } catch {
            "$($_.Exception.Message)"
            continue
        }

    }

    $body = [pscustomobject]@{'Results' = @($results) }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddCAPolicy.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddCATemplate.ps1' -1

Function Invoke-AddCATemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $Name = $Request.Body.name
    try {
        $GUID = (New-Guid).GUID
        $JSON = New-CIPPCATemplate -TenantFilter $TenantFilter -JSON $Request.Body
        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$JSON"
            RowKey       = "$GUID"
            PartitionKey = 'CATemplate'
            GUID         = "$GUID"
        }
        $Result = "Created CA Template $($Name) with GUID $GUID"
        Write-LogMessage -headers $Headers -API $APIName -message "Created CA Template $($Name) with GUID $GUID" -Sev 'Debug'
        $StatusCode = [HttpStatusCode]::OK

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create CA Template: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to create CA Template: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = "$Result" }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddCATemplate.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddNamedLocation.ps1' -1

function Invoke-AddNamedLocation {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    # Input bindings are passed in via param block.
    $Tenants = $request.body.selectedTenants.value
    Write-Host ($Request.body | ConvertTo-Json)
    if ($Tenants -eq 'AllTenants') { $Tenants = (Get-Tenants).defaultDomainName }
    $results = foreach ($Tenant in $tenants) {
        try {
            $ObjBody = if ($Request.body.Type -eq 'IPLocation') {
                $IPRanges = ($Request.body.Ips -split "`n") | ForEach-Object { if ($_ -ne '') { @{cidrAddress = "$_" } } }
                if (!$IPRanges) { $IPRanges = @(@{cidrAddress = "$($Request.Body.Ips)" }) }
                [pscustomobject]@{
                    '@odata.type' = '#microsoft.graph.ipNamedLocation'
                    displayName   = $request.body.policyName
                    ipRanges      = @($IPRanges)
                    isTrusted     = $Request.body.Trusted
                }
            } else {
                [pscustomobject]@{
                    '@odata.type'                     = '#microsoft.graph.countryNamedLocation'
                    displayName                       = $request.body.policyName
                    countriesAndRegions               = @($Request.Body.Countries.value)
                    includeUnknownCountriesAndRegions = $Request.body.includeUnknownCountriesAndRegions
                }
            }
            $Body = ConvertTo-Json -InputObject $ObjBody
            $GraphRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -body $body -Type POST -tenantid $tenant
            "Successfully added Named Location for $($Tenant)"
            Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $tenant -message "Added Named Location $($Displayname)" -Sev 'Info'

        } catch {
            "Failed to add Named Location $($Tenant): $($_.Exception.Message)"
            Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $tenant -message "Failed adding Named Location$($Displayname). Error: $($_.Exception.Message)" -Sev 'Error'
            continue
        }

    }

    $body = [pscustomobject]@{'Results' = @($results) }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-AddNamedLocation.ps1' 56
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-EditCAPolicy.ps1' -1

Function Invoke-EditCAPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with the request
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.GUID ?? $Request.Body.GUID
    $State = $Request.Query.State ?? $Request.Body.State
    $DisplayName = $Request.Query.newDisplayName ?? $Request.Body.newDisplayName

    try {
        $properties = @{}

        # Conditionally add properties
        if ($State) {
            $properties["state"] = $State
        }

        if ($DisplayName) {
            $properties["displayName"] = $DisplayName
        }

        $Request = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($ID)" -tenantid $TenantFilter -type PATCH -body ($properties | ConvertTo-Json) -asapp $true

        $Result = "Successfully updated CA policy $($ID)"
        if ($State) { $Result += " state to $($State)" }
        if ($DisplayName) { $Result += " name to '$($DisplayName)'" }

        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to update CA policy $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{ 'Results' = $Result }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-EditCAPolicy.ps1' 54
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCACheck.ps1' -1

function Invoke-ExecCaCheck {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Tenant = $Request.Body.tenantFilter
    $UserID = $Request.Body.userID.value
    if ($Request.Body.IncludeApplications.value) {
        $IncludeApplications = $Request.Body.IncludeApplications.value
    } else {
        $IncludeApplications = '67ad5377-2d78-4ac2-a867-6300cda00e85'
    }
    $results = try {
        $CAContext = @{
            '@odata.type'         = '#microsoft.graph.applicationContext'
            'includeApplications' = @($IncludeApplications)
        }
        $ConditionalAccessWhatIfDefinition = @{
            'signInIdentity'   = @{
                '@odata.type' = '#microsoft.graph.userSignIn'
                'userId'      = "$userId"
            }
            'signInContext'    = $CAContext
            'signInConditions' = @{}
        }
        $whatIfConditions = $ConditionalAccessWhatIfDefinition.signInConditions
        if ($Request.body.UserRiskLevel) { $whatIfConditions.userRiskLevel = $Request.body.UserRiskLevel.value }
        if ($Request.body.SignInRiskLevel) { $whatIfConditions.signInRiskLevel = $Request.body.SignInRiskLevel.value }
        if ($Request.body.ClientAppType) { $whatIfConditions.clientAppType = $Request.body.ClientAppType.value }
        if ($Request.body.DevicePlatform) { $whatIfConditions.devicePlatform = $Request.body.DevicePlatform.value }
        if ($Request.body.Country) { $whatIfConditions.country = $Request.body.Country.value }
        if ($Request.body.IpAddress) { $whatIfConditions.ipAddress = $Request.body.IpAddress.value }

        $JSONBody = $ConditionalAccessWhatIfDefinition | ConvertTo-Json -Depth 10
        Write-Host $JSONBody
        $Request = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/evaluate' -tenantid $tenant -type POST -body $JsonBody -AsApp $true
        $Request
    } catch {
        "Failed to execute check: $($_.Exception.Message)"
    }

    $body = [pscustomobject]@{'Results' = $results }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCACheck.ps1' 54
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCAExclusion.ps1' -1

function Invoke-ExecCAExclusion {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers

    try {
        #If UserId is a guid, get the user's UPN
        $TenantFilter = $Request.Body.tenantFilter
        $UserID = $Request.Body.UserID
        $Username = $Request.Body.Username
        $Users = $Request.Body.Users
        $EndDate = $Request.Body.EndDate
        $PolicyId = $Request.Body.PolicyId
        $ExclusionType = $Request.Body.ExclusionType
        $ExcludeLocationAuditAlerts = $Request.Body.excludeLocationAuditAlerts

        if ($Users) {
            $UserID = $Users.value
            $Username = $Users.addedFields.userPrincipalName -join ', '
        } else {
            if ($UserID -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$' -and -not $Username) {
                $Username = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)" -tenantid $TenantFilter).userPrincipalName
            }
        }

        $Policy = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($PolicyId)?`$select=id,displayName,conditions" -tenantid $TenantFilter -asApp $true

        if (-not $Policy) {
            throw "Policy with ID $PolicyId not found in tenant $TenantFilter."
        }

        $SecurityGroups = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups?`$select=id,displayName&`$filter=securityEnabled eq true and mailEnabled eq false&`$count=true" -tenantid $TenantFilter
        $VacationGroup = $SecurityGroups | Where-Object { $_.displayName -contains "Vacation Exclusion - $($Policy.displayName)" }

        if (!$VacationGroup) {
            Write-Information "Creating vacation group: Vacation Exclusion - $($Policy.displayName)"
            $Guid = [guid]::NewGuid().ToString()
            $GroupObject = @{
                groupType       = 'generic'
                displayName     = "Vacation Exclusion - $($Policy.displayName)"
                username        = "vacation$Guid"
                securityEnabled = $true
            }
            $NewGroup = New-CIPPGroup -GroupObject $GroupObject -TenantFilter $TenantFilter -APIName 'Invoke-ExecCAExclusion'
            $GroupId = $NewGroup.GroupId
        } else {
            Write-Information "Using existing vacation group: $($VacationGroup.displayName)"
            $GroupId = $VacationGroup.id
        }

        if ($Policy.conditions.users.excludeGroups -notcontains $GroupId) {
            Set-CIPPCAExclusion -TenantFilter $TenantFilter -ExclusionType 'Add' -PolicyId $PolicyId -Groups @{ value = @($GroupId); addedFields = @{ displayName = @("Vacation Exclusion - $($Policy.displayName)") } } -Headers $Headers
        }

        $PolicyName = $Policy.displayName
        if ($Request.Body.vacation -eq 'true') {
            $StartDate = $Request.Body.StartDate
            $EndDate = $Request.Body.EndDate
            # Detect if policy targets specific named locations (GUIDs) and user requested audit log exclusion
            $GuidRegex = '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'
            $LocationIds = @()
            if ($Policy.conditions.locations.includeLocations) { $LocationIds += $Policy.conditions.locations.includeLocations }
            if ($Policy.conditions.locations.excludeLocations) { $LocationIds += $Policy.conditions.locations.excludeLocations }
            $PolicyHasGuidLocations = $LocationIds | Where-Object { $_ -match $GuidRegex }

            $Parameters = [PSCustomObject]@{
                GroupType = 'Security'
                GroupId   = $GroupId
                Member    = $Users.addedFields.userPrincipalName ?? $Users.value ?? $Users ?? $UserID
            }

            $TaskBody = [pscustomobject]@{
                TenantFilter  = $TenantFilter
                Name          = "Add CA Exclusion Vacation Mode: $PolicyName"
                Command       = @{
                    value = 'Add-CIPPGroupMember'
                    label = 'Add-CIPPGroupMember'
                }
                Parameters    = [pscustomobject]$Parameters
                ScheduledTime = $StartDate
            }

            Write-Information ($TaskBody | ConvertTo-Json -Depth 10)

            Add-CIPPScheduledTask -Task $TaskBody -hidden $false
            # Optional: schedule audit log exclusion add task if requested and policy has location GUIDs
            if ($ExcludeLocationAuditAlerts -and $PolicyHasGuidLocations) {
                $AuditUsers = $Users.addedFields.userPrincipalName ?? $Users.value ?? $Users ?? $UserID
                $AuditAddTask = [pscustomobject]@{
                    TenantFilter  = $TenantFilter
                    Name          = "Add Audit Log Location Exclusion: $PolicyName"
                    Command       = @{ value = 'Set-CIPPAuditLogUserExclusion'; label = 'Set-CIPPAuditLogUserExclusion' }
                    Parameters    = [pscustomobject]@{ Users = $AuditUsers; Action = 'Add'; Type = 'Location' }
                    ScheduledTime = $StartDate
                }
                Add-CIPPScheduledTask -Task $AuditAddTask -hidden $true
            }
            #Removal of the exclusion
            $TaskBody.Command = @{
                label = 'Remove-CIPPGroupMember'
                value = 'Remove-CIPPGroupMember'
            }
            $TaskBody.Name = "Remove CA Exclusion Vacation Mode: $PolicyName"
            $TaskBody.ScheduledTime = $EndDate
            Add-CIPPScheduledTask -Task $TaskBody -hidden $false
            if ($ExcludeLocationAuditAlerts -and $PolicyHasGuidLocations) {
                $AuditUsers = $Users.addedFields.userPrincipalName ?? $Users.value ?? $Users ?? $UserID
                $AuditRemoveTask = [pscustomobject]@{
                    TenantFilter  = $TenantFilter
                    Name          = "Remove Audit Log Location Exclusion: $PolicyName"
                    Command       = @{ value = 'Set-CIPPAuditLogUserExclusion'; label = 'Set-CIPPAuditLogUserExclusion' }
                    Parameters    = [pscustomobject]@{ Users = $AuditUsers; Action = 'Remove'; Type = 'Location' }
                    ScheduledTime = $EndDate
                }
                Add-CIPPScheduledTask -Task $AuditRemoveTask -hidden $true
            }
            $body = @{ Results = "Successfully added vacation mode schedule for $Username." }
        } else {
            $Parameters = @{
                ExclusionType = $ExclusionType
                PolicyId      = $PolicyId
            }
            if ($Users) {
                $Parameters.Users = $Users
            } else {
                $Parameters.UserID = $UserID
            }

            Set-CIPPCAExclusion -TenantFilter $TenantFilter -Headers $Headers @Parameters
        }
    } catch {
        Write-Warning "Failed to perform exclusion for $Username : $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        $body = @{ Results = "Failed to perform exclusion for $Username : $($_.Exception.Message)" }
        Write-LogMessage -headers $Headers -API 'Invoke-ExecCAExclusion' -message "Failed to perform exclusion for $Username : $_" -Sev 'Error' -tenant $TenantFilter -LogData (Get-CippException -Exception $_)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCAExclusion.ps1' 150
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCAServiceExclusion.ps1' -1

Function Invoke-ExecCAServiceExclusion {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with the request
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $ID = $Request.Query.GUID ?? $Request.Body.GUID

    try {
        $result = Set-CIPPCAPolicyServiceException -TenantFilter $TenantFilter -PolicyId $ID
        $Body = @{ Results = $result }
        Write-LogMessage -headers $Headers -API 'Set-CIPPCAPolicyServiceException' -message $Message -Sev 'Info' -tenant $TenantFilter
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Body = @{ Results = "Failed to add service provider exception to policy $($ID): $($ErrorMessage.NormalizedError)" }
        Write-LogMessage -headers $Headers -API 'Set-CIPPCAPolicyServiceException' -message "Failed to update policy $($PolicyId) with service provider exception for tenant $($CSPtenantId): $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter -LogData (Get-CippException -Exception $_)
    }

    return ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $Body
    })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecCAServiceExclusion.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecNamedLocation.ps1' -1

function Invoke-ExecNamedLocation {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter ?? $Request.Query.tenantFilter
    $NamedLocationId = $Request.Body.namedLocationId ?? $Request.Query.namedLocationId
    $Change = $Request.Body.change ?? $Request.Query.change
    $Content = $Request.Body.input ?? $Request.Query.input
    if ($content.value) { $content = $content.value }

    try {
        $results = Set-CIPPNamedLocation -NamedLocationId $NamedLocationId -TenantFilter $TenantFilter -Change $Change -Content $Content -Headers $Headers
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to edit named location: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        $results = "Failed to edit named location. Error: $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = @($results) }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ExecNamedLocation.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListCAtemplates.ps1' -1

function Invoke-ListCAtemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.ConditionalAccess.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    Write-Host $Request.query.id
    #Migrating old policies whenever you do a list
    $Table = Get-CippTable -tablename 'templates'
    $Imported = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'settings'"
    if ($Imported.CATemplate -ne $true) {
        $Templates = Get-ChildItem 'Config\*.CATemplate.json' | ForEach-Object {
            $Entity = @{
                JSON         = "$(Get-Content $_)"
                RowKey       = "$($_.name)"
                PartitionKey = 'CATemplate'
                GUID         = "$($_.name)"
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
        }
        Add-CIPPAzDataTableEntity @Table -Entity @{
            CATemplate   = $true
            RowKey       = 'CATemplate'
            PartitionKey = 'settings'
        } -Force
    }
    #List new policies
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'CATemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        try {
            $row = $_
            $data = $row.JSON | ConvertFrom-Json -Depth 100 -ErrorAction Stop
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $row.GUID -Force
            $data
        } catch {
            Write-Warning "Failed to process CA template: $($row.RowKey) - $($_.Exception.Message)"
        }
    } | Sort-Object -Property displayName

    if ($Request.query.ID) { $Templates = $Templates | Where-Object -Property GUID -EQ $Request.query.id }

    $Templates = ConvertTo-Json -InputObject @($Templates) -Depth 100
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Templates
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListCAtemplates.ps1' 53
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListConditionalAccessPolicies.ps1' -1

function Invoke-ListConditionalAccessPolicies {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    #Region Helper functions
    function Get-LocationNameFromId {
        [CmdletBinding()]
        param (
            [Parameter()]
            $ID,
            $Locations
        )
        if ($id -eq 'All') {
            return 'All'
        }
        $DisplayName = $Locations | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) {
            return  $ID
        } else {
            return $DisplayName
        }
    }

    function Get-RoleNameFromId {
        [CmdletBinding()]
        param (
            [Parameter()]
            $ID,
            $RoleDefinitions
        )
        if ($id -eq 'All') {
            return 'All'
        }
        $DisplayName = $RoleDefinitions | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) {
            return $ID
        } else {
            return $DisplayName
        }
    }

    function Get-UserNameFromId {
        [CmdletBinding()]
        param (
            [Parameter()]
            $ID,
            $Users
        )
        if ($id -eq 'All') {
            return 'All'
        }
        $DisplayName = $Users | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) {
            return $ID
        } else {
            return $DisplayName
        }
    }

    function Get-GroupNameFromId {
        param (
            [Parameter()]
            $ID,
            $Groups
        )
        if ($id -eq 'All') {
            return 'All'
        }
        $DisplayName = $Groups | Where-Object { $_.id -eq $ID } | Select-Object -ExpandProperty DisplayName
        if ([string]::IsNullOrEmpty($displayName)) {
            return 'No Data'
        } else {
            return $DisplayName
        }
    }

    function Get-ApplicationNameFromId {
        [CmdletBinding()]
        param (
            [Parameter()]
            $ID,
            $Applications,
            $ServicePrincipals
        )
        if ($id -eq 'All') {
            return 'All'
        }

        $return = $ServicePrincipals | Where-Object { $_.appId -eq $ID } | Select-Object -ExpandProperty DisplayName

        if ([string]::IsNullOrEmpty($return)) {
            $return = $Applications | Where-Object { $_.Appid -eq $ID } | Select-Object -ExpandProperty DisplayName
        }

        if ([string]::IsNullOrEmpty($return)) {
            $return = $Applications | Where-Object { $_.ID -eq $ID } | Select-Object -ExpandProperty DisplayName
        }

        if ([string]::IsNullOrEmpty($return)) {
            $return = ''
        }

        return $return
    }
    #EndRegion Helper functions

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    try {
        $GraphRequest = if ($TenantFilter -ne 'AllTenants') {
            # Single tenant functionality
            $Requests = @(
                @{
                    id     = 'policies'
                    url    = 'identity/conditionalAccess/policies'
                    method = 'GET'
                }
                @{
                    id     = 'namedLocations'
                    url    = 'identity/conditionalAccess/namedLocations'
                    method = 'GET'
                }
                @{
                    id     = 'applications'
                    url    = 'applications?$top=999&$select=appId,displayName'
                    method = 'GET'
                }
                @{
                    id     = 'roleDefinitions'
                    url    = 'roleManagement/directory/roleDefinitions?$select=id,displayName'
                    method = 'GET'
                }
                @{
                    id     = 'groups'
                    url    = 'groups?$top=999&$select=id,displayName'
                    method = 'GET'
                }
                @{
                    id     = 'users'
                    url    = 'users?$top=999&$select=id,displayName,userPrincipalName'
                    method = 'GET'
                }
                @{
                    id     = 'servicePrincipals'
                    url    = 'servicePrincipals?$top=999&$select=appId,displayName'
                    method = 'GET'
                }
            )

            $BulkResults = New-GraphBulkRequest -Requests $Requests -tenantid $TenantFilter -asapp $true

            $ConditionalAccessPolicyOutput = ($BulkResults | Where-Object { $_.id -eq 'policies' }).body.value
            $AllNamedLocations = ($BulkResults | Where-Object { $_.id -eq 'namedLocations' }).body.value
            $AllApplications = ($BulkResults | Where-Object { $_.id -eq 'applications' } ).body.value
            $AllRoleDefinitions = ($BulkResults | Where-Object { $_.id -eq 'roleDefinitions' }).body.value
            $GroupListOutput = ($BulkResults | Where-Object { $_.id -eq 'groups' }).body.value
            $UserListOutput = ($BulkResults | Where-Object { $_.id -eq 'users' }).body.value
            $AllServicePrincipals = ($BulkResults | Where-Object { $_.id -eq 'servicePrincipals' }).body.value

            foreach ($cap in $ConditionalAccessPolicyOutput) {
                [PSCustomObject]@{
                    id                                          = $cap.id
                    displayName                                 = $cap.displayName
                    customer                                    = $cap.Customer
                    Tenant                                      = $TenantFilter
                    createdDateTime                             = $(if (![string]::IsNullOrEmpty($cap.createdDateTime)) { [datetime]$cap.createdDateTime } else { '' })
                    modifiedDateTime                            = $(if (![string]::IsNullOrEmpty($cap.modifiedDateTime)) { [datetime]$cap.modifiedDateTime }else { '' })
                    state                                       = $cap.state
                    clientAppTypes                              = ($cap.conditions.clientAppTypes) -join ','
                    includePlatforms                            = ($cap.conditions.platforms.includePlatforms) -join ','
                    excludePlatforms                            = ($cap.conditions.platforms.excludePlatforms) -join ','
                    includeLocations                            = (Get-LocationNameFromId -Locations $AllNamedLocations -id $cap.conditions.locations.includeLocations) -join ','
                    excludeLocations                            = (Get-LocationNameFromId -Locations $AllNamedLocations -id $cap.conditions.locations.excludeLocations) -join ','
                    includeApplications                         = ($cap.conditions.applications.includeApplications | ForEach-Object { Get-ApplicationNameFromId -Applications $AllApplications -ServicePrincipals $AllServicePrincipals -id $_ }) -join ','
                    excludeApplications                         = ($cap.conditions.applications.excludeApplications | ForEach-Object { Get-ApplicationNameFromId -Applications $AllApplications -ServicePrincipals $AllServicePrincipals -id $_ }) -join ','
                    includeUserActions                          = ($cap.conditions.applications.includeUserActions | Out-String)
                    includeAuthenticationContextClassReferences = ($cap.conditions.applications.includeAuthenticationContextClassReferences | Out-String)
                    includeUsers                                = ($cap.conditions.users.includeUsers | ForEach-Object { Get-UserNameFromId -Users $UserListOutput -id $_ }) | Out-String
                    excludeUsers                                = ($cap.conditions.users.excludeUsers | ForEach-Object { Get-UserNameFromId -Users $UserListOutput -id $_ }) | Out-String
                    includeGroups                               = ($cap.conditions.users.includeGroups | ForEach-Object { Get-GroupNameFromId -Groups $GroupListOutput -id $_ }) | Out-String
                    excludeGroups                               = ($cap.conditions.users.excludeGroups | ForEach-Object { Get-GroupNameFromId -Groups $GroupListOutput -id $_ }) | Out-String
                    includeRoles                                = ($cap.conditions.users.includeRoles | ForEach-Object { Get-RoleNameFromId -RoleDefinitions $AllRoleDefinitions -id $_ }) | Out-String
                    excludeRoles                                = ($cap.conditions.users.excludeRoles | ForEach-Object { Get-RoleNameFromId -RoleDefinitions $AllRoleDefinitions -id $_ }) | Out-String
                    grantControlsOperator                       = ($cap.grantControls.operator) -join ','
                    builtInControls                             = ($cap.grantControls.builtInControls) -join ','
                    customAuthenticationFactors                 = ($cap.grantControls.customAuthenticationFactors) -join ','
                    termsOfUse                                  = ($cap.grantControls.termsOfUse) -join ','
                    rawjson                                     = ($cap | ConvertTo-Json -Depth 100)
                }
            }
        } else {
            # AllTenants functionality
            $Table = Get-CIPPTable -TableName cacheCAPolicies
            $PartitionKey = 'CAPolicy'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-60)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            # If a queue is running, we will not start a new one
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
            } elseif (!$Rows -and !$RunningQueue) {
                # If no rows are found and no queue is running, we will start a new one
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'Conditional Access Policies - All Tenants' -Link '/tenant/conditional/list-policies?customerId=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'CAPoliciesOrchestrator'
                    QueueFunction    = @{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ListConditionalAccessPoliciesAllTenants'
                    }
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress) | Out-Null
            } else {
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }
                $Policies = $Rows
                # Output all policies from all tenants
                foreach ($policy in $Policies) {
                    ($policy.Policy | ConvertFrom-Json)
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    if (!$Body) {
        $StatusCode = [HttpStatusCode]::OK
        $Body = [PSCustomObject]@{
            Results  = @($GraphRequest | Where-Object -Property id -NE $null | Sort-Object id -Descending)
            Metadata = $Metadata
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListConditionalAccessPolicies.ps1' 262
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListConditionalAccessPolicyChanges.ps1' -1

Function Invoke-ListConditionalAccessPolicyChanges {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $PolicyId = $Request.Query.id
    $PolicyDisplayName = $Request.Query.displayName

    try {
        [array]$Changes = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/auditLogs/directoryAudits?`$filter=targetResources/any(s:s/id eq '$($PolicyId)')" -tenantid $TenantFilter | ForEach-Object {
            [pscustomobject]@{
                policy           = $PolicyDisplayName
                policyId         = $PolicyId
                typeFriendlyName = $_.activityDisplayName
                type             = $_.operationType
                initiatedBy      = if ($_.initiatedBy.user.userPrincipalName) { $_.initiatedBy.user.userPrincipalName } else { $_.initiatedBy.app.displayName }
                date             = $_.activityDateTime
                oldValue         = ($_.targetResources[0].modifiedProperties.oldValue | ConvertFrom-Json) # targetResources is an array, can we ever get more than 1 object in it?
                newValue         = ($_.targetResources[0].modifiedProperties.newValue | ConvertFrom-Json)
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $StatusCode = [HttpStatusCode]::BadRequest
        $Changes = "Failed to request audit logs for policy $($PolicyDisplayName): $($_.Exception.message)"
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Changes)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-ListConditionalAccessPolicyChanges.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-RemoveCAPolicy.ps1' -1

Function Invoke-RemoveCAPolicy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter ?? $Request.Body.tenantFilter
    $policyId = $Request.Query.GUID ?? $Request.Body.GUID
    if (!$policyId) { exit }
    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/identity/conditionalAccess/policies/$($policyId)" -type DELETE -tenant $TenantFilter -asapp $true
        $Result = "Deleted CA Policy $($policyId)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info' -tenant $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not delete CA policy with ID $($policyId) : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    $body = [pscustomobject]@{'Results' = $Result }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-RemoveCAPolicy.ps1' 39
#Region './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-RemoveCATemplate.ps1' -1

Function Invoke-RemoveCATemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $request.Query.ID ?? $Request.Body.ID
    try {
        $Table = Get-CippTable -tablename 'templates'

        $Filter = "PartitionKey eq 'CATemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Conditional Access Template with ID $ID"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Conditional Access template $($ID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Conditional/Invoke-RemoveCATemplate.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecAddGDAPRole.ps1' -1

function Invoke-ExecAddGDAPRole {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Action = $Request.Body.Action ?? $Request.Query.Action ?? 'AddRoleSimple'
    $GroupBlockList = @('All Users', 'AdminAgents', 'HelpdeskAgents', 'SalesAgents')

    switch ($Action) {
        'ListGroups' {
            $Groups = New-GraphGetRequest -NoAuthCheck $True -uri 'https://graph.microsoft.com/beta/groups?$filter=securityEnabled eq true&$select=id,displayName&$top=999' -tenantid $env:TenantID -AsApp $true | Where-Object -Property displayName -NotIn $GroupBlockList
            $Results = @($Groups)
        }
        'AddRoleAdvanced' {
            $Mappings = $Request.Body.mappings
            $Table = Get-CIPPTable -TableName 'GDAPRoles'
            $ExistingGroups = New-GraphGetRequest -NoAuthCheck $True -uri 'https://graph.microsoft.com/beta/groups?$filter=securityEnabled eq true&$select=id,displayName&$top=999' -tenantid $env:TenantID -AsApp $true
            $Results = [System.Collections.Generic.List[object]]::new()
            $ErrorsFound = $false
            $Entities = foreach ($Mapping in $Mappings) {
                $GroupId = $Mapping.GroupId
                if ($ExistingGroups.id -contains $GroupId) {
                    $ExistingGroup = $ExistingGroups | Where-Object -Property id -EQ $GroupId
                    if ($ExistingGroup.displayName -in $GroupBlockList) {
                        $Results.Add(@{
                                state      = 'error'
                                resultText = "Group $($ExistingGroup.displayName) is a reserved group and cannot be mapped to a GDAP role"
                            })
                        $ErrorsFound = $true
                    } else {
                        @{
                            PartitionKey     = 'Roles'
                            RowKey           = $GroupId
                            RoleName         = $Mapping.RoleName
                            GroupName        = $ExistingGroup.displayName
                            GroupId          = $GroupId
                            roleDefinitionId = $Mapping.roleDefinitionId
                        }
                        $Results.Add(@{
                                state      = 'success'
                                resultText = "Mapped $($ExistingGroup.displayName) to $($Mapping.RoleName)"
                            })
                    }
                }
            }
            if (($Entities | Measure-Object).Count -gt 0) {
                Write-Warning "Adding $($Entities.Count) entities to table"
                Write-Information ($Entities | ConvertTo-Json -Depth 10 -Compress)
                Add-CIPPAzDataTableEntity @Table -Entity $Entities -Force
            } elseif ($ErrorsFound -eq $false) {
                $Results.Add(@{
                        state      = 'success'
                        resultText = 'All role mappings already exist'
                    })
            }
        }
        'AddRoleSimple' {
            $CippDefaults = @(
                @{ label = 'Application Administrator'; value = '9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3' },
                @{ label = 'User Administrator'; value = 'fe930be7-5e62-47db-91af-98c3a49a38b1' },
                @{ label = 'Intune Administrator'; value = '3a2c62db-5318-420d-8d74-23affee5d9d5' },
                @{ label = 'Exchange Administrator'; value = '29232cdf-9323-42fd-ade2-1d097af3e4de' },
                @{ label = 'Security Administrator'; value = '194ae4cb-b126-40b2-bd5b-6091b380977d' },
                @{ label = 'Cloud App Security Administrator'; value = '892c5842-a9a6-463a-8041-72aa08ca3cf6' },
                @{ label = 'Cloud Device Administrator'; value = '7698a772-787b-4ac8-901f-60d6b08affd2' },
                @{ label = 'Teams Administrator'; value = '69091246-20e8-4a56-aa4d-066075b2a7a8' },
                @{ label = 'SharePoint Administrator'; value = 'f28a1f50-f6e7-4571-818b-6a12f2af6b6c' },
                @{ label = 'Authentication Policy Administrator'; value = '0526716b-113d-4c15-b2c8-68e3c22b9f80' },
                @{ label = 'Privileged Role Administrator'; value = 'e8611ab8-c189-46e8-94e1-60213ab1f814' },
                @{ label = 'Privileged Authentication Administrator'; value = '7be44c8a-adaf-4e2a-84d6-ab2649e08a13' }
            )

            $Groups = $Request.Body.gdapRoles ?? $CippDefaults

            $CustomSuffix = $Request.Body.customSuffix
            $Table = Get-CIPPTable -TableName 'GDAPRoles'

            $Results = [System.Collections.Generic.List[string]]::new()
            $Requests = [System.Collections.Generic.List[object]]::new()
            $ExistingGroups = New-GraphGetRequest -NoAuthCheck $True -uri 'https://graph.microsoft.com/beta/groups' -tenantid $env:TenantID -AsApp $true

            $ExistingRoleMappings = foreach ($Group in $Groups) {
                $RoleName = $Group.label ?? $Group.Name
                $Value = $Group.value ?? $Group.ObjectId

                if ($CustomSuffix) {
                    $GroupName = "M365 GDAP $($RoleName) - $CustomSuffix"
                    $MailNickname = "M365GDAP$(($RoleName).replace(' ',''))$($CustomSuffix.replace(' ',''))"
                } else {
                    $GroupName = "M365 GDAP $($RoleName)"
                    $MailNickname = "M365GDAP$(($RoleName).replace(' ',''))"
                }

                if ($GroupName -in $ExistingGroups.displayName) {
                    @{
                        PartitionKey     = 'Roles'
                        RowKey           = ($ExistingGroups | Where-Object -Property displayName -EQ $GroupName).id
                        RoleName         = $RoleName
                        GroupName        = $GroupName
                        GroupId          = ($ExistingGroups | Where-Object -Property displayName -EQ $GroupName).id
                        roleDefinitionId = $Value
                    }
                    $Results.Add("$GroupName already exists")
                } else {
                    $Requests.Add(@{
                            id      = $Value
                            url     = '/groups'
                            method  = 'POST'
                            headers = @{
                                'Content-Type' = 'application/json'
                            }
                            body    = @{
                                displayName     = $GroupName
                                description     = "This group is used to manage M365 partner tenants at the $($RoleName) level."
                                securityEnabled = $true
                                mailEnabled     = $false
                                mailNickname    = $MailNickname
                            }
                        })
                }
            }
            if ($ExistingRoleMappings) {
                Add-CIPPAzDataTableEntity @Table -Entity $ExistingRoleMappings -Force
            }

            if ($Requests) {
                $ReturnedData = New-GraphBulkRequest -Requests $Requests -tenantid $env:TenantID -NoAuthCheck $True -asapp $true
                $NewRoleMappings = foreach ($Return in $ReturnedData) {
                    if ($Return.body.error) {
                        $Results.Add("Could not create GDAP group: $($Return.body.error.message)")
                    } else {
                        $GroupName = $Return.body.displayName
                        @{
                            PartitionKey     = 'Roles'
                            RowKey           = $Return.body.id
                            RoleName         = $Return.body.displayName -replace '^M365 GDAP ', '' -replace " - $CustomSuffix$", ''
                            GroupName        = $Return.body.displayName
                            GroupId          = $Return.body.id
                            roleDefinitionId = $Return.id
                        }
                        $Results.Add("Created $($GroupName)")
                    }
                }
                Write-Information ($NewRoleMappings | ConvertTo-Json -Depth 10 -Compress)
                if ($NewRoleMappings) {
                    Add-CIPPAzDataTableEntity @Table -Entity $NewRoleMappings -Force
                }
            }

            $RoleMappings = [System.Collections.Generic.List[object]]::new()
            if ($ExistingRoleMappings) {
                $RoleMappings.AddRange(@($ExistingRoleMappings))
            }
            if ($NewRoleMappings) {
                $RoleMappings.AddRange(@($NewRoleMappings))
            }

            if ($Request.Body.templateId) {
                Add-CIPPGDAPRoleTemplate -TemplateId $Request.Body.templateId -RoleMappings ($RoleMappings | Select-Object -Property RoleName, GroupName, GroupId, roleDefinitionId)
                $Results.Add("Added role mappings to template $($Request.Body.templateId)")
            }
        }
    }

    $body = @{Results = @($Results) }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecAddGDAPRole.ps1' 176
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecAutoExtendGDAP.ps1' -1

Function Invoke-ExecAutoExtendGDAP {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Id = $Request.query.ID ?? $Request.Body.ID
    $Results = Set-CIPPGDAPAutoExtend -RelationShipid $Id

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ Results = $Results }
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecAutoExtendGDAP.ps1' 19
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecDeleteGDAPRelationship.ps1' -1

Function Invoke-ExecDeleteGDAPRelationship {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $GDAPID = $Request.Query.GDAPId ?? $Request.Body.GDAPId
    try {
        $DELETE = New-GraphPostRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($GDAPID)/requests" -type POST -body '{"action":"terminate"}' -tenantid $env:TenantID
        $Results = [pscustomobject]@{'Results' = "Success. GDAP relationship for $($GDAPID) been revoked" }
        Write-LogMessage -headers $Headers -API $APIName -message "Success. GDAP relationship for $($GDAPID) been revoked" -Sev 'Info'

    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecDeleteGDAPRelationship.ps1' 32
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecDeleteGDAPRoleMapping.ps1' -1

Function Invoke-ExecDeleteGDAPRoleMapping {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    $Table = Get-CIPPTable -TableName 'GDAPRoles'
    $GroupId = $Request.Query.GroupId ?? $Request.Body.GroupId
    try {
        $Filter = "PartitionKey eq 'Roles' and RowKey eq '{0}'" -f $GroupId
        $Entity = Get-CIPPAzDataTableEntity @Table -Filter $Filter
        Remove-AzDataTableEntity -Force @Table -Entity $Entity
        $Results = [pscustomobject]@{'Results' = 'Success. GDAP relationship mapping deleted' }
        Write-LogMessage -headers $Headers -API $APIName -message "GDAP relationship mapping deleted for $($GroupId)" -Sev 'Info'

    } catch {
        $Results = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecDeleteGDAPRoleMapping.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPAccessAssignment.ps1' -1

function Invoke-ExecGDAPAccessAssignment {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    Write-LogMessage -headers $Request.Headers -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    $Action = $Request.Body.Action ?? $Request.Query.Action
    $Id = $Request.Body.Id ?? $Request.Query.Id

    switch ($Action) {
        'ResetMappings' {
            $RoleTemplateId = $Request.Body.RoleTemplateId

            if (-not $RoleTemplateId) {
                $Body = @{
                    Results = @{
                        state      = 'error'
                        resultText = 'RoleTemplateId is required'
                    }
                }
            } else {
                $GDAPRoleTemplatesTable = Get-CIPPTable -TableName 'GDAPRoleTemplates'
                $Mappings = Get-CIPPAzDataTableEntity @GDAPRoleTemplatesTable -Filter "PartitionKey eq 'RoleTemplate' and RowKey eq '$($RoleTemplateId)'" | Select-Object -ExpandProperty RoleMappings | ConvertFrom-Json

                $RelationshipRequests = @(
                    @{
                        'id'     = 'getRelationship'
                        'url'    = "tenantRelationships/delegatedAdminRelationships/$Id"
                        'method' = 'GET'
                    }
                    @{
                        'id'     = 'getAccessAssignments'
                        'url'    = "tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments"
                        'method' = 'GET'
                    }
                )

                $RelationshipResults = New-GraphBulkRequest -Requests $RelationshipRequests -NoAuthCheck $true
                $Relationship = ($RelationshipResults | Where-Object id -EQ 'getRelationship').body
                $AccessAssignments = ($RelationshipResults | Where-Object id -EQ 'getAccessAssignments').body.value

                $Groups = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/groups?`$top=999&`$select=id,displayName&`$filter=securityEnabled eq true" -asApp $true -NoAuthCheck $true

                $Requests = [System.Collections.Generic.List[object]]::new()
                $Messages = [System.Collections.Generic.List[object]]::new()

                foreach ($AccessAssignment in $AccessAssignments) {
                    $RoleCount = ($AccessAssignment.accessDetails.unifiedRoles | Measure-Object).Count
                    if ($Mappings.GroupId -notcontains $AccessAssignment.accessContainer.accessContainerId -and $AccessAssignment.status -notin @('deleting', 'deleted', 'error')) {
                        Write-Warning "Deleting access assignment for $($AccessAssignment.accessContainer.accessContainerId)"
                        $Group = $Groups | Where-Object id -EQ $AccessAssignment.accessContainer.accessContainerId
                        $Requests.Add(@{
                                'id'      = "delete-$($AccessAssignment.id)"
                                'url'     = "tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments/$($AccessAssignment.id)"
                                'method'  = 'DELETE'
                                'headers' = @{
                                    'If-Match' = $AccessAssignment.'@odata.etag'
                                }
                            })

                        $Messages.Add(@{
                                'id'      = "delete-$($AccessAssignment.id)"
                                'message' = "Deleting access assignment for $($Group.displayName)"
                            })

                    } elseif ($AccessAssignment.status -notin @('deleting', 'deleted', 'error')) {
                        # check for mismatched role definitions (e.g. role in assignment does not match role in mapping)
                        $Mapping = $Mappings | Where-Object { $_.GroupId -eq $AccessAssignment.accessContainer.accessContainerId }
                        $Group = $Groups | Where-Object id -EQ $AccessAssignment.accessContainer.accessContainerId

                        if ($RoleCount -gt 1 -or $AccessAssignment.accessDetails.unifiedRoles.roleDefinitionId -notcontains $Mapping.roleDefinitionId) {
                            Write-Warning "Patching access assignment for $($AccessAssignment.accessContainer.accessContainerId)"
                            $Requests.Add(@{
                                    'id'      = "patch-$($AccessAssignment.id)"
                                    'url'     = "tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments/$($AccessAssignment.id)"
                                    'method'  = 'PATCH'
                                    'body'    = @{
                                        'accessDetails' = @{
                                            'unifiedRoles' = @(
                                                @{
                                                    roleDefinitionId = $Mapping.roleDefinitionId
                                                }
                                            )
                                        }
                                    }
                                    'headers' = @{
                                        'If-Match'     = $AccessAssignment.'@odata.etag'
                                        'Content-Type' = 'application/json'
                                    }
                                })

                            $Messages.Add(@{
                                    'id'      = "patch-$($AccessAssignment.id)"
                                    'message' = "Updating access assignment for $($Group.displayName)"
                                })
                        }
                    }
                }

                foreach ($Mapping in $Mappings) {
                    $DeletedAssignments = $AccessAssignments | Where-Object { $_.accessContainer.accessContainerId -eq $Mapping.GroupId -and $_.status -eq 'deleted' }
                    if (($AccessAssignments.accessContainer.accessContainerId -notcontains $Mapping.GroupId -or $DeletedAssignments.accessContainer.accessContainerId -contains $Mapping.GroupId) -and $Relationship.accessDetails.unifiedRoles.roleDefinitionId -contains $Mapping.roleDefinitionId) {
                        Write-Information "Creating access assignment for $($Mapping.GroupId)"
                        $Requests.Add(@{
                                'id'      = "create-$($Mapping.GroupId)"
                                'url'     = "tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments"
                                'method'  = 'POST'
                                'body'    = @{
                                    'accessDetails'   = @{
                                        'unifiedRoles' = @(
                                            @{
                                                roleDefinitionId = $Mapping.roleDefinitionId
                                            }
                                        )
                                    }
                                    'accessContainer' = @{
                                        'accessContainerId'   = $Mapping.GroupId
                                        'accessContainerType' = 'securityGroup'
                                    }
                                }
                                'headers' = @{
                                    'Content-Type' = 'application/json'
                                }
                            })
                        $Messages.Add(@{
                                'id'      = "create-$($Mapping.GroupId)"
                                'message' = "Creating access assignment for $($Mapping.GroupName)"
                            })
                    }
                }

                if ($Requests) {
                    Write-Warning "Executing $($Requests.Count) access assignment changes"
                    Write-Information ($Requests | ConvertTo-Json -Depth 10)

                    $BulkResults = New-GraphBulkRequest -Requests $Requests -NoAuthCheck $true

                    Write-Warning "Received $($BulkResults.Count) access assignment results"
                    Write-Information ($BulkResults | ConvertTo-Json -Depth 10)
                    $Results = foreach ($Result in $BulkResults) {
                        $Message = $Messages | Where-Object id -EQ $Result.id
                        if ($Result.status -in @('201', '202', '204')) {
                            @{
                                resultText = $Message.message
                                state      = 'success'
                            }
                        } else {
                            @{
                                resultText = "Error: $($Message.message): $($Result.body.error.message)"
                                state      = 'error'
                            }
                        }
                    }

                } else {
                    $Results = @{
                        resultText = 'This relationship already has the correct access assignments'
                        state      = 'success'
                    }
                }

                $Body = @{
                    Results = @($Results)
                }
            }
        }
        default {
            $Body = @{
                Results = @(@{
                        state      = 'error'
                        resultText = 'Invalid action'
                    })
            }
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPAccessAssignment.ps1' 188
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPInvite.ps1' -1

function Invoke-ExecGDAPInvite {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    $Action = $Request.Body.Action ?? $Request.Query.Action ?? 'Create'
    $InviteId = $Request.Body.InviteId
    $Reference = $Request.Body.Reference
    $Table = Get-CIPPTable -TableName 'GDAPInvites'

    # Extract technician from headers (same logic as Write-LogMessage)
    if ($Headers.'x-ms-client-principal-idp' -eq 'azureStaticWebApps' -or !$Headers.'x-ms-client-principal-idp') {
        $user = $headers.'x-ms-client-principal'
        $Technician = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails
    } elseif ($Headers.'x-ms-client-principal-idp' -eq 'aad') {
        $Table = Get-CIPPTable -TableName 'ApiClients'
        $Client = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($headers.'x-ms-client-principal-name')'"
        $Technician = $Client.AppName ?? 'CIPP-API'
    } else {
        try {
            $user = $headers.'x-ms-client-principal'
            $Technician = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails
        } catch {
            $Technician = 'System'
        }
    }

    switch ($Action) {
        'Create' {
            $RoleMappings = $Request.Body.roleMappings

            if ($RoleMappings.roleDefinitionId -contains '62e90394-69f5-4237-9190-012177145e10') {
                $AutoExtendDuration = 'PT0S'
            } else {
                $AutoExtendDuration = 'P180D'
            }

            try {
                $Step = 'Creating GDAP relationship'
                $JSONBody = @{
                    'displayName'        = "CIPP_$((New-Guid).GUID)"
                    'accessDetails'      = @{
                        'unifiedRoles' = @($RoleMappings | Select-Object roleDefinitionId)
                    }
                    'autoExtendDuration' = $AutoExtendDuration
                    'duration'           = 'P730D'
                } | ConvertTo-Json -Depth 5 -Compress

                $NewRelationship = New-GraphPostRequest -NoAuthCheck $True -uri 'https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships' -type POST -body $JSONBody -verbose -tenantid $env:TenantID
                Start-Sleep -Milliseconds 100
                $Count = 0
                do {
                    $CheckActive = New-GraphGetRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($NewRelationship.id)" -tenantid $env:TenantID
                    Start-Sleep -Milliseconds 200
                    $Count++
                } until ($CheckActive.status -eq 'created' -or $Count -gt 5)

                if ($CheckActive.status -eq 'created') {
                    # Lock for approval
                    $JSONBody = @{
                        'action' = 'lockForApproval'
                    } | ConvertTo-Json
                    $Step = 'Locking GDAP relationship for approval'

                    $AddedHeaders = @{
                        'If-Match' = $NewRelationship.'@odata.etag'
                    }

                    $NewRelationshipRequest = New-GraphPostRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($NewRelationship.id)/requests" -type POST -body $JSONBody -verbose -tenantid $env:TenantID -AddedHeaders $AddedHeaders

                    if ($NewRelationshipRequest.action -eq 'lockForApproval') {
                        $InviteUrl = "https://admin.microsoft.com/AdminPortal/Home#/partners/invitation/granularAdminRelationships/$($NewRelationship.id)"
                        try {
                            $Uri = ([System.Uri]$TriggerMetadata.Headers.Referer)
                            $OnboardingUrl = $Uri.AbsoluteUri.Replace($Uri.PathAndQuery, "/tenant/gdap-management/onboarding/start?id=$($NewRelationship.id)")
                        } catch {
                            $OnboardingUrl = $null
                        }

                        $InviteEntity = [PSCustomObject]@{
                            'PartitionKey'  = 'invite'
                            'RowKey'        = $NewRelationship.id
                            'InviteUrl'     = $InviteUrl
                            'OnboardingUrl' = $OnboardingUrl
                            'RoleMappings'  = [string](@($RoleMappings) | ConvertTo-Json -Depth 10 -Compress)
                            'Technician'    = [string]$Technician
                            'Reference'     = if ($Reference) { [string]$Reference } else { $null }
                        }

                        Add-CIPPAzDataTableEntity @Table -Entity $InviteEntity

                        $Message = 'GDAP relationship invite created. Log in as a Global Admin in the new tenant to approve the invite.'
                    } else {
                        $Message = 'Error creating GDAP relationship request'
                    }

                    Write-LogMessage -headers $Request.Headers -API $APINAME -message "Created GDAP Invite - $InviteUrl" -Sev 'Info'
                }
            } catch {
                $Message = 'Error creating GDAP relationship, failed at step: ' + $Step
                Write-Host "GDAP ERROR: $($_.InvocationInfo.PositionMessage)"

                if ($Step -eq 'Creating GDAP relationship' -and $_.Exception.Message -match 'The user (principal) does not have the required permissions to perform the specified action on the resource.') {
                    $Message = 'Error creating GDAP relationship, ensure that all users have MFA enabled and enforced without exception. Please see the Microsoft Partner Security Requirements documentation for more information. https://learn.microsoft.com/en-us/partner-center/security/partner-security-requirements'
                } else {
                    $Message = "$($Message): $($_.Exception.Message)"
                }

                Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $env:TenantID -message $Message -Sev 'Error' -LogData (Get-CippException -Exception $_)
            }

            $body = @{
                Message = $Message
                Invite  = $InviteEntity
            }
        }
        'Update' {
            $Invite = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'invite' and RowKey eq '$InviteId'"
            if ($Invite) {

                $InviteEntity = [PSCustomObject]@{
                    'PartitionKey' = 'invite'
                    'RowKey'       = $InviteId
                    'Technician'   = $Technician
                    'Reference'    = if ($Reference) { $Reference } else { $null }
                }

                Add-CIPPAzDataTableEntity @Table -Entity $InviteEntity -OperationType 'UpsertMerge'
                $Message = 'Invite updated'
            } else {
                $Message = 'Invite not found'
            }
            $body = @{
                Message = $Message
            }
        }
        'Delete' {
            $Invite = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'invite' and RowKey eq '$InviteId'"
            if ($Invite) {
                Remove-AzDataTableEntity @Table -Entity $Invite
                $Message = 'Invite deleted'
            } else {
                $Message = 'Invite not found'
            }
            $body = @{
                Message = $Message
            }
        }

    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPInvite.ps1' 166
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPInviteApproved.ps1' -1

Function Invoke-ExecGDAPInviteApproved {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    Set-CIPPGDAPInviteGroups

    $body = @{Results = @('Processing recently activated GDAP relationships') }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPInviteApproved.ps1' 20
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPRemoveGArole.ps1' -1

Function Invoke-ExecGDAPRemoveGArole {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $GDAPID = $Request.Query.GDAPId ?? $Request.Body.GDAPId

    try {
        $CheckActive = New-GraphGetRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($GDAPID)" -tenantid $env:TenantID
        if ($CheckActive.status -eq 'active' -AND '62e90394-69f5-4237-9190-012177145e10' -in $CheckActive.accessDetails.unifiedRoles.roleDefinitionId) {
            $AddedHeader = @{'If-Match' = $CheckActive.'@odata.etag' }

            $RawJSON = [pscustomobject]@{
                accessDetails = [pscustomobject]@{
                    unifiedRoles = @(
                        ($CheckActive.accessDetails.unifiedRoles | Where-Object { $_.roleDefinitionId -ne '62e90394-69f5-4237-9190-012177145e10' })
                    )
                }
            } | ConvertTo-Json -Depth 3

            New-GraphPOSTRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($GDAPID)" -tenantid $env:TenantID -type PATCH -body $RawJSON -AddedHeaders $AddedHeader

            $Message = "Removed Global Administrator from $($GDAPID)"
            Write-LogMessage -headers $Request.Headers -API $APINAME -message $Message -Sev 'Info'
        } else {
            if ($CheckActive.status -ne 'active') {
                $Message = "Relationship status is currently $($CheckActive.status), it is not possible to remove the Global Administrator role in this state."
            }
            if ('62e90394-69f5-4237-9190-012177145e10' -notin $CheckActive.accessDetails.unifiedRoles.roleDefinitionId) {
                $Message = 'This relationship does not contain the Global Administrator role.'
            }
        }
    } catch {
        $Message = "Unexpected error patching GDAP relationship: $($_.Exception.Message)"
        Write-Host "GDAP ERROR: $($_.Exception.Message)"
        Write-LogMessage -headers $Request.Headers -API $APINAME -tenant $env:TenantID -message "$($Message): $($_.Exception.Message)" -Sev 'Error'
    }

    $body = @{
        Message = $Message
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPRemoveGArole.ps1' 52
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPRoleTemplate.ps1' -1

function Invoke-ExecGDAPRoleTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $Table = Get-CIPPTable -TableName 'GDAPRoleTemplates'
    $Templates = Get-CIPPAzDataTableEntity @Table

    if ($Request.Query.TemplateId) {
        $Template = $Templates | Where-Object -Property RowKey -EQ $Request.Query.TemplateId
        if (!$Template) {
            Write-LogMessage -headers $Headers -API $APIName -message "GDAP role template '$($Request.Query.TemplateId)' not found" -Sev 'Warning'
            $Body = @{}
        } else {
            Write-LogMessage -headers $Headers -API $APIName -message "Retrieved GDAP role template '$($Request.Query.TemplateId)'" -Sev 'Info'
            $Body = @{
                TemplateId   = $Template.RowKey
                RoleMappings = @($Template.RoleMappings | ConvertFrom-Json)
            }
        }
    } else {
        switch ($Request.Query.Action) {
            'Add' {
                $RowKey = ($Request.Body | Select-Object -First 1 -ExpandProperty TemplateId).value ?? $Request.Body.TemplateId
                if ($Request.Body.GroupId) {
                    $RoleMappings = $Request.Body | Select-Object * -ExcludeProperty TemplateId
                } else {
                    $RoleMappings = $Request.Body.RoleMappings
                }
                Write-Information ($RoleMappings | ConvertTo-Json)
                Add-CIPPGDAPRoleTemplate -TemplateId $RowKey -RoleMappings $RoleMappings
                Write-LogMessage -headers $Headers -API $APIName -message "Added role mappings to GDAP template '$RowKey'" -Sev 'Info'
                $Body = @{
                    Results = "Added role mappings to template $RowKey"
                }
            }
            'Edit' {
                # Use OriginalTemplateId if provided (for rename), otherwise use TemplateId
                $OriginalRowKey = $Request.Body.OriginalTemplateId ?? $Request.Body.TemplateId
                $NewRowKey = $Request.Body.TemplateId
                $Template = $Templates | Where-Object -Property RowKey -EQ $OriginalRowKey
                if ($Template) {
                    $RoleMappings = $Request.Body.RoleMappings
                    
                    # If the template ID is being changed, delete the old one and create a new one
                    if ($OriginalRowKey -ne $NewRowKey) {
                        Remove-AzDataTableEntity -Force @Table -Entity $Template
                        Add-CIPPGDAPRoleTemplate -TemplateId $NewRowKey -RoleMappings $RoleMappings -Overwrite
                        Write-LogMessage -headers $Headers -API $APIName -message "Renamed GDAP template from '$OriginalRowKey' to '$NewRowKey' and updated role mappings" -Sev 'Info'
                        $Body = @{
                            Results = "Renamed template from $OriginalRowKey to $NewRowKey and updated role mappings"
                        }
                    } else {
                        # Just update the existing template
                        Add-CIPPGDAPRoleTemplate -TemplateId $NewRowKey -RoleMappings $RoleMappings -Overwrite
                        Write-LogMessage -headers $Headers -API $APIName -message "Updated role mappings for GDAP template '$NewRowKey'" -Sev 'Info'
                        $Body = @{
                            Results = "Updated role mappings for template $NewRowKey"
                        }
                    }
                } else {
                    Write-LogMessage -headers $Headers -API $APIName -message "GDAP role template '$OriginalRowKey' not found for editing" -Sev 'Warning'
                    $Body = @{
                        Results = "Template $OriginalRowKey not found"
                    }
                }
            }
            'Delete' {
                $RowKey = $Request.Body.TemplateId
                $Template = $Templates | Where-Object -Property RowKey -EQ $RowKey
                if ($Template) {
                    Remove-AzDataTableEntity -Force @Table -Entity $Template
                    Write-LogMessage -headers $Headers -API $APIName -message "Deleted GDAP role template '$RowKey'" -Sev 'Info'
                    $Body = @{
                        Results = "Deleted template $RowKey"
                    }
                } else {
                    Write-LogMessage -headers $Headers -API $APIName -message "GDAP role template '$RowKey' not found for deletion" -Sev 'Warning'
                    $Body = @{
                        Results = "Template $RowKey not found"
                    }
                }
            }
            default {
                Write-LogMessage -headers $Headers -API $APIName -message "Retrieved $($Templates.Count) GDAP role templates" -Sev 'Info'
                $Results = foreach ($Template in $Templates) {
                    [PSCustomObject]@{
                        TemplateId   = $Template.RowKey
                        RoleMappings = @($Template.RoleMappings | ConvertFrom-Json)
                    }
                }
                $Body = @{
                    Results  = @($Results)
                    Metadata = @{
                        Count = $Results.Count
                    }
                }
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ExecGDAPRoleTemplate.ps1' 117
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPAccessAssignments.ps1' -1

function Invoke-ListGDAPAccessAssignments {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Id = $Request.Query.Id
    $TenantFilter = $env:TenantID

    Write-Information "Getting access assignments for $Id"

    $AccessAssignments = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$Id/accessAssignments" -tenantid $TenantFilter

    # get groups asapp
    $Groups = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/groups?`$top=999&`$select=id,displayName&`$filter=securityEnabled eq true" -tenantid $TenantFilter -asApp $true -NoAuthCheck $true


    # Get all the access containers
    $AccessContainers = $AccessAssignments.accessContainer.accessContainerId
    Write-Information "Getting access containers for $($AccessContainers -join ',')"

    $ContainerMembers = foreach ($AccessContainer in $AccessContainers) {
        @{
            'id'     = $AccessContainer
            'url'    = "groups/$AccessContainer/members?`$select=id,displayName,userPrincipalName,isAssignableToRole&`$top=999"
            'method' = 'GET'
        }
    }
    $Members = New-GraphBulkRequest -Requests @($ContainerMembers) -tenantid $TenantFilter -asApp $true -NoAuthCheck $true

    $Results = foreach ($AccessAssignment in $AccessAssignments) {
        [PSCustomObject]@{
            'id'               = $AccessAssignment.id
            'status'           = $AccessAssignment.status
            'createdDateTime'  = $AccessAssignment.createdDateTime
            'modifiedDateTime' = $AccessAssignment.modifiedDateTime
            'roles'            = $AccessAssignment.accessDetails.unifiedRoles
            'group'            = $Groups | Where-Object id -EQ $AccessAssignment.accessContainer.accessContainerId
            'members'          = ($Members | Where-Object id -EQ $AccessAssignment.accessContainer.accessContainerId).body.value
        }
    }
    if (!$Results) {
        $Results = @()
    } else {
        $Results = $Results | Sort-Object -Property @{Expression = { $_.group.displayName }; Ascending = $true }
    }

    $Body = @{
        Results = @($Results)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPAccessAssignments.ps1' 58
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPInvite.ps1' -1

Function Invoke-ListGDAPInvite {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $RelationshipId = $Request.Query.RelationshipId

    $Table = Get-CIPPTable -TableName 'GDAPInvites'
    if (![string]::IsNullOrEmpty($RelationshipId)) {
        $Invite = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($RelationshipId)'"
    } else {
        $Invite = Get-CIPPAzDataTableEntity @Table | ForEach-Object {
            $_.RoleMappings = @(try { $_.RoleMappings | ConvertFrom-Json } catch { $_.RoleMappings })
            $_
        }
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Invite)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPInvite.ps1' 27
#Region './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPRoles.ps1' -1

Function Invoke-ListGDAPRoles {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.Relationship.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable -TableName 'GDAPRoles'
    $Groups = Get-CIPPAzDataTableEntity @Table

    $MappedGroups = foreach ($Group in $Groups) {
        [PSCustomObject]@{
            GroupName        = $Group.GroupName
            GroupId          = $Group.GroupId
            RoleName         = $Group.RoleName
            roleDefinitionId = $Group.roleDefinitionId
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($MappedGroups)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/GDAP/Invoke-ListGDAPRoles.ps1' 28
#Region './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListLicenses.ps1' -1

Function Invoke-ListLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $RawGraphRequest = if ($TenantFilter -ne 'AllTenants') {
        $GraphRequest = Get-CIPPLicenseOverview -TenantFilter $TenantFilter | ForEach-Object {
            $TermInfo = $_.TermInfo | ConvertFrom-Json -ErrorAction SilentlyContinue
            $_.TermInfo = $TermInfo
            $_
        }
    } else {
        $Table = Get-CIPPTable -TableName cachelicenses
        $Rows = Get-CIPPAzDataTableEntity @Table | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-1)
        if (!$Rows) {
            $GraphRequest = [PSCustomObject]@{
                Tenant  = 'Loading data for all tenants. Please check back in 1 minute'
                License = 'Loading data for all tenants. Please check back in 1 minute'
            }
            $Tenants = Get-Tenants -IncludeErrors

            if (($Tenants | Measure-Object).Count -gt 0) {
                $Queue = New-CippQueueEntry -Name 'Licenses (All Tenants)' -TotalTasks ($Tenants | Measure-Object).Count
                $Tenants = $Tenants | Select-Object customerId, defaultDomainName, @{Name = 'QueueId'; Expression = { $Queue.RowKey } }, @{Name = 'FunctionName'; Expression = { 'ListLicensesQueue' } }, @{Name = 'QueueName'; Expression = { $_.defaultDomainName } }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'ListLicensesOrchestrator'
                    Batch            = @($Tenants)
                    SkipLog          = $true
                }
                #Write-Host ($InputObject | ConvertTo-Json)
                $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                Write-Host "Started permissions orchestration with ID = '$InstanceId'"
            }
        } else {
            $GraphRequest = $Rows | Where-Object { $_.License } | ForEach-Object {
                if ($_.TermInfo) {
                    $TermInfo = $_.TermInfo | ConvertFrom-Json -ErrorAction SilentlyContinue
                    $_.TermInfo = $TermInfo
                } else {
                    $_ | Add-Member -NotePropertyName TermInfo -NotePropertyValue $null
                }
                $_
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListLicenses.ps1' 59
#Region './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListOAuthApps.ps1' -1

Function Invoke-ListOAuthApps {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    if ($TenantFilter -eq 'AllTenants') { $Tenants = (Get-Tenants).defaultDomainName } else { $Tenants = $TenantFilter }

    try {
        $GraphRequest = foreach ($Tenant in $Tenants) {
            try {
                $ServicePrincipals = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals?`$select=id,displayName,appid" -tenantid $Tenant
                New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/oauth2PermissionGrants' -tenantid $Tenant | ForEach-Object {
                    $CurrentServicePrincipal = ($ServicePrincipals | Where-Object -Property id -EQ $_.clientId)
                    [PSCustomObject]@{
                        Tenant        = $Tenant
                        Name          = $CurrentServicePrincipal.displayName
                        ApplicationID = $CurrentServicePrincipal.appid
                        ObjectID      = $_.clientId
                        Scope         = ($_.scope -join ',')
                        StartTime     = $_.startTime
                    }
                }
                $StatusCode = [HttpStatusCode]::OK
            } catch {
                continue
            }
        }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListOAuthApps.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListServiceHealth.ps1' -1

Function Invoke-ListServiceHealth {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Administration.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    if ($TenantFilter -eq 'AllTenants') {
        $ResultHealthSummary = Get-Tenants | ForEach-Object -Parallel {
            Import-Module '.\Modules\AzBobbyTables'
            Import-Module '.\Modules\CIPPCore'
            $TenantName = $_.displayName
            Write-Host "Processed Service Health for $TenantName via AllTenants"
            $prop = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/admin/serviceAnnouncement/issues?`$filter=endDateTime eq null" -tenantid $_.defaultDomainName
            $prop | Add-Member -NotePropertyName 'tenant' -NotePropertyValue $TenantName
            $prop | Add-Member -NotePropertyName 'defaultDomainName' -NotePropertyValue $_.defaultDomainName
            $prop
        }
    } else {
        $TenantName = $Request.Query.displayName
        $DefaultDomainName = $Request.Query.defaultDomainName
        $ResultHealthSummary = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/admin/serviceAnnouncement/issues?`$filter=endDateTime eq null" -tenantid $TenantFilter
        $ResultHealthSummary | Add-Member -NotePropertyName 'tenant' -NotePropertyValue $TenantName
        $ResultHealthSummary | Add-Member -NotePropertyName 'defaultDomainName' -NotePropertyValue $DefaultDomainName
        Write-Host "Processed Service Health for $TenantName"
    }
    $Results = foreach ($h in $ResultHealthSummary) {
        [PSCustomObject]@{
            TenantName        = $h.tenant
            DefaultDomainName = $h.defaultDomainName
            issueId           = $h.ID
            service           = $h.service
            type              = $h.feature
            desc              = $h.impactDescription
        }
    }

    $StatusCode = [HttpStatusCode]::OK

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Reports/Invoke-ListServiceHealth.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-AddStandardsDeploy.ps1' -1

Function Invoke-AddStandardsDeploy {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $user = $request.headers.'x-ms-client-principal'
    $username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails

    try {
        $Tenant = $Request.body.tenant
        $Settings = ($request.body | Select-Object -Property * -ExcludeProperty Select_*, None )
        $Settings | Add-Member -NotePropertyName 'v2.1' -NotePropertyValue $true -Force
        if ($Settings.phishProtection.remediate) {
            $URL = $request.headers.'x-ms-original-url'.split('/api') | Select-Object -First 1
            Write-Host $URL
            $Settings.phishProtection = [pscustomobject]@{
                remediate = [bool]$Settings.phishProtection.remediate
                URL       = $URL
            }
        }
        #Get all subobjects in $Settings that are set to false, and remove them.
        $Settings.psobject.properties.name | Where-Object { $Settings.$_ -eq $false -and $_ -ne 'v2.1' -and $_ -in 'Alert', 'Remediate', 'Report' } | ForEach-Object {
            $Settings.psobject.properties.remove($_)
        }

        $object = [PSCustomObject]@{
            Tenant    = $Tenant
            AddedBy   = $username
            AppliedAt = (Get-Date).ToString('s')
            Standards = $Settings
            v2        = $true
        } | ConvertTo-Json -Depth 10

        $Table = Get-CippTable -tablename 'standards'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$object"
            RowKey       = "$Tenant"
            PartitionKey = 'standards'
        }
        Write-LogMessage -headers $Request.Headers -tenant $tenant -API 'Standards' -message 'Successfully added standards deployment' -Sev 'Info'

        $body = [pscustomobject]@{'Results' = 'Successfully added standards deployment' }
    } catch {
        Write-LogMessage -headers $Request.Headers -API 'Standards' -message "Standards API failed. Error:$($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Failed to add standard: $($_.Exception.Message)" }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-AddStandardsDeploy.ps1' 60
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-AddStandardsTemplate.ps1' -1

function Invoke-AddStandardsTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers
    if ($Request.Body.tenantFilter -eq 'tenantFilter') {
        throw 'Invalid Tenant Selection. A standard must be assigned to at least 1 tenant.'
    }

    $GUID = $Request.body.GUID ? $request.body.GUID : (New-Guid).GUID
    #updatedBy    = $request.headers.'x-ms-client-principal'
    #updatedAt    = (Get-Date).ToUniversalTime()
    $request.body | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID -Force
    $request.body | Add-Member -NotePropertyName 'createdAt' -NotePropertyValue ($Request.body.createdAt ? $Request.body.createdAt : (Get-Date).ToUniversalTime()) -Force
    $Request.body | Add-Member -NotePropertyName 'updatedBy' -NotePropertyValue ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($request.headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails -Force
    $Request.body | Add-Member -NotePropertyName 'updatedAt' -NotePropertyValue (Get-Date).ToUniversalTime() -Force
    $JSON = (ConvertTo-Json -Compress -Depth 100 -InputObject ($Request.body))
    $Table = Get-CippTable -tablename 'templates'
    $Table.Force = $true
    Add-CIPPAzDataTableEntity @Table -Entity @{
        JSON         = "$JSON"
        RowKey       = "$GUID"
        PartitionKey = 'StandardsTemplateV2'
        GUID         = "$GUID"
    }

    $AddObject = @{
        PartitionKey = 'InstanceProperties'
        RowKey       = 'CIPPURL'
        Value        = [string]([System.Uri]$Headers.'x-ms-original-url').Host
    }
    $ConfigTable = Get-CIPPTable -tablename 'Config'
    Add-AzDataTableEntity @ConfigTable -Entity $AddObject -Force

    Write-LogMessage -headers $Request.Headers -API $APINAME -message "Standards Template $($Request.body.templateName) with GUID $GUID added/edited." -Sev 'Info'
    $body = [pscustomobject]@{'Results' = 'Successfully added template'; Metadata = @{id = $GUID } }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-AddStandardsTemplate.ps1' 51
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-BestPracticeAnalyser_List.ps1' -1

Function Invoke-BestPracticeAnalyser_List {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.BestPracticeAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Tenants = Get-Tenants
    $Table = get-cipptable 'cachebpa'
    $Results = (Get-CIPPAzDataTableEntity @Table) | ForEach-Object {
        $_.UnusedLicenseList = @(ConvertFrom-Json -ErrorAction silentlycontinue -InputObject $_.UnusedLicenseList)
        $_
    }

    if (!$Results) {
        $Results = @{
            Tenant = 'The BPA has not yet run.'
        }
    }
    Write-Host ($Tenants | ConvertTo-Json)
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @(($Results | Where-Object -Property RowKey -In $Tenants.customerId))
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-BestPracticeAnalyser_List.ps1' 29
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-CIPPStandardsRun.ps1' -1


function Invoke-CIPPStandardsRun {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$TenantFilter = 'allTenants',
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        [Parameter(Mandatory = $false)]
        $TemplateID,
        [Parameter(Mandatory = $false)]
        $runManually = $false,
        [Parameter(Mandatory = $false)]
        [switch]$Drift
    )
    Write-Information "Starting process for standards - $($tenantFilter). TemplateID: $($TemplateID) RunManually: $($runManually) Force: $($Force.IsPresent) Drift: $($Drift.IsPresent)"

    if ($Drift.IsPresent) {
        Write-Information 'Drift Standards Run'
        $AllTasks = Get-CIPPTenantAlignment | Where-Object -Property standardtype -EQ 'drift' | Select-Object -Property TenantFilter | Sort-Object -Unique -Property TenantFilter

        #For each item in our object, run the queue.
        $Queue = New-CippQueueEntry -Name 'Drift Standards' -TotalTasks ($AllTasks | Measure-Object).Count

        $Batch = foreach ($Task in $AllTasks) {
            [PSCustomObject]@{
                FunctionName = 'CIPPDriftManagement'
                Tenant       = $Task.TenantFilter
            }
        }

        $InputObject = [PSCustomObject]@{
            OrchestratorName = 'DriftStandardsOrchestrator'
            Batch            = @($Batch)
            SkipLog          = $true
        }

        $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
        Write-Information "Started orchestration with ID = '$InstanceId' for drift standards run"
        #$Orchestrator = New-OrchestrationCheckStatusResponse -Request $Request -InstanceId $InstanceId
        return
    } else {
        Write-Information 'Classic Standards Run'

        $GetStandardParams = @{
            TenantFilter = $TenantFilter
            runManually  = $runManually
        }

        if ($TemplateID) {
            $GetStandardParams['TemplateId'] = $TemplateID
        }

        $AllTasks = Get-CIPPStandards @GetStandardParams

        if ($Force.IsPresent) {
            Write-Information 'Clearing Rerun Cache'
            Test-CIPPRerun -ClearAll -TenantFilter $TenantFilter -Type 'Standard'
        }

        if ($AllTasks.Count -eq 0) {
            Write-Information "No standards found for tenant $($TenantFilter)."
            return
        }

        #For each item in our object, run the queue.
        $Queue = New-CippQueueEntry -Name "Applying Standards ($TenantFilter)" -TotalTasks ($AllTasks | Measure-Object).Count

        $InputObject = [PSCustomObject]@{
            OrchestratorName = 'StandardsOrchestrator'
            QueueFunction    = @{
                FunctionName   = 'GetStandards'
                QueueId        = $Queue.RowKey
                StandardParams = @{
                    TenantFilter = $TenantFilter
                    runManually  = $runManually
                }
            }
            SkipLog          = $true
        }
        if ($TemplateID) {
            $InputObject.QueueFunction.StandardParams['TemplateId'] = $TemplateID
        }
        Write-Information "InputObject: $($InputObject | ConvertTo-Json -Depth 5 -Compress)"
        $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
        Write-Information "Started orchestration with ID = '$InstanceId'"
        #$Orchestrator = New-OrchestrationCheckStatusResponse -Request $Request -InstanceId $InstanceId
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-CIPPStandardsRun.ps1' 96
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/invoke-DomainAnalyser_List.ps1' -1


#using namespace System.Net

Function Invoke-DomainAnalyser_List {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.DomainAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $DomainTable = Get-CIPPTable -Table 'Domains'

    # Get all the things

    if ($Request.Query.tenantFilter -ne 'AllTenants') {
        $DomainTable.Filter = "TenantId eq '{0}'" -f $Request.Query.tenantFilter
    }

    try {
        # Extract json from table results
        $Results = foreach ($DomainAnalyserResult in (Get-CIPPAzDataTableEntity @DomainTable).DomainAnalyser) {
            try {
                if (![string]::IsNullOrEmpty($DomainAnalyserResult)) {
                    $Object = $DomainAnalyserResult | ConvertFrom-Json -ErrorAction SilentlyContinue
                    $Object
                }
            } catch {}
        }
    } catch {
        $Results = @()
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Results)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/invoke-DomainAnalyser_List.ps1' 41
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecBPA.ps1' -1

function Invoke-ExecBPA {
    <#
        .FUNCTIONALITY
        Entrypoint,AnyTenant
        .ROLE
        Tenant.BestPracticeAnalyser.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $ConfigTable = Get-CIPPTable -tablename Config
    $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"

    $TenantFilter = $Request.Query.tenantFilter ? $Request.Query.tenantFilter.value : $Request.Body.tenantfilter.value

    if ($Config -and $Config.state -eq $true) {
        if ($env:CIPP_PROCESSOR -ne 'true') {
            $Parameters = @{Force = $true }
            if ($TenantFilter -and $TenantFilter -ne 'AllTenants') {
                $Parameters.TenantFilter = $TenantFilter
                $RowKey = "Start-BPAOrchestrator-$($TenantFilter)"
            } else {
                $RowKey = 'Start-BPAOrchestrator'
            }

            $ProcessorQueue = Get-CIPPTable -TableName 'ProcessorQueue'
            $ProcessorFunction = [PSCustomObject]@{
                PartitionKey = 'Function'
                RowKey       = $RowKey
                FunctionName = 'Start-BPAOrchestrator'
                Parameters   = [string](ConvertTo-Json -Compress -InputObject $Parameters)
            }
            Add-AzDataTableEntity @ProcessorQueue -Entity $ProcessorFunction -Force
            $Results = [pscustomobject]@{'Results' = 'BPA queued for execution' }
        }
    } else {
        Start-BPAOrchestrator -TenantFilter $TenantFilter
        $Results = [pscustomobject]@{'Results' = 'BPA started' }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecBPA.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecDomainAnalyser.ps1' -1

function Invoke-ExecDomainAnalyser {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.DomainAnalyser.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $ConfigTable = Get-CIPPTable -tablename Config
    $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"

    if ($Config -and $Config.state -eq $true) {
        if ($env:CIPP_PROCESSOR -ne 'true') {
            $ProcessorFunction = [PSCustomObject]@{
                PartitionKey = 'Function'
                RowKey       = 'Start-DomainOrchestrator'
                FunctionName = 'Start-DomainOrchestrator'
            }
            $ProcessorQueue = Get-CIPPTable -TableName 'ProcessorQueue'
            Add-AzDataTableEntity @ProcessorQueue -Entity $ProcessorFunction -Force
            $Results = [pscustomobject]@{'Results' = 'Queueing Domain Analyser' }
        }
    } else {
        $OrchStatus = Start-DomainOrchestrator
        if ($OrchStatus) {
            $Message = 'Domain Analyser started'
        } else {
            $Message = 'Domain Analyser error: check logs'
        }
        $Results = [pscustomobject]@{'Results' = $Message }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecDomainAnalyser.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecDriftClone.ps1' -1

function Invoke-ExecDriftClone {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    try {
        $TemplateId = $Request.Body.id

        if (-not $TemplateId) {
            $Results = [pscustomobject]@{
                'Results' = 'Template ID is required'
                'Success' = $false
            }
            return ([HttpResponseContext]@{
                    StatusCode = [HttpStatusCode]::BadRequest
                    Body       = $Results
                })
            return
        }
        $CloneResult = New-CippStandardsDriftClone -TemplateId $TemplateId -UpgradeToDrift -Headers $Request.Headers
        $Results = [pscustomobject]@{
            'Results' = $CloneResult
            'Success' = $true
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Results
            })
    } catch {
        $Results = [pscustomobject]@{
            'Results' = "Failed to create drift clone: $($_.Exception.Message)"
            'Success' = $false
        }
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = $Results
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecDriftClone.ps1' 46
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecStandardConvert.ps1' -1

function Invoke-ExecStandardConvert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    function Convert-SingleStandardItem {
        param(
            [Parameter(Mandatory)]
            $OldStd
        )

        $Actions = New-Object System.Collections.ArrayList
        $RemediatePresent = ($OldStd.PSObject.Properties.Name -contains 'remediate')
        $AlertPresent = ($OldStd.PSObject.Properties.Name -contains 'alert')
        $ReportPresent = ($OldStd.PSObject.Properties.Name -contains 'report')

        $RemediateTrue = $RemediatePresent -and $OldStd.remediate -eq $true
        $AlertTrue = $AlertPresent -and $OldStd.alert -eq $true
        $ReportTrue = $ReportPresent -and $OldStd.report -eq $true

        if (-not ($RemediateTrue -or $AlertTrue -or $ReportTrue)) {
            return $null
        }

        if ($RemediateTrue) {
            [void]$Actions.Add([pscustomobject]@{label = 'Remediate'; value = 'Remediate' })
        }
        if ($AlertTrue) {
            [void]$Actions.Add([pscustomobject]@{label = 'Alert'; value = 'warn' })
        }
        if ($ReportTrue) {
            [void]$Actions.Add([pscustomobject]@{label = 'Report'; value = 'Report' })
        }

        $propsToCopy = $OldStd | Select-Object * -ExcludeProperty alert, report, remediate
        $Result = [ordered]@{}
        if ($Actions.Count -gt 0) {
            $ActionArray = $Actions | ForEach-Object { $_ }
            $Result.action = @($ActionArray)
        }

        foreach ($prop in $propsToCopy.PSObject.Properties) {
            if ($prop.Name -ne 'PSObject') {
                $Result.$($prop.Name) = $prop.Value
            }
        }

        return $Result
    }

    function Convert-OldStandardToNewFormat {
        param(
            [Parameter(Mandatory = $true)]
            $OldStandard,
            [Parameter(Mandatory = $false)]
            $AllTenantsExclusions = @()
        )

        $Tenant = $OldStandard.Tenant
        if ($Tenant -eq 'AllTenants') {
            $TenantFilter = @(
                [pscustomobject]@{
                    label       = '*All Tenants (AllTenants)'
                    value       = 'AllTenants'
                    addedFields = [pscustomobject]@{}
                }
            )
            if ($AllTenantsExclusions.Count -gt 0) {
                $Excluded = $AllTenantsExclusions | ForEach-Object {
                    [pscustomobject]@{
                        label       = "$_ ($_)"
                        value       = $_
                        addedFields = [pscustomobject]@{}
                    }
                }
            } else {
                $Excluded = $null
            }
        } else {
            $TenantFilter = @(
                [pscustomobject]@{
                    label       = "$Tenant ($Tenant)"
                    value       = $Tenant
                    addedFields = [pscustomobject]@{}
                }
            )
            $Excluded = $null
        }

        $NewStandards = [ordered]@{}

        foreach ($StdKey in $OldStandard.Standards.PSObject.Properties.Name) {
            if ($StdKey -in ('tenant', 'OverrideAllTenants', 'v2', 'v2.1')) {
                continue
            }

            $OldStd = $OldStandard.Standards.$StdKey
            $NewStdKey = if ($StdKey -eq 'ConditionalAccess') {
                Write-Host 'Converting ConditionalAccess to ConditionalAccessTemplate'
                'ConditionalAccessTemplate'
            } else { $StdKey }
            $IsArrayStandard = ($NewStdKey -eq 'IntuneTemplate' -or $NewStdKey -eq 'ConditionalAccessTemplate')
            $ConvertedObj = Convert-SingleStandardItem $OldStd
            if ($null -eq $ConvertedObj) {
                continue
            }

            if ($IsArrayStandard) {
                $FinalArray = New-Object System.Collections.ArrayList
                $TemplateList = $ConvertedObj.TemplateList
                $ConvertedObj.PSObject.Properties.Remove('TemplateList')

                if ($TemplateList -and $TemplateList.Count -gt 0) {
                    foreach ($TItem in $TemplateList) {
                        $NewItem = [ordered]@{}
                        if ($ConvertedObj.action) {
                            $NewItem.action = $ConvertedObj.action
                        }
                        foreach ($prop in $ConvertedObj.PSObject.Properties.Name) {
                            if ($prop -ne 'action') {
                                $NewItem.$prop = $ConvertedObj.$prop
                            }
                        }
                        $NewItem.TemplateList = $TItem
                        [void]$FinalArray.Add($NewItem)
                    }
                }

                if ($FinalArray.Count -gt 0) {
                    $ArrayItems = $FinalArray | ForEach-Object { $_ }
                    $NewStandards.$NewStdKey = $ArrayItems
                }
            } else {
                $Action = $ConvertedObj.action
                if ($Action) {
                    $ConvertedObj.PSObject.Properties.Remove('action')
                }
                $Wrap = [ordered]@{}
                if ($Action) {
                    $Wrap.action = $Action
                }
                $Wrap.standards = [ordered]@{}
                $Wrap.standards.$NewStdKey = $ConvertedObj
                $NewStandards.$NewStdKey = $Wrap
            }

        }

        $NewTemplate = [pscustomobject]@{
            tenantFilter = $TenantFilter
            templateName = "Converted Legacy Template for $Tenant"
            standards    = $NewStandards
            runManually  = $true
        }

        if ($Tenant -eq 'AllTenants' -and $Excluded) {
            $ExcludedArr = $Excluded | ForEach-Object { $_ }
            $NewTemplate | Add-Member -NotePropertyName 'excludedTenants' -NotePropertyValue @($ExcludedArr) -Force
        }

        return $NewTemplate
    }

    $Table = Get-CippTable -tablename 'standards'
    $Filter = "PartitionKey eq 'standards'"
    $OldStandards = (Get-CIPPAzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json

    $AllTenantsStd = $OldStandards | Where-Object { $_.Tenant -eq 'AllTenants' }
    $HasAllTenants = $null -ne $AllTenantsStd

    $AllTenantsExclusions = New-Object System.Collections.ArrayList
    $StandardsToConvert = New-Object System.Collections.ArrayList

    foreach ($OldStd in $OldStandards) {
        $Tenant = $OldStd.Tenant
        $StdNames = $OldStd.Standards.PSObject.Properties.Name | Where-Object { $_ -notin ('tenant', 'OverrideAllTenants', 'v2', 'v2.1') }
        $HasOverride = ($OldStd.Standards.PSObject.Properties.Name -contains 'OverrideAllTenants')

        if ($Tenant -ne 'AllTenants') {
            if ($HasOverride -and $StdNames.Count -eq 0) {
                [void]$AllTenantsExclusions.Add($Tenant)
                continue
            }

            if ($HasOverride -and $StdNames.Count -gt 0 -and $HasAllTenants) {
                [void]$AllTenantsExclusions.Add($Tenant)
            }
        }

        [void]$StandardsToConvert.Add($OldStd)
    }

    foreach ($OldStd in $StandardsToConvert) {
        $Converted = Convert-OldStandardToNewFormat $OldStd ($AllTenantsExclusions)
        $GUID = [guid]::NewGuid()
        $Converted | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $GUID -Force
        $Converted | Add-Member -NotePropertyName 'createdAt' -NotePropertyValue ((Get-Date).ToUniversalTime()) -Force
        $Converted | Add-Member -NotePropertyName 'updatedBy' -NotePropertyValue 'System' -Force
        $Converted | Add-Member -NotePropertyName 'updatedAt' -NotePropertyValue (Get-Date).ToUniversalTime() -Force
        $JSON = ConvertTo-Json -Depth 100 -InputObject $Converted -Compress

        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        if ($Converted.standards) {
            Add-CIPPAzDataTableEntity @Table -Entity @{
                JSON         = "$JSON"
                RowKey       = "$GUID"
                PartitionKey = 'StandardsTemplateV2'
                GUID         = "$GUID"
            }
        }
    }

    #delete the old standards
    if ($StandardsToConvert.Count -gt 0) {
        $StandardsToConvert | ForEach-Object {
            $Table = Get-CippTable -tablename 'standards'
            $OldStdsTableItems = Get-CIPPAzDataTableEntity @Table -Filter $Filter
            try {
                Remove-AzDataTableEntity @Table -Entity $OldStdsTableItems -Force
            } catch {
                #donothing
            }
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = 'Successfully converted legacy standards to new format'
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecStandardConvert.ps1' 237
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecStandardsRun.ps1' -1

function Invoke-ExecStandardsRun {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers



    $TenantFilter = $Request.Query.tenantFilter ?? 'allTenants'
    $TemplateId = $Request.Query.templateId ?? '*'
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'StandardsTemplateV2'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter | Sort-Object TimeStamp).JSON | ForEach-Object {
        try {
            ConvertFrom-Json $_ -ErrorAction SilentlyContinue
        } catch {

        }
    } | Where-Object {
        $_.guid -like $TemplateId
    }



    $ConfigTable = Get-CIPPTable -tablename Config
    $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"

    if ($Config -and $Config.state -eq $true) {
        if ($env:CIPP_PROCESSOR -ne 'true') {

            $ProcessorFunction = [PSCustomObject]@{
                PartitionKey = 'Function'
                RowKey       = "Invoke-CIPPStandardsRun-$TenantFilter-$TemplateId"
                FunctionName = 'Invoke-CIPPStandardsRun'
                Parameters   = [string](ConvertTo-Json -Compress -InputObject @{
                        TenantFilter = $TenantFilter
                        TemplateId   = $TemplateId
                        runManually  = [bool]$Templates.runManually
                        Force        = $true
                    })
            }
            $ProcessorQueue = Get-CIPPTable -TableName 'ProcessorQueue'
            Add-AzDataTableEntity @ProcessorQueue -Entity $ProcessorFunction -Force
            $Results = "Successfully Queued Standards Run for Tenant $TenantFilter"
        }
    } else {
        try {
            $null = Invoke-CIPPStandardsRun -TenantFilter $TenantFilter -TemplateID $TemplateId -runManually ([bool]$Templates.runManually) -Force
            $Results = "Successfully started Standards Run for tenant: $TenantFilter"
            Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Results -Sev 'Info'
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Results = "Failed to start standards run for tenant: $TenantFilter. Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Results -Sev 'Error' -LogData $ErrorMessage
        }
    }

    $Results = [pscustomobject]@{'Results' = "$Results" }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecStandardsRun.ps1' 72
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecUpdateDriftDeviation.ps1' -1

function Invoke-ExecUpdateDriftDeviation {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $TriggerMetadata.FunctionName
    Write-LogMessage -user $request.headers.'x-ms-client-principal' -API $APINAME -message 'Accessed this API' -Sev 'Debug'

    try {
        $TenantFilter = $Request.Body.TenantFilter

        if ($Request.Body.RemoveDriftCustomization) {
            $Table = Get-CippTable -tablename 'tenantDrift'
            $Filter = "PartitionKey eq '$TenantFilter'"
            $ExistingDeviations = Get-CIPPAzDataTableEntity @Table -Filter $Filter
            foreach ($Deviation in $ExistingDeviations) {
                Remove-AzDataTableEntity @Table -Entity $Deviation
            }
            $Results = @([PSCustomObject]@{
                    success = $true
                    result  = "All drift customizations removed for tenant $TenantFilter"
                })
            Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Removed all drift customizations for tenant $TenantFilter" -Sev 'Info'
        } else {
            $Deviations = $Request.Body.deviations
            $Reason = $Request.Body.reason
            $Results = foreach ($Deviation in $Deviations) {
                try {
                    $user = $request.headers.'x-ms-client-principal'
                    $username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails
                    $Result = Set-CIPPDriftDeviation -TenantFilter $TenantFilter -StandardName $Deviation.standardName -Status $Deviation.status -Reason $Reason -user $username
                    [PSCustomObject]@{
                        success = $true
                        result  = $Result
                    }
                    Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Updated drift deviation status for $($Deviation.standardName) to $($Deviation.status) with reason: $Reason" -Sev 'Info'
                    if ($Deviation.status -eq 'DeniedRemediate') {
                        $Setting = $Deviation.standardName -replace 'standards.', ''
                        $StandardTemplate = Get-CIPPTenantAlignment -TenantFilter $TenantFilter | Where-Object -Property standardType -EQ 'drift'
                        if ($Setting -like '*IntuneTemplate*') {
                            $Setting = 'IntuneTemplate'
                            $TemplateId = $Deviation.standardName.split('.') | Select-Object -Index 2
                            $StandardTemplate = $StandardTemplate.standardSettings.IntuneTemplate | Where-Object { $_.TemplateList.value -like "*$TemplateId*" }
                            $StandardTemplate | Add-Member -MemberType NoteProperty -Name 'remediate' -Value $true -Force
                            $StandardTemplate | Add-Member -MemberType NoteProperty -Name 'report' -Value $true -Force
                            $Settings = $StandardTemplate
                        } elseif ($Setting -like '*ConditionalAccessTemplate*') {
                            $Setting = 'ConditionalAccessTemplate'
                            $TemplateId = $Deviation.standardName.split('.') | Select-Object -Index 2
                            $StandardTemplate = $StandardTemplate.standardSettings.ConditionalAccessTemplate | Where-Object { $_.TemplateList.value -like "*$TemplateId*" }
                            $StandardTemplate | Add-Member -MemberType NoteProperty -Name 'remediate' -Value $true -Force
                            $StandardTemplate | Add-Member -MemberType NoteProperty -Name 'report' -Value $true -Force
                            $Settings = $StandardTemplate
                        } else {
                            $StandardTemplate = $StandardTemplate.standardSettings.$Setting
                            $StandardTemplate.standards.$Setting | Add-Member -MemberType NoteProperty -Name 'remediate' -Value $true -Force
                            $StandardTemplate.standards.$Setting | Add-Member -MemberType NoteProperty -Name 'report' -Value $true -Force
                            $Settings = $StandardTemplate.standards.$Setting
                        }
                        $TaskBody = @{
                            TenantFilter  = $TenantFilter
                            Name          = "One Off Drift Remediation: $Setting - $TenantFilter"
                            Command       = @{
                                value = "Invoke-CIPPStandard$Setting"
                                label = "Invoke-CIPPStandard$Setting"
                            }

                            Parameters    = [pscustomobject]@{
                                Tenant   = $TenantFilter
                                Settings = $Settings
                            }
                            ScheduledTime = '0'
                            PostExecution = @{
                                Webhook = $false
                                Email   = $false
                                PSA     = $false
                            }
                        }
                        Add-CIPPScheduledTask -Task $TaskBody -hidden $false
                        Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Scheduled drift remediation task for $Setting" -Sev 'Info'
                    }
                    if ($Deviation.status -eq 'deniedDelete') {
                        $Policy = $Deviation.receivedValue | ConvertFrom-Json -ErrorAction SilentlyContinue
                        Write-Host "Policy is $($Policy)"
                        if ($Deviation.standardName -like '*ConditionalAccessTemplates*') {
                            $URLName = 'identity/conditionalAccess/policies'
                        } else {
                            $URLName = Get-CIPPURLName -Template $Policy
                        }
                        $ID = $Policy.ID
                        if ($Policy -and $URLName) {
                            Write-Host "Going to delete Policy with ID $($Policy.ID) Deviation Name is $($Deviation.standardName)"
                            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/$($URLName)/$($ID)" -type DELETE -tenant $TenantFilter
                            "Deleted Policy $($ID)"
                            Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Deleted Policy with ID $($ID)" -Sev 'Info'
                        } else {
                            "could not find policy with ID $($ID)"
                            Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Could not find Policy with ID $($ID) to delete for remediation" -Sev 'Warning'
                        }


                    }
                } catch {
                    [PSCustomObject]@{
                        standardName = $Deviation.standardName
                        success      = $false
                        error        = $_.Exception.Message
                    }
                    Write-LogMessage -tenant $TenantFilter -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Failed to update drift deviation for $($Deviation.standardName): $($_.Exception.Message)" -Sev 'Error'
                }
            }
        }

        $Body = @{ Results = @($Results) }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Body
            })

    } catch {
        Write-LogMessage -user $request.headers.'x-ms-client-principal' -API $APINAME -message "Failed to update drift deviation: $($_.Exception.Message)" -Sev 'Error'
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::BadRequest
                Body       = @{error = $_.Exception.Message }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ExecUpdateDriftDeviation.ps1' 134
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListBPA.ps1' -1

Function Invoke-ListBPA {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.BestPracticeAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $Table = Get-CippTable 'cachebpav2'
    $name = $Request.Query.Report
    if ($null -eq $name) { $name = 'CIPP Best Practices v1.5 - Table view' }

    # Get all possible JSON files for reports, find the correct one, select the Columns
    $JSONFields = @()
    $BPATemplateTable = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'BPATemplate'"
    $Templates = (Get-CIPPAzDataTableEntity @BPATemplateTable -Filter $Filter).JSON | ConvertFrom-Json

    $Templates | ForEach-Object {
        $Template = $_
        if ($Template.Name -eq $NAME) {
            $JSONFields = $Template.Fields | Where-Object { $_.StoreAs -eq 'JSON' } | ForEach-Object { $_.name }
            $Columns = $Template.fields.FrontendFields | Where-Object -Property name -NE $null
            $Style = $Template.Style
        }
    }


    if ($TenantFilter -ne 'AllTenants' -and $Style -eq 'Tenant') {
        $CustomerId = (Get-Tenants -TenantFilter $TenantFilter).customerId
        $mergedObject = New-Object pscustomobject
        $Data = (Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$CustomerId'") | ForEach-Object {
            $row = $_
            $JSONFields | ForEach-Object {
                $jsonContent = $row.$_
                if (![string]::IsNullOrEmpty($jsonContent) -and $jsonContent -ne 'FAILED') {
                    try {
                        $row.$_ = $jsonContent | ConvertFrom-Json -Depth 15
                    } catch {
                    }
                }
            }
            $row.PSObject.Properties | ForEach-Object {
                Write-Host "Adding $($_.Name) to mergedObject"
                $mergedObject | Add-Member -NotePropertyName $_.Name -NotePropertyValue $_.Value -Force
            }
        }

        $Data = $mergedObject
    } else {
        $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList
        $Tenants = Get-Tenants -IncludeErrors
        if ($AllowedTenants -notcontains 'AllTenants') {
            $Tenants = $Tenants | Where-Object -Property customerId -In $AllowedTenants
        }
        Write-Information ($tenants.defaultDomainName | ConvertTo-Json)
        $Data = (Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$NAME'") | ForEach-Object {
            $row = $_
            $JSONFields | ForEach-Object {
                $jsonContent = $row.$_
                if (![string]::IsNullOrEmpty($jsonContent) -and $jsonContent -ne 'FAILED') {
                    try {
                        $row.$_ = $jsonContent | ConvertFrom-Json -Depth 15
                    } catch {
                    }
                }
            }
            $row | Where-Object -Property PartitionKey -In $Tenants.customerId
        }


    }

    $Results = [PSCustomObject]@{
        Data    = @($Data)
        Columns = @($Columns)
        Keys    = $Data | ForEach-Object {
            $_.PSObject.Properties |
                Where-Object { $_.Name -ne 'PartitionKey' -and $_.Name -ne 'RowKey' -and $_.Name -ne 'Timestamp' } |
                ForEach-Object { $_.Name }
            } | Select-Object -Unique
        Style   = $Style
    }

    if (!$Results) {
        $Results = @{
            Columns = @( value = 'Results'; name = 'Results')
            Data    = @(@{ Results = 'The BPA has not yet run.' })
            Keys    = @()
        }
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = (ConvertTo-Json -Depth 15 -InputObject $Results)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListBPA.ps1' 102
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListBPATemplates.ps1' -1

Function Invoke-ListBPATemplates {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.BestPracticeAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'templates'

    $Templates = Get-ChildItem 'Config\*.BPATemplate.json' | ForEach-Object {
        $TemplateJson = Get-Content $_ | ConvertFrom-Json | ConvertTo-Json -Compress -Depth 10
        $Entity = @{
            JSON         = "$TemplateJson"
            RowKey       = "$($_.name)"
            PartitionKey = 'BPATemplate'
            GUID         = "$($_.name)"
        }
        Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
    }

    $Filter = "PartitionKey eq 'BPATemplate'"
    $Templates = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    if ($Request.Query.RawJson) {
        foreach ($Template in $Templates) {
            $Template.JSON = $Template.JSON -replace '"parameters":', '"Parameters":'
        }
        $Templates = $Templates.JSON | ConvertFrom-Json | Sort-Object Name
    } else {
        $Templates = $Templates | ForEach-Object {
            $TemplateJson = $_.JSON -replace '"parameters":', '"Parameters":'
            $Template = $TemplateJson | ConvertFrom-Json
            @{
                GUID  = $_.GUID
                Data  = $Template.fields
                Name  = $Template.Name
                Style = $Template.Style
            }
        } | Sort-Object Name
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = ($Templates | ConvertTo-Json -Depth 10)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListBPATemplates.ps1' 49
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListDomainAnalyser.ps1' -1


Function Invoke-ListDomainAnalyser {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.DomainAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    $Results = Get-CIPPDomainAnalyser -TenantFilter $TenantFilter

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Results)
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListDomainAnalyser.ps1' 21
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListDomainHealth.ps1' -1

function Invoke-ListDomainHealth {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        Tenant.DomainAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    Import-Module DNSHealth

    try {
        $ConfigTable = Get-CippTable -tablename Config
        $Filter = "PartitionKey eq 'Domains' and RowKey eq 'Domains'"
        $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter $Filter

        $ValidResolvers = @('Google', 'CloudFlare', 'Quad9')
        if ($ValidResolvers -contains $Config.Resolver) {
            $Resolver = $Config.Resolver
        } else {
            $Resolver = 'Google'
            $Config = @{
                PartitionKey = 'Domains'
                RowKey       = 'Domains'
                Resolver     = $Resolver
            }
            Add-CIPPAzDataTableEntity @ConfigTable -Entity $Config -Force
        }
    } catch {
        $Resolver = 'Google'
    }

    Set-DnsResolver -Resolver $Resolver

    $UserRoles = Get-CIPPAccessRole -Request $Request

    $APIName = $Request.Params.CIPPEndpoint


    $StatusCode = [HttpStatusCode]::OK
    try {
        if ($Request.Query.Action) {
            if ($Request.Query.Domain -match '^(((?!-))(xn--|_{1,1})?[a-z0-9-]{0,61}[a-z0-9]{1,1}\.)*(xn--)?([a-z0-9][a-z0-9\-]{0,60}|[a-z0-9-]{1,30}\.[a-z]{2,})$') {
                $DomainTable = Get-CIPPTable -Table 'Domains'
                $Filter = "RowKey eq '{0}'" -f $Request.Query.Domain
                $DomainInfo = Get-CIPPAzDataTableEntity @DomainTable -Filter $Filter
                switch ($Request.Query.Action) {
                    'ListDomainInfo' {
                        $Body = $DomainInfo
                    }
                    'GetDkimSelectors' {
                        $Body = ($DomainInfo.DkimSelectors | ConvertFrom-Json) -join ','
                    }
                    'ReadSpfRecord' {
                        $SpfQuery = @{
                            Domain = $Request.Query.Domain
                        }

                        if ($Request.Query.ExpectedInclude) {
                            $SpfQuery.ExpectedInclude = $Request.Query.ExpectedInclude
                        }

                        if ($Request.Query.Record) {
                            $SpfQuery.Record = $Request.Query.Record
                        }

                        $Body = Read-SpfRecord @SpfQuery
                    }
                    'ReadDmarcPolicy' {
                        $Body = Read-DmarcPolicy -Domain $Request.Query.Domain
                    }
                    'ReadDkimRecord' {
                        $DkimQuery = @{
                            Domain                       = $Request.Query.Domain
                            FallbackToMicrosoftSelectors = $true
                        }
                        if ($Request.Query.Selector) {
                            $DkimQuery.Selectors = ($Request.Query.Selector).trim() -split '\s*,\s*'

                            if ('admin' -in $UserRoles -or 'editor' -in $UserRoles) {
                                $DkimSelectors = [string]($DkimQuery.Selectors | ConvertTo-Json -Compress)
                                if ($DomainInfo) {
                                    $DomainInfo.DkimSelectors = $DkimSelectors
                                } else {
                                    $DomainInfo = @{
                                        'RowKey'         = $Request.Query.Domain
                                        'PartitionKey'   = 'ManualEntry'
                                        'TenantId'       = 'NoTenant'
                                        'MailProviders'  = ''
                                        'TenantDetails'  = ''
                                        'DomainAnalyser' = ''
                                        'DkimSelectors'  = $DkimSelectors
                                    }
                                }
                                Write-Host $DomainInfo
                                Add-CIPPAzDataTableEntity @DomainTable -Entity $DomainInfo -Force
                            }
                        } elseif (![string]::IsNullOrEmpty($DomainInfo.DkimSelectors)) {
                            $DkimQuery.Selectors = [System.Collections.Generic.List[string]]($DomainInfo.DkimSelectors | ConvertFrom-Json)
                        }
                        $Body = Read-DkimRecord @DkimQuery

                    }
                    'ReadMXRecord' {
                        $Body = Read-MXRecord -Domain $Request.Query.Domain
                    }
                    'TestDNSSEC' {
                        $Body = Test-DNSSEC -Domain $Request.Query.Domain
                    }
                    'ReadWhoisRecord' {
                        $Body = Read-WhoisRecord -Query $Request.Query.Domain
                    }
                    'ReadNSRecord' {
                        $Body = Read-NSRecord -Domain $Request.Query.Domain
                    }
                    'TestHttpsCertificate' {
                        $HttpsQuery = @{
                            Domain = $Request.Query.Domain
                        }
                        if ($Request.Query.Subdomains) {
                            $HttpsQuery.Subdomains = ($Request.Query.Subdomains).trim() -split '\s*,\s*'
                        } else {
                            $HttpsQuery.Subdomains = 'www'
                        }

                        $Body = Test-HttpsCertificate @HttpsQuery
                    }
                    'TestMtaSts' {
                        $HttpsQuery = @{
                            Domain = $Request.Query.Domain
                        }
                        $Body = Test-MtaSts @HttpsQuery
                    }
                }
            } else {
                $body = [pscustomobject]@{'Results' = "Domain: $($Request.Query.Domain) is invalid" }
            }
        }
    } catch {
        Write-LogMessage -API $APINAME -tenant $($name) -headers $Request.Headers -message "DNS Helper API failed. $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Failed. $($_.Exception.Message)" }
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListDomainHealth.ps1' 153
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListStandards.ps1' -1

Function Invoke-ListStandards {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter


    if ($Request.Query.ShowConsolidated -eq $true) {
        $StandardQuery = @{
            TenantFilter = $TenantFilter
        }
        if ($TenantFilter -eq 'AllTenants') {
            $StandardQuery.ListAllTenants = $true
        }
        $CurrentStandards = @(Get-CIPPStandards @StandardQuery)
    } else {
        $Table = Get-CippTable -tablename 'standards'
        $Filter = "PartitionKey eq 'standards'"

        try {
            if ($TenantFilter) {
                $Tenants = (Get-CIPPAzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json -Depth 15 -ErrorAction Stop | Where-Object Tenant -EQ $TenantFilter
            } else {
                $Tenants = (Get-CIPPAzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json -Depth 15 -ErrorAction Stop
            }
        } catch {}

        $CurrentStandards = foreach ($tenant in $Tenants) {
            [PSCustomObject]@{
                displayName     = $tenant.tenant
                appliedBy       = $tenant.addedBy
                appliedAt       = $tenant.appliedAt
                standards       = $tenant.Standards
                StandardsExport = ($tenant.Standards.PSObject.Properties.Name) -join ', '
            }
        }

        $CurrentStandards = ConvertTo-Json -InputObject @($CurrentStandards) -Depth 15 -Compress
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $CurrentStandards
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListStandards.ps1' 52
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListStandardsCompare.ps1' -1

function Invoke-ListStandardsCompare {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.BestPracticeAnalyser.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)


    $Table = Get-CIPPTable -TableName 'CippStandardsReports'
    $TenantFilter = $Request.Query.tenantFilter
    $TemplateFilter = $Request.Query.templateId

    $Filters = [system.collections.generic.list[string]]::new()
    if ($TenantFilter) {
        $Filters.Add("PartitionKey eq '{0}'" -f $TenantFilter)
    }
    if ($TemplateFilter) {
        $Filters.Add("TemplateId eq '{0}'" -f $TemplateFilter)
    }
    $Filter = $Filters -join ' and '

    $Tenants = Get-Tenants -IncludeErrors
    $Standards = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object { $_.PartitionKey -in $Tenants.defaultDomainName }

    $TenantStandards = @{}
    $Results = [System.Collections.Generic.List[object]]::new()

    foreach ($Standard in $Standards) {
        # each standard is on their own row now, the field name is the RowKey and the value is in the Value field
        $FieldName = $Standard.RowKey
        $FieldValue = $Standard.Value
        $Tenant = $Standard.PartitionKey

        # decode field names that are hex encoded (e.g. QuarantineTemplates)
        if ($FieldName -match '^(standards\.QuarantineTemplate\.)(.+)$') {
            $Prefix = $Matches[1]
            $HexEncodedName = $Matches[2]
            $Chars = [System.Collections.Generic.List[char]]::new()
            for ($i = 0; $i -lt $HexEncodedName.Length; $i += 2) {
                $Chars.Add([char][Convert]::ToInt32($HexEncodedName.Substring($i, 2), 16))
            }
            $FieldName = "$Prefix$(-join $Chars)"
        }

        if ($FieldValue -is [System.Boolean]) {
            $FieldValue = [bool]$FieldValue
        } elseif (Test-Json -Json $FieldValue -ErrorAction SilentlyContinue) {
            $FieldValue = ConvertFrom-Json -InputObject $FieldValue -ErrorAction SilentlyContinue
        } else {
            $FieldValue = [string]$FieldValue
        }

        if (-not $TenantStandards.ContainsKey($Tenant)) {
            $TenantStandards[$Tenant] = @{}
        }
        $TenantStandards[$Tenant][$FieldName] = @{
            Value       = $FieldValue
            LastRefresh = $Standard.TimeStamp.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
            TemplateId  = $Standard.TemplateId
        }
    }

    foreach ($Tenant in $TenantStandards.Keys) {
        $TenantStandard = [PSCustomObject]@{
            tenantFilter = $Tenant
        }
        foreach ($Field in $TenantStandards[$Tenant].Keys) {
            $Value = $TenantStandards[$Tenant][$Field]
            $TenantStandard | Add-Member -MemberType NoteProperty -Name $Field -Value $Value -Force
        }
        $Results.Add($TenantStandard)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Results)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListStandardsCompare.ps1' 83
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-listStandardTemplates.ps1' -1

function Invoke-listStandardTemplates {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $ID = $Request.Query.id
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'StandardsTemplateV2'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter) | ForEach-Object {
        $JSON = $_.JSON -replace '"Action":', '"action":'
        try {
            $RowKey = $_.RowKey
            $Data = $JSON | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue

        } catch {
            Write-Host "$($RowKey) standard could not be loaded: $($_.Exception.Message)"
            return
        }
        if ($Data) {
            $Data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.GUID -Force

            if (!$Data.excludedTenants) {
                $Data | Add-Member -NotePropertyName 'excludedTenants' -NotePropertyValue @() -Force
            } else {
                if ($Data.excludedTenants -and $Data.excludedTenants -ne 'excludedTenants') {
                    $Data.excludedTenants = @($Data.excludedTenants)
                } else {
                    $Data.excludedTenants = @()
                }
            }
            $Data
        }
    } | Sort-Object -Property templateName

    if ($ID) { $Templates = $Templates | Where-Object GUID -EQ $ID }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($Templates)
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-listStandardTemplates.ps1' 47
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListTenantAlignment.ps1' -1

function Invoke-ListTenantAlignment {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {
        # Use the new Get-CIPPTenantAlignment function to get alignment data
        $AlignmentData = Get-CIPPTenantAlignment

        # Transform the data to match the expected API response format
        $Results = $AlignmentData | ForEach-Object {
            [PSCustomObject]@{
                tenantFilter             = $_.TenantFilter
                standardName             = $_.StandardName
                standardType             = $_.StandardType ? $_.StandardType : 'Classic Standard'
                standardId               = $_.StandardId
                alignmentScore           = $_.AlignmentScore
                LicenseMissingPercentage = $_.LicenseMissingPercentage
                combinedAlignmentScore   = $_.CombinedScore
                latestDataCollection     = $_.LatestDataCollection
            }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($Results)
            })
    } catch {
        Write-LogMessage -API $APIName -message "Failed to get tenant alignment data: $($_.Exception.Message)" -sev Error
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = @{ error = "Failed to get tenant alignment data: $($_.Exception.Message)" }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListTenantAlignment.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListTenantDrift.ps1' -1

function Invoke-ListTenantDrift {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint

    try {
        # Use the new Get-CIPPTenantAlignment function to get alignment data
        if ($Request.Query.TenantFilter) {
            $TenantFilter = $Request.Query.TenantFilter
            $Results = Get-CIPPDrift -TenantFilter $TenantFilter
        } else {
            $Tenants = Get-Tenants
            $Results = $Tenants | ForEach-Object { Get-CIPPDrift -AllTenants -TenantFilter $_.defaultDomainName }
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = @($Results)
            })
    } catch {
        Write-LogMessage -API $APIName -message "Failed to get tenant alignment data: $($_.Exception.Message)" -sev Error
        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::InternalServerError
                Body       = @{ error = "Failed to get tenant alignment data: $($_.Exception.Message)" }
            })
    }
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-ListTenantDrift.ps1' 35
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveBPATemplate.ps1' -1

Function Invoke-RemoveBPATemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    $ID = $Request.Query.TemplateName ?? $Request.Body.TemplateName
    try {
        $Table = Get-CippTable -tablename 'templates'

        $Filter = "PartitionKey eq 'BPATemplate' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed BPA Template with ID $ID"
        Write-LogMessage -Headers $Headers -API $APINAME -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove BPA template with ID $ID. $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APINAME -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveBPATemplate.ps1' 40
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveStandard.ps1' -1

Function Invoke-RemoveStandard {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $ID = $Request.Query.ID
    try {
        $Table = Get-CippTable -tablename 'standards'
        $Filter = "PartitionKey eq 'standards' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        Write-LogMessage -Headers $Headers -API $APIName -message "Removed standards for $ID." -Sev 'Info'
        $body = [pscustomobject]@{'Results' = 'Successfully removed standards deployment' }
        $StatusCode = [HttpStatusCode]::OK


    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APIName -message "Failed to remove standard for $ID. $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
        $body = [pscustomobject]@{'Results' = 'Failed to remove standard' }
    }


    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $body
        })


}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveStandard.ps1' 42
#Region './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveStandardTemplate.ps1' -1

function Invoke-RemoveStandardTemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Standards.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $ID = $Request.Body.ID ?? $Request.Query.ID
    try {
        $Table = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'StandardsTemplateV2' and RowKey eq '$ID'"
        $ClearRow = Get-CIPPAzDataTableEntity @Table -Filter $Filter -Property PartitionKey, RowKey, JSON
        $TemplateName = (ConvertFrom-Json -InputObject $ClearRow.JSON).templateName
        Remove-AzDataTableEntity -Force @Table -Entity $ClearRow
        $Result = "Removed Standards Template named: '$($TemplateName)' with id: $($ID)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Info
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove Standards template: $TemplateName with id: $ID. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -message $Result -Sev Error -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{'Results' = $Result }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Standards/Invoke-RemoveStandardTemplate.ps1' 38
#Region './Public/Entrypoints/HTTP Functions/Tenant/Tools/Invoke-AddBPATemplate.ps1' -1

Function Invoke-AddBPATemplate {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.BestPracticeAnalyser.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {

        $Table = Get-CippTable -tablename 'templates'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$($Request.body | ConvertTo-Json -Depth 10 -Compress)"
            RowKey       = $Request.body.name
            PartitionKey = 'BPATemplate'
            GUID         = $Request.body.name
        }
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Created BPA named $($Request.body.name)" -Sev 'Debug'

        $body = [pscustomobject]@{'Results' = 'Successfully added template' }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "BPA Template Creation failed: $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "BPA Template Creation failed: $($_.Exception.Message)" }
    }


    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        })

}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Tools/Invoke-AddBPATemplate.ps1' 37
#Region './Public/Entrypoints/HTTP Functions/Tenant/Tools/Invoke-ExecGraphExplorerPreset.ps1' -1

function Invoke-ExecGraphExplorerPreset {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers

    $Username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails

    $Action = $Request.Body.action ?? ''

    Write-Information ($Request.Body | ConvertTo-Json -Depth 10)

    switch ($Action) {
        'Copy' {
            $Id = $Request.Body.preset.id ? $Request.Body.preset.id : (New-Guid).Guid
        }
        'Save' {
            $Id = $Request.Body.preset.id
        }
        'Delete' {
            $Id = $Request.Body.preset.id
        }
        default {
            $Action = 'Copy'
            $Id = (New-Guid).Guid
        }
    }

    $params = $Request.Body.preset | Select-Object endpoint, '$filter', '$select', '$count', '$expand', '$search', NoPagination, '$top', IsShared

    if ($params.'$select'.value) {
        $params.'$select' = ($params.'$select').value -join ','
    }

    if (!$Request.Body.preset.name -and $Action -ne 'Delete') {
        $Message = 'Error: Preset name is required'
        $StatusCode = [HttpStatusCode]::BadRequest
        return ([HttpResponseContext]@{
                StatusCode = $StatusCode
                Body       = @{
                    Results = @(@{
                        resultText = $Message
                        state      = 'error'
                    })
                }
            })
        return
    }

    if (!$Request.Body.preset.endpoint -and $Action -ne 'Delete') {
        $Message = 'Error: Preset endpoint is required'
        $StatusCode = [HttpStatusCode]::BadRequest
        return ([HttpResponseContext]@{
                StatusCode = $StatusCode
                Body       = @{
                    Results = @(@{
                        resultText = $Message
                        state      = 'error'
                    })
                }
            })
        return
    }

    $Preset = [PSCustomObject]@{
        PartitionKey = 'Preset'
        RowKey       = [string]$Id
        id           = [string]$Id
        name         = [string]$Request.Body.preset.name
        Owner        = [string]$Username
        IsShared     = $Request.Body.preset.IsShared
        params       = [string](ConvertTo-Json -InputObject $params -Compress)
    }

    try {
        $Success = $false
        $Table = Get-CIPPTable -TableName 'GraphPresets'
        $Message = '{0} preset succeeded' -f $Action
        if ($Action -eq 'Copy') {
            Add-CIPPAzDataTableEntity @Table -Entity $Preset -Force
            $Success = $true
        } else {
            $Entity = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$Id'"
            if ($Entity.Owner -eq $Username ) {
                if ($Action -eq 'Delete') {
                    Remove-AzDataTableEntity -Force @Table -Entity $Entity
                } elseif ($Action -eq 'Save') {
                    Add-CIPPAzDataTableEntity @Table -Entity $Preset -Force
                }
                $Success = $true
            } else {
                Write-Host "username in table: $($Entity.Owner). Username in request: $Username"
                $Message = 'Error: You can only modify your own presets.'
                $Success = $false
            }
        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Success = $false
        $Message = $_.Exception.Message
        $StatusCode = [HttpStatusCode]::BadRequest
    }
    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{
                Results = @(@{
                    resultText = $Message
                    state      = if ($Success) { 'success' } else { 'error' }
                })
            }
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tenant/Tools/Invoke-ExecGraphExplorerPreset.ps1' 119
#Region './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ExecCommunityRepo.ps1' -1

function Invoke-ExecCommunityRepo {
    <#
    .SYNOPSIS
        Make changes to a community repository
    .DESCRIPTION
        This function makes changes to a community repository in table storage
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Action = $Request.Body.Action
    $Id = $Request.Body.Id
    if ($Request.Body.Id) {
        $Filter = "PartitionKey eq 'CommunityRepos' and RowKey eq '$($Id)'"
    } elseif ($Request.Body.FullName) {
        $Filter = "PartitionKey eq 'CommunityRepos' and FullName eq '$($Request.Body.FullName)'"
    } else {
        $Results = @(
            @{
                resultText = 'Id or FullName required'
                state      = 'error'
            }
        )
        $Body = @{
            Results = $Results
        }

        return ([HttpResponseContext]@{
                StatusCode = [HttpStatusCode]::OK
                Body       = $Body
            })
        return
    }

    $Table = Get-CIPPTable -TableName CommunityRepos
    $RepoEntity = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    switch ($Action) {
        'Add' {
            $Repo = Invoke-GitHubApiRequest -Path "repositories/$($Id)"
            $RepoEntity = @{
                PartitionKey  = 'CommunityRepos'
                RowKey        = [string]$Repo.id
                Name          = [string]$Repo.name
                Description   = [string]$Repo.description
                URL           = [string]$Repo.html_url
                FullName      = [string]$Repo.full_name
                Owner         = [string]$Repo.owner.login
                Visibility    = [string]$Repo.visibility
                WriteAccess   = [bool]$Repo.permissions.push
                DefaultBranch = [string]$Repo.default_branch
                Permissions   = [string]($Repo.permissions | ConvertTo-Json -Compress)
            }

            Add-CIPPAzDataTableEntity @Table -Entity $RepoEntity -Force | Out-Null

            $Results = @{
                resultText = "Community repository '$($Repo.name)' added"
                state      = 'success'
            }
        }
        'Update' {
            if ($RepoEntity) {
                $Repo = Invoke-GitHubApiRequest -Path "repositories/$($Id)"
                $Update = @{
                    PartitionKey  = 'CommunityRepos'
                    RowKey        = [string]$Repo.id
                    Name          = [string]$Repo.name
                    Description   = [string]$Repo.description
                    URL           = [string]$Repo.html_url
                    FullName      = [string]$Repo.full_name
                    Owner         = [string]$Repo.owner.login
                    Visibility    = [string]$Repo.visibility
                    WriteAccess   = [bool]$Repo.permissions.push
                    DefaultBranch = [string]$Repo.default_branch
                    Permissions   = [string]($Repo.permissions | ConvertTo-Json -Compress)
                    ETag          = $RepoEntity.ETag
                }

                Update-CIPPAzDataTableEntity @Table -Entity $Update

                $Results = @{
                    resultText = "Repository $($Repo.name) updated"
                    state      = 'success'
                }
            } else {
                $Results = @{
                    resultText = "Repository $($Repo.name) not found"
                    state      = 'error'
                }
            }
        }
        'Delete' {
            if ($RepoEntity) {
                $Delete = $RepoEntity | Select-Object PartitionKey, RowKey, ETag
                Remove-AzDataTableEntity @Table -Entity $Delete
            }
            $Results = @{
                resultText = "Repository $($RepoEntity.Name) deleted"
                state      = 'success'
            }
        }
        'UploadTemplate' {
            $GUID = $Request.Body.GUID
            $TemplateTable = Get-CIPPTable -TableName templates
            $TemplateEntity = Get-CIPPAzDataTableEntity @TemplateTable -Filter "RowKey eq '$($GUID)'" | Select-Object -ExcludeProperty ETag, Timestamp
            $Branch = $RepoEntity.UploadBranch ?? $RepoEntity.DefaultBranch
            if ($TemplateEntity) {
                $Template = $TemplateEntity.JSON | ConvertFrom-Json
                $DisplayName = $Template.Displayname ?? $Template.templateName ?? $Template.name
                if ($Template.tenantFilter) {
                    $Template.tenantFilter = @(@{ label = 'Template Tenant'; value = 'Template Tenant' })
                }
                if ($Template.excludedTenants) {
                    $Template.excludedTenants = @()
                }
                $TemplateEntity.JSON = $Template | ConvertTo-Json -Compress -Depth 100

                $Basename = $DisplayName -replace '\s', '_' -replace '[^\w\d_]', ''
                $Path = '{0}/{1}.json' -f $TemplateEntity.PartitionKey, $Basename
                $Results = Push-GitHubContent -FullName $Request.Body.FullName -Path $Path -Content ($TemplateEntity | ConvertTo-Json -Compress) -Message $Request.Body.Message -Branch $Branch

                $Results = @{
                    resultText = "Template '$($DisplayName)' uploaded"
                    state      = 'success'
                }
            } else {
                $Results = @{
                    resultText = "Template '$($GUID)' not found"
                    state      = 'error'
                }
            }
        }
        'SetBranch' {
            if (!$RepoEntity) {
                $Results = @{
                    resultText = "Repository $($Id) not found"
                    state      = 'error'
                }
            } else {
                $Branch = $Request.Body.Branch
                if (!$RepoEntity.UploadBranch) {
                    $RepoEntity | Add-Member -NotePropertyName 'UploadBranch' -NotePropertyValue $Branch
                } else {
                    $RepoEntity.UploadBranch = $Branch
                }
                $null = Add-CIPPAzDataTableEntity @Table -Entity $RepoEntity -Force

                $Results = @{
                    resultText = "Branch set to $Branch"
                    state      = 'success'
                }
            }
        }
        'ImportTemplate' {
            $Path = $Request.Body.Path
            $FullName = $Request.Body.FullName
            $Branch = $Request.Body.Branch
            try {
                $Template = Get-GitHubFileContents -FullName $FullName -Path $Path -Branch $Branch

                $Content = $Template.content | ConvertFrom-Json
                if ($Content.'@odata.type' -like '*conditionalAccessPolicy*') {
                    $Files = (Get-GitHubFileTree -FullName $FullName -Branch $Branch).tree | Where-Object { $_.path -match '.json$' -and $_.path -notmatch 'NativeImport' } | Select-Object *, @{n = 'html_url'; e = { "https://github.com/$($SplatParams.FullName)/tree/$($SplatParams.Branch)/$($_.path)" } }, @{n = 'name'; e = { ($_.path -split '/')[ -1 ] -replace '\.json$', '' } }

                    $MigrationTable = $Files | Where-Object { $_.name -eq 'MigrationTable' } | Select-Object -Last 1
                    if ($MigrationTable) {
                        Write-Host "Found a migration table, getting contents for $FullName"
                        $MigrationTable = (Get-GitHubFileContents -FullName $FullName -Branch $Branch -Path $MigrationTable.path).content | ConvertFrom-Json
                    }

                    $NamedLocations = $Files | Where-Object { $_.name -match 'ALLOWED COUNTRIES' }
                    $LocationData = foreach ($Location in $NamedLocations) {
                        (Get-GitHubFileContents -FullName $FullName -Branch $Branch -Path $Location.path).content | ConvertFrom-Json
                    }
                }
                Import-CommunityTemplate -Template $Content -SHA $Template.sha -MigrationTable $MigrationTable -LocationData $LocationData

                $Results = @{
                    resultText = 'Template imported'
                    state      = 'success'
                }
            } catch {
                $Results = @{
                    resultText = "Error importing template: $($_.Exception.Message)"
                    state      = 'error'
                }
            }
        }
        default {
            $Results = @{
                resultText = "Action $Action not supported"
                state      = 'error'
            }
        }
    }

    $Body = @{
        Results = @($Results)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ExecCommunityRepo.ps1' 211
#Region './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ExecGitHubAction.ps1' -1

function Invoke-ExecGitHubAction {
    <#
    .SYNOPSIS
        Invoke GitHub Action
    .DESCRIPTION
        Call GitHub API
    .ROLE
        CIPP.Extension.ReadWrite
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Action = $Request.Query.Action ?? $Request.Body.Action

    if ($Request.Query.Action) {
        $Parameters = $Request.Query
    } else {
        $Parameters = $Request.Body
    }

    $SplatParams = $Parameters | Select-Object -ExcludeProperty Action, TenantFilter | ConvertTo-Json | ConvertFrom-Json -AsHashtable

    $Table = Get-CIPPTable -TableName Extensionsconfig
    $Configuration = ((Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json -ErrorAction SilentlyContinue).GitHub

    if (!$Configuration.Enabled) {
        $Response = Invoke-RestMethod -Uri 'https://cippy.azurewebsites.net/api/ExecGitHubAction' -Method POST -Body ($Parameters | ConvertTo-Json -Depth 10) -ContentType 'application/json'
        $Results = $Response.Results
        $Metadata = $Response.Metadata
    } else {
        switch ($Action) {
            'Search' {
                $SearchResults = Search-GitHub @SplatParams
                $Results = @($SearchResults.items)
                $Metadata = $SearchResults | Select-Object -Property total_count, incomplete_results
            }
            'GetFileContents' {
                $Results = Get-GitHubFileContents @SplatParams
            }
            'GetBranches' {
                $Results = @(Get-GitHubBranch @SplatParams)
            }
            'GetOrgs' {
                try {
                    $Orgs = Invoke-GitHubApiRequest -Path 'user/orgs'
                    $Results = @($Orgs)
                } catch {
                    $Results = @{
                        resultText = 'You may not have permission to view organizations, check your PAT scopes and try again - {0}' -f $_.Exception.Message
                        state      = 'error'
                    }
                }
            }
            'GetFileTree' {
                $Files = (Get-GitHubFileTree @SplatParams).tree | Where-Object { $_.path -match '.json$' } | Select-Object *, @{n = 'html_url'; e = { "https://github.com/$($SplatParams.FullName)/tree/$($SplatParams.Branch)/$($_.path)" } }
                $Results = @($Files)
            }
            'ImportTemplate' {
                $Results = Import-CommunityTemplate @SplatParams
            }
            'CreateRepo' {
                try {
                    Write-Information "Creating repository '$($SplatParams.Name)'"
                    $Repo = New-GitHubRepo @SplatParams
                    if ($Repo.id) {
                        $Table = Get-CIPPTable -TableName CommunityRepos
                        $RepoEntity = @{
                            PartitionKey  = 'CommunityRepos'
                            RowKey        = [string]$Repo.id
                            Name          = [string]($Repo.name -replace ' ', '-')
                            Description   = [string]$Repo.description
                            URL           = [string]$Repo.html_url
                            FullName      = [string]$Repo.full_name
                            Owner         = [string]$Repo.owner.login
                            Visibility    = [string]$Repo.visibility
                            WriteAccess   = [bool]$Repo.permissions.push
                            DefaultBranch = [string]$Repo.default_branch
                            Permissions   = [string]($Repo.permissions | ConvertTo-Json -Compress)
                        }
                        Add-CIPPAzDataTableEntity @Table -Entity $RepoEntity -Force | Out-Null

                        $Results = @{
                            resultText = "Repository '$($Repo.name)' created"
                            state      = 'success'
                        }
                    }
                } catch {
                    Write-Information (Get-CippException -Exception $_ | ConvertTo-Json)
                    $Results = @{
                        resultText = 'You may not have permission to create repositories, check your PAT scopes and try again - {0}' -f $_.Exception.Message
                        state      = 'error'
                    }
                }
            }
            default {
                $Results = @{
                    resultText = "Unknown action '$Action'"
                    state      = 'error'
                }
            }
        }
    }

    $Body = @{
        Results = $Results
    }
    if ($Metadata) {
        $Body.Metadata = $Metadata
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ExecGitHubAction.ps1' 118
#Region './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ListCommunityRepos.ps1' -1

function Invoke-ListCommunityRepos {
    <#
    .SYNOPSIS
        List community repositories in Table Storage
    .DESCRIPTION
        This function lists community repositories in Table Storage
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Table = Get-CIPPTable -TableName CommunityRepos

    if ($Request.Query.WriteAccess -eq 'true') {
        $Filter = "PartitionKey eq 'CommunityRepos' and WriteAccess eq true"
    } else {
        $Filter = ''
    }

    $Repos = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    if (!$Request.Query.WriteAccess) {
        $CIPPRoot = (Get-Item (Get-Module -Name CIPPCore).ModuleBase).Parent.Parent.FullName
        $CommunityRepos = Join-Path -Path $CIPPRoot -ChildPath 'CommunityRepos.json'
        $DefaultCommunityRepos = Get-Content -Path $CommunityRepos -Raw | ConvertFrom-Json

        $DefaultsMissing = $false
        foreach ($Repo in $DefaultCommunityRepos) {
            if ($Repos.Url -notcontains $Repo.Url) {
                $Entity = [PSCustomObject]@{
                    PartitionKey  = 'CommunityRepos'
                    RowKey        = $Repo.Id
                    Name          = $Repo.Name
                    Description   = $Repo.Description
                    URL           = $Repo.URL
                    FullName      = $Repo.FullName
                    Owner         = $Repo.Owner
                    Visibility    = $Repo.Visibility
                    WriteAccess   = $Repo.WriteAccess
                    DefaultBranch = $Repo.DefaultBranch
                    UploadBranch  = $Repo.DefaultBranch
                    Permissions   = [string]($Repo.RepoPermissions | ConvertTo-Json)
                }
                Add-CIPPAzDataTableEntity @Table -Entity $Entity
                $DefaultsMissing = $true
            }
        }
        if ($DefaultsMissing) {
            $Repos = Get-CIPPAzDataTableEntity @Table
        }
    }

    $Repos = $Repos | ForEach-Object {
        [pscustomobject]@{
            Id              = $_.RowKey
            Name            = $_.Name
            Description     = $_.Description
            URL             = $_.URL
            FullName        = $_.FullName
            Owner           = $_.Owner
            Visibility      = $_.Visibility
            WriteAccess     = $_.WriteAccess
            DefaultBranch   = $_.DefaultBranch
            UploadBranch    = $_.UploadBranch ?? $_.DefaultBranch
            RepoPermissions = $_.Permissions | ConvertFrom-Json
        }
    }

    $Body = @{
        Results = @($Repos | Sort-Object -Property FullName)
    }

    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Body
        })
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ListCommunityRepos.ps1' 81
#Region './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ListGitHubReleaseNotes.ps1' -1

function Invoke-ListGitHubReleaseNotes {
    <#
    .SYNOPSIS
        Retrieves release notes for a GitHub repository.
    .DESCRIPTION
        Returns release metadata for the provided repository and semantic version. Hotfix
        versions (e.g. v8.5.2) map back to the base release tag (v8.5.0).
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $Owner = $Request.Query.Owner
    $Repository = $Request.Query.Repository

    if (-not $Owner) {
        throw 'Owner parameter is required to retrieve release notes.'
    }

    if (-not $Repository) {
        throw 'Repository parameter is required to retrieve release notes.'
    }

    $ReleasePath = "repos/$Owner/$Repository/releases?per_page=50"

    $Table = Get-CIPPTable -TableName cacheGitHubReleaseNotes
    $PartitionKey = 'GitHubReleaseNotes'
    $Filter = "PartitionKey eq '$PartitionKey'"
    $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddHours(-24)

    try {
        if ($Rows) {
            $Releases = ConvertFrom-Json -InputObject $Rows.GitHubReleases -Depth 10
        } else {
            $Releases = Invoke-GitHubApiRequest -Path $ReleasePath
            $Releases = $Releases | ForEach-Object {
                [ordered]@{
                    name        = $_.name
                    body        = $_.body
                    releaseTag  = $_.tag_name
                    htmlUrl     = $_.html_url
                    publishedAt = $_.published_at
                    draft       = [bool]$_.draft
                    prerelease  = [bool]$_.prerelease
                    commitish   = $_.target_commitish
                }
            }

            $Results = @{
                GitHubReleases = [string](ConvertTo-Json -Depth 10 -InputObject $Releases)
                RowKey         = [string]'GitHubReleaseNotes'
                PartitionKey   = $PartitionKey
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Results -Force | Out-Null
        }

    } catch {
        $ErrorMessage = "Failed to retrieve release information: $($_)"
        throw $ErrorMessage
    }

    if (-not $Releases) {
        return $IsListRequest ? @() : (throw "No releases returned for $Owner/$Repository")
    }

    return $Releases
}
#EndRegion './Public/Entrypoints/HTTP Functions/Tools/GitHub/Invoke-ListGitHubReleaseNotes.ps1' 71
#Region './Public/Entrypoints/Invoke-ExecBreachSearch.ps1' -1

function Invoke-ExecBreachSearch {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.body.tenantFilter

    #Move to background job
    New-BreachTenantSearch -TenantFilter $TenantFilter
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{ Results = "Executing Search for $TenantFilter. This may take up to 24 hours to complete." }
        })

}
#EndRegion './Public/Entrypoints/Invoke-ExecBreachSearch.ps1' 21
#Region './Public/Entrypoints/Invoke-ExecCSPLicense.ps1' -1

function Invoke-ExecCSPLicense {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $Action = $Request.Body.Action
    $SKU = $Request.Body.SKU.value ?? $Request.Body.SKU

    try {
        if ($Action -eq 'Add') {
            $null = Set-SherwebSubscription -Headers $Headers -tenantFilter $TenantFilter -SKU $SKU -add $Request.Body.Add
        }

        if ($Action -eq 'Remove') {
            $null = Set-SherwebSubscription -Headers $Headers -tenantFilter $TenantFilter -SKU $SKU -remove $Request.Body.Remove
        }

        if ($Action -eq 'NewSub') {
            $null = Set-SherwebSubscription -Headers $Headers -tenantFilter $TenantFilter -SKU $SKU -Quantity $Request.Body.Quantity
        }
        if ($Action -eq 'Cancel') {
            $null = Remove-SherwebSubscription -Headers $Headers -tenantFilter $TenantFilter -SubscriptionIds $Request.Body.SubscriptionIds
        }
        $Result = 'License change executed successfully.'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = "Failed to execute license change. Error: $_"
        $StatusCode = [HttpStatusCode]::InternalServerError
    }
    # If $GraphRequest is a GUID, the subscription was edited successfully, and return that it's done.
    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $Result
    }

}
#EndRegion './Public/Entrypoints/Invoke-ExecCSPLicense.ps1' 46
#Region './Public/Entrypoints/Invoke-ExecExtensionNinjaOneQueue.ps1' -1

function Invoke-ExecExtensionNinjaOneQueue {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    switch ($QueueItem.NinjaAction) {
        'StartAutoMapping' { Invoke-NinjaOneOrgMapping }
        'AutoMapTenant' { Invoke-NinjaOneOrgMappingTenant -QueueItem $QueueItem }
        'SyncTenant' { Invoke-NinjaOneTenantSync -QueueItem $QueueItem }
    }

    $Body = [PSCustomObject]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = 'Success'
    }

    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $Body
    }
}
#EndRegion './Public/Entrypoints/Invoke-ExecExtensionNinjaOneQueue.ps1' 26
#Region './Public/Entrypoints/Invoke-ExecListAppId.ps1' -1

Function Invoke-ExecListAppId {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    Get-CIPPAuthentication
    $ResponseURL = "$(($Request.headers.'x-ms-original-url').replace('/api/ExecListAppId','/api/ExecSAMSetup'))"
    #make sure we get the very latest version of the appid from kv:
    if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
        $DevSecretsTable = Get-CIPPTable -tablename 'DevSecrets'
        $Secret = Get-CIPPAzDataTableEntity @DevSecretsTable -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
        $env:ApplicationID = $Secret.ApplicationID
        $env:TenantID = $Secret.TenantID
    } else {
        Write-Information 'Connecting to Azure'
        Connect-AzAccount -Identity
        $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
        try {
            $Context = Get-AzContext
            if ($Context.Subscription) {
                #Write-Information "Current context: $($Context | ConvertTo-Json)"
                if ($Context.Subscription.Id -ne $SubscriptionId) {
                    Write-Information "Setting context to subscription $SubscriptionId"
                    $null = Set-AzContext -SubscriptionId $SubscriptionId
                }
            }
        } catch {
            Write-Information "ERROR: Could not set context to subscription $SubscriptionId."
        }

        $keyvaultname = ($env:WEBSITE_DEPLOYMENT_ID -split '-')[0]
        try {
            $env:ApplicationID = (Get-AzKeyVaultSecret -AsPlainText -VaultName $keyvaultname -Name 'ApplicationID')
            $env:TenantID = (Get-AzKeyVaultSecret -AsPlainText -VaultName $keyvaultname -Name 'TenantID')
            Write-Information "Retrieving secrets from KeyVault: $keyvaultname. The AppId is $($env:ApplicationID) and the TenantId is $($env:TenantID)"
        } catch {
            Write-Information "Retrieving secrets from KeyVault: $keyvaultname. The AppId is $($env:ApplicationID) and the TenantId is $($env:TenantID)"
            Write-LogMessage -message "Failed to retrieve secrets from KeyVault: $keyvaultname" -LogData (Get-CippException -Exception $_) -Sev 'Error'
            $env:ApplicationID = (Get-CippException -Exception $_)
            $env:TenantID = (Get-CippException -Exception $_)
        }
    }
    $Results = @{
        applicationId = $env:ApplicationID
        tenantId      = $env:TenantID
        refreshUrl    = "https://login.microsoftonline.com/$env:TenantID/oauth2/v2.0/authorize?client_id=$env:ApplicationID&response_type=code&redirect_uri=$ResponseURL&response_mode=query&scope=https%3A%2F%2Fgraph.microsoft.com%2F.default+offline_access+profile+openid&state=1&prompt=select_account"
    }
    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $Results
        }

}
#EndRegion './Public/Entrypoints/Invoke-ExecListAppId.ps1' 58
#Region './Public/Entrypoints/Invoke-ExecSchedulerBillingRun.ps1' -1

Function Invoke-ExecSchedulerBillingRun {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Scheduler.Billing.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    try {
        Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message 'Starting billing processing.' -sev Info

        $Table = Get-CIPPTable -TableName Extensionsconfig
        $Configuration = (Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json -Depth 10
        foreach ($ConfigItem in $Configuration.PSObject.Properties.Name) {
            switch ($ConfigItem) {
                'Gradient' {
                    If ($Configuration.Gradient.enabled -and $Configuration.Gradient.BillingEnabled) {
                        New-GradientServiceSyncRun
                    }
                }
            }
        }
    } catch {
        Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message "Could not start billing processing $($_.Exception.Message)" -sev Error -headers $Headers
    }

}
#EndRegion './Public/Entrypoints/Invoke-ExecSchedulerBillingRun.ps1' 32
#Region './Public/Entrypoints/Invoke-ExecSendOrgMessage.ps1' -1

Function Invoke-ExecSendOrgMessage {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    $Device = $request.query.ID
    try {

        $type = switch ($request.Query.type) {
            'taskbar' {
                '844ec9d0-dd31-459c-a1e7-21fb1b39d5da'
                $placementDetails = @(@{
                        placement = 'default'
                        variants  = @(@{
                                variantId      = 'b3fce1ee-9658-4267-b174-23d4a1be148f'
                                localizedTexts = @(@{
                                        locale = 'invariant'
                                        text   = @{
                                            'clickUrl' = $Request.query.URL
                                        }
                                    })
                            })
                    })
            }
            'notification' {
                '1ff7c7e7-128c-4e18-a926-bdac4e906ea1'
                $placementDetails = @(@{
                        placement = 'default'
                        variants  = @(@{
                                variantId      = '7a1419c9-9263-4202-9225-35b326b92792'
                                localizedTexts = @(@{
                                        locale = 'invariant'
                                        text   = @{
                                            'clickUrl' = $Request.query.URL
                                        }
                                    })
                            })
                    })
            }
            'getStarted' {
                $placementDetails = @(@{
                        placement = 'card0'
                        variants  = @(@{
                                variantId      = 'ed0d0fa2-df72-42f4-9866-66cf3de1fafb'
                                localizedTexts = @(@{
                                        locale = 'invariant'
                                        text   = @{
                                            'message'    = 'My Message Value'
                                            'clickUrl'   = 'https://example.com/clickUrl/'
                                            'title'      = 'This message'
                                            'buttonText' = 'PlzClick'
                                        }
                                    })
                            })
                    }
                    @{
                        placement = 'card1'
                        variants  = @(@{
                                variantId      = 'ed0d0fa2-df72-42f4-9866-66cf3de1fafb'
                                localizedTexts = @(@{
                                        locale = 'invariant'
                                        text   = @{
                                            'message'    = 'My Message Value'
                                            'clickUrl'   = 'https://example.com/clickUrl/'
                                            'title'      = 'This message'
                                            'buttonText' = 'PlzClick'
                                        }
                                    })
                            })
                    })
            }

        }
        $freq = $request.query.freq
        $object = [pscustomobject]@{
            startDateTime	= (Get-Date).ToString('O')
            endDateTime   = (Get-Date).AddYears('1').ToString('O')
            frequency     = $freq
            targeting     = @{
                targetingType = 'aadGroup'
                includeIds    = @($Device)
            }
            content       = @{
                'guidedContentId' = "$Type"
                placementDetails  = $placementDetails
                logoInfo          = @{
                    contentType = 'png'
                    logoCdnUrl  = 'https://hulpnu.nl/tools/Red.jpg'
                }
            }
        }
        $tmpbody = ConvertTo-Json -Depth 15 -Compress -InputObject $object
        Write-Host $tmpbody

        $GraphRequest = New-GraphPOSTRequest -noauthcheck $true -type 'POST' -uri 'https://graph.microsoft.com/beta/deviceManagement/organizationalMessageDetails' -tenantid $tenantfilter -body $tmpbody
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ExecSendOrgMessage.ps1' 114
#Region './Public/Entrypoints/Invoke-ExecUniversalSearch.ps1' -1

Function Invoke-ExecUniversalSearch {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.

    try {
        $tenantfilter = Get-Tenants
        $payload = [PSCustomObject]@{
            returnsPartialResults = $false
            displayName           = 'getUsers'
            target                = [PSCustomObject]@{
                allTenants = $true
            }
            operationDefinition   = [PSCustomObject]@{
                values = @(
                    "@sys.normalize([ConsistencyLevel: eventual GET /v1.0/users?`$top=5&`$search=`"userPrincipalName:$($Request.query.name)`" OR `"displayName:$($Request.query.name)`"])"
                )
            }
            aggregationDefinition = [PSCustomObject]@{
                values = @(
                    '@sys.append([/result],50)'
                )
            }
        } | ConvertTo-Json -Depth 10
        $GraphRequest = New-GraphPOSTRequest -noauthcheck $true -type 'POST' -uri 'https://graph.microsoft.com/beta/tenantRelationships/managedTenants/managedTenantOperations' -tenantid $env:TenantID -body $payload -IgnoreErrors $true
        if (!$GraphRequest.result.results) {
            $GraphRequest = ($GraphRequest.error.message | ConvertFrom-Json).result.results | ConvertFrom-Json | Where-Object { $_.'_TenantId' -in $tenantfilter.customerId }
        } else {
            $GraphRequest = $GraphRequest.result.Results | ConvertFrom-Json -ErrorAction SilentlyContinue | Where-Object { $_.'_TenantId' -in $tenantfilter.customerId }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = "Could not connect to Azure Lighthouse API: $($ErrorMessage)"
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ExecUniversalSearch.ps1' 49
#Region './Public/Entrypoints/Invoke-ExecUserSettings.ps1' -1

function Invoke-ExecUserSettings {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.ReadWrite
    #>
    param($Request, $TriggerMetadata)
    try {
        $object = $Request.Body.currentSettings | Select-Object * -ExcludeProperty CurrentTenant, pageSizes, sidebarShow, sidebarUnfoldable, _persist | ConvertTo-Json -Compress -Depth 10
        $User = $Request.Body.user
        $Table = Get-CippTable -tablename 'UserSettings'
        $Table.Force = $true
        Add-CIPPAzDataTableEntity @Table -Entity @{
            JSON         = "$object"
            RowKey       = "$User"
            PartitionKey = 'UserSettings'
        }
        $StatusCode = [HttpStatusCode]::OK
        $Results = [pscustomobject]@{'Results' = 'Successfully added user settings' }
    } catch {
        $ErrorMsg = Get-NormalizedError -message $($_.Exception.Message)
        $Results = "Function Error: $ErrorMsg"
        $StatusCode = [HttpStatusCode]::BadRequest
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ExecUserSettings.ps1' 32
#Region './Public/Entrypoints/Invoke-ListAllTenantDeviceCompliance.ps1' -1

Function Invoke-ListAllTenantDeviceCompliance {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.DeviceCompliance.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        if ($TenantFilter -eq 'AllTenants') {
            $GraphRequest = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/tenantRelationships/managedTenants/managedDeviceCompliances'
            $StatusCode = [HttpStatusCode]::OK
        } else {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/managedTenants/managedDeviceCompliances?`$top=999&`$filter=organizationId eq '$TenantFilter'"
            $StatusCode = [HttpStatusCode]::OK
        }

        if ($GraphRequest.value.count -lt 1) {
            $StatusCode = [HttpStatusCode]::Forbidden
            $GraphRequest = 'No data found - This client might not be onboarded in Lighthouse'
        }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = "Could not connect to Azure Lighthouse API: $($ErrorMessage)"
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListAllTenantDeviceCompliance.ps1' 36
#Region './Public/Entrypoints/Invoke-ListAppStatus.ps1' -1

Function Invoke-ListAppStatus {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Device.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $appFilter = $Request.Query.AppFilter
    Write-Host "Using $appFilter"
    $body = @"
{"select":["DeviceName","UserPrincipalName","Platform","AppVersion","InstallState","InstallStateDetail","LastModifiedDateTime","DeviceId","ErrorCode","UserName","UserId","ApplicationId","AssignmentFilterIdsList","AppInstallState","AppInstallStateDetails","HexErrorCode"],"skip":0,"top":999,"filter":"(ApplicationId eq '$Appfilter')","orderBy":[]}
"@
    try {
        $GraphRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/reports/getDeviceInstallStatusReport' -tenantid $TenantFilter -body $body
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListAppStatus.ps1' 32
#Region './Public/Entrypoints/Invoke-ListBreachesAccount.ps1' -1

Function Invoke-ListBreachesAccount {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $Account = $Request.Query.account

    if ($Account -like '*@*') {
        $Results = Get-HIBPRequest "breachedaccount/$($Account)?truncateResponse=false"
    } else {
        $Results = Get-BreachInfo -Domain $Account
    }

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($results)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListBreachesAccount.ps1' 25
#Region './Public/Entrypoints/Invoke-ListBreachesTenant.ps1' -1

function Invoke-ListBreachesTenant {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $TenantFilter = $Request.Query.tenantFilter

    $Table = Get-CIPPTable -TableName UserBreaches
    if ($TenantFilter -ne 'AllTenants') {
        $filter = "PartitionKey eq '$TenantFilter'"
    } else {
        $filter = $null
    }
    try {
        $Tenants = Get-Tenants -IncludeErrors
        $Rows = Get-CIPPAzDataTableEntity @Table -Filter $filter | Where-Object { $Tenants.defaultDomainName -contains $_.PartitionKey }
        $usersResults = $Rows.breaches | ConvertFrom-Json -ErrorAction SilentlyContinue
    } catch {
        $usersResults = $null
    }
    if ($null -eq $usersResults) {
        $usersResults = @()
    }
    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @($usersResults)
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListBreachesTenant.ps1' 34
#Region './Public/Entrypoints/Invoke-ListCheckExtAlerts.ps1' -1

function Invoke-ListCheckExtAlerts {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers

    $TenantFilter = $Request.Query.tenantFilter
    $Table = Get-CIPPTable -tablename CheckExtensionAlerts

    if ($TenantFilter -and $TenantFilter -ne 'AllTenants') {
        $Filter = "PartitionKey eq 'CheckAlert' and tenantFilter eq '$TenantFilter'"
    } else {
        $Filter = "PartitionKey eq 'CheckAlert'"
    }

    try {
        $Tenants = Get-Tenants -IncludeErrors
        $Alerts = (Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object { $Tenants.defaultDomainName -contains $_.tenantFilter }) ?? @()
    } catch {
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to retrieve check extension alerts: $($_.Exception.Message)" -Sev 'Error'
        $Alerts = @()
    }

    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @($Alerts | Sort-Object -Property Timestamp -Descending)
    }
}
#EndRegion './Public/Entrypoints/Invoke-ListCheckExtAlerts.ps1' 36
#Region './Public/Entrypoints/Invoke-ListCSPLicenses.ps1' -1

function Invoke-ListCSPLicenses {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $Result = Get-SherwebCurrentSubscription -TenantFilter $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $Result = 'Unable to retrieve CSP licenses, ensure that you have enabled the Sherweb integration and mapped the tenant in the integration settings.'
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = @($Result)
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListCSPLicenses.ps1' 27
#Region './Public/Entrypoints/Invoke-ListCSPsku.ps1' -1

function Invoke-ListCSPsku {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $CurrentSkuOnly = $Request.Query.currentSkuOnly

    try {
        if ($CurrentSkuOnly) {
            $GraphRequest = Get-SherwebCurrentSubscription -TenantFilter $TenantFilter
        } else {
            $GraphRequest = Get-SherwebCatalog -TenantFilter $TenantFilter
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $GraphRequest = [PSCustomObject]@{
            name = @(@{value = 'Error getting catalog' })
            sku  = $_.Exception.Message
        }
        $StatusCode = [HttpStatusCode]::InternalServerError
    }

    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = @($GraphRequest)
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListCSPsku.ps1' 35
#Region './Public/Entrypoints/Invoke-ListDeviceDetails.ps1' -1

Function Invoke-ListDeviceDetails {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Device.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # XXX Seems to be an unused endpoint? -Bobby

    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $DeviceID = $Request.Query.DeviceID
    $DeviceName = $Request.Query.DeviceName
    $DeviceSerial = $Request.Query.DeviceSerial

    try {
        if ($DeviceID) {
            $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices/$DeviceID" -Tenantid $TenantFilter
        } elseif ($DeviceSerial -or $DeviceName) {
            $Found = $False
            if ($DeviceSerial -and $DeviceName) {
                $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices?`$filter=serialnumber eq '$DeviceSerial' and deviceName eq '$DeviceName'" -Tenantid $TenantFilter

                if (($GraphRequest | Measure-Object).count -eq 1 -and $GraphRequest.'@odata.count' -ne 0 ) {
                    $Found = $True
                }
            }
            if ($DeviceSerial -and $Found -eq $False) {
                $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices?`$filter=serialnumber eq '$DeviceSerial'" -Tenantid $TenantFilter
                if (($GraphRequest | Measure-Object).count -eq 1 -and $GraphRequest.'@odata.count' -ne 0 ) {
                    $Found = $True
                }
            }
            if ($DeviceName -and $Found -eq $False) {
                $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices?`$filter=deviceName eq '$DeviceName'" -Tenantid $TenantFilter
                if (($GraphRequest | Measure-Object).count -eq 1 -and $GraphRequest.'@odata.count' -ne 0 ) {
                    $Found = $True
                }
            }

        }

        if (!(($GraphRequest | Measure-Object).count -eq 1 -and $GraphRequest.'@odata.count' -ne 0 )) {
            $GraphRequest = $Null
        }

        if ($GraphRequest) {
            [System.Collections.Generic.List[PSCustomObject]]$BulkRequests = @(
                @{
                    id     = 'DeviceGroups'
                    method = 'GET'
                    url    = "/devices(deviceID='$($GraphRequest.azureADDeviceId)')/memberOf"
                },
                @{
                    id     = 'CompliancePolicies'
                    method = 'GET'
                    url    = "/deviceManagement/managedDevices('$($GraphRequest.id)')/deviceCompliancePolicyStates"
                },
                @{
                    id     = 'DetectedApps'
                    method = 'GET'
                    url    = "deviceManagement/managedDevices('$($GraphRequest.id)')?expand=detectedApps"
                }
            )

            $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter

            $DeviceGroups = Get-GraphBulkResultByID -Results $BulkResults -ID 'DeviceGroups' -Value
            $CompliancePolicies = Get-GraphBulkResultByID -Results $BulkResults -ID 'CompliancePolicies' -Value
            $DetectedApps = Get-GraphBulkResultByID -Results $BulkResults -ID 'DetectedApps'

            $Null = $GraphRequest | Add-Member -NotePropertyName 'DetectedApps' -NotePropertyValue ($DetectedApps.DetectedApps | Select-Object id, displayName, version)
            $Null = $GraphRequest | Add-Member -NotePropertyName 'CompliancePolicies' -NotePropertyValue ($CompliancePolicies | Select-Object id, displayName, UserPrincipalName, state)
            $Null = $GraphRequest | Add-Member -NotePropertyName 'DeviceGroups' -NotePropertyValue ($DeviceGroups | Select-Object id, displayName, description)


        }

        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage

    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $GraphRequest
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListDeviceDetails.ps1' 94
#Region './Public/Entrypoints/Invoke-ListExtensionsConfig.ps1' -1

function Invoke-ListExtensionsConfig {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Extension.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable -TableName Extensionsconfig
    try {
        $Config = (Get-CIPPAzDataTableEntity @Table).config
        if (Test-Json -Json $Config) {
            $Body = $Config | ConvertFrom-Json -Depth 10 -ErrorAction Stop
            if ($Body.HaloPSA.TicketType -and !$Body.HaloPSA.TicketType.value) {
                # translate ticket type to autocomplete format
                Write-Information "Ticket Type: $($Body.HaloPSA.TicketType)"
                $Types = Get-HaloTicketType
                $Type = $Types | Where-Object { $_.id -eq $Body.HaloPSA.TicketType }
                #Write-Information ($Type | ConvertTo-Json)
                if ($Type) {
                    $Body.HaloPSA.TicketType = @{
                        label = $Type.name
                        value = $Type.id
                    }
                }
            }
        } else {
            $Body = @{}
        }
    } catch {
        Write-Information (Get-CippException -Exception $_ | ConvertTo-Json)
        $Body = @{}
    }
    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $body
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListExtensionsConfig.ps1' 41
#Region './Public/Entrypoints/Invoke-ListExternalTenantInfo.ps1' -1

function Invoke-ListExternalTenantInfo {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $HttpResponse = [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = 'Default response, you should never see this'
    }

    try {
        if ($Request.Query.tenant) {
            $Tenant = $Request.Query.tenant

            # Normalize to tenantid and determine if tenant exists
            $TenantId = (Invoke-RestMethod -Method GET "https://login.windows.net/$Tenant/.well-known/openid-configuration").token_endpoint.Split('/')[3]

            if ($TenantId) {
                $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/findTenantInformationByTenantId(tenantId='$TenantId')" -NoAuthCheck $true -tenantid $env:TenantID
                $StatusCode = [HttpStatusCode]::OK
                $HttpResponse.Body = [PSCustomObject]@{
                    GraphRequest = $GraphRequest
                }
            } else {
                $HttpResponse.StatusCode = [HttpStatusCode]::BadRequest
                $HttpResponse.Body = "Tenant $($Tenant) not found"
            }
        } else {
            $HttpResponse.StatusCode = [HttpStatusCode]::BadRequest
            $HttpResponse.Body = 'Tenant parameter is required'
        }
    } catch {
        $HttpResponse.StatusCode = [HttpStatusCode]::InternalServerError
        $HttpResponse.Body = "Something went wrong while trying to get tenant info for tenant $($Tenant): $($_.Exception.Message)"
    }

    return [HttpResponseContext]$HttpResponse
}
#EndRegion './Public/Entrypoints/Invoke-ListExternalTenantInfo.ps1' 43
#Region './Public/Entrypoints/Invoke-ListFunctionParameters.ps1' -1

function Invoke-ListFunctionParameters {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $Module = $Request.Query.Module
    $Function = $Request.Query.Function

    $CommandQuery = @{}
    if ($Module) {
        $CommandQuery.Module = $Module
    }
    if ($Function) {
        $CommandQuery.Name = $Function
    }
    $IgnoreList = 'entryPoint', 'internal'
    $CommonParameters = @('Verbose', 'Debug', 'ErrorAction', 'WarningAction', 'InformationAction', 'ErrorVariable', 'WarningVariable', 'InformationVariable', 'OutVariable', 'OutBuffer', 'PipelineVariable', 'TenantFilter', 'APIName', 'Headers', 'ProgressAction', 'WhatIf', 'Confirm', 'Headers', 'NoAuthCheck')
    $TemporaryBlacklist = 'Get-CIPPAuthentication', 'Invoke-CippWebhookProcessing', 'Invoke-ListFunctionParameters', 'New-CIPPAPIConfig', 'New-CIPPGraphSubscription'
    try {
        if ($Module -eq 'ExchangeOnlineManagement') {
            $ExoRequest = @{
                AvailableCmdlets = $true
                tenantid         = $env:TenantID
                NoAuthCheck      = $true
            }
            if ($Request.Query.Compliance -eq $true) {
                $ExoRequest.Compliance = $true
            }
            $Functions = New-ExoRequest @ExoRequest
            #Write-Host $Functions
        } else {
            $Functions = Get-Command @CommandQuery | Where-Object { $_.Visibility -eq 'Public' }
        }
        $Results = foreach ($Function in $Functions) {
            if ($Function -In $TemporaryBlacklist) { continue }
            $GetHelp = @{
                Name = $Function
            }
            if ($Module -eq 'ExchangeOnlineManagement') {
                $GetHelp.Path = 'ExchangeOnlineHelp'
            }
            $Help = Get-Help @GetHelp
            $ParamsHelp = ($Help | Select-Object -ExpandProperty parameters).parameter | Select-Object name, @{n = 'description'; exp = { $_.description.Text } }
            if ($Help.Functionality -in $IgnoreList) { continue }
            if ($Help.Functionality -match 'Entrypoint') { continue }
            $Parameters = foreach ($Key in $Function.Parameters.Keys) {
                if ($CommonParameters -notcontains $Key) {
                    $Param = $Function.Parameters.$Key
                    $ParamHelp = $ParamsHelp | Where-Object { $_.name -eq $Key }
                    [PSCustomObject]@{
                        Name        = $Key
                        Type        = $Param.ParameterType.FullName
                        Description = $ParamHelp.description
                        Required    = $Param.Attributes.Mandatory
                    }
                }
            }
            [PSCustomObject]@{
                Function   = $Function.Name
                Synopsis   = $Help.Synopsis
                Parameters = @($Parameters)
            }
        }
        $StatusCode = [HttpStatusCode]::OK
        $Results
    } catch {
        $Results = "Function Error: $($_.Exception.Message)"
        $StatusCode = [HttpStatusCode]::BadRequest
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($Results)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListFunctionParameters.ps1' 80
#Region './Public/Entrypoints/Invoke-ListFunctionStats.ps1' -1

function Invoke-ListFunctionStats {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        $TenantFilter = $Request.Query.tenantFilter
        $PartitionKey = $Request.Query.FunctionType
        $Time = $Request.Query.Time
        $Interval = $Request.Query.Interval

        $Timestamp = if (![string]::IsNullOrEmpty($Interval) -and ![string]::IsNullOrEmpty($Time)) {
            switch ($Interval) {
                'Days' {
                    (Get-Date).AddDays(-$Time).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK')
                }
                'Hours' {
                    (Get-Date).AddHours(-$Time).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK')
                }
                'Minutes' {
                    (Get-Date).AddMinutes(-$Time).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK')
                }
            }
        } else {
            (Get-Date).AddDays(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK')
        }
        $Table = Get-CIPPTable -tablename 'CippFunctionStats'

        if (!$PartitionKey) { $PartitionKey = 'Durable' }
        if (![string]::IsNullOrEmpty($TenantFilter) -and $TenantFilter -ne 'AllTenants') {
            $TenantQuery = " and (tenant eq '{0}' or Tenant eq '{0}' or Tenantid eq '{0}' or tenantid eq '{0}')" -f $TenantFilter
        } else {
            $TenantQuery = ''
        }
        $Filter = "PartitionKey eq '{0}' and Start ge datetime'{1}'{2}" -f $PartitionKey, $Timestamp, $TenantQuery

        $Entries = Get-CIPPAzDataTableEntity @Table -Filter $Filter
        $FunctionList = $Entries | Group-Object -Property FunctionName
        $StandardList = $Entries | Where-Object { $_.Standard } | Group-Object -Property Standard
        $FunctionStats = foreach ($Function in $FunctionList) {
            $Stats = $Function.Group | Measure-Object -Property Duration -AllStats
            [PSCustomObject]@{
                'Name'           = $Function.Name
                'ExecutionCount' = $Function.Count
                'TotalSeconds'   = $Stats.Sum
                'MaxSeconds'     = $Stats.Maximum
                'AvgSeconds'     = $Stats.Average
            }
        }
        $StandardStats = foreach ($Standard in $StandardList) {
            $Stats = $Standard.Group | Measure-Object -Property Duration -AllStats
            [PSCustomObject]@{
                'Name'           = $Standard.Name
                'ExecutionCount' = $Standard.Count
                'TotalSeconds'   = $Stats.Sum
                'MaxSeconds'     = $Stats.Maximum
                'AvgSeconds'     = $Stats.Average
            }
        }
        $StatusCode = [HttpStatusCode]::OK
        $Body = @{
            Results  = @{
                Functions = @($FunctionStats)
                Standards = @($StandardStats)
            }
            Metadata = @{
                Filter = $Filter
            }
        }
    } catch {
        $StatusCode = [HttpStatusCode]::BadRequest
        $Body = @{
            Results  = @()
            Metadata = @{
                Filter    = $Filter
                Exception = $_.Exception.Message
            }
        }
    }

    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $Body
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListFunctionStats.ps1' 91
#Region './Public/Entrypoints/Invoke-ListGenericTestFunction.ps1' -1

function Invoke-ListGenericTestFunction {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $graphRequest = ($Headers.'x-ms-original-url').split('/api') | Select-Object -First 1

    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @($graphRequest)
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListGenericTestFunction.ps1' 21
#Region './Public/Entrypoints/Invoke-ListGraphExplorerPresets.ps1' -1

function Invoke-ListGraphExplorerPresets {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Headers = $Request.Headers


    $Username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($Headers.'x-ms-client-principal')) | ConvertFrom-Json).userDetails

    try {
        $Table = Get-CIPPTable -TableName 'GraphPresets'
        $Presets = Get-CIPPAzDataTableEntity @Table | Where-Object { $Username -eq $_.Owner -or $_.IsShared -eq $true } | Sort-Object -Property name
        $Results = foreach ($Preset in $Presets) {
            [PSCustomObject]@{
                id         = $Preset.Id
                name       = $Preset.name
                IsShared   = $Preset.IsShared
                IsMyPreset = $Preset.Owner -eq $Username
                Owner      = $Preset.Owner
                params     = (ConvertFrom-Json -InputObject $Preset.Params)
            }
        }

        if ($Request.Query.Endpoint) {
            $Endpoint = $Request.Query.Endpoint -replace '^/', ''
            $Results = $Results | Where-Object { ($_.params.endpoint -replace '^/', '') -eq $Endpoint }
        }
    } catch {
        Write-Warning "Could not list presets. $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        $Results = @()
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{
                Results  = @($Results)
                Metadata = @{
                    Count = ($Results | Measure-Object).Count
                }
            }
        })
}
#EndRegion './Public/Entrypoints/Invoke-ListGraphExplorerPresets.ps1' 48
#Region './Public/Entrypoints/Invoke-ListHaloClients.ps1' -1

Function Invoke-ListHaloClients {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Extension.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    try {
        $Table = Get-CIPPTable -TableName Extensionsconfig
        $Configuration = ((Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json).HaloPSA
        $Token = Get-HaloToken -configuration $Configuration
        $i = 1
        $RawHaloClients = do {
            $Result = Invoke-RestMethod -Uri "$($Configuration.ResourceURL)/Client?page_no=$i&page_size=999&pageinate=true" -ContentType 'application/json' -Method GET -Headers @{Authorization = "Bearer $($Token.access_token)" }
            $Result.clients | Select-Object * -ExcludeProperty logo
            $i++
            $PageCount = [Math]::Ceiling($Result.record_count / 999)
        } while ($i -le $PageCount)
        $HaloClients = $RawHaloClients | ForEach-Object {
            [PSCustomObject]@{
                label = $_.name
                value = $_.id
            }
        }
        Write-Host "Found $($HaloClients.Count) Halo Clients"
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $HaloClients = $ErrorMessage
    }

    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($HaloClients)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListHaloClients.ps1' 42
#Region './Public/Entrypoints/Invoke-ListIntuneIntents.ps1' -1

Function Invoke-ListIntuneIntents {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.MEM.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/Intents?`$expand=settings,categories" -tenantid $TenantFilter
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }

    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListIntuneIntents.ps1' 28
#Region './Public/Entrypoints/Invoke-ListIPWhitelist.ps1' -1

Function Invoke-ListIPWhitelist {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CippTable -tablename 'trustedIps'
    $body = Get-CIPPAzDataTableEntity @Table

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($body)
        }
}
#EndRegion './Public/Entrypoints/Invoke-ListIPWhitelist.ps1' 18
#Region './Public/Entrypoints/Invoke-ListKnownIPDb.ps1' -1

Function Invoke-ListKnownIPDb {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter


    $Table = Get-CIPPTable -TableName 'knownlocationdbv2'
    $Filter = "Tenant eq '$($TenantFilter)'"
    $KnownIPDb = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($KnownIPDb)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListKnownIPDb.ps1' 24
#Region './Public/Entrypoints/Invoke-ListLogs.ps1' -1

function Invoke-ListLogs {
    <#
    .FUNCTIONALITY
        Entrypoint,AnyTenant
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable

    $TemplatesTable = Get-CIPPTable -tablename 'templates'
    $Templates = Get-CIPPAzDataTableEntity @TemplatesTable

    $ReturnedLog = if ($Request.Query.ListLogs) {
        Get-AzDataTableEntity @Table -Property PartitionKey | Sort-Object -Unique PartitionKey | Select-Object PartitionKey | ForEach-Object {
            @{
                value = $_.PartitionKey
                label = $_.PartitionKey
            }
        }
    } elseif ($Request.Query.logentryid) {
        # Return single log entry by RowKey
        $Filter = "RowKey eq '{0}'" -f $Request.Query.logentryid
        $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList
        Write-Host "Getting single log entry for RowKey: $($Request.Query.logentryid)"

        $Row = Get-AzDataTableEntity @Table -Filter $Filter

        if ($Row) {
            if ($AllowedTenants -notcontains 'AllTenants') {
                $TenantList = Get-Tenants -IncludeErrors | Where-Object { $_.customerId -in $AllowedTenants }
            }

            if ($AllowedTenants -contains 'AllTenants' -or ($AllowedTenants -notcontains 'AllTenants' -and ($TenantList.defaultDomainName -contains $Row.Tenant -or $Row.Tenant -eq 'CIPP' -or $TenantList.customerId -contains $Row.TenantId)) ) {

                if ($Row.StandardTemplateId) {
                    $Standard = ($Templates | Where-Object { $_.RowKey -eq $Row.StandardTemplateId }).JSON | ConvertFrom-Json

                    $StandardInfo = @{
                        Template = $Standard.templateName
                        Standard = $Row.Standard
                    }

                    if ($Row.IntuneTemplateId) {
                        $IntuneTemplate = ($Templates | Where-Object { $_.RowKey -eq $Row.IntuneTemplateId }).JSON | ConvertFrom-Json
                        $StandardInfo.IntunePolicy = $IntuneTemplate.displayName
                    }
                    if ($Row.ConditionalAccessTemplateId) {
                        $ConditionalAccessTemplate = ($Templates | Where-Object { $_.RowKey -eq $Row.ConditionalAccessTemplateId }).JSON | ConvertFrom-Json
                        $StandardInfo.ConditionalAccessPolicy = $ConditionalAccessTemplate.displayName
                    }

                } else {
                    $StandardInfo = @{}
                }

                $LogData = if ($Row.LogData -and (Test-Json -Json $Row.LogData -ErrorAction SilentlyContinue)) {
                    $Row.LogData | ConvertFrom-Json
                } else { $Row.LogData }
                [PSCustomObject]@{
                    DateTime = $Row.Timestamp
                    Tenant   = $Row.Tenant
                    API      = $Row.API
                    Message  = $Row.Message
                    User     = $Row.Username
                    Severity = $Row.Severity
                    LogData  = $LogData
                    TenantID = if ($Row.TenantID -ne $null) {
                        $Row.TenantID
                    } else {
                        'None'
                    }
                    AppId    = $Row.AppId
                    IP       = $Row.IP
                    RowKey   = $Row.RowKey
                    Standard = $StandardInfo
                }
            }
        }
    } else {
        if ($request.Query.Filter -eq 'True') {
            $LogLevel = if ($Request.Query.Severity) { ($Request.query.Severity).split(',') } else { 'Info', 'Warn', 'Error', 'Critical', 'Alert' }
            $PartitionKey = $Request.Query.DateFilter
            $username = $Request.Query.User ?? '*'
            $TenantFilter = $Request.Query.Tenant
            $ApiFilter = $Request.Query.API
            $StandardFilter = $Request.Query.StandardTemplateId
            $ScheduledTaskFilter = $Request.Query.ScheduledTaskId

            $StartDate = $Request.Query.StartDate ?? $Request.Query.DateFilter
            $EndDate = $Request.Query.EndDate ?? $Request.Query.DateFilter

            if ($StartDate -and $EndDate) {
                # Collect logs for each partition key date in range
                $PartitionKeys = for ($Date = [datetime]::ParseExact($StartDate, 'yyyyMMdd', $null); $Date -le [datetime]::ParseExact($EndDate, 'yyyyMMdd', $null); $Date = $Date.AddDays(1)) {
                    $PartitionKey = $Date.ToString('yyyyMMdd')
                    "PartitionKey eq '$PartitionKey'"
                }
                $Filter = $PartitionKeys -join ' or '
            } elseif ($StartDate) {
                $Filter = "PartitionKey eq '{0}'" -f $StartDate
            } else {
                $Filter = "PartitionKey eq '{0}'" -f (Get-Date -UFormat '%Y%m%d')
            }
        } else {
            $LogLevel = 'Info', 'Warn', 'Error', 'Critical', 'Alert'
            $PartitionKey = Get-Date -UFormat '%Y%m%d'
            $username = '*'
            $TenantFilter = $null
            $Filter = "PartitionKey eq '{0}'" -f $PartitionKey
        }
        $AllowedTenants = Test-CIPPAccess -Request $Request -TenantList
        Write-Host "Getting logs for filter: $Filter, LogLevel: $LogLevel, Username: $username"

        $Rows = Get-AzDataTableEntity @Table -Filter $Filter | Where-Object {
            $_.Severity -in $LogLevel -and
            $_.Username -like $username -and
            ([string]::IsNullOrEmpty($TenantFilter) -or $TenantFilter -eq 'AllTenants' -or $_.Tenant -like "*$TenantFilter*" -or $_.TenantID -eq $TenantFilter) -and
            ([string]::IsNullOrEmpty($ApiFilter) -or $_.API -match "$ApiFilter") -and
            ([string]::IsNullOrEmpty($StandardFilter) -or $_.StandardTemplateId -eq $StandardFilter) -and
            ([string]::IsNullOrEmpty($ScheduledTaskFilter) -or $_.ScheduledTaskId -eq $ScheduledTaskFilter)
        }

        if ($AllowedTenants -notcontains 'AllTenants') {
            $TenantList = Get-Tenants -IncludeErrors | Where-Object { $_.customerId -in $AllowedTenants }
        }

        foreach ($Row in $Rows) {
            if ($AllowedTenants -contains 'AllTenants' -or ($AllowedTenants -notcontains 'AllTenants' -and ($TenantList.defaultDomainName -contains $Row.Tenant -or $Row.Tenant -eq 'CIPP' -or $TenantList.customerId -contains $Row.TenantId)) ) {
                if ($StandardTaskFilter -and $Row.StandardTemplateId) {
                    $Standard = ($Templates | Where-Object { $_.RowKey -eq $Row.StandardTemplateId }).JSON | ConvertFrom-Json

                    $StandardInfo = @{
                        Template = $Standard.templateName
                        Standard = $Row.Standard
                    }

                    if ($Row.IntuneTemplateId) {
                        $IntuneTemplate = ($Templates | Where-Object { $_.RowKey -eq $Row.IntuneTemplateId }).JSON | ConvertFrom-Json
                        $StandardInfo.IntunePolicy = $IntuneTemplate.displayName
                    }
                    if ($Row.ConditionalAccessTemplateId) {
                        $ConditionalAccessTemplate = ($Templates | Where-Object { $_.RowKey -eq $Row.ConditionalAccessTemplateId }).JSON | ConvertFrom-Json
                        $StandardInfo.ConditionalAccessPolicy = $ConditionalAccessTemplate.displayName
                    }
                } else {
                    $StandardInfo = @{}
                }

                $LogData = if ($Row.LogData -and (Test-Json -Json $Row.LogData -ErrorAction SilentlyContinue)) {
                    $Row.LogData | ConvertFrom-Json
                } else { $Row.LogData }
                [PSCustomObject]@{
                    DateTime     = $Row.Timestamp
                    Tenant       = $Row.Tenant
                    API          = $Row.API
                    Message      = $Row.Message
                    User         = $Row.Username
                    Severity     = $Row.Severity
                    LogData      = $LogData
                    TenantID     = if ($Row.TenantID -ne $null) {
                        $Row.TenantID
                    } else {
                        'None'
                    }
                    AppId        = $Row.AppId
                    IP           = $Row.IP
                    RowKey       = $Row.RowKey
                    StandardInfo = $StandardInfo
                }
            }
        }
    }

    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = @($ReturnedLog | Sort-Object -Property DateTime -Descending)
    }

}
#EndRegion './Public/Entrypoints/Invoke-ListLogs.ps1' 182
#Region './Public/Entrypoints/Invoke-ListNamedLocations.ps1' -1

Function Invoke-ListNamedLocations {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.ConditionalAccess.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.TenantFilter
    try {
        $GraphRequest = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -Tenantid $tenantfilter | Select-Object *,
        @{
            name       = 'rangeOrLocation'
            expression = { if ($_.ipRanges) { $_.ipranges.cidrAddress -join ', ' } else { $_.countriesAndRegions -join ', ' } }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage

    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @($GraphRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListNamedLocations.ps1' 31
#Region './Public/Entrypoints/Invoke-ListNotificationConfig.ps1' -1

Function Invoke-ListNotificationConfig {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.AppSettings.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    $Table = Get-CIPPTable -TableName SchedulerConfig
    $Filter = "RowKey eq 'CippNotifications' and PartitionKey eq 'CippNotifications'"
    $Config = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    if ($Config) {
        $Config = $Config | ConvertTo-Json -Depth 10 | ConvertFrom-Json -Depth 10 -AsHashtable
    } else {
        $Config = @{}
    }
    #$config | Add-Member -NotePropertyValue @() -NotePropertyName 'logsToInclude' -Force
    $config.logsToInclude = @(([pscustomobject]$config | Select-Object * -ExcludeProperty schedule, type, tenantid, onepertenant, sendtoIntegration, partitionkey, rowkey, tenant, ETag, email, logsToInclude, Severity, Alert, Info, Error, timestamp, webhook, includeTenantId).psobject.properties.name)
    if (!$config.logsToInclude) {
        $config.logsToInclude = @('None')
    }
    if (!$config.Severity) {
        $config.Severity = @('Alert')
    } else {
        $config.Severity = $config.Severity -split ','
    }
    $body = [PSCustomObject]$Config

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListNotificationConfig.ps1' 36
#Region './Public/Entrypoints/Invoke-ListOrg.ps1' -1

Function Invoke-ListOrg {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Core.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    if ($TenantFilter -eq 'AllTenants') {
        $GraphRequest = @()
    } else {
        $GraphRequest = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/organization' -tenantid $TenantFilter
    }

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $GraphRequest
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListOrg.ps1' 24
#Region './Public/Entrypoints/Invoke-ListPartnerRelationships.ps1' -1

Function Invoke-ListPartnerRelationships {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Relationship.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        $GraphRequestList = @{
            Endpoint            = 'policies/crossTenantAccessPolicy/partners'
            TenantFilter        = $TenantFilter
            QueueNameOverride   = 'Partner Relationships'
            ReverseTenantLookup = $true
        }
        $GraphRequest = Get-GraphRequestList @GraphRequestList
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $GraphRequest = @()
        $StatusCode = [HttpStatusCode]::Forbidden
    }


    $Results = [PSCustomObject]@{
        Results = @($GraphRequest)
    }
    return [HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = $Results
        }
}
#EndRegion './Public/Entrypoints/Invoke-ListPartnerRelationships.ps1' 36
#Region './Public/Entrypoints/Invoke-ListPendingWebhooks.ps1' -1

function Invoke-ListPendingWebhooks {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    try {
        $Table = Get-CIPPTable -TableName 'WebhookIncoming'
        $Webhooks = Get-CIPPAzDataTableEntity @Table
        $Results = $Webhooks | Select-Object -ExcludeProperty RowKey, PartitionKey, ETag, Timestamp
        $PendingWebhooks = foreach ($Result in $Results) {
            foreach ($Property in $Result.PSObject.Properties.Name) {
                if (Test-Json -Json $Result.$Property -ErrorAction SilentlyContinue) {
                    $Result.$Property = $Result.$Property | ConvertFrom-Json
                }
            }
            $Result
        }
    } catch {
        $PendingWebhooks = @()
    }
    return ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @{
                Results  = @($PendingWebhooks)
                Metadata = @{
                    Count = ($PendingWebhooks | Measure-Object).Count
                }
            }
        })
}
#EndRegion './Public/Entrypoints/Invoke-ListPendingWebhooks.ps1' 35
#Region './Public/Entrypoints/Invoke-ListPotentialApps.ps1' -1

Function Invoke-ListPotentialApps {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Endpoint.Application.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    if ($request.body.type -eq 'WinGet') {
        $body = @"
{"MaximumResults":50,"Filters":[{"PackageMatchField":"Market","RequestMatch":{"KeyWord":"US","MatchType":"CaseInsensitive"}}],"Query":{"KeyWord":"$($Request.Body.SearchString)","MatchType":"Substring"}}
"@
        $DataRequest = (Invoke-RestMethod -Uri 'https://storeedgefd.dsx.mp.microsoft.com/v9.0/manifestSearch' -Method POST -Body $body -ContentType 'Application/json').data | Select-Object @{l = 'applicationName'; e = { $_.packagename } }, @{l = 'packagename'; e = { $_.packageIdentifier } } | Sort-Object -Property applicationName
    }

    if ($Request.Body.type -eq 'Choco') {
        $DataRequest = Invoke-RestMethod -Uri "https://community.chocolatey.org/api/v2/Search()?`$filter=IsLatestVersion&`$skip=0&`$top=999&searchTerm=%27$($Request.Body.SearchString)%27&targetFramework=%27%27&includePrerelease=false" -ContentType 'application/json' | Select-Object @{l = 'applicationName'; e = { $_.properties.Title } }, @{l = 'packagename'; e = { $_.title.'#text' } } | Sort-Object -Property applicationName
    }


    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = @($DataRequest)
        }

}
#EndRegion './Public/Entrypoints/Invoke-ListPotentialApps.ps1' 28
#Region './Public/Entrypoints/Invoke-ListRoles.ps1' -1

function Invoke-ListRoles {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Identity.Role.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter

    try {
        [System.Collections.Generic.List[PSCustomObject]]$Roles = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/directoryRoles?`$expand=members" -tenantid $TenantFilter
        $GraphRequest = foreach ($Role in $Roles) {
            $Members = if ($Role.members) {
                $Role.members | ForEach-Object { [PSCustomObject]@{
                        displayName       = $_.displayName
                        userPrincipalName = $_.userPrincipalName
                        id                = $_.id
                    } }
            }
            [PSCustomObject]@{
                Id             = $Role.id
                roleTemplateId = $Role.roleTemplateId
                DisplayName    = $Role.displayName
                Description    = $Role.description
                Members        = @($Members)
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        "Failed to list roles for tenant $TenantFilter. $($ErrorMessage.NormalizedError)"
        $StatusCode = [HttpStatusCode]::BadRequest
    }

    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $GraphRequest
    }
}
#EndRegion './Public/Entrypoints/Invoke-ListRoles.ps1' 43
#Region './Public/Entrypoints/Invoke-ListTenantAllowBlockList.ps1' -1

function Invoke-ListTenantAllowBlockList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)
    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Query.tenantFilter
    $ListTypes = 'Sender', 'Url', 'FileHash', 'IP'
    try {
        if ($TenantFilter -ne 'AllTenants') {
            $Results = $ListTypes | ForEach-Object -Parallel {
                Import-Module CIPPCore
                $TempResults = New-ExoRequest -tenantid $using:TenantFilter -cmdlet 'Get-TenantAllowBlockListItems' -cmdParams @{ ListType = $_ }
                $TempResults | Add-Member -MemberType NoteProperty -Name ListType -Value $_ -Force
                $TempResults | Add-Member -MemberType NoteProperty -Name Tenant -Value $using:TenantFilter -Force
                $TempResults | Select-Object -ExcludeProperty *'@data.type'*, *'(DateTime])'*
            } -ThrottleLimit 5
            $Metadata = [PSCustomObject]@{}
        } else {
            $Table = Get-CIPPTable -TableName 'cacheTenantAllowBlockList'
            $PartitionKey = 'TenantAllowBlockList'
            $Filter = "PartitionKey eq '$PartitionKey'"
            $Rows = Get-CIPPAzDataTableEntity @Table -filter $Filter | Where-Object -Property Timestamp -GT (Get-Date).AddMinutes(-60)
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            if ($RunningQueue) {
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Still loading data for all tenants. Please check back in a few more minutes'
                    QueueId      = $RunningQueue.RowKey
                }
                $Results = @()
            } elseif (!$Rows -and !$RunningQueue) {
                $TenantList = Get-Tenants -IncludeErrors
                $Queue = New-CippQueueEntry -Name 'Tenant Allow/Block List - All Tenants' -Link '/tenant/administration/allow-block-list?customerId=AllTenants' -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                $Metadata = [PSCustomObject]@{
                    QueueMessage = 'Loading data for all tenants. Please check back in a few minutes'
                    QueueId      = $Queue.RowKey
                }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'TenantAllowBlockListOrchestrator'
                    QueueFunction    = @{
                        FunctionName = 'GetTenants'
                        QueueId      = $Queue.RowKey
                        TenantParams = @{
                            IncludeErrors = $true
                        }
                        DurableName  = 'ListTenantAllowBlockListAllTenants'
                    }
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress) | Out-Null
                $Results = @()
            } else {
                $TenantList = Get-Tenants -IncludeErrors
                $Rows = $Rows | Where-Object { $TenantList.defaultDomainName -contains $_.Tenant }
                $Metadata = [PSCustomObject]@{
                    QueueId = $RunningQueue.RowKey ?? $null
                }
                $Results = foreach ($Row in $Rows) {
                    $Row.Entry | ConvertFrom-Json
                }
            }
        }
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $Results = $ErrorMessage
    }

    if (!$Body) {
        $Body = [PSCustomObject]@{
            Results  = @($Results)
            Metadata = $Metadata
        }
    }

    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = $Body
    }
}
#EndRegion './Public/Entrypoints/Invoke-ListTenantAllowBlockList.ps1' 87
#Region './Public/Entrypoints/Invoke-ListUsersAndGroups.ps1' -1

function Invoke-ListUsersAndGroups {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Tenant.Directory.Read
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $TenantFilter = $Request.Query.TenantFilter
    $select = 'id,displayName,userPrincipalName'

    try {
        # Build batch requests for users and groups
        $BulkRequests = @(
            @{
                id     = 'users'
                method = 'GET'
                url    = "users?`$select=$select&`$top=999&"
            }
            @{
                id     = 'groups'
                method = 'GET'
                url    = "groups?`$select=id,displayName&`$top=999"
            }
        )
        $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $TenantFilter
        $Users = ($BulkResults | Where-Object { $_.id -eq 'users' }).body.value | Select-Object *, @{Name = '@odata.type'; Expression = { '#microsoft.graph.user' } }
        $Groups = ($BulkResults | Where-Object { $_.id -eq 'groups' }).body.value | Select-Object id, displayName, @{Name = 'userPrincipalName'; Expression = { $null } }, @{Name = '@odata.type'; Expression = { '#microsoft.graph.group' } }
        $GraphRequest = @($Users) + @($Groups) | Sort-Object displayName
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        $StatusCode = [HttpStatusCode]::Forbidden
        $GraphRequest = $ErrorMessage
    }
    return [HttpResponseContext]@{
        StatusCode = $StatusCode
        Body       = @($GraphRequest)
    }
}
#EndRegion './Public/Entrypoints/Invoke-ListUsersAndGroups.ps1' 43
#Region './Public/Entrypoints/Invoke-PublicPhishingCheck.ps1' -1

function Invoke-PublicPhishingCheck {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Public
    #>
    [CmdletBinding()]

    #this has been switched to the external free service by cyberdrain at clone.cipp.app due to extreme numbers of executions if selfhosted.
    param($Request, $TriggerMetadata)

    $Tenant = Get-Tenants -TenantFilter $Request.body.TenantId

    if ($Request.body.Cloned -and $Tenant.customerId -eq $Request.body.TenantId) {
        Write-AlertMessage -message $Request.body.AlertMessage -sev 'Alert' -tenant $Request.body.TenantId
    } elseif ($Request.Body.source -and $Tenant) {
        $table = Get-CIPPTable -tablename CheckExtensionAlerts
        $Message = "Alert received from $($Request.Body.source) for $($Request.body.TenantId)"
        $ID = (New-Guid).GUID
        $TableBody = @{
            RowKey                   = "$ID"
            PartitionKey             = 'CheckAlert'
            tenantFilter             = [string]$Tenant.defaultDomainName
            message                  = [string]$Message
            type                     = [string]$request.body.type
            url                      = [string]$request.body.url
            reason                   = [string]$request.body.reason
            score                    = [string]$request.body.score
            threshold                = [string]$request.body.threshold
            potentialUserName        = [string]$request.body.userEmail
            potentialUserDisplayName = [string]$request.body.userDisplayName
            reportedByIP             = [string]$Request.headers.'x-forwarded-for'
            rawBody                  = "$($Request.body | ConvertTo-Json)"
        }
        $null = Add-CIPPAzDataTableEntity @table -Entity $TableBody -Force
        Write-AlertTrace -cmdletName 'CheckExtentionAlert' -tenantFilter $Tenant.defaultDomainName -data $TableBody
        #Write-AlertMessage -message $Message -sev 'Alert' -tenant $Tenant.customerId -LogData $Request.body
    }

    return [HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = 'OK'
    }
}
#EndRegion './Public/Entrypoints/Invoke-PublicPhishingCheck.ps1' 46
#Region './Public/Entrypoints/Invoke-RemoveTenantAllowBlockList.ps1' -1

function Invoke-RemoveTenantAllowBlockList {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        Exchange.SpamFilter.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    $Headers = $Request.Headers


    # Interact with query parameters or the body of the request.
    $TenantFilter = $Request.Body.tenantFilter
    $Entries = $Request.Body.Entries
    $ListType = $Request.Body.ListType

    try {

        Write-Host "List type is $listType"
        $ExoRequest = @{
            tenantid  = $TenantFilter
            cmdlet    = 'Remove-TenantAllowBlockListItems'
            cmdParams = @{
                Entries  = @($Entries)
                ListType = $ListType
            }
        }

        $Results = New-ExoRequest @ExoRequest
        Write-Host $Results

        $Result = "Successfully removed $($Entries) with type $ListType from Block/Allow list"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
        $StatusCode = [HttpStatusCode]::OK
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to remove $($Entries) type $ListType. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        $StatusCode = [HttpStatusCode]::Forbidden
    }

    return ([HttpResponseContext]@{
            StatusCode = $StatusCode
            Body       = @{
                'Results' = $Result
                # 'Request' = $ExoRequest
            }
        })
}
#EndRegion './Public/Entrypoints/Invoke-RemoveTenantAllowBlockList.ps1' 53
#Region './Public/Entrypoints/Orchestrator Functions/Start-ApplicationOrchestrator.ps1' -1

function Start-ApplicationOrchestrator {
    <#
    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param()

    Write-LogMessage -API 'IntuneApps' -message 'Started uploading applications to tenants' -sev Info
    Write-Information 'Started uploading applications to tenants'
    $InputObject = [PSCustomObject]@{
        OrchestratorName = 'ApplicationOrchestrator'
        SkipLog          = $true
        QueueFunction    = @{
            FunctionName = 'GetApplicationQueue'
        }
    }

    if ($PSCmdlet.ShouldProcess('Upload Applications')) {
        return Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-ApplicationOrchestrator.ps1' 23
#Region './Public/Entrypoints/Orchestrator Functions/Start-AuditLogOrchestrator.ps1' -1

function Start-AuditLogOrchestrator {
    <#
    .SYNOPSIS
    Start the Audit Log Polling Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    try {
        $AuditLogSearchesTable = Get-CIPPTable -TableName 'AuditLogSearches'
        $15MinutesAgo = (Get-Date).AddMinutes(-15).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        $1DayAgo = (Get-Date).AddDays(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        $AuditLogSearches = Get-CIPPAzDataTableEntity @AuditLogSearchesTable -Filter "(CippStatus eq 'Pending' or (CippStatus eq 'Processing' and Timestamp le datetime'$15MinutesAgo')) and Timestamp ge datetime'$1DayAgo'" -Property PartitionKey, RowKey, Tenant, CippStatus, Timestamp

        $WebhookRulesTable = Get-CIPPTable -TableName 'WebhookRules'
        $WebhookRules = Get-CIPPAzDataTableEntity @WebhookRulesTable

        if (($AuditLogSearches | Measure-Object).Count -eq 0) {
            Write-Information 'No audit log searches available'
        } elseif (($AuditLogSearches | Measure-Object).Count -eq 0 -and ($WebhookRules | Measure-Object).Count -eq 0) {
            Write-Information 'No webhook rules defined'
        } else {
            Write-Information "Audit Logs: Downloading $($AuditLogSearches.Count) searches"
            if ($PSCmdlet.ShouldProcess('Start-AuditLogOrchestrator', 'Starting Audit Log Polling')) {
                $Queue = New-CippQueueEntry -Name 'Audit Logs Download' -Reference 'AuditLogsDownload' -TotalTasks ($AuditLogSearches).Count
                $Batch = $AuditLogSearches | Sort-Object -Property Tenant -Unique | Select-Object @{Name = 'TenantFilter'; Expression = { $_.Tenant } }, @{Name = 'QueueId'; Expression = { $Queue.RowKey } }, @{Name = 'FunctionName'; Expression = { 'AuditLogTenantDownload' } }
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'AuditLogsDownload'
                    Batch            = @($Batch)
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
            }
        }
    } catch {
        Write-LogMessage -API 'Audit Logs' -message 'Error processing audit logs' -sev Error -LogData (Get-CippException -Exception $_)
        Write-Information ( 'Audit logs error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-AuditLogOrchestrator.ps1' 42
#Region './Public/Entrypoints/Orchestrator Functions/Start-AuditLogProcessingOrchestrator.ps1' -1

function Start-AuditLogProcessingOrchestrator {
    <#
    .SYNOPSIS
    Start the Audit Log Processing Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    Write-Information 'Starting audit log processing in batches of 1000, per tenant'
    $WebhookCacheTable = Get-CippTable -TableName 'CacheWebhooks'

    $DataTableQuery = @{
        First = 20000
        Skip  = 0
    }

    do {
        $WebhookCache = Get-CIPPAzDataTableEntity @WebhookCacheTable @DataTableQuery
        $TenantGroups = $WebhookCache | Group-Object -Property PartitionKey

        if ($TenantGroups) {
            Write-Information "Processing webhook cache for $($TenantGroups.Count) tenants"
            #Write-Warning "AuditLogJobs are: $($TenantGroups.Count) tenants. Tenants: $($TenantGroups.name | ConvertTo-Json -Compress) "
            #Write-Warning "Here are the groups: $($TenantGroups | ConvertTo-Json -Compress)"
            $ProcessQueue = New-CippQueueEntry -Name 'Audit Logs Process' -Reference 'AuditLogsProcess' -TotalTasks ($TenantGroups | Measure-Object -Property Count -Sum).Sum
            $ProcessBatch = foreach ($TenantGroup in $TenantGroups) {
                $TenantFilter = $TenantGroup.Name
                $RowIds = @($TenantGroup.Group.RowKey)
                for ($i = 0; $i -lt $RowIds.Count; $i += 1000) {
                    Write-Host "Processing $TenantFilter with $($RowIds.Count) row IDs. We're processing id $($RowIds[$i]) to $($RowIds[[Math]::Min($i + 999, $RowIds.Count - 1)])"
                    $BatchRowIds = $RowIds[$i..([Math]::Min($i + 999, $RowIds.Count - 1))]
                    [PSCustomObject]@{
                        TenantFilter = $TenantFilter
                        RowIds       = $BatchRowIds
                        QueueId      = $ProcessQueue.RowKey
                        FunctionName = 'AuditLogTenantProcess'
                    }
                }
            }
            if ($ProcessBatch) {
                $ProcessInputObject = [PSCustomObject]@{
                    OrchestratorName = 'AuditLogTenantProcess'
                    Batch            = @($ProcessBatch)
                    SkipLog          = $true
                }
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($ProcessInputObject | ConvertTo-Json -Depth 5 -Compress)
                Write-Information "Started audit log processing orchestration with $($ProcessBatch.Count) batches"
            }
        }

        if ($WebhookCache.Count -lt 20000) {
            Write-Information 'No more rows to process'
            break
        }
        Write-Information "Processed $($WebhookCache.Count) rows"
        $DataTableQuery.Skip += 20000
        Write-Information "Getting next batch of $($DataTableQuery.First) rows"
    } while ($WebhookCache.Count -eq 20000)
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-AuditLogProcessingOrchestrator.ps1' 62
#Region './Public/Entrypoints/Orchestrator Functions/Start-AuditLogSearchCreation.ps1' -1

function Start-AuditLogSearchCreation {
    <#
    .SYNOPSIS
    Start the Audit Log Searches

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    try {
        $ConfigTable = Get-CippTable -TableName 'WebhookRules'
        $ConfigEntries = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'Webhookv2'" | ForEach-Object {
            $ConfigEntry = $_
            if (!$ConfigEntry.excludedTenants) {
                $ConfigEntry | Add-Member -MemberType NoteProperty -Name 'excludedTenants' -Value @() -Force
            } else {
                $ConfigEntry.excludedTenants = $ConfigEntry.excludedTenants | ConvertFrom-Json
            }
            $ConfigEntry.Tenants = $ConfigEntry.Tenants | ConvertFrom-Json
            $ConfigEntry
        }

        $TenantList = Get-Tenants -IncludeErrors
        # Round time down to nearest minute
        $Now = Get-Date
        $StartTime = ($Now.AddSeconds(-$Now.Seconds)).AddHours(-1)
        $EndTime = $Now.AddSeconds(-$Now.Seconds)

        Write-Information 'Audit Logs: Creating new searches'

        $Batch = foreach ($Tenant in $TenantList) {
            Write-Information "Processing tenant $($Tenant.defaultDomainName) - $($Tenant.customerId)"
            $TenantInConfig = $false
            $MatchingConfigs = [System.Collections.Generic.List[object]]::new()
            foreach ($ConfigEntry in $ConfigEntries) {
                if ($ConfigEntry.excludedTenants.value -contains $Tenant.defaultDomainName) {
                    continue
                }
                $TenantsList = Expand-CIPPTenantGroups -TenantFilter ($ConfigEntry.Tenants)
                if ($TenantsList.value -contains $Tenant.defaultDomainName -or $TenantsList.value -contains 'AllTenants') {
                    $TenantInConfig = $true
                    $MatchingConfigs.Add($ConfigEntry)
                }
            }

            if (!$TenantInConfig) {
                Write-Information "Tenant $($Tenant.defaultDomainName) has no configured audit log rules, skipping search creation."
                continue
            }

            if ($MatchingConfigs) {
                [PSCustomObject]@{
                    FunctionName   = 'AuditLogSearchCreation'
                    Tenant         = $Tenant | Select-Object defaultDomainName, customerId, displayName
                    StartTime      = $StartTime
                    EndTime        = $EndTime
                    ServiceFilters = @($MatchingConfigs | Select-Object -Property type | Sort-Object -Property type -Unique | ForEach-Object { $_.type.split('.')[1] })
                }
            }
        }

        if (($Batch | Measure-Object).Count -gt 0) {
            $InputObject = [PSCustomObject]@{
                Batch            = @($Batch)
                OrchestratorName = 'AuditLogSearchCreation'
                SkipLog          = $true
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
            Write-Information "Started Audit Log search creation orchestratorwith $($Batch.Count) tenants"
        } else {
            Write-Information 'No tenants found for Audit Log search creation'
        }
    } catch {
        Write-LogMessage -API 'Audit Logs' -message 'Error creating audit log searches' -sev Error -LogData (Get-CippException -Exception $_)
        Write-Information ( 'Audit logs error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-AuditLogSearchCreation.ps1' 79
#Region './Public/Entrypoints/Orchestrator Functions/Start-BPAOrchestrator.ps1' -1

function Start-BPAOrchestrator {
    <#
    .SYNOPSIS
        Start the Best Practice Analyser
    .DESCRIPTION
        This function starts the Best Practice Analyser
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter = 'AllTenants',
        [switch]$Force
    )

    try {
        if ($TenantFilter -ne 'AllTenants') {
            Write-Verbose "TenantFilter: $TenantFilter"
            if ($TenantFilter -notmatch '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {
                $TenantFilter = @($TenantFilter)
            } else {
                Write-Verbose 'Got GUID: Looking up tenant'
                $TenantFilter = Get-Tenants -TenantFilter $TenantFilter | Select-Object -ExpandProperty defaultDomainName
            }
            $TenantList = @($TenantFilter)
            $Name = "Best Practice Analyser ($TenantFilter)"
        } else {
            $TenantList = (Get-Tenants).defaultDomainName
            $Name = 'Best Practice Analyser'
        }

        Write-Verbose 'Getting BPA templates'


        $BPATemplateTable = Get-CippTable -tablename 'templates'
        $Filter = "PartitionKey eq 'BPATemplate'"
        try {
            $TemplateRows = Get-CIPPAzDataTableEntity @BPATemplateTable -Filter $Filter

            if (!$TemplateRows) {
                $null = Get-ChildItem 'Config\*.BPATemplate.json' | ForEach-Object {
                    $TemplateJson = Get-Content $_ | ConvertFrom-Json | ConvertTo-Json -Compress -Depth 10
                    $Entity = @{
                        JSON         = "$TemplateJson"
                        RowKey       = "$($_.name)"
                        PartitionKey = 'BPATemplate'
                        GUID         = "$($_.name)"
                    }
                    Add-CIPPAzDataTableEntity @BPATemplateTable -Entity $Entity -Force
                }
                $TemplateRows = Get-CIPPAzDataTableEntity @BPATemplateTable -Filter $Filter
            }

            $Templates = ($TemplateRows.JSON | ConvertFrom-Json).Name
        } catch {
            Write-LogMessage -API 'BestPracticeAnalyser' -message 'Could not get BPA templates' -sev Error
            return $false
        }
        Write-Verbose 'Creating orchestrator batch'
        $BPAReports = foreach ($Tenant in $TenantList) {
            foreach ($Template in $Templates) {
                [PSCustomObject]@{
                    FunctionName = 'BPACollectData'
                    Tenant       = $Tenant
                    Template     = $Template
                    QueueName    = '{0} - {1}' -f $Template, $Tenant
                }
            }
        }

        if ($Force.IsPresent) {
            Write-Host 'Clearing Rerun Cache'
            foreach ($Report in $BPAReports) {
                $null = Test-CIPPRerun -Type BPA -Tenant $Report.Tenant -API $Report.Template -Clear
            }
        }

        if (($BPAReports | Measure-Object).Count -eq 0) {
            Write-Information 'No BPA reports to run'
            return 0
        }

        if ($PSCmdlet.ShouldProcess($Name, 'Starting Orchestrator')) {
            Write-LogMessage -API 'BestPracticeAnalyser' -message 'Starting Best Practice Analyser' -sev Info
            $Queue = New-CippQueueEntry -Name $Name -TotalTasks ($BPAReports | Measure-Object).Count
            $BPAReports = $BPAReports | Select-Object *, @{Name = 'QueueId'; Expression = { $Queue.RowKey } }
            $InputObject = [PSCustomObject]@{
                Batch            = @($BPAReports)
                OrchestratorName = 'BPAOrchestrator'
                SkipLog          = $true
            }
            return Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'BestPracticeAnalyser' -message "Could not start Best Practice Analyser: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return $false
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-BPAOrchestrator.ps1' 100
#Region './Public/Entrypoints/Orchestrator Functions/Start-DomainOrchestrator.ps1' -1

function Start-DomainOrchestrator {
    <#
    .SYNOPSIS
        Start the Domain Orchestrator
    .DESCRIPTION
        This function starts the Domain Orchestrator
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    try {
        $TenantList = Get-Tenants -IncludeAll
        if (($TenantList | Measure-Object).Count -eq 0) {
            Write-Information 'No tenants found'
            return 0
        }

        $Queue = New-CippQueueEntry -Name 'Domain Analyser' -TotalTasks ($TenantList | Measure-Object).Count
        $InputObject = [PSCustomObject]@{
            QueueFunction    = [PSCustomObject]@{
                FunctionName = 'GetTenants'
                DurableName  = 'DomainAnalyserTenant'
                QueueId      = $Queue.RowKey
                TenantParams = @{
                    IncludeAll = $true
                }
            }
            OrchestratorName = 'DomainAnalyser_Tenants'
            SkipLog          = $true
        }
        if ($PSCmdlet.ShouldProcess('Domain Analyser', 'Starting Orchestrator')) {
            Write-LogMessage -API 'DomainAnalyser' -message 'Starting Domain Analyser' -sev Info
            return Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Compress -Depth 5)
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'DomainAnalyser' -message "Could not start Domain Analyser: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return $false
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-DomainOrchestrator.ps1' 42
#Region './Public/Entrypoints/Orchestrator Functions/Start-DriftStandardsOrchestrator.ps1' -1

function Start-DriftStandardsOrchestrator {
    <#
    .SYNOPSIS
    Start the Drift Standards Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    if ($PSCmdlet.ShouldProcess('Start-DriftStandardsOrchestrator', 'Starting Drift Standards Orchestrator')) {
        Write-LogMessage -API 'Standards' -message 'Starting Drift Standards Schedule' -sev Info
        Invoke-CIPPStandardsRun -Drift
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-DriftStandardsOrchestrator.ps1' 17
#Region './Public/Entrypoints/Orchestrator Functions/Start-ExtensionOrchestrator.ps1' -1

function Start-ExtensionOrchestrator {
    <#
    .SYNOPSIS
        Start the Extension Orchestrator
    .FUNCTIONALITY
        Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $Table = Get-CIPPTable -TableName Extensionsconfig
    $ExtensionConfig = (Get-AzDataTableEntity @Table).config
    if (Test-Json -Json $ExtensionConfig) {
        $Configuration = ($ExtensionConfig | ConvertFrom-Json)
    } else {
        $Configuration = @{}
    }

    Write-Host 'Started Scheduler for Extensions'

    # NinjaOne Extension
    if ($Configuration.NinjaOne.Enabled -eq $true) {
        if ($PSCmdlet.ShouldProcess('Invoke-NinjaOneExtensionScheduler')) {
            Invoke-NinjaOneExtensionScheduler
        }
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-ExtensionOrchestrator.ps1' 28
#Region './Public/Entrypoints/Orchestrator Functions/Start-SchedulerOrchestrator.ps1' -1

function Start-SchedulerOrchestrator {
    <#
    .SYNOPSIS
    Start the Scheduler Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $Table = Get-CIPPTable -TableName SchedulerConfig
    $Tenants = Get-CIPPAzDataTableEntity @Table | Where-Object -Property PartitionKey -NE 'WebhookAlert'

    $Tasks = foreach ($Tenant in $Tenants) {
        if ($Tenant.tenant -ne 'AllTenants') {
            [pscustomobject]@{
                Tenant   = $Tenant.tenant
                Tag      = 'SingleTenant'
                TenantID = $Tenant.tenantid
                Type     = $Tenant.type
                RowKey   = $Tenant.RowKey
            }
        } else {
            Write-Information 'All tenants, doing them all'
            $TenantList = Get-Tenants
            foreach ($t in $TenantList) {
                [pscustomobject]@{
                    Tenant   = $t.defaultDomainName
                    Tag      = 'AllTenants'
                    TenantID = $t.customerId
                    Type     = $Tenant.type
                    RowKey   = $Tenant.RowKey
                }
            }
        }
    }

    if (($Tasks | Measure-Object).Count -eq 0) {
        return
    }

    $Queue = New-CippQueueEntry -Name 'Scheduler' -TotalTasks ($Tasks | Measure-Object).Count

    $Batch = foreach ($Task in $Tasks) {
        [pscustomobject]@{
            Tenant       = $task.tenant
            Tenantid     = $task.tenantid
            Tag          = $task.tag
            Type         = $task.type
            QueueId      = $Queue.RowKey
            SchedulerRow = $Task.RowKey
            QueueName    = '{0} - {1}' -f $Task.Type, $task.tenant
            FunctionName = "Scheduler$($Task.Type)"
        }
    }
    $InputObject = [PSCustomObject]@{
        OrchestratorName = 'SchedulerOrchestrator'
        Batch            = @($Batch)
        SkipLog          = $true
    }

    if ($PSCmdlet.ShouldProcess('Start-ScheduleOrchestrator', 'Starting Scheduler Orchestrator')) {
        Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-SchedulerOrchestrator.ps1' 67
#Region './Public/Entrypoints/Orchestrator Functions/Start-StandardsOrchestrator.ps1' -1

function Start-StandardsOrchestrator {
    <#
    .SYNOPSIS
    Start the Standards Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    if ($PSCmdlet.ShouldProcess('Start-StandardsOrchestrator', 'Starting Standards Orchestrator')) {
        Write-LogMessage -API 'Standards' -message 'Starting Standards Schedule' -sev Info
        Invoke-CIPPStandardsRun -tenantfilter 'allTenants'
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-StandardsOrchestrator.ps1' 17
#Region './Public/Entrypoints/Orchestrator Functions/Start-TenantDynamicGroupOrchestrator.ps1' -1

function Start-TenantDynamicGroupOrchestrator {
    <#
    .SYNOPSIS
    Start the Tenant Dynamic Group Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [string]$GroupId = 'All'
    )

    try {
        Write-Information 'Updating Dynamic Tenant Groups'
        $TenantGroups = @{
            Dynamic = $true
        }
        $TenantGroups = Get-TenantGroups @TenantGroups
        if ($GroupId -ne 'All') {
            $TenantGroups = $TenantGroups | Where-Object { $_.Id -eq $GroupId }
        }

        if ($TenantGroups.Count -gt 0) {
            Write-Information "Found $($TenantGroups.Count) dynamic tenant groups"
            $Queue = New-CippQueueEntry -Name 'Dynamic Tenant Groups' -TotalTasks $TenantGroups.Count
            $TenantBatch = $TenantGroups | Select-Object Name, Id, @{n = 'FunctionName'; exp = { 'UpdateDynamicTenantGroup' } }, @{n = 'QueueId'; exp = { $Queue.RowKey } }
            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'UpdateDynamicTenantGroups'
                Batch            = @($TenantBatch)
                SkipLog          = $true
            }
            if ($PSCmdlet.ShouldProcess('Start-TenantDynamicGroupOrchestrator', 'Starting Tenant Dynamic Group Orchestrator')) {
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
            }
        } else {
            Write-Information 'No tenants require permissions update'
        }
    } catch {}
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-TenantDynamicGroupOrchestrator.ps1' 41
#Region './Public/Entrypoints/Orchestrator Functions/Start-UpdatePermissionsOrchestrator.ps1' -1

function Start-UpdatePermissionsOrchestrator {
    <#
    .SYNOPSIS
    Start the Update Permissions Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    try {
        Write-Information 'Updating Permissions'

        $PartnerTenant = @{
            'customerId'        = $env:TenantID
            'defaultDomainName' = 'PartnerTenant'
            'displayName'       = '*Partner Tenant'
        }

        $TenantList = Get-Tenants -IncludeAll | Where-Object { $_.Excluded -eq $false }

        $Tenants = [System.Collections.Generic.List[object]]::new()
        foreach ($Tenant in $TenantList) {
            $Tenants.Add($Tenant)
        }

        if ($Tenants.customerId -notcontains $env:TenantID) {
            $Tenants.Add($PartnerTenant)
        }

        $CPVTable = Get-CIPPTable -TableName cpvtenants
        $CPVRows = Get-CIPPAzDataTableEntity @CPVTable
        $LastCPV = ($CPVRows | Sort-Object -Property Timestamp -Descending | Select-Object -First 1).Timestamp.DateTime
        Write-Information "CPV last updated at $LastCPV"

        $SAMPermissions = Get-CIPPSamPermissions
        Write-Information "SAM Permissions last updated at $($SAMPermissions.Timestamp)"

        $SAMRolesTable = Get-CIPPTable -TableName SAMRoles
        $SAMRoles = Get-CIPPAzDataTableEntity @SAMRolesTable
        Write-Information "SAM Roles last updated at $($SAMRoles.Timestamp.DateTime)"

        $Tenants = $Tenants | ForEach-Object {
            $CPVRow = $CPVRows | Where-Object -Property Tenant -EQ $_.customerId
            if (!$CPVRow -or $env:ApplicationID -notin $CPVRow.applicationId -or $SAMPermissions.Timestamp -gt $CPVRow.Timestamp.DateTime -or $CPVRow.Timestamp.DateTime -le (Get-Date).AddDays(-7).ToUniversalTime() -or !$_.defaultDomainName -or ($SAMroles.Timestamp.DateTime -gt $CPVRow.Timestamp.DateTime -and ($SAMRoles.Tenants -contains $_.defaultDomainName -or $SAMRoles.Tenants.value -contains $_.defaultDomainName -or $SAMRoles.Tenants -contains 'AllTenants' -or $SAMRoles.Tenants.value -contains 'AllTenants'))) {
                $_
            }
        }
        $TenantCount = ($Tenants | Measure-Object).Count

        if ($TenantCount -gt 0) {
            Write-Information "Found $TenantCount tenants that require permissions update"
            $Queue = New-CippQueueEntry -Name 'Update Permissions' -TotalTasks $TenantCount
            $TenantBatch = $Tenants | Select-Object defaultDomainName, customerId, displayName, @{n = 'FunctionName'; exp = { 'UpdatePermissionsQueue' } }, @{n = 'QueueId'; exp = { $Queue.RowKey } }
            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'UpdatePermissionsOrchestrator'
                Batch            = @($TenantBatch)
            }
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
        } else {
            Write-Information 'No tenants require permissions update'
        }
    } catch {}
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-UpdatePermissionsOrchestrator.ps1' 66
#Region './Public/Entrypoints/Orchestrator Functions/Start-UserTasksOrchestrator.ps1' -1

function Start-UserTasksOrchestrator {
    <#
    .SYNOPSIS
    Start the User Tasks Orchestrator

    .FUNCTIONALITY
    Entrypoint
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $Table = Get-CippTable -tablename 'ScheduledTasks'
    $1HourAgo = (Get-Date).AddHours(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
    $Filter = "PartitionKey eq 'ScheduledTask' and (TaskState eq 'Planned' or TaskState eq 'Failed - Planned' or (TaskState eq 'Running' and Timestamp lt datetime'$1HourAgo'))"
    $tasks = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    $RateLimitTable = Get-CIPPTable -tablename 'SchedulerRateLimits'
    $RateLimits = Get-CIPPAzDataTableEntity @RateLimitTable -Filter "PartitionKey eq 'SchedulerRateLimits'"

    $CIPPCoreModuleRoot = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $CIPPRoot = (Get-Item $CIPPCoreModuleRoot).Parent.Parent
    $DefaultRateLimits = Get-Content -Path "$CIPPRoot/Config/SchedulerRateLimits.json" | ConvertFrom-Json
    $NewRateLimits = foreach ($Limit in $DefaultRateLimits) {
        if ($Limit.Command -notin $RateLimits.RowKey) {
            @{
                PartitionKey = 'SchedulerRateLimits'
                RowKey       = $Limit.Command
                MaxRequests  = $Limit.MaxRequests
            }
        }
    }

    if ($NewRateLimits) {
        $null = Add-CIPPAzDataTableEntity @RateLimitTable -Entity $NewRateLimits -Force
        $RateLimits = Get-CIPPAzDataTableEntity @RateLimitTable -Filter "PartitionKey eq 'SchedulerRateLimits'"
    }

    # Create a hashtable for quick rate limit lookups
    $RateLimitLookup = @{}
    foreach ($limit in $RateLimits) {
        $RateLimitLookup[$limit.RowKey] = $limit.MaxRequests
    }

    $Batch = [System.Collections.Generic.List[object]]::new()
    $TenantList = Get-Tenants -IncludeErrors
    foreach ($task in $tasks) {
        $tenant = $task.Tenant

        $currentUnixTime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
        if ($currentUnixTime -ge $task.ScheduledTime) {
            try {
                $null = Update-AzDataTableEntity -Force @Table -Entity @{
                    PartitionKey = $task.PartitionKey
                    RowKey       = $task.RowKey
                    ExecutedTime = "$currentUnixTime"
                    TaskState    = 'Planned'
                }
                $task.Parameters = $task.Parameters | ConvertFrom-Json -AsHashtable
                $task.AdditionalProperties = $task.AdditionalProperties | ConvertFrom-Json

                if (!$task.Parameters) { $task.Parameters = @{} }
                $ScheduledCommand = [pscustomobject]@{
                    Command      = $task.Command
                    Parameters   = $task.Parameters
                    TaskInfo     = $task
                    FunctionName = 'ExecScheduledCommand'
                }

                if ($task.Tenant -eq 'AllTenants') {
                    $ExcludedTenants = $task.excludedTenants -split ','
                    Write-Host "Excluded Tenants from this task: $ExcludedTenants"
                    $AllTenantCommands = foreach ($Tenant in $TenantList | Where-Object { $_.defaultDomainName -notin $ExcludedTenants }) {
                        $NewParams = $task.Parameters.Clone()
                        if ((Get-Command $task.Command).Parameters.TenantFilter) {
                            $NewParams.TenantFilter = $Tenant.defaultDomainName
                        }
                        [pscustomobject]@{
                            Command      = $task.Command
                            Parameters   = $NewParams
                            TaskInfo     = $task
                            FunctionName = 'ExecScheduledCommand'
                        }
                    }
                    $Batch.AddRange($AllTenantCommands)
                } elseif ($task.TenantGroup) {
                    # Handle tenant groups - expand group to individual tenants
                    try {
                        $TenantGroupObject = $task.TenantGroup | ConvertFrom-Json
                        Write-Host "Expanding tenant group: $($TenantGroupObject.label) with ID: $($TenantGroupObject.value)"

                        # Create a tenant filter object for expansion
                        $TenantFilterForExpansion = @([PSCustomObject]@{
                                type  = 'Group'
                                value = $TenantGroupObject.value
                                label = $TenantGroupObject.label
                            })

                        # Expand the tenant group to individual tenants
                        $ExpandedTenants = Expand-CIPPTenantGroups -TenantFilter $TenantFilterForExpansion

                        $ExcludedTenants = $task.excludedTenants -split ','
                        Write-Host "Excluded Tenants from this task: $ExcludedTenants"

                        $GroupTenantCommands = foreach ($ExpandedTenant in $ExpandedTenants | Where-Object { $_.value -notin $ExcludedTenants }) {
                            $NewParams = $task.Parameters.Clone()
                            if ((Get-Command $task.Command).Parameters.TenantFilter) {
                                $NewParams.TenantFilter = $ExpandedTenant.value
                            }
                            [pscustomobject]@{
                                Command      = $task.Command
                                Parameters   = $NewParams
                                TaskInfo     = $task
                                FunctionName = 'ExecScheduledCommand'
                            }
                        }
                        $Batch.AddRange($GroupTenantCommands)
                    } catch {
                        Write-Host "Error expanding tenant group: $($_.Exception.Message)"
                        Write-LogMessage -API 'Scheduler_UserTasks' -tenant $tenant -message "Failed to expand tenant group for task $($task.Name): $($_.Exception.Message)" -sev Error

                        # Fall back to treating as single tenant
                        if ((Get-Command $task.Command).Parameters.TenantFilter) {
                            $ScheduledCommand.Parameters['TenantFilter'] = $task.Tenant
                        }
                        $Batch.Add($ScheduledCommand)
                    }
                } else {
                    # Handle single tenant
                    if ((Get-Command $task.Command).Parameters.TenantFilter) {
                        $ScheduledCommand.Parameters['TenantFilter'] = $task.Tenant
                    }
                    $Batch.Add($ScheduledCommand)
                }
            } catch {
                $errorMessage = $_.Exception.Message

                $null = Update-AzDataTableEntity -Force @Table -Entity @{
                    PartitionKey = $task.PartitionKey
                    RowKey       = $task.RowKey
                    Results      = "$errorMessage"
                    ExecutedTime = "$currentUnixTime"
                    TaskState    = 'Failed'
                }
                Write-LogMessage -API 'Scheduler_UserTasks' -tenant $tenant -message "Failed to execute task $($task.Name): $errorMessage" -sev Error
            }
        }
    }

    Write-Information 'Batching tasks for execution...'
    Write-Information "Total tasks to process: $($Batch.Count)"

    if (($Batch | Measure-Object).Count -gt 0) {
        # Group commands by type and apply rate limits
        $CommandGroups = $Batch | Group-Object -Property Command
        $ProcessedBatches = [System.Collections.Generic.List[object]]::new()

        foreach ($CommandGroup in $CommandGroups) {
            $CommandName = $CommandGroup.Name
            $Commands = [System.Collections.Generic.List[object]]::new($CommandGroup.Group)

            # Get rate limit for this command (default to 100 if not found)
            $MaxItemsPerBatch = if ($RateLimitLookup.ContainsKey($CommandName)) {
                $RateLimitLookup[$CommandName]
            } else {
                100
            }

            # Split into batches based on rate limit
            while ($Commands.Count -gt 0) {
                $BatchSize = [Math]::Min($Commands.Count, $MaxItemsPerBatch)
                $CommandBatch = [System.Collections.Generic.List[object]]::new()

                for ($i = 0; $i -lt $BatchSize; $i++) {
                    $CommandBatch.Add($Commands[0])
                    $Commands.RemoveAt(0)
                }

                $ProcessedBatches.Add($CommandBatch)
            }
        }

        # Process each batch separately
        foreach ($ProcessedBatch in $ProcessedBatches) {
            Write-Information "Processing batch with $($ProcessedBatch.Count) tasks..."
            Write-Information 'Tasks by command:'
            $ProcessedBatch | Group-Object -Property Command | ForEach-Object {
                Write-Information " - $($_.Name): $($_.Count)"
            }

            # Create queue entry for each batch
            $Queue = New-CippQueueEntry -Name "Scheduled Tasks - Batch #$($ProcessedBatches.IndexOf($ProcessedBatch) + 1) of $($ProcessedBatches.Count)"
            $QueueId = $Queue.RowKey
            $BatchWithQueue = $ProcessedBatch | Select-Object *, @{Name = 'QueueId'; Expression = { $QueueId } }, @{Name = 'QueueName'; Expression = { '{0} - {1}' -f $_.TaskInfo.Name, ($_.TaskInfo.Tenant -ne 'AllTenants' ? $_.TaskInfo.Tenant : $_.Parameters.TenantFilter) } }

            $InputObject = [PSCustomObject]@{
                OrchestratorName = 'UserTaskOrchestrator'
                Batch            = @($BatchWithQueue)
                SkipLog          = $true
            }

            if ($PSCmdlet.ShouldProcess('Start-UserTasksOrchestrator', 'Starting User Tasks Orchestrator')) {
                Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 10 -Compress)
            }
        }
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-UserTasksOrchestrator.ps1' 207
#Region './Public/Entrypoints/Orchestrator Functions/Start-WebhookOrchestrator.ps1' -1

function Start-WebhookOrchestrator {
    <#
    .SYNOPSIS
    Start the Webhook Orchestrator
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    try {
        $webhookTable = Get-CIPPTable -tablename webhookTable
        $Webhooks = Get-CIPPAzDataTableEntity @webhookTable -Property PartitionKey, RowKey
        if (($Webhooks | Measure-Object).Count -eq 0) {
            Write-Information 'No webhook subscriptions found. Exiting.'
            return
        }

        $WebhookIncomingTable = Get-CIPPTable -TableName WebhookIncoming
        $WebhookIncoming = Get-CIPPAzDataTableEntity @WebhookIncomingTable -Property PartitionKey, RowKey
        if (($WebhookIncoming | Measure-Object).Count -eq 0) {
            Write-Information 'No webhook incoming found. Exiting.'
            return
        }

        Write-Information 'Processing webhooks'

        $InputObject = [PSCustomObject]@{
            OrchestratorName = 'WebhookOrchestrator'
            QueueFunction    = @{
                FunctionName = 'GetPendingWebhooks'
            }
            SkipLog          = $true
        }
        if ($PSCmdlet.ShouldProcess('Start-WebhookOrchestrator', 'Starting Webhook Orchestrator')) {
            Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)

        }
    } catch {
        Write-LogMessage -API 'Webhooks' -message 'Error processing webhooks' -sev Error -LogData (Get-CippException -Exception $_)
        Write-Information ( 'Webhook error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
    }
}
#EndRegion './Public/Entrypoints/Orchestrator Functions/Start-WebhookOrchestrator.ps1' 41
#Region './Public/Entrypoints/Timer Functions/Start-BillingTimer.ps1' -1

function Start-BillingTimer {
    <#
    .SYNOPSIS
        Start the Billing Timer
    .DESCRIPTION
        This function starts the Billing Timner
    .FUNCTIONALITY
        Entrypoint
    #>

    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    try {
        Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message 'Starting billing processing.' -sev Info

        $Table = Get-CIPPTable -TableName Extensionsconfig
        $Configuration = (Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json -Depth 10
        foreach ($ConfigItem in $Configuration.psobject.properties.name) {
            switch ($ConfigItem) {
                'Gradient' {
                    If ($Configuration.Gradient.enabled -and $Configuration.Gradient.BillingEnabled) {
                        New-GradientServiceSyncRun
                    }
                }
            }
        }
    } catch {
        Write-LogMessage -API 'Scheduler_Billing' -tenant 'none' -message "Could not start billing processing $($_.Exception.Message)" -sev Error
    }
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-BillingTimer.ps1' 31
#Region './Public/Entrypoints/Timer Functions/Start-CIPPGraphSubscriptionRenewalTimer.ps1' -1

function Start-CIPPGraphSubscriptionRenewalTimer {
    <#
    .SYNOPSIS
    Start the Graph Subscription Renewal Timer
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    if ($PSCmdlet.ShouldProcess('Start-CIPPGraphSubscriptionRenewalTimer', 'Starting Graph Subscription Renewal Timer')) {
        Invoke-CippGraphWebhookRenewal
    }
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-CIPPGraphSubscriptionRenewalTimer.ps1' 13
#Region './Public/Entrypoints/Timer Functions/Start-CIPPProcessorQueue.ps1' -1

function Start-CIPPProcessorQueue {
    <#
    .SYNOPSIS
    Starts a specified function on the processor node
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $QueueTable = Get-CIPPTable -tablename 'ProcessorQueue'
    $QueueItems = Get-CIPPAzDataTableEntity @QueueTable -Filter "PartitionKey eq 'Function'"

    foreach ($QueueItem in $QueueItems) {
        $FunctionName = $QueueItem.FunctionName ?? $QueueItem.RowKey
        if ($PSCmdlet.ShouldProcess("Processing function $($FunctionName)")) {
            Write-Information "Running queued function $($FunctionName)"
            if ($QueueItem.Parameters) {
                try {
                    $Parameters = $QueueItem.Parameters | ConvertFrom-Json -AsHashtable
                } catch {
                    $Parameters = @{}
                }
            } else {
                $Parameters = @{}
            }
            if (Get-Command -Name $FunctionName -ErrorAction SilentlyContinue) {
                try {
                    # Prepare telemetry metadata
                    $metadata = @{
                        FunctionName = $FunctionName
                        TriggerType  = 'ProcessorQueue'
                        QueueRowKey  = $QueueItem.RowKey
                    }
                    
                    # Add parameters info if available
                    if ($Parameters.Count -gt 0) {
                        $metadata['ParameterCount'] = $Parameters.Count
                        # Add common parameters
                        if ($Parameters.Tenant) {
                            $metadata['Tenant'] = $Parameters.Tenant
                        }
                        if ($Parameters.TenantFilter) {
                            $metadata['Tenant'] = $Parameters.TenantFilter
                        }
                    }
                    
                    # Wrap function execution with telemetry
                    Measure-CippTask -TaskName $FunctionName -Metadata $metadata -Script {
                        Invoke-Command -ScriptBlock { & $FunctionName @Parameters }
                    }
                } catch {
                    Write-Warning "Failed to run function $($FunctionName). Error: $($_.Exception.Message)"
                }
            } else {
                Write-Warning "Function $($FunctionName) not found"
            }
            Remove-AzDataTableEntity -Force @QueueTable -Entity $QueueItem
        }
    }
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-CIPPProcessorQueue.ps1' 60
#Region './Public/Entrypoints/Timer Functions/Start-CIPPStatsTimer.ps1' -1

function Start-CIPPStatsTimer {
    <#
    .SYNOPSIS
    Start the CIPP Stats Timer
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    #These stats are sent to a central server to help us understand how many tenants are using the product, and how many are using the latest version, this information allows the CIPP team to make decisions about what features to support, and what features to deprecate.
    #We will never ship any data that is related to your instance, all we care about is the number of tenants, and the version of the API you are running, and if you completed setup.

    if ($PSCmdlet.ShouldProcess('Start-CIPPStatsTimer', 'Starting CIPP Stats Timer')) {
        if ($env:ApplicationID -ne 'LongApplicationID') {
            $SetupComplete = $true
        }
        $TenantCount = (Get-Tenants -IncludeAll).count


        $ModuleBase = Get-Module CIPPCore | Select-Object -ExpandProperty ModuleBase
        $CIPPRoot = (Get-Item $ModuleBase).Parent.Parent.FullName

        $APIVersion = Get-Content "$CIPPRoot\version_latest.txt" | Out-String
        $Table = Get-CIPPTable -TableName Extensionsconfig
        try {
            $RawExt = (Get-CIPPAzDataTableEntity @Table).config | ConvertFrom-Json -Depth 10 -ErrorAction Stop
        } catch {
            $RawExt = @{}
        }

        $SendingObject = [PSCustomObject]@{
            rgid                = $env:WEBSITE_SITE_NAME
            SetupComplete       = $SetupComplete
            RunningVersionAPI   = $APIVersion.trim()
            CountOfTotalTenants = $tenantcount
            uid                 = $env:TenantID
            CIPPAPI             = $RawExt.CIPPAPI.Enabled
            Hudu                = $RawExt.Hudu.Enabled
            Sherweb             = $RawExt.Sherweb.Enabled
            Gradient            = $RawExt.Gradient.Enabled
            NinjaOne            = $RawExt.NinjaOne.Enabled
            haloPSA             = $RawExt.haloPSA.Enabled
            HIBP                = $RawExt.HIBP.Enabled
            PWPush              = $RawExt.PWPush.Enabled
            CFZTNA              = $RawExt.CFZTNA.Enabled
            GitHub              = $RawExt.GitHub.Enabled
        } | ConvertTo-Json

        Invoke-RestMethod -Uri 'https://management.cipp.app/api/stats' -Method POST -Body $SendingObject -ContentType 'application/json'
    }
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-CIPPStatsTimer.ps1' 50
#Region './Public/Entrypoints/Timer Functions/Start-DurableCleanup.ps1' -1

function Start-DurableCleanup {
    <#
    .SYNOPSIS
    Start the durable cleanup process.

    .DESCRIPTION
    Look for orchestrators running for more than the specified time and terminate them. Also, clear any queues that have items for that function app.

    .PARAMETER MaxDuration
    The maximum duration an orchestrator can run before being terminated.

    .FUNCTIONALITY
    Internal
    #>

    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [int]$MaxDuration = 86400
    )

    $WarningPreference = 'SilentlyContinue'
    $StorageContext = New-AzStorageContext -ConnectionString $env:AzureWebJobsStorage
    $TargetTime = (Get-Date).ToUniversalTime().AddSeconds(-$MaxDuration)
    $Context = New-AzDataTableContext -ConnectionString $env:AzureWebJobsStorage
    $InstancesTables = Get-AzDataTable -Context $Context | Where-Object { $_ -match 'Instances' }

    $CleanupCount = 0
    $QueueCount = 0

    $FunctionsWithLongRunningOrchestrators = [System.Collections.Generic.List[object]]::new()
    $NonDeterministicOrchestrators = [System.Collections.Generic.List[object]]::new()

    foreach ($Table in $InstancesTables) {
        $Table = Get-CippTable -TableName $Table
        $FunctionName = $Table.TableName -replace 'Instances', ''
        $Orchestrators = Get-CIPPAzDataTableEntity @Table -Filter "RuntimeStatus eq 'Running'" | Select-Object * -ExcludeProperty Input
        $Queues = Get-AzStorageQueue -Context $StorageContext -Name ('{0}*' -f $FunctionName) | Select-Object -Property Name, ApproximateMessageCount, QueueClient
        $LongRunningOrchestrators = $Orchestrators | Where-Object { $_.CreatedTime.DateTime -lt $TargetTime }

        if ($LongRunningOrchestrators.Count -gt 0) {
            $FunctionsWithLongRunningOrchestrators.Add(@{'FunctionName' = $FunctionName })
            foreach ($Orchestrator in $LongRunningOrchestrators) {
                $CreatedTime = [DateTime]::SpecifyKind($Orchestrator.CreatedTime.DateTime, [DateTimeKind]::Utc)
                $TimeSpan = New-TimeSpan -Start $CreatedTime -End (Get-Date).ToUniversalTime()
                $RunningDuration = [math]::Round($TimeSpan.TotalMinutes, 2)
                Write-Information "Orchestrator: $($Orchestrator.PartitionKey), created: $CreatedTime, running for: $RunningDuration minutes"
                if ($PSCmdlet.ShouldProcess($_.PartitionKey, 'Terminate Orchestrator')) {
                    $Orchestrator = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$($Orchestrator.PartitionKey)'"
                    $Orchestrator.RuntimeStatus = 'Failed'
                    if ($Orchestrator.PSObject.Properties.Name -contains 'CustomStatus') {
                        $Orchestrator.CustomStatus = "Terminated by Durable Cleanup - Exceeded max duration of $MaxDuration seconds"
                    } else {
                        $Orchestrator | Add-Member -MemberType NoteProperty -Name CustomStatus -Value "Terminated by Durable Cleanup - Exceeded max duration of $MaxDuration seconds"
                    }
                    Update-AzDataTableEntity @Table -Entity $Orchestrator
                    $CleanupCount++
                }
            }
        }

        $NonDeterministicOrchestrators = $Orchestrators | Where-Object { $_.Output -match 'Non-Deterministic workflow detected' }
        if ($NonDeterministicOrchestrators.Count -gt 0) {
            $NonDeterministicOrchestrators.Add(@{'FunctionName' = $FunctionName })
            foreach ($Orchestrator in $NonDeterministicOrchestrators) {
                Write-Information "Orchestrator: $($Orchestrator.PartitionKey) is Non-Deterministic"
                if ($PSCmdlet.ShouldProcess($_.PartitionKey, 'Terminate Orchestrator')) {
                    $Orchestrator = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$($Orchestrator.PartitionKey)'"
                    $Orchestrator.RuntimeStatus = 'Failed'
                    if ($Orchestrator.PSObject.Properties.Name -contains 'CustomStatus') {
                        $Orchestrator.CustomStatus = 'Terminated by Durable Cleanup - Non-Deterministic workflow detected'
                    } else {
                        $Orchestrator | Add-Member -MemberType NoteProperty -Name CustomStatus -Value 'Terminated by Durable Cleanup - Non-Deterministic workflow detected'
                    }
                    Update-AzDataTableEntity @Table -Entity $Orchestrator
                    $CleanupCount++
                }
            }
        }

        if (($LongRunningOrchestrators.Count -gt 0 -or $NonDeterministicOrchestrators.Count -gt 0) -and $Queues.ApproximateMessageCount -gt 0) {
            $RunningQueues = $Queues | Where-Object { $_.ApproximateMessageCount -gt 0 }
            foreach ($Queue in $RunningQueues) {
                Write-Information "- Removing queue: $($Queue.Name), message count: $($Queue.ApproximateMessageCount)"
                if ($PSCmdlet.ShouldProcess($Queue.Name, 'Clear Queue')) {
                    $Queue.QueueClient.ClearMessagesAsync() | Out-Null
                }
                $QueueCount++
            }
        }
    }

    if ($CleanupCount -gt 0 -or $QueueCount -gt 0) {
        Write-LogMessage -api 'Durable Cleanup' -message "$CleanupCount orchestrators were terminated. $QueueCount queues were cleared." -sev 'Info' -LogData $FunctionsWithLongRunningOrchestrators
    }

    Write-Information "Durable cleanup complete. $CleanupCount orchestrators were terminated. $QueueCount queues were cleared."
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-DurableCleanup.ps1' 98
#Region './Public/Entrypoints/Timer Functions/Start-TableCleanup.ps1' -1

function Start-TableCleanup {
    <#
    .SYNOPSIS
    Start the Table Cleanup Timer
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()

    $Batch = @(
        @{
            FunctionName   = 'TableCleanupTask'
            Type           = 'CleanupRule'
            TableName      = 'webhookTable'
            DataTableProps = @{
                Property = @('PartitionKey', 'RowKey', 'ETag', 'Resource')
                First    = 1000
            }
            Where          = "`$_.Resource -match '^Audit'"
        }
        @{
            FunctionName   = 'TableCleanupTask'
            Type           = 'CleanupRule'
            TableName      = 'AuditLogSearches'
            DataTableProps = @{
                Filter   = "PartitionKey eq 'Search' and Timestamp lt datetime'$((Get-Date).AddHours(-12).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ'))'"
                First    = 10000
                Property = @('PartitionKey', 'RowKey', 'ETag')
            }
        }
        @{
            FunctionName   = 'TableCleanupTask'
            Type           = 'CleanupRule'
            TableName      = 'CippFunctionStats'
            DataTableProps = @{
                Filter   = "PartitionKey eq 'Durable' and Timestamp lt datetime'$((Get-Date).AddDays(-7).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ'))'"
                First    = 10000
                Property = @('PartitionKey', 'RowKey', 'ETag')
            }
        }
        @{
            FunctionName   = 'TableCleanupTask'
            Type           = 'CleanupRule'
            TableName      = 'CippQueue'
            DataTableProps = @{
                Filter   = "PartitionKey eq 'CippQueue' and Timestamp lt datetime'$((Get-Date).AddDays(-7).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ'))'"
                First    = 10000
                Property = @('PartitionKey', 'RowKey', 'ETag')
            }
        }
        @{
            FunctionName   = 'TableCleanupTask'
            Type           = 'CleanupRule'
            TableName      = 'CippQueueTasks'
            DataTableProps = @{
                Filter   = "PartitionKey eq 'Task' and Timestamp lt datetime'$((Get-Date).AddDays(-7).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ'))'"
                First    = 10000
                Property = @('PartitionKey', 'RowKey', 'ETag')
            }
        }
        @{
            FunctionName = 'TableCleanupTask'
            Type         = 'DeleteTable'
            Tables       = @('knownlocationdb')
        }
    )

    $InputObject = @{
        Batch            = @($Batch)
        OrchestratorName = 'TableCleanup'
        SkipLog          = $true
    }

    Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-TableCleanup.ps1' 75
#Region './Public/Entrypoints/Timer Functions/Start-UpdateTokensTimer.ps1' -1

function Start-UpdateTokensTimer {
    <#
    .SYNOPSIS
    Start the Update Tokens Timer
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '')]
    [CmdletBinding(SupportsShouldProcess = $true)]
    param()
    if ($PSCmdlet.ShouldProcess('Start-UpdateTokensTimer', 'Starting Update Tokens Timer')) {
        Write-Information 'Starting Update Tokens Timer'
        Write-Information "Getting new refresh token for $($env:TenantId)"
        # Get the current universal time in the default string format.
        $currentUTCtime = (Get-Date).ToUniversalTime()
        try {
            $Refreshtoken = (Get-GraphToken -ReturnRefresh $true).Refresh_token
            if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                $Table = Get-CIPPTable -tablename 'DevSecrets'
                $Secret = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
                if ($Secret) {
                    $Secret.RefreshToken = $Refreshtoken
                    Add-AzDataTableEntity @Table -Entity $Secret -Force
                } else {
                    Write-LogMessage -API 'Update Tokens' -message 'Could not update refresh token. Will try again in 7 days.' -sev 'CRITICAL'
                }
            } else {
                if ($env:MSI_SECRET) {
                    Disable-AzContextAutosave -Scope Process | Out-Null
                    $null = Connect-AzAccount -Identity
                    $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
                    $null = Set-AzContext -SubscriptionId $SubscriptionId
                }
                $KV = ($env:WEBSITE_DEPLOYMENT_ID -split '-')[0]
                if ($Refreshtoken) {
                    Set-AzKeyVaultSecret -VaultName $KV -Name 'RefreshToken' -SecretValue (ConvertTo-SecureString -String $Refreshtoken -AsPlainText -Force)
                } else {
                    Write-LogMessage -API 'Update Tokens' -message 'Could not update refresh token. Will try again in 7 days.' -sev 'CRITICAL'
                }
            }
        } catch {
            Write-Warning "Error updating refresh token $($_.Exception.Message)."
            Write-Information ($_.InvocationInfo.PositionMessage)
            Write-LogMessage -API 'Update Tokens' -message 'Error updating refresh token, see Log Data for details. Will try again in 7 days.' -sev 'CRITICAL' -LogData (Get-CippException -Exception $_)
        }

        # Check application secret expiration for $env:ApplicationId and generate a new application secret if expiration is within 30 days.
        try {
            $AppId = $env:ApplicationID
            $PasswordCredentials = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/applications(appId='$AppId')?`$select=id,passwordCredentials" -NoAuthCheck $true -AsApp $true -ErrorAction Stop
            # sort by latest expiration date and get the first one
            $LastPasswordCredential = $PasswordCredentials.passwordCredentials | Sort-Object -Property endDateTime -Descending | Select-Object -First 1
            if ($LastPasswordCredential.endDateTime -lt (Get-Date).AddDays(30).ToUniversalTime()) {
                Write-Information "Application secret for $AppId is expiring soon. Generating a new application secret."
                $AppSecret = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/applications/$($PasswordCredentials.id)/addPassword" -Body '{"passwordCredential":{"displayName":"UpdateTokens"}}' -NoAuthCheck $true -AsApp $true -ErrorAction Stop
                Write-Information "New application secret generated for $AppId. Expiration date: $($AppSecret.endDateTime)."
            } else {
                Write-Information "Application secret for $AppId is valid until $($LastPasswordCredential.endDateTime). No need to generate a new application secret."
            }

            if ($AppSecret) {
                if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                    $Table = Get-CIPPTable -tablename 'DevSecrets'
                    $Secret = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
                    $Secret.ApplicationSecret = $AppSecret.secretText
                    Add-AzDataTableEntity @Table -Entity $Secret -Force
                } else {
                    Set-AzKeyVaultSecret -VaultName $KV -Name 'ApplicationSecret' -SecretValue (ConvertTo-SecureString -String $AppSecret.secretText -AsPlainText -Force)
                }
                Write-LogMessage -API 'Update Tokens' -message "New application secret generated for $AppId. Expiration date: $($AppSecret.endDateTime)." -sev 'INFO'
            }

            # Clean up expired application secrets
            $ExpiredSecrets = $PasswordCredentials.passwordCredentials | Where-Object { $_.endDateTime -lt (Get-Date).ToUniversalTime() }
            if ($ExpiredSecrets.Count -gt 0) {
                Write-Information "Found $($ExpiredSecrets.Count) expired application secrets for $AppId. Removing them."
                foreach ($Secret in $ExpiredSecrets) {
                    try {
                        New-GraphPostRequest -type DELETE -uri "https://graph.microsoft.com/v1.0/applications/$($PasswordCredentials.id)/removePassword" -Body "{`"keyId`":`"$($Secret.keyId)`"}" -NoAuthCheck $true -AsApp $true -ErrorAction Stop
                        Write-Information "Removed expired application secret with keyId $($Secret.keyId)."
                    } catch {
                        Write-LogMessage -API 'Update Tokens' -message "Error removing expired application secret with keyId $($Secret.keyId), see Log Data for details." -sev 'CRITICAL' -LogData (Get-CippException -Exception $_)
                    }
                }
            } else {
                Write-Information "No expired application secrets found for $AppId."
            }
        } catch {
            Write-Warning "Error updating application secret $($_.Exception.Message)."
            Write-Information ($_.InvocationInfo.PositionMessage)
            Write-LogMessage -API 'Update Tokens' -message 'Error updating application secret, will try again in 7 days' -sev 'CRITICAL' -LogData (Get-CippException -Exception $_)
        }

        # Get new refresh token for each direct added tenant
        $TenantList = Get-Tenants -IncludeAll | Where-Object { $_.Excluded -eq $false -and $_.delegatedPrivilegeStatus -eq 'directTenant' }
        if ($TenantList.Count -eq 0) {
            Write-Information 'No direct tenants found for refresh token update.'
        } else {
            Write-Information "Found $($TenantList.Count) direct tenant(s) for refresh token update."
            foreach ($Tenant in $TenantList) {
                try {
                    Write-Information "Updating refresh token for tenant $($Tenant.displayName) - $($Tenant.customerId)"
                    $Refreshtoken = (Get-GraphToken -ReturnRefresh $true -TenantId $Tenant.customerId).Refresh_token
                    if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
                        $Table = Get-CIPPTable -tablename 'DevSecrets'
                        $Secret = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
                        if ($Secret) {
                            $name = $Tenant.customerId -replace '-', '_'
                            $Secret | Add-Member -MemberType NoteProperty -Name $name -Value $Refreshtoken -Force
                            Add-AzDataTableEntity @Table -Entity $Secret -Force
                        } else {
                            Write-Warning "Could not update refresh token for tenant $($Tenant.displayName) ($($Tenant.customerId))."
                            Write-LogMessage -API 'Update Tokens' -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -message "Could not update refresh token for tenant $($Tenant.displayName). Will try again in 7 days." -sev 'CRITICAL'
                        }
                    } else {
                        if ($Refreshtoken) {
                            $name = $Tenant.customerId
                            Set-AzKeyVaultSecret -VaultName $KV -Name $name -SecretValue (ConvertTo-SecureString -String $Refreshtoken -AsPlainText -Force)
                        } else {
                            Write-Warning "Could not update refresh token for tenant $($Tenant.displayName) ($($Tenant.customerId))."
                            Write-LogMessage -API 'Update Tokens' -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -message "Could not update refresh token for tenant $($Tenant.displayName). Will try again in 7 days." -sev 'CRITICAL'
                        }
                    }
                } catch {
                    Write-LogMessage -API 'Update Tokens' -tenant $Tenant.defaultDomainName -tenantid $Tenant.customerId -message "Error updating refresh token for tenant $($Tenant.displayName), see Log Data for details. Will try again in 7 days." -sev 'CRITICAL' -LogData (Get-CippException -Exception $_)
                }
            }
        }

        # Write an information log with the current time.
        Write-Information "UpdateTokens completed: $currentUTCtime"
    }
}
#EndRegion './Public/Entrypoints/Timer Functions/Start-UpdateTokensTimer.ps1' 132
#Region './Public/Functions/Get-CIPPTenantAlignment.ps1' -1

function Get-CIPPTenantAlignment {
    <#
    .SYNOPSIS
        Gets tenant alignment data for standards compliance
    .DESCRIPTION
        This function calculates tenant alignment percentages against standards templates.
        It processes all standard templates and compares them against tenant standards data.
    .PARAMETER TenantFilter
        The tenant to get alignment data for. If not specified, processes all tenants.
    .PARAMETER TemplateId
        Optional specific template GUID to check alignment for. If not specified, processes all templates.
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Get-CIPPTenantAlignment -TenantFilter "contoso.onmicrosoft.com"
    .EXAMPLE
        Get-CIPPTenantAlignment -TenantFilter "contoso.onmicrosoft.com" -TemplateId "12345-67890-abcdef"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $false)]
        [string]$TemplateId
    )
    $TemplateTable = Get-CippTable -tablename 'templates'
    $TemplateFilter = "PartitionKey eq 'StandardsTemplateV2'"
    $TenantGroups = Get-TenantGroups

    try {
        # Get all standard templates
        $Templates = (Get-CIPPAzDataTableEntity @TemplateTable -Filter $TemplateFilter) | ForEach-Object {
            $JSON = $_.JSON
            try {
                $RowKey = $_.RowKey
                $Data = $JSON | ConvertFrom-Json -Depth 100 -ErrorAction Stop
            } catch {
                Write-Warning "$($RowKey) standard could not be loaded: $($_.Exception.Message)"
                return
            }
            if ($Data) {
                $Data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.GUID -Force
                $Data
            }
        }

        if (-not $Templates) {
            Write-Warning 'No templates found matching the criteria'
            return @()
        }

        # Get standards comparison data
        $StandardsTable = Get-CippTable -TableName 'CippStandardsReports'
        #this if statement is to bring down performance when running scheduled checks, we have to revisit this to a better query due to the extreme size this can get.
        if ($TenantFilter) {
            $filter = "PartitionKey eq '$TenantFilter'"
        } else {
            $filter = "PartitionKey ne 'StandardReport' and PartitionKey ne ''"
        }
        $AllStandards = Get-CIPPAzDataTableEntity @StandardsTable -Filter $filter

        # Filter by tenant if specified
        $Standards = if ($TenantFilter) {
            $AllStandards
        } else {
            $Tenants = Get-Tenants -IncludeErrors
            $AllStandards | Where-Object { $_.PartitionKey -in $Tenants.defaultDomainName }
        }
        $TagTemplates = Get-CIPPAzDataTableEntity @TemplateTable
        # Build tenant standards data structure
        $tenantData = @{}
        foreach ($Standard in $Standards) {
            $FieldName = $Standard.RowKey
            $FieldValue = $Standard.Value
            $Tenant = $Standard.PartitionKey

            # Process field value
            if ($FieldValue -is [System.Boolean]) {
                $FieldValue = [bool]$FieldValue
            } else {
                try {
                    $FieldValue = ConvertFrom-Json -Depth 5 -InputObject $FieldValue -ErrorAction Stop
                } catch {
                    $FieldValue = [string]$FieldValue
                }
            }

            if (-not $tenantData.ContainsKey($Tenant)) {
                $tenantData[$Tenant] = @{}
            }
            $tenantData[$Tenant][$FieldName] = @{
                Value       = $FieldValue
                LastRefresh = $Standard.TimeStamp.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
            }
        }
        $TenantStandards = $tenantData

        $Results = [System.Collections.Generic.List[object]]::new()

        # Process each template against all tenants
        foreach ($Template in $Templates) {
            $TemplateStandards = $Template.standards
            if (-not $TemplateStandards) {
                continue
            }

            # Check if template has tenant assignments (scope)
            $TemplateAssignedTenants = @()
            $AppliestoAllTenants = $false

            if ($Template.tenantFilter -and $Template.tenantFilter.Count -gt 0) {
                # Extract tenant values from the tenantFilter array
                $TenantValues = $Template.tenantFilter | ForEach-Object {
                    if ($_.type -eq 'group') {
                        ($TenantGroups | Where-Object -Property GroupName -EQ $_.value).Members.defaultDomainName
                    } else {
                        $_.value
                    }
                }

                if ($TenantValues -contains 'AllTenants') {
                    $AppliestoAllTenants = $true
                } else {
                    $TemplateAssignedTenants = $TenantValues
                }
            } else {
                $AppliestoAllTenants = $true
            }

            $StandardsData = foreach ($StandardKey in $TemplateStandards.PSObject.Properties.Name) {
                $StandardConfig = $TemplateStandards.$StandardKey
                $StandardId = "standards.$StandardKey"

                $Actions = @()
                if ($StandardConfig.action) {
                    $Actions = $StandardConfig.action
                } elseif ($StandardConfig.Action) {
                    $Actions = $StandardConfig.Action
                } elseif ($StandardConfig.PSObject.Properties['action']) {
                    $Actions = $StandardConfig.PSObject.Properties['action'].Value
                }

                $ReportingEnabled = $false
                if ($Actions -and $Actions.Count -gt 0) {
                    $ReportingEnabled = ($Actions | Where-Object { $_.value -and ($_.value.ToLower() -eq 'report' -or $_.value.ToLower() -eq 'remediate') }).Count -gt 0
                }

                # Handle Intune templates specially
                if ($StandardKey -eq 'IntuneTemplate' -and $StandardConfig -is [array]) {
                    foreach ($IntuneTemplate in $StandardConfig) {
                        if ($IntuneTemplate.TemplateList.value) {
                            $IntuneStandardId = "standards.IntuneTemplate.$($IntuneTemplate.TemplateList.value)"
                            $IntuneActions = if ($IntuneTemplate.action) { $IntuneTemplate.action } else { @() }
                            $IntuneReportingEnabled = ($IntuneActions | Where-Object { $_.value -and ($_.value.ToLower() -eq 'report' -or $_.value.ToLower() -eq 'remediate') }).Count -gt 0
                            [PSCustomObject]@{
                                StandardId       = $IntuneStandardId
                                ReportingEnabled = $IntuneReportingEnabled
                            }
                        }

                        if ($IntuneTemplate.'TemplateList-Tags') {
                            foreach ($Tag in $IntuneTemplate.'TemplateList-Tags') {
                                Write-Host "Processing Intune Tag: $($Tag.value)"
                                $IntuneActions = if ($IntuneTemplate.action) { $IntuneTemplate.action } else { @() }
                                $IntuneReportingEnabled = ($IntuneActions | Where-Object { $_.value -and ($_.value.ToLower() -eq 'report' -or $_.value.ToLower() -eq 'remediate') }).Count -gt 0
                                $TagTemplate = $TagTemplates | Where-Object -Property package -EQ $Tag.value
                                $TagTemplates | ForEach-Object {
                                    $TagStandardId = "standards.IntuneTemplate.$($_.GUID)"
                                    [PSCustomObject]@{
                                        StandardId       = $TagStandardId
                                        ReportingEnabled = $IntuneReportingEnabled
                                    }
                                }
                            }
                        }
                    }
                }
                # Handle Conditional Access templates specially
                elseif ($StandardKey -eq 'ConditionalAccessTemplate' -and $StandardConfig -is [array]) {
                    foreach ($CATemplate in $StandardConfig) {
                        if ($CATemplate.TemplateList.value) {
                            $CAStandardId = "standards.ConditionalAccessTemplate.$($CATemplate.TemplateList.value)"
                            $CAActions = if ($CATemplate.action) { $CATemplate.action } else { @() }
                            $CAReportingEnabled = ($CAActions | Where-Object { $_.value -and ($_.value.ToLower() -eq 'report' -or $_.value.ToLower() -eq 'remediate') }).Count -gt 0

                            [PSCustomObject]@{
                                StandardId       = $CAStandardId
                                ReportingEnabled = $CAReportingEnabled
                            }
                        }
                    }
                } else {
                    [PSCustomObject]@{
                        StandardId       = $StandardId
                        ReportingEnabled = $ReportingEnabled
                    }
                }
            }

            $AllStandards = $StandardsData.StandardId
            $AllStandardsArray = @($AllStandards)
            $ReportingDisabledStandards = ($StandardsData | Where-Object { -not $_.ReportingEnabled }).StandardId
            $ReportingDisabledSet = [System.Collections.Generic.HashSet[string]]::new()
            foreach ($item in $ReportingDisabledStandards) { [void]$ReportingDisabledSet.Add($item) }
            $TemplateAssignedTenantsSet = if ($TemplateAssignedTenants.Count -gt 0) {
                $set = [System.Collections.Generic.HashSet[string]]::new()
                foreach ($item in $TemplateAssignedTenants) { [void]$set.Add($item) }
                $set
            } else { $null }

            foreach ($TenantName in $TenantStandards.Keys) {
                # Check tenant scope with HashSet and cache tenant data
                if (-not $AppliestoAllTenants) {
                    if ($TemplateAssignedTenantsSet -and -not $TemplateAssignedTenantsSet.Contains($TenantName)) {
                        continue
                    }
                }

                $AllCount = $AllStandards.Count
                $LatestDataCollection = $null
                # Cache hashtable lookup
                $CurrentTenantStandards = $TenantStandards[$TenantName]

                # Pre-allocate list with capacity
                $ComparisonResults = [System.Collections.Generic.List[object]]::new($AllStandardsArray.Count)

                # Use for loop instead of foreach
                for ($i = 0; $i -lt $AllStandardsArray.Count; $i++) {
                    $StandardKey = $AllStandardsArray[$i]

                    # Use HashSet for Contains
                    $IsReportingDisabled = $ReportingDisabledSet.Contains($StandardKey)
                    # Use cached tenant data
                    $HasStandard = $CurrentTenantStandards.ContainsKey($StandardKey)

                    if ($HasStandard) {
                        $StandardObject = $CurrentTenantStandards[$StandardKey]
                        $Value = $StandardObject.Value

                        if ($StandardObject.LastRefresh) {
                            $RefreshTime = [DateTime]::Parse($StandardObject.LastRefresh)
                            if (-not $LatestDataCollection -or $RefreshTime -gt $LatestDataCollection) {
                                $LatestDataCollection = $RefreshTime
                            }
                        }

                        $IsCompliant = ($Value -eq $true)
                        $IsLicenseMissing = ($Value -is [string] -and $Value -like 'License Missing:*')

                        $ComplianceStatus = if ($IsReportingDisabled) {
                            'Reporting Disabled'
                        } elseif ($IsCompliant) {
                            'Compliant'
                        } elseif ($IsLicenseMissing) {
                            'License Missing'
                        } else {
                            'Non-Compliant'
                        }

                        $StandardValueJson = $Value | ConvertTo-Json -Depth 5 -Compress

                        $ComparisonResults.Add([PSCustomObject]@{
                                StandardName      = $StandardKey
                                Compliant         = $IsCompliant
                                StandardValue     = $StandardValueJson
                                ComplianceStatus  = $ComplianceStatus
                                ReportingDisabled = $IsReportingDisabled
                            })
                    } else {
                        $ComplianceStatus = if ($IsReportingDisabled) {
                            'Reporting Disabled'
                        } else {
                            'Non-Compliant'
                        }

                        $ComparisonResults.Add([PSCustomObject]@{
                                StandardName      = $StandardKey
                                Compliant         = $false
                                StandardValue     = 'NOT FOUND'
                                ComplianceStatus  = $ComplianceStatus
                                ReportingDisabled = $IsReportingDisabled
                            })
                    }
                }

                # Replace Where-Object with direct counting
                $CompliantStandards = 0
                $NonCompliantStandards = 0
                $LicenseMissingStandards = 0
                $ReportingDisabledStandardsCount = 0

                foreach ($item in $ComparisonResults) {
                    if ($item.ComplianceStatus -eq 'Compliant') { $CompliantStandards++ }
                    elseif ($item.ComplianceStatus -eq 'Non-Compliant') { $NonCompliantStandards++ }
                    elseif ($item.ComplianceStatus -eq 'License Missing') { $LicenseMissingStandards++ }
                    if ($item.ReportingDisabled) { $ReportingDisabledStandardsCount++ }
                }

                $AlignmentPercentage = if (($AllCount - $ReportingDisabledStandardsCount) -gt 0) {
                    [Math]::Round(($CompliantStandards / ($AllCount - $ReportingDisabledStandardsCount)) * 100)
                } else {
                    0
                }

                $LicenseMissingPercentage = if ($AllCount -gt 0) {
                    [Math]::Round(($LicenseMissingStandards / $AllCount) * 100)
                } else {
                    0
                }

                $Result = [PSCustomObject]@{
                    TenantFilter             = $TenantName
                    StandardName             = $Template.templateName
                    StandardId               = $Template.GUID
                    standardType             = $Template.type
                    standardSettings         = $Template.Standards
                    driftAlertEmail          = $Template.driftAlertEmail
                    driftAlertWebhook        = $Template.driftAlertWebhook
                    AlignmentScore           = $AlignmentPercentage
                    LicenseMissingPercentage = $LicenseMissingPercentage
                    CombinedScore            = $AlignmentPercentage + $LicenseMissingPercentage
                    CompliantStandards       = $CompliantStandards
                    NonCompliantStandards    = $NonCompliantStandards
                    LicenseMissingStandards  = $LicenseMissingStandards
                    TotalStandards           = $AllCount
                    ReportingDisabledCount   = $ReportingDisabledStandardsCount
                    LatestDataCollection     = if ($LatestDataCollection) { $LatestDataCollection } else { $null }
                    ComparisonDetails        = $ComparisonResults
                }

                $Results.Add($Result)
            }
        }

        return $Results
    } catch {
        Write-Error "Error getting tenant alignment data: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        throw
    }
}
#EndRegion './Public/Functions/Get-CIPPTenantAlignment.ps1' 343
#Region './Public/Functions/Get-CIPPURLName.ps1' -1

function Get-CIPPURLName {
    <#
    .SYNOPSIS
        Gets the correct Microsoft Graph URL based on the OData type of a template
    .DESCRIPTION
        This function examines the @odata.type property of a JSON template object and returns
        the appropriate full Microsoft Graph API URL for that resource type.
    .PARAMETER Template
        The template object containing the @odata.type property to analyze
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Get-CIPPURLName -Template $MyTemplate
    .EXAMPLE
        $Template | Get-CIPPURLName
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [PSCustomObject]$Template
    )

    # Extract the OData type from the template
    $ODataType = $Template.'@odata.type'
    if ($Template.urlName) { return $Template.urlName }

    if (-not $ODataType) {
        Write-Warning 'No @odata.type property found in template'
        return $null
    }

    # Determine the full Microsoft Graph URL based on the OData type
    $URLName = switch -wildcard ($ODataType) {
        # Device Compliance Policies
        '*CompliancePolicy' {
            'deviceManagement/deviceCompliancePolicies'
        }
        '*deviceCompliancePolicy' {
            'deviceManagement/deviceCompliancePolicies'
        }

        # Managed App Policies (App Protection)
        '*ManagedAppProtection' {
            'deviceAppManagement/managedAppPolicies'
        }
        '*managedAppPolicies' {
            'deviceAppManagement/managedAppPolicies'
        }
        '*managedAppPolicy' {
            'deviceAppManagement/managedAppPolicies'
        }
        '*appProtectionPolicy' {
            'deviceAppManagement/managedAppPolicies'
        }

        # Configuration Policies (Settings Catalog)
        '*configurationPolicies' {
            'deviceManagement/configurationPolicies'
        }
        '*deviceManagementConfigurationPolicy' {
            'deviceManagement/configurationPolicies'
        }

        # Windows Driver Update Profiles
        '*windowsDriverUpdateProfiles' {
            'deviceManagement/windowsDriverUpdateProfiles'
        }
        '*windowsDriverUpdateProfile' {
            'deviceManagement/windowsDriverUpdateProfiles'
        }

        # Device Configurations
        '*deviceConfigurations' {
            'deviceManagement/deviceConfigurations'
        }
        '*deviceConfiguration' {
            'deviceManagement/deviceConfigurations'
        }

        # Group Policy Configurations (Administrative Templates)
        '*groupPolicyConfigurations' {
            'deviceManagement/groupPolicyConfigurations'
        }
        '*groupPolicyConfiguration' {
            'deviceManagement/groupPolicyConfigurations'
        }

        # Conditional Access Policies
        '*conditionalAccessPolicy' {
            'identity/conditionalAccess/policies'
        }

        # Device Enrollment Configurations
        '*deviceEnrollmentConfiguration' {
            'deviceManagement/deviceEnrollmentConfigurations'
        }
        '*enrollmentConfiguration' {
            'deviceManagement/deviceEnrollmentConfigurations'
        }

        # Mobile App Configurations
        '*mobileAppConfiguration' {
            'deviceAppManagement/mobileAppConfigurations'
        }
        '*appConfiguration' {
            'deviceAppManagement/mobileAppConfigurations'
        }

        # Windows Feature Update Profiles
        '*windowsFeatureUpdateProfile' {
            'deviceManagement/windowsFeatureUpdateProfiles'
        }

        # Device Health Scripts (Remediation Scripts)
        '*deviceHealthScript' {
            'deviceManagement/deviceHealthScripts'
        }

        # Device Management Scripts (PowerShell Scripts)
        '*deviceManagementScript' {
            'deviceManagement/deviceManagementScripts'
        }

        # Mobile Applications
        '*mobileApp' {
            'deviceAppManagement/mobileApps'
        }
        '*winGetApp' {
            'deviceAppManagement/mobileApps'
        }
        '*officeSuiteApp' {
            'deviceAppManagement/mobileApps'
        }

        # Named Locations
        '*namedLocation' {
            'identity/conditionalAccess/namedLocations'
        }
        '*ipNamedLocation' {
            'identity/conditionalAccess/namedLocations'
        }
        '*countryNamedLocation' {
            'identity/conditionalAccess/namedLocations'
        }

        # Default fallback
        default {
            Write-Warning "Unknown OData type: $ODataType"
            $null
        }
    }

    return $URLName
}

#EndRegion './Public/Functions/Get-CIPPURLName.ps1' 156
#Region './Public/Functions/Test-CIPPStandardLicense.ps1' -1

function Test-CIPPStandardLicense {
    <#
    .SYNOPSIS
        Tests if a tenant has the required license capabilities for a specific standard
    .DESCRIPTION
        This function checks if a tenant has the necessary license capabilities to run a specific standard.
        If the license is missing, it logs an error and sets the comparison field appropriately.
    .PARAMETER StandardName
        The name of the standard to check licensing for
    .PARAMETER TenantFilter
        The tenant to check licensing for
    .PARAMETER RequiredCapabilities
        Array of required capabilities for the standard
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Test-CIPPStandardLicense -StandardName "ConditionalAccessTemplate" -TenantFilter "contoso.onmicrosoft.com" -RequiredCapabilities @('AADPremiumService')
    .EXAMPLE
        Test-CIPPStandardLicense -StandardName "SafeLinksPolicy" -TenantFilter "contoso.onmicrosoft.com" -RequiredCapabilities @('DEFENDER_FOR_OFFICE_365_PLAN_1', 'DEFENDER_FOR_OFFICE_365_PLAN_2')
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$StandardName,

        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $true)]
        [string[]]$RequiredCapabilities,

        [Parameter(Mandatory = $false)]
        [switch]$SkipLog
    )

    try {
        $TenantCapabilities = Get-CIPPTenantCapabilities -TenantFilter $TenantFilter

        $Capabilities = foreach ($Capability in $RequiredCapabilities) {
            Write-Verbose "Checking capability: $Capability"
            if ($TenantCapabilities.$Capability -eq $true) {
                $Capability
            }
        }

        if ($Capabilities.Count -le 0) {
            if (!$SkipLog.IsPresent) {
                Write-LogMessage -API 'Standards' -tenant $TenantFilter -message "Tenant does not have the required capability to run standard $StandardName`: The tenant needs one of the following service plans: $($RequiredCapabilities -join ',')" -sev Error
                Set-CIPPStandardsCompareField -FieldName "standards.$StandardName" -FieldValue "License Missing: This tenant is not licensed for the following capabilities: $($RequiredCapabilities -join ',')" -Tenant $TenantFilter
                Write-Verbose "Tenant does not have the required capability to run standard $StandardName - $($RequiredCapabilities -join ','). Exiting"
            }
            return $false
        }
        Write-Verbose "Tenant has the required capabilities for standard $StandardName"
        return $true
    } catch {
        if (!$SkipLog.IsPresent) {
            # Sanitize exception message to prevent JSON parsing issues - remove characters that could interfere with JSON detection
            $SanitizedMessage = $_.Exception.Message -replace '[{}\[\]]', ''
            Write-LogMessage -API 'Standards' -tenant $TenantFilter -message "Error checking license capabilities for standard $StandardName`: $SanitizedMessage" -sev Error
            Set-CIPPStandardsCompareField -FieldName "standards.$StandardName" -FieldValue "License Missing: Error checking license capabilities - $SanitizedMessage" -Tenant $TenantFilter
        }
        return $false
    }
}
#EndRegion './Public/Functions/Test-CIPPStandardLicense.ps1' 66
#Region './Public/Get-ApplicationInsightsQuery.ps1' -1

function Get-ApplicationInsightsQuery {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$Query
    )

    if (-not $env:APPLICATIONINSIGHTS_CONNECTION_STRING -and -not $env:APPINSIGHTS_INSTRUMENTATIONKEY) {
        throw 'Application Insights is not enabled for this instance.'
    }

    if ($env:MSI_SECRET) {
        $null = Connect-AzAccount -Identity
    }

    $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
    if ($env:WEBSITE_SKU -ne 'FlexConsumption' -and $Owner -match '^(?<SubscriptionId>[^+]+)\+(?<RGName>[^-]+(?:-[^-]+)*?)(?:-[^-]+webspace(?:-Linux)?)?$') {
        $RGName = $Matches.RGName
    } else {
        $RGName = $env:WEBSITE_RESOURCE_GROUP
    }
    $AppInsightsName = $env:WEBSITE_SITE_NAME

    $Body = @{
        'query'            = $Query
        'options'          = @{'truncationMaxSize' = 67108864 }
        'maxRows'          = 1001
        'workspaceFilters' = @{'regions' = @() }
    } | ConvertTo-Json -Depth 10 -Compress

    $AppInsightsQuery = 'subscriptions/{0}/resourceGroups/{1}/providers/microsoft.insights/components/{2}/query' -f $SubscriptionId, $RGName, $AppInsightsName

    $resource = 'https://api.loganalytics.io'
    $Token = Get-AzAccessToken -ResourceUrl $resource

    $headerParams = @{'Authorization' = "Bearer $($Token.Token)" }
    $logAnalyticsBaseURI = 'https://api.loganalytics.io/v1'

    $result = Invoke-RestMethod -Method POST -Uri "$($logAnalyticsBaseURI)/$AppInsightsQuery" -Headers $headerParams -Body $Body -ContentType 'application/json' -ErrorAction Stop

    # Format Result to PSObject
    $headerRow = $null
    $headerRow = $result.tables.columns | Select-Object name
    $columnsCount = $headerRow.Count
    $logData = foreach ($row in $result.tables.rows) {
        $data = New-Object PSObject
        for ($i = 0; $i -lt $columnsCount; $i++) {
            $data | Add-Member -MemberType NoteProperty -Name $headerRow[$i].name -Value $row[$i]
        }
        $data
    }

    return $logData
}
#EndRegion './Public/Get-ApplicationInsightsQuery.ps1' 55
#Region './Public/Get-CIPPAuthentication.ps1' -1


function Get-CIPPAuthentication {
    [CmdletBinding()]
    param (
        $APIName = 'Get Keyvault Authentication'
    )
    $Variables = @('ApplicationID', 'ApplicationSecret', 'TenantID', 'RefreshToken')

    try {
        if ($env:AzureWebJobsStorage -eq 'UseDevelopmentStorage=true' -or $env:NonLocalHostAzurite -eq 'true') {
            $Table = Get-CIPPTable -tablename 'DevSecrets'
            $Secret = Get-AzDataTableEntity @Table -Filter "PartitionKey eq 'Secret' and RowKey eq 'Secret'"
            if (!$Secret) {
                throw 'Development variables not set'
            }
            foreach ($Var in $Variables) {
                if ($Secret.$Var) {
                    Set-Item -Path env:$Var -Value $Secret.$Var -Force -ErrorAction Stop
                }
            }
            Write-Host "Got secrets from dev storage. ApplicationID: $env:ApplicationID"
            #Get list of tenants that have 'directTenant' set to true
            #get directtenants directly from table, avoid get-tenants due to performance issues
            $TenantsTable = Get-CippTable -tablename 'Tenants'
            $Filter = "PartitionKey eq 'Tenants' and delegatedPrivilegeStatus eq 'directTenant'"
            $tenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
            if ($tenants) {
                $tenants | ForEach-Object {
                    $secretname = $_.customerId -replace '-', '_'
                    if ($secret.$secretname) {
                        $name = $_.customerId
                        Set-Item -Path env:$name -Value $secret.$secretname -Force
                    }
                }
            }
        } else {
            Write-Information 'Connecting to Azure'
            Connect-AzAccount -Identity
            $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
            try {
                $Context = Get-AzContext
                if ($Context.Subscription) {
                    #Write-Information "Current context: $($Context | ConvertTo-Json)"
                    if ($Context.Subscription.Id -ne $SubscriptionId) {
                        Write-Information "Setting context to subscription $SubscriptionId"
                        $null = Set-AzContext -SubscriptionId $SubscriptionId
                    }
                }
            } catch {
                Write-Information "ERROR: Could not set context to subscription $SubscriptionId."
            }

            $keyvaultname = ($env:WEBSITE_DEPLOYMENT_ID -split '-')[0]
            #Get list of tenants that have 'directTenant' set to true
            $TenantsTable = Get-CippTable -tablename 'Tenants'
            $Filter = "PartitionKey eq 'Tenants' and delegatedPrivilegeStatus eq 'directTenant'"
            $tenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
            if ($tenants) {
                $tenants | ForEach-Object {
                    $name = $_.customerId
                    $secret = Get-AzKeyVaultSecret -VaultName $keyvaultname -Name $name -AsPlainText -ErrorAction Stop
                    if ($secret) {
                        Set-Item -Path env:$name -Value $secret -Force
                    }
                }
            }
            $Variables | ForEach-Object {
                Set-Item -Path env:$_ -Value (Get-AzKeyVaultSecret -VaultName $keyvaultname -Name $_ -AsPlainText -ErrorAction Stop) -Force
            }
        }
        $env:SetFromProfile = $true
        Write-LogMessage -message 'Reloaded authentication data from KeyVault' -Sev 'debug' -API 'CIPP Authentication'

        return $true
    } catch {
        Write-LogMessage -message 'Could not retrieve keys from Keyvault' -Sev 'CRITICAL' -API 'CIPP Authentication' -LogData (Get-CippException -Exception $_)
        return $false
    }
}
#EndRegion './Public/Get-CIPPAuthentication.ps1' 80
#Region './Public/Get-CIPPAzDatatableEntity.ps1' -1

function Get-CIPPAzDataTableEntity {
    [CmdletBinding()]
    param(
        $Context,
        $Filter,
        $Property,
        $First,
        $Skip,
        $Sort,
        $Count
    )

    $Results = Get-AzDataTableEntity @PSBoundParameters
    $mergedResults = @{}
    $rootEntities = @{} # Keyed by "$PartitionKey|$RowKey"

    foreach ($entity in $Results) {
        $partitionKey = $entity.PartitionKey
        $rowKey = $entity.RowKey
        $hasOriginalId = $entity.PSObject.Properties.Match('OriginalEntityId') -and $entity.OriginalEntityId

        if (-not $mergedResults.ContainsKey($partitionKey)) {
            $mergedResults[$partitionKey] = @{}
        }

        if (-not $hasOriginalId) {
            # It's a standalone root row
            $rootEntities["$partitionKey|$rowKey"] = $true
            $mergedResults[$partitionKey][$rowKey] = @{
                Entity = $entity
                Parts  = [System.Collections.Generic.List[object]]::new()
            }
            continue
        }

        # It's a part of something else
        $entityId = $entity.OriginalEntityId

        # Check if this entity's target has a "real" base
        if ($rootEntities.ContainsKey("$partitionKey|$entityId")) {
            # Root row exists  skip merging this part
            continue
        }

        # Merge it as a part
        if (-not $mergedResults[$partitionKey].ContainsKey($entityId)) {
            $mergedResults[$partitionKey][$entityId] = @{
                Parts = [System.Collections.Generic.List[object]]::new()
            }
        }
        $mergedResults[$partitionKey][$entityId]['Parts'].Add($entity)
    }

    $finalResults = [System.Collections.Generic.List[object]]::new()
    foreach ($partitionKey in $mergedResults.Keys) {
        foreach ($entityId in $mergedResults[$partitionKey].Keys) {
            $entityData = $mergedResults[$partitionKey][$entityId]
            if (($entityData.Parts | Measure-Object).Count -gt 0) {
                $fullEntity = [PSCustomObject]@{}
                $parts = $entityData.Parts | Sort-Object PartIndex
                foreach ($part in $parts) {
                    foreach ($key in $part.PSObject.Properties.Name) {
                        if ($key -notin @('OriginalEntityId', 'PartIndex', 'PartitionKey', 'RowKey', 'Timestamp')) {
                            if ($fullEntity.PSObject.Properties[$key]) {
                                $fullEntity | Add-Member -MemberType NoteProperty -Name $key -Value ($fullEntity.$key + $part.$key) -Force
                            } else {
                                $fullEntity | Add-Member -MemberType NoteProperty -Name $key -Value $part.$key
                            }
                        }
                    }
                }
                $fullEntity | Add-Member -MemberType NoteProperty -Name 'PartitionKey' -Value $parts[0].PartitionKey -Force
                $fullEntity | Add-Member -MemberType NoteProperty -Name 'RowKey' -Value $entityId -Force
                $fullEntity | Add-Member -MemberType NoteProperty -Name 'Timestamp' -Value $parts[0].Timestamp -Force
                $finalResults.Add($fullEntity)
            } else {
                $FinalResults.Add($entityData.Entity)
            }
        }
    }

    foreach ($entity in $finalResults) {
        if ($entity.SplitOverProps) {
            $splitInfoList = $entity.SplitOverProps | ConvertFrom-Json
            foreach ($splitInfo in $splitInfoList) {
                $mergedData = [string]::Join('', ($splitInfo.SplitHeaders | ForEach-Object { $entity.$_ }))
                $entity | Add-Member -NotePropertyName $splitInfo.OriginalHeader -NotePropertyValue $mergedData -Force
                $propsToRemove = $splitInfo.SplitHeaders
                foreach ($prop in $propsToRemove) {
                    $entity.PSObject.Properties.Remove($prop)
                }
            }
            $entity.PSObject.Properties.Remove('SplitOverProps')
        }
    }

    return $finalResults
}
#EndRegion './Public/Get-CIPPAzDatatableEntity.ps1' 99
#Region './Public/Get-CIPPBackup.ps1' -1

function Get-CIPPBackup {
    [CmdletBinding()]
    param (
        [string]$Type = 'CIPP',
        [string]$TenantFilter,
        [string]$Name,
        [switch]$NameOnly
    )

    Write-Host "Getting backup for $Type with TenantFilter $TenantFilter"
    $Table = Get-CippTable -tablename "$($Type)Backup"

    $Conditions = [System.Collections.Generic.List[string]]::new()
    $Conditions.Add("PartitionKey eq '$($Type)Backup'")

    if ($Name) {
        $Conditions.Add("RowKey eq '$($Name)' or OriginalEntityId eq '$($Name)'")
    }

    if ($NameOnly.IsPresent) {
        $Table.Property = @('PartitionKey', 'RowKey', 'Timestamp', 'OriginalEntityId')
    }

    $Filter = $Conditions -join ' and '
    $Table.Filter = $Filter
    $Info = Get-CIPPAzDataTableEntity @Table -Debug
    if ($TenantFilter) {
        $Info = $Info | Where-Object { $_.TenantFilter -eq $TenantFilter }
    }
    return $Info
}
#EndRegion './Public/Get-CIPPBackup.ps1' 32
#Region './Public/Get-CIPPBitlockerKey.ps1' -1

<#
.SYNOPSIS
    Retrieves BitLocker recovery keys for a managed device from Microsoft Graph API.

.DESCRIPTION
    This function queries the Microsoft Graph API to retrieve all BitLocker recovery keys
    associated with a specified device. It handles cases where no key is found and provides appropriate
    logging and error handling.
.PARAMETER Device
    The ID of the device for which to retrieve BitLocker recovery keys.

.PARAMETER TenantFilter
    The tenant ID to filter the request to the appropriate tenant.

.PARAMETER APIName
    The name of the API operation for logging purposes. Defaults to 'Get BitLocker key'.

.PARAMETER Headers
    The headers to include in the request, typically used for authentication and logging.

.OUTPUTS
    Array of PSCustomObject with properties:
    - resultText: Formatted string containing the key ID and key value
    - copyField: The raw key value
    - state: Status of the operation ('success')

    Or a string message if no keys are found.
#>

function Get-CIPPBitLockerKey {
    [CmdletBinding()]
    param (
        $Device,
        $TenantFilter,
        $APIName = 'Get BitLocker key',
        $Headers
    )

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/informationProtection/bitlocker/recoveryKeys?`$filter=deviceId eq '$($Device)'" -tenantid $TenantFilter |
            ForEach-Object {
                $BitLockerKeyObject = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/informationProtection/bitlocker/recoveryKeys/$($_.id)?`$select=key" -tenantid $TenantFilter)
                [PSCustomObject]@{
                    resultText = "Id: $($_.id) Key: $($BitLockerKeyObject.key)"
                    copyField  = $BitLockerKeyObject.key
                    state      = 'success'
                }
            }

        if ($GraphRequest.Count -eq 0) {
            Write-LogMessage -headers $Headers -API $APIName -message "No BitLocker recovery keys found for $($Device)" -Sev Info -tenant $TenantFilter
            return "No BitLocker recovery keys found for $($Device)"
        }
        Write-LogMessage -headers $Headers -API $APIName -message "Retrieved BitLocker recovery keys for $($Device)" -Sev Info -tenant $TenantFilter
        return $GraphRequest
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not retrieve BitLocker recovery key for $($Device). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Get-CIPPBitlockerKey.ps1' 63
#Region './Public/Get-CippCustomDataAttributes.ps1' -1

function Get-CippCustomDataAttributes {
    <#
    .SYNOPSIS
        Get the custom data attributes for CIPP
    .DESCRIPTION
        This function is used to get the custom data attributes for CIPP
    #>
    [CmdletBinding()]
    param(
        $TargetObject = 'All'
    )
    $CustomDataTable = Get-CippTable -tablename 'CustomData'
    $CustomDataEntities = Get-CIPPAzDataTableEntity @CustomDataTable
    $AvailableAttributes = foreach ($CustomDataEntity in $CustomDataEntities) {
        $Type = $CustomDataEntity.PartitionKey
        $CustomData = $CustomDataEntity.JSON | ConvertFrom-Json
        if ($CustomData) {
            if ($Type -eq 'SchemaExtension') {
                $Name = $CustomData.id
                foreach ($TargetObject in $CustomData.targetTypes) {
                    foreach ($Property in $CustomData.properties) {
                        [PSCustomObject]@{
                            name          = '{0}.{1}' -f $Name, $Property.name
                            type          = $Type
                            targetObject  = $TargetObject
                            dataType      = $Property.type
                            isMultiValued = $false
                        }
                    }
                }
            } elseif ($Type -eq 'DirectoryExtension') {
                $Name = $CustomDataEntity.RowKey
                foreach ($TargetObject in $CustomData.targetObjects) {
                    [PSCustomObject]@{
                        name          = $Name
                        type          = $Type
                        targetObject  = $TargetObject
                        dataType      = $CustomData.dataType
                        isMultiValued = $CustomData.isMultiValued
                    }
                }
            }
        }
    }

    if ($TargetObject -eq 'All') {
        return $AvailableAttributes
    } else {
        return $AvailableAttributes | Where-Object { $_.targetObject -eq $TargetObject }
    }
}
#EndRegion './Public/Get-CippCustomDataAttributes.ps1' 52
#Region './Public/Get-CIPPDomainAnalyser.ps1' -1

function Get-CIPPDomainAnalyser {
    <#
    .SYNOPSIS
    Domain Analyser list

    .DESCRIPTION
    This function returns a list of domain analyser results for the selected tenant filter

    .PARAMETER TenantFilter
    Tenant to filter by, enter AllTenants to get all results

    .EXAMPLE
    Get-CIPPDomainAnalyser -TenantFilter 'AllTenants'
    #>
    [CmdletBinding()]
    param([string]$TenantFilter)
    $DomainTable = Get-CIPPTable -Table 'Domains'

    # Get all the things
    #Transform the tenantFilter to the GUID.
    if ($TenantFilter -ne 'AllTenants' -and ![string]::IsNullOrEmpty($TenantFilter)) {
        $TenantFilter = (Get-Tenants -TenantFilter $tenantFilter).customerId
        $DomainTable.Filter = "TenantGUID eq '{0}'" -f $TenantFilter
    } else {
        $Tenants = Get-Tenants -IncludeErrors
    }
    $Domains = Get-CIPPAzDataTableEntity @DomainTable | Where-Object { $_.TenantGUID -in $Tenants.customerId -or $TenantFilter -eq $_.TenantGUID }
    try {
        # Extract json from table results
        $Results = foreach ($DomainAnalyserResult in ($Domains).DomainAnalyser) {
            try {
                if (![string]::IsNullOrEmpty($DomainAnalyserResult)) {
                    $Object = $DomainAnalyserResult | ConvertFrom-Json -ErrorAction SilentlyContinue
                    $Object
                }
            } catch {}
        }
    } catch {
        $Results = @()
    }
    return $Results
}
#EndRegion './Public/Get-CIPPDomainAnalyser.ps1' 43
#Region './Public/Get-CIPPDrift.ps1' -1

function Get-CIPPDrift {
    <#
    .SYNOPSIS
        Gets comprehensive drift information for a tenant including standards compliance and policy deviations
    .DESCRIPTION
        This function collects drift information by executing Get-CIPPTenantAlignment and comparing
        tenant policies against standards templates. It identifies both standards deviations and
        extra policies not defined in templates.
    .PARAMETER TenantFilter
        The tenant to get drift data for
    .PARAMETER TemplateId
        Optional specific template GUID to check drift for. If not specified, processes all templates.
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Get-CIPPDrift -TenantFilter "contoso.onmicrosoft.com"
    .EXAMPLE
        Get-CIPPDrift -TenantFilter "contoso.onmicrosoft.com" -TemplateId "12345-67890-abcdef"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $false)]
        [string]$TemplateId,

        [Parameter(Mandatory = $false)]
        [switch]$AllTenants
    )

    $IntuneCapable = Test-CIPPStandardLicense -StandardName 'IntuneTemplate_general' -TenantFilter $TenantFilter -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    $ConditionalAccessCapable = Test-CIPPStandardLicense -StandardName 'ConditionalAccessTemplate_general' -TenantFilter $TenantFilter -RequiredCapabilities @('AAD_PREMIUM', 'AAD_PREMIUM_P2')
    $IntuneTable = Get-CippTable -tablename 'templates'
    if ($IntuneCapable) {
        $IntuneFilter = "PartitionKey eq 'IntuneTemplate'"
        $RawIntuneTemplates = (Get-CIPPAzDataTableEntity @IntuneTable -Filter $IntuneFilter)
        $AllIntuneTemplates = $RawIntuneTemplates | ForEach-Object {
            try {
                $JSONData = $_.JSON | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue
                $data = $JSONData.RAWJson | ConvertFrom-Json -Depth 10 -ErrorAction SilentlyContinue
                $data | Add-Member -NotePropertyName 'displayName' -NotePropertyValue $JSONData.Displayname -Force
                $data | Add-Member -NotePropertyName 'description' -NotePropertyValue $JSONData.Description -Force
                $data | Add-Member -NotePropertyName 'Type' -NotePropertyValue $JSONData.Type -Force
                $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.RowKey -Force
                $data
            } catch {
                # Skip invalid templates
            }
        } | Sort-Object -Property displayName
    }
    # Load all CA templates
    if ($ConditionalAccessCapable) {
        $CAFilter = "PartitionKey eq 'CATemplate'"
        $RawCATemplates = (Get-CIPPAzDataTableEntity @IntuneTable -Filter $CAFilter)
        $AllCATemplates = $RawCATemplates | ForEach-Object {
            try {
                $data = $_.JSON | ConvertFrom-Json -Depth 100 -ErrorAction SilentlyContinue
                $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.RowKey -Force
                $data
            } catch {
                # Skip invalid templates
            }
        } | Sort-Object -Property displayName
    }

    try {
        $AlignmentData = Get-CIPPTenantAlignment -TenantFilter $TenantFilter -TemplateId $TemplateId | Where-Object -Property standardType -EQ 'drift'

        if (-not $AlignmentData) {
            Write-Warning "No alignment data found for tenant $TenantFilter"
            return @()
        }

        # Get existing drift states from the tenantDrift table
        $DriftTable = Get-CippTable -tablename 'tenantDrift'
        $DriftFilter = "PartitionKey eq '$TenantFilter'"
        $ExistingDriftStates = @{}
        try {
            $DriftEntities = Get-CIPPAzDataTableEntity @DriftTable -Filter $DriftFilter
            foreach ($Entity in $DriftEntities) {
                $ExistingDriftStates[$Entity.StandardName] = $Entity
            }
        } catch {
            Write-Warning "Failed to get existing drift states: $($_.Exception.Message)"
        }

        $Results = [System.Collections.Generic.List[object]]::new()
        foreach ($Alignment in $AlignmentData) {
            # Initialize deviation collections
            $StandardsDeviations = [System.Collections.Generic.List[object]]::new()
            $PolicyDeviations = [System.Collections.Generic.List[object]]::new()

            # Process standards compliance deviations
            if ($Alignment.ComparisonDetails) {
                foreach ($ComparisonItem in $Alignment.ComparisonDetails) {
                    if ($ComparisonItem.Compliant -ne $true) {
                        $Status = if ($ExistingDriftStates.ContainsKey($ComparisonItem.StandardName)) {
                            $ExistingDriftStates[$ComparisonItem.StandardName].Status
                        } else {
                            'New'
                        }
                        # Reset displayName and description for each deviation to prevent carryover from previous iterations
                        $displayName = $null
                        $standardDescription = $null
                        #if the $ComparisonItem.StandardName contains *intuneTemplate*, then it's an Intune policy deviation, and we need to grab the correct displayname from the template table
                        if ($ComparisonItem.StandardName -like '*intuneTemplate*') {
                            $CompareGuid = $ComparisonItem.StandardName.Split('.') | Select-Object -Index 2
                            Write-Verbose "Extracted GUID: $CompareGuid"
                            $Template = $AllIntuneTemplates | Where-Object { $_.GUID -eq "$CompareGuid" }
                            if ($Template) {
                                $displayName = $Template.displayName
                                $standardDescription = $Template.description
                            }
                        }
                        # Handle Conditional Access templates
                        if ($ComparisonItem.StandardName -like '*ConditionalAccessTemplate*') {
                            $CompareGuid = $ComparisonItem.StandardName.Split('.') | Select-Object -Index 2
                            Write-Verbose "Extracted CA GUID: $CompareGuid"
                            $Template = $AllCATemplates | Where-Object { $_.GUID -eq "$CompareGuid" }
                            if ($Template) {
                                $displayName = $Template.displayName
                                $standardDescription = $Template.description
                            }
                        }
                        $reason = if ($ExistingDriftStates.ContainsKey($ComparisonItem.StandardName)) { $ExistingDriftStates[$ComparisonItem.StandardName].Reason }
                        $User = if ($ExistingDriftStates.ContainsKey($ComparisonItem.StandardName)) { $ExistingDriftStates[$ComparisonItem.StandardName].User }
                        $StandardsDeviations.Add([PSCustomObject]@{
                                standardName        = $ComparisonItem.StandardName
                                standardDisplayName = $displayName
                                standardDescription = $standardDescription
                                expectedValue       = 'Compliant'
                                receivedValue       = $ComparisonItem.StandardValue
                                state               = 'current'
                                Status              = $Status
                                Reason              = $reason
                                lastChangedByUser   = $User
                            })
                    }
                }
            }

            # Perform full policy collection
            if ($IntuneCapable) {
                # Always get live data when not in AllTenants mode
                $IntuneRequests = @(
                    @{
                        id     = 'deviceAppManagement/managedAppPolicies'
                        url    = 'deviceAppManagement/managedAppPolicies?$top=999'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/deviceCompliancePolicies'
                        url    = 'deviceManagement/deviceCompliancePolicies?$top=999'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/groupPolicyConfigurations'
                        url    = 'deviceManagement/groupPolicyConfigurations?$top=999'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/deviceConfigurations'
                        url    = 'deviceManagement/deviceConfigurations?$top=999'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/configurationPolicies'
                        url    = 'deviceManagement/configurationPolicies?$top=999'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/windowsDriverUpdateProfiles'
                        url    = 'deviceManagement/windowsDriverUpdateProfiles?$top=200'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/windowsFeatureUpdateProfiles'
                        url    = 'deviceManagement/windowsFeatureUpdateProfiles?$top=200'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/windowsQualityUpdatePolicies'
                        url    = 'deviceManagement/windowsQualityUpdatePolicies?$top=200'
                        method = 'GET'
                    }
                    @{
                        id     = 'deviceManagement/windowsQualityUpdateProfiles'
                        url    = 'deviceManagement/windowsQualityUpdateProfiles?$top=200'
                        method = 'GET'
                    }
                )

                $TenantIntunePolicies = [System.Collections.Generic.List[object]]::new()

                try {
                    $IntuneGraphRequest = New-GraphBulkRequest -Requests $IntuneRequests -tenantid $TenantFilter -asapp $true

                    foreach ($Request in $IntuneGraphRequest) {
                        if ($Request.body.value) {
                            foreach ($Policy in $Request.body.value) {
                                $TenantIntunePolicies.Add([PSCustomObject]@{
                                        Type   = $Request.id
                                        Policy = $Policy
                                    })
                            }
                        }
                    }
                } catch {
                    Write-Warning "Failed to get Intune policies: $($_.Exception.Message)"
                }
            }
            # Get Conditional Access policies
            if ($ConditionalAccessCapable) {
                try {
                    $CARequests = @(
                        @{
                            id     = 'policies'
                            url    = 'identity/conditionalAccess/policies?$top=999'
                            method = 'GET'
                        }
                    )
                    $CAGraphRequest = New-GraphBulkRequest -Requests $CARequests -tenantid $TenantFilter -asapp $true
                    $TenantCAPolicies = ($CAGraphRequest | Where-Object { $_.id -eq 'policies' }).body.value
                } catch {
                    Write-Warning "Failed to get Conditional Access policies: $($_.Exception.Message)"
                    $TenantCAPolicies = @()
                }
            }

            if ($Alignment.standardSettings) {
                if ($Alignment.standardSettings.IntuneTemplate) {
                    $IntuneTemplateIds = $Alignment.standardSettings.IntuneTemplate.TemplateList | ForEach-Object { $_.value }
                }
                if ($Alignment.standardSettings.ConditionalAccessTemplate) {
                    $CATemplateIds = $Alignment.standardSettings.ConditionalAccessTemplate.TemplateList | ForEach-Object { $_.value }
                }
            }

            # Get actual CA templates from templates table
            if ($CATemplateIds.Count -gt 0) {
                try {
                    $TemplateCATemplates = $AllCATemplates | Where-Object { $_.GUID -in $CATemplateIds }
                } catch {
                    Write-Warning "Failed to get CA templates: $($_.Exception.Message)"
                }
            }

            # Get actual Intune templates from templates table
            if ($IntuneTemplateIds.Count -gt 0) {
                try {

                    $TemplateIntuneTemplates = $AllIntuneTemplates | Where-Object { $_.GUID -in $IntuneTemplateIds }
                } catch {
                    Write-Warning "Failed to get Intune templates: $($_.Exception.Message)"
                }
            }

            # Check for extra Intune policies not in template
            foreach ($TenantPolicy in $TenantIntunePolicies) {
                $PolicyFound = $false
                $tenantPolicy.policy | Add-Member -MemberType NoteProperty -Name 'URLName' -Value $TenantPolicy.Type -Force
                $TenantPolicyName = if ($TenantPolicy.Policy.displayName) { $TenantPolicy.Policy.displayName } else { $TenantPolicy.Policy.name }
                foreach ($TemplatePolicy in $TemplateIntuneTemplates) {
                    $TemplatePolicyName = if ($TemplatePolicy.displayName) { $TemplatePolicy.displayName } else { $TemplatePolicy.name }

                    if ($TemplatePolicy.displayName -eq $TenantPolicy.Policy.displayName -or
                        $TemplatePolicy.name -eq $TenantPolicy.Policy.name -or
                        $TemplatePolicy.displayName -eq $TenantPolicy.Policy.name -or
                        $TemplatePolicy.name -eq $TenantPolicy.Policy.displayName) {
                        $PolicyFound = $true
                        break
                    }
                }

                if (-not $PolicyFound) {
                    $PolicyKey = "IntuneTemplates.$($TenantPolicy.Policy.id)"
                    $Status = if ($ExistingDriftStates.ContainsKey($PolicyKey)) {
                        $ExistingDriftStates[$PolicyKey].Status
                    } else {
                        'New'
                    }
                    $PolicyDeviation = [PSCustomObject]@{
                        standardName        = $PolicyKey
                        standardDisplayName = "Intune - $TenantPolicyName"
                        expectedValue       = 'This policy only exists in the tenant, not in the template.'
                        receivedValue       = $TenantPolicy.Policy
                        state               = 'current'
                        Status              = $Status
                    }
                    $PolicyDeviations.Add($PolicyDeviation)
                }
            }

            # Check for extra Conditional Access policies not in template
            foreach ($TenantCAPolicy in $TenantCAPolicies) {
                $PolicyFound = $false

                foreach ($TemplateCAPolicy in $TemplateCATemplates) {
                    if ($TemplateCAPolicy.displayName -eq $TenantCAPolicy.displayName) {
                        $PolicyFound = $true
                        break
                    }
                }

                if (-not $PolicyFound) {
                    $PolicyKey = "ConditionalAccessTemplates.$($TenantCAPolicy.id)"
                    $Status = if ($ExistingDriftStates.ContainsKey($PolicyKey)) {
                        $ExistingDriftStates[$PolicyKey].Status
                    } else {
                        'New'
                    }
                    $PolicyDeviation = [PSCustomObject]@{
                        standardName        = $PolicyKey
                        standardDisplayName = "Conditional Access - $($TenantCAPolicy.displayName)"
                        expectedValue       = 'This policy only exists in the tenant, not in the template.'
                        receivedValue       = $TenantCAPolicy | Out-String
                        state               = 'current'
                        Status              = $Status
                    }
                    $PolicyDeviations.Add($PolicyDeviation)
                }
            }


            # Combine all deviations and filter by status
            $AllDeviations = [System.Collections.Generic.List[object]]::new()
            $AllDeviations.AddRange($StandardsDeviations)
            $AllDeviations.AddRange($PolicyDeviations)

            # Filter deviations by status for counting
            $NewDeviations = $AllDeviations | Where-Object { $_.Status -eq 'New' }
            $AcceptedDeviations = $AllDeviations | Where-Object { $_.Status -eq 'Accepted' }
            $DeniedDeviations = $AllDeviations | Where-Object { $_.Status -like 'Denied*' }
            $CustomerSpecificDeviations = $AllDeviations | Where-Object { $_.Status -eq 'CustomerSpecific' }

            # Current deviations are New + Denied (not accepted or customer specific)
            $CurrentDeviations = $AllDeviations | Where-Object { $_.Status -in @('New', 'Denied') }

            $Result = [PSCustomObject]@{
                tenantFilter                    = $TenantFilter
                standardName                    = $Alignment.StandardName
                standardId                      = $Alignment.StandardId
                alignmentScore                  = $Alignment.AlignmentScore
                acceptedDeviationsCount         = $AcceptedDeviations.Count
                currentDeviationsCount          = $CurrentDeviations.Count
                deniedDeviationsCount           = $DeniedDeviations.Count
                customerSpecificDeviationsCount = $CustomerSpecificDeviations.Count
                newDeviationsCount              = $NewDeviations.Count
                alignedCount                    = $Alignment.CompliantStandards
                currentDeviations               = @($CurrentDeviations)
                acceptedDeviations              = @($AcceptedDeviations)
                customerSpecificDeviations      = @($CustomerSpecificDeviations)
                deniedDeviations                = @($DeniedDeviations)
                allDeviations                   = @($AllDeviations)
                latestDataCollection            = $Alignment.LatestDataCollection
                driftSettings                   = $AlignmentData
            }

            $Results.Add($Result)
        }

        return @($Results)

    } catch {
        Write-Error "Error getting drift data: $($_.Exception.Message)"
        throw
    }
}
#EndRegion './Public/Get-CIPPDrift.ps1' 370
#Region './Public/Get-CIPPFileVaultKey.ps1' -1

<#
.SYNOPSIS
    Retrieves the FileVault recovery key for a managed device from Microsoft Graph API.

.DESCRIPTION
    This function makes a request to the Microsoft Graph API to retrieve the FileVault recovery key
    for a specified managed device. It handles cases where no key is found and provides appropriate
    logging and error handling.

.PARAMETER Device
    The GUID of the managed device for which to retrieve the FileVault key.

.PARAMETER TenantFilter
    The tenant ID to filter the request to the appropriate tenant.

.PARAMETER APIName
    The name of the API operation for logging purposes. Defaults to 'Get FileVault key'.

.PARAMETER Headers
    The headers to include in the request, typically used for authentication and logging.

.OUTPUTS
    PSCustomObject with properties:
    - resultText: Formatted string containing the key
    - copyField: The raw key value
    - state: Status of the operation ('success')

    Or a string message if no key is found.

#>

function Get-CIPPFileVaultKey {
    [CmdletBinding()]
    param (
        $Device,
        $TenantFilter,
        $APIName = 'Get FileVault key',
        $Headers
    )

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices/$Device/getFileVaultKey" -tenantid $TenantFilter

        if ([string]::IsNullOrEmpty($GraphRequest)) {
            $Result = "No FileVault recovery key found for $($Device)"
            Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Info -tenant $TenantFilter
            return $Result
        }

        Write-LogMessage -headers $Headers -API $APIName -message "Retrieved FileVault recovery key for $($Device)" -Sev Info -tenant $TenantFilter
        return [PSCustomObject]@{
            resultText = "Key: $($GraphRequest)"
            copyField  = $GraphRequest
            state      = 'success'
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not retrieve FileVault recovery key for $($Device). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }

}
#EndRegion './Public/Get-CIPPFileVaultKey.ps1' 64
#Region './Public/Get-CIPPGeoIPLocation.ps1' -1

function Get-CIPPGeoIPLocation {
    [CmdletBinding()]
    param (
        [string]$IP
    )

    $CacheGeoIPTable = Get-CippTable -tablename 'cachegeoip'
    $30DaysAgo = (Get-Date).AddDays(-30).ToString('yyyy-MM-ddTHH:mm:ssZ')
    $Filter = "PartitionKey eq 'IP' and RowKey eq '$IP' and Timestamp ge datetime'$30DaysAgo'"
    $GeoIP = Get-CippAzDataTableEntity @CacheGeoIPTable -Filter $Filter
    if ($GeoIP) {
        return ($GeoIP.Data | ConvertFrom-Json)
    }
    $location = Invoke-RestMethod "https://geoipdb.azurewebsites.net/api/GetIPInfo?IP=$IP"
    if ($location.status -eq 'FAIL') { throw "Could not get location for $IP" }
    $CacheGeo = @{
        PartitionKey = 'IP'
        RowKey       = $IP
        Data         = [string]($location | ConvertTo-Json -Compress)
    }
    Add-AzDataTableEntity @CacheGeoIPTable -Entity $CacheGeo -Force
    return $location
}
#EndRegion './Public/Get-CIPPGeoIPLocation.ps1' 24
#Region './Public/Get-CIPPIntunePolicy.ps1' -1

function Get-CIPPIntunePolicy {
    param (
        [Parameter(Mandatory = $true)]
        $TemplateType,
        $DisplayName,
        $PolicyId,
        $Headers,
        $APINAME,
        $tenantFilter
    )

    try {
        switch ($TemplateType) {
            'AppProtection' {
                $PlatformType = 'deviceAppManagement'
                $AndroidTemplateTypeURL = 'androidManagedAppProtections'
                $iOSTemplateTypeURL = 'iosManagedAppProtections'

                # Define bulk request for both platforms - used by all scenarios
                $BulkRequests = @(
                    @{
                        id     = 'AndroidPolicies'
                        url    = "$PlatformType/$AndroidTemplateTypeURL"
                        method = 'GET'
                    },
                    @{
                        id     = 'iOSPolicies'
                        url    = "$PlatformType/$iOSTemplateTypeURL"
                        method = 'GET'
                    }
                )
                $BulkResults = New-GraphBulkRequest -Requests $BulkRequests -tenantid $tenantFilter

                $androidPolicies = ($BulkResults | Where-Object { $_.id -eq 'AndroidPolicies' }).body.value
                $iOSPolicies = ($BulkResults | Where-Object { $_.id -eq 'iOSPolicies' }).body.value

                if ($DisplayName) {
                    $androidPolicy = $androidPolicies | Where-Object -Property displayName -EQ $DisplayName
                    $iOSPolicy = $iOSPolicies | Where-Object -Property displayName -EQ $DisplayName

                    # Return the matching policy (Android or iOS) - using full data from bulk request
                    if ($androidPolicy) {
                        $policyJson = ConvertTo-Json -InputObject $androidPolicy -Depth 100 -Compress
                        $androidPolicy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                        return $androidPolicy
                    } elseif ($iOSPolicy) {
                        $policyJson = ConvertTo-Json -InputObject $iOSPolicy -Depth 100 -Compress
                        $iOSPolicy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                        return $iOSPolicy
                    }
                    return $null

                } elseif ($PolicyId) {
                    $androidPolicy = $androidPolicies | Where-Object -Property id -EQ $PolicyId
                    $iOSPolicy = $iOSPolicies | Where-Object -Property id -EQ $PolicyId

                    # Return the matching policy - using full data from bulk request
                    if ($androidPolicy) {
                        $policyJson = ConvertTo-Json -InputObject $androidPolicy -Depth 100 -Compress
                        $androidPolicy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                        return $androidPolicy
                    } elseif ($iOSPolicy) {
                        $policyJson = ConvertTo-Json -InputObject $iOSPolicy -Depth 100 -Compress
                        $iOSPolicy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                        return $iOSPolicy
                    }
                    return $null

                } else {
                    # Process all Android policies
                    foreach ($policy in $androidPolicies) {
                        $policyJson = ConvertTo-Json -InputObject $policy -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }

                    # Process all iOS policies
                    foreach ($policy in $iOSPolicies) {
                        $policyJson = ConvertTo-Json -InputObject $policy -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }

                    # Combine and return all policies
                    $allPolicies = [System.Collections.Generic.List[object]]::new()
                    if ($androidPolicies) { $allPolicies.AddRange($androidPolicies) }
                    if ($iOSPolicies) { $allPolicies.AddRange($iOSPolicies) }
                    return $allPolicies
                }
            }
            'deviceCompliancePolicies' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'deviceCompliancePolicies'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')?`$expand=scheduledActionsForRule(`$expand=scheduledActionConfigurations)" -tenantid $tenantFilter
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')?`$expand=scheduledActionsForRule(`$expand=scheduledActionConfigurations)" -tenantid $tenantFilter
                    if ($policy) {
                        $policyJson = ConvertTo-Json -InputObject $policy -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')?`$expand=scheduledActionsForRule(`$expand=scheduledActionConfigurations)" -tenantid $tenantFilter
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'Admin' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'groupPolicyConfigurations'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $definitionValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')/definitionValues" -tenantid $tenantFilter
                        $policy | Add-Member -MemberType NoteProperty -Name 'definitionValues' -Value $definitionValues -Force

                        $templateJsonItems = $definitionValues
                        $templateJsonSource = foreach ($templateJsonItem in $templateJsonItems) {
                            $presentationValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')/definitionValues('$($templateJsonItem.id)')/presentationValues?`$expand=presentation" -tenantid $tenantFilter | ForEach-Object {
                                $obj = $_
                                if ($obj.id) {
                                    $presObj = @{
                                        id                        = $obj.id
                                        'presentation@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')/presentations('$($obj.presentation.id)')"
                                    }
                                    if ($obj.values) { $presObj['values'] = $obj.values }
                                    if ($obj.value) { $presObj['value'] = $obj.value }
                                    if ($obj.'@odata.type') { $presObj['@odata.type'] = $obj.'@odata.type' }
                                    [pscustomobject]$presObj
                                }
                            }
                            [PSCustomObject]@{
                                'definition@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')"
                                enabled                 = $templateJsonItem.enabled
                                presentationValues      = @($presentationValues)
                            }
                        }
                        $inputvar = [pscustomobject]@{
                            added      = @($templateJsonSource)
                            updated    = @()
                            deletedIds = @()
                        }
                        $policyJson = ConvertTo-Json -InputObject $inputvar -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $definitionValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')/definitionValues" -tenantid $tenantFilter
                        $policy | Add-Member -MemberType NoteProperty -Name 'definitionValues' -Value $definitionValues -Force

                        $templateJsonItems = $definitionValues
                        $templateJsonSource = foreach ($templateJsonItem in $templateJsonItems) {
                            $presentationValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')/definitionValues('$($templateJsonItem.id)')/presentationValues?`$expand=presentation" -tenantid $tenantFilter | ForEach-Object {
                                $obj = $_
                                if ($obj.id) {
                                    $presObj = @{
                                        id                        = $obj.id
                                        'presentation@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')/presentations('$($obj.presentation.id)')"
                                    }
                                    if ($obj.values) { $presObj['values'] = $obj.values }
                                    if ($obj.value) { $presObj['value'] = $obj.value }
                                    if ($obj.'@odata.type') { $presObj['@odata.type'] = $obj.'@odata.type' }
                                    [pscustomobject]$presObj
                                }
                            }
                            [PSCustomObject]@{
                                'definition@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')"
                                enabled                 = $templateJsonItem.enabled
                                presentationValues      = @($presentationValues)
                            }
                        }
                        $inputvar = [pscustomobject]@{
                            added      = @($templateJsonSource)
                            updated    = @()
                            deletedIds = @()
                        }
                        $policyJson = ConvertTo-Json -InputObject $inputvar -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $definitionValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')/definitionValues" -tenantid $tenantFilter
                        $policy | Add-Member -MemberType NoteProperty -Name 'definitionValues' -Value $definitionValues -Force

                        $templateJsonItems = $definitionValues
                        $templateJsonSource = foreach ($templateJsonItem in $templateJsonItems) {
                            $presentationValues = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')/definitionValues('$($templateJsonItem.id)')/presentationValues?`$expand=presentation" -tenantid $tenantFilter | ForEach-Object {
                                $obj = $_
                                if ($obj.id) {
                                    $presObj = @{
                                        id                        = $obj.id
                                        'presentation@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')/presentations('$($obj.presentation.id)')"
                                    }
                                    if ($obj.values) { $presObj['values'] = $obj.values }
                                    if ($obj.value) { $presObj['value'] = $obj.value }
                                    if ($obj.'@odata.type') { $presObj['@odata.type'] = $obj.'@odata.type' }
                                    [pscustomobject]$presObj
                                }
                            }
                            [PSCustomObject]@{
                                'definition@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($templateJsonItem.definition.id)')"
                                enabled                 = $templateJsonItem.enabled
                                presentationValues      = @($presentationValues)
                            }
                        }
                        $inputvar = [pscustomobject]@{
                            added      = @($templateJsonSource)
                            updated    = @()
                            deletedIds = @()
                        }
                        $policyJson = ConvertTo-Json -InputObject $inputvar -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'Device' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'deviceConfigurations'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'Catalog' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'configurationPolicies'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property Name -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')?`$expand=settings" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object name, description, settings, platforms, technologies, templateReference
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')?`$expand=settings" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object name, description, settings, platforms, technologies, templateReference
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')?`$expand=settings" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object name, description, settings, platforms, technologies, templateReference
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'windowsDriverUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsDriverUpdateProfiles'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'windowsFeatureUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsFeatureUpdateProfiles'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'windowsQualityUpdatePolicies' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsQualityUpdatePolicies'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            'windowsQualityUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsQualityUpdateProfiles'

                if ($DisplayName) {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    $policy = $policies | Where-Object -Property displayName -EQ $DisplayName
                    if ($policy) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } elseif ($PolicyId) {
                    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$PolicyId')" -tenantid $tenantFilter
                    if ($policy) {
                        $policyDetails = $policy | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policy
                } else {
                    $policies = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                    foreach ($policy in $policies) {
                        $policyDetails = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($policy.id)')" -tenantid $tenantFilter
                        $policyDetails = $policyDetails | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
                        $policyJson = ConvertTo-Json -InputObject $policyDetails -Depth 100 -Compress
                        $policy | Add-Member -MemberType NoteProperty -Name 'cippconfiguration' -Value $policyJson -Force
                    }
                    return $policies
                }
            }
            default {
                return $null
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APINAME -tenant $($tenantFilter) -message "Failed to get policy. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        throw "Failed to get policy for $($tenantFilter): $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Get-CIPPIntunePolicy.ps1' 442
#Region './Public/Get-CIPPLAPSPassword.ps1' -1


function Get-CIPPLapsPassword {
    [CmdletBinding()]
    param (
        $device,
        $TenantFilter,
        $APIName = 'Get LAPS Password',
        $Headers
    )

    try {
        $GraphRequest = (New-GraphGetRequest -noauthcheck $true -uri "https://graph.microsoft.com/beta/directory/deviceLocalCredentials/$($device)?`$select=credentials" -tenantid $TenantFilter).credentials | Select-Object -First 1 | ForEach-Object {
            $PlainText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_.passwordBase64))
            $date = $_.BackupDateTime
            [PSCustomObject]@{
                resultText = "LAPS password retrieved for $($_.accountName), generated at $($date). Copy the password by clicking the copy button"
                copyField  = $PlainText
                state      = 'success'
            }
        }
        if ($GraphRequest) { return $GraphRequest } else { return "No LAPS password found for $device" }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Could not retrieve LAPS password for $($device). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        return "Could not retrieve LAPS password for $($device). Error: $($ErrorMessage.NormalizedError)"
    }
}


#EndRegion './Public/Get-CIPPLAPSPassword.ps1' 30
#Region './Public/Get-CIPPLicenseOverview.ps1' -1


function Get-CIPPLicenseOverview {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $APIName = 'Get License Overview',
        $Headers
    )

    $Requests = @(
        @{
            id     = 'subscribedSkus'
            url    = 'subscribedSkus'
            method = 'GET'
        }
        @{
            id     = 'directorySubscriptions'
            url    = 'directory/subscriptions'
            method = 'GET'
        }
        @{
            id      = 'licensedUsers'
            url     = "users?`$select=id,displayName,userPrincipalName,assignedLicenses&`$filter=assignedLicenses/`$count ne 0&`$count=true"
            method  = 'GET'
            headers = @{
                'ConsistencyLevel' = 'eventual'
            }
        }
        @{
            id      = 'licensedGroups'
            url     = "groups?`$select=id,displayName,assignedLicenses,mailEnabled,securityEnabled,groupTypes,onPremisesSyncEnabled&`$filter=assignedLicenses/`$count ne 0&`$count=true"
            method  = 'GET'
            headers = @{
                'ConsistencyLevel' = 'eventual'
            }
        }
    )

    try {
        $AdminPortalLicenses = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $TenantFilter -Uri 'https://admin.microsoft.com/admin/api/tenant/accountSkus'
    } catch {
        Write-Warning 'Failed to get Admin Portal Licenses'
    }

    $Results = New-GraphBulkRequest -Requests $Requests -TenantID $TenantFilter -asapp $true
    $LicRequest = ($Results | Where-Object { $_.id -eq 'subscribedSkus' }).body.value
    $SkuIDs = ($Results | Where-Object { $_.id -eq 'directorySubscriptions' }).body.value

    $RawGraphRequest = [PSCustomObject]@{
        Tenant   = $TenantFilter
        Licenses = $LicRequest
    }
    $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
    $ConvertTable = Import-Csv (Join-Path $ModuleBase 'lib\data\ConversionTable.csv')
    $LicenseTable = Get-CIPPTable -TableName ExcludedLicenses
    $ExcludedSkuList = Get-CIPPAzDataTableEntity @LicenseTable

    $AllLicensedUsers = @(($Results | Where-Object { $_.id -eq 'licensedUsers' }).body.value)
    $UsersBySku = @{}
    foreach ($User in $AllLicensedUsers) {
        if (-not $User.assignedLicenses) { continue } # Skip users with no assigned licenses. Should not happens as the filter is applied, but just in case
        $UserInfo = [PSCustomObject]@{
            displayName       = [string]$User.displayName
            userPrincipalName = [string]$User.userPrincipalName
            id                = [string]$User.id
        }

        foreach ($AssignedLicense in $User.assignedLicenses) {
            $LicenseSkuId = ([string]$AssignedLicense.skuId).ToLowerInvariant()
            if ([string]::IsNullOrWhiteSpace($LicenseSkuId)) { continue } # Skip if SKU ID is null or whitespace. Should not happen but just in case
            if (-not $UsersBySku.ContainsKey($LicenseSkuId)) {
                $UsersBySku[$LicenseSkuId] = [System.Collections.Generic.List[object]]::new()
            }
            $UsersBySku[$LicenseSkuId].Add($UserInfo)
        }

    }

    $AllLicensedGroups = @(($Results | Where-Object { $_.id -eq 'licensedGroups' }).body.value)
    $GroupsBySku = @{}
    foreach ($Group in $AllLicensedGroups) {
        if (-not $Group.assignedLicenses) { continue }
        $GroupInfo = [PSCustomObject]@{
            displayName           = [string]$Group.displayName
            calculatedGroupType   = if ($Group.groupTypes -contains 'Unified') { 'Microsoft 365' }
            elseif ($Group.mailEnabled -and $Group.securityEnabled) { 'Mail-Enabled Security' }
            elseif (-not $Group.mailEnabled -and $Group.securityEnabled) { 'Security' }
            elseif (([string]::isNullOrEmpty($Group.groupTypes)) -and ($Group.mailEnabled) -and (-not $Group.securityEnabled)) { 'Distribution List' }
            id                    = [string]$Group.id
            onPremisesSyncEnabled = [bool]$Group.onPremisesSyncEnabled

        }
        foreach ($AssignedLicense in $Group.assignedLicenses) {
            $LicenseSkuId = ([string]$AssignedLicense.skuId).ToLowerInvariant()
            if ([string]::IsNullOrWhiteSpace($LicenseSkuId)) { continue }
            if (-not $GroupsBySku.ContainsKey($LicenseSkuId)) {
                $GroupsBySku[$LicenseSkuId] = [System.Collections.Generic.List[object]]::new()
            }
            $GroupsBySku[$LicenseSkuId].Add($GroupInfo)
        }
    }
    $GraphRequest = foreach ($singleReq in $RawGraphRequest) {
        $skuId = $singleReq.Licenses
        foreach ($sku in $skuId) {
            if ($sku.skuId -in $ExcludedSkuList.GUID) { continue }
            $PrettyNameAdmin = $AdminPortalLicenses | Where-Object { $_.SkuId -eq $sku.skuId } | Select-Object -ExpandProperty Name
            $PrettyNameCSV = ($ConvertTable | Where-Object { $_.guid -eq $sku.skuid }).'Product_Display_Name' | Select-Object -Last 1
            $PrettyName = $PrettyNameAdmin ?? $PrettyNameCSV ?? $sku.skuPartNumber

            # Initialize $Term with the default value
            $TermInfo = foreach ($Subscription in $sku.subscriptionIds) {
                $SubInfo = $SkuIDs | Where-Object { $_.id -eq $Subscription }
                $diff = $SubInfo.nextLifecycleDateTime - $SubInfo.createdDateTime
                $Term = 'Term unknown or non-NCE license'
                if ($diff.Days -ge 360 -and $diff.Days -le 1089) {
                    $Term = 'Yearly'
                } elseif ($diff.Days -ge 1090 -and $diff.Days -le 1100) {
                    $Term = '3 Year'
                } elseif ($diff.Days -ge 25 -and $diff.Days -le 35) {
                    $Term = 'Monthly'
                }
                $TimeUntilRenew = ($subinfo.nextLifecycleDateTime - (Get-Date)).days
                [PSCustomObject]@{
                    Status            = $SubInfo.status
                    Term              = $Term
                    TotalLicenses     = $SubInfo.totalLicenses
                    DaysUntilRenew    = $TimeUntilRenew
                    NextLifecycle     = $SubInfo.nextLifecycleDateTime
                    IsTrial           = $SubInfo.isTrial
                    SubscriptionId    = $subinfo.id
                    CSPSubscriptionId = $SubInfo.commerceSubscriptionId
                    OCPSubscriptionId = $SubInfo.ocpSubscriptionId
                }
            }
            $SkuKey = ([string]$sku.skuId).ToLowerInvariant()
            [pscustomobject]@{
                Tenant         = [string]$singleReq.Tenant
                License        = [string]$PrettyName
                CountUsed      = [string]"$($sku.consumedUnits)"
                CountAvailable = [string]$sku.prepaidUnits.enabled - $sku.consumedUnits
                TotalLicenses  = [string]"$($sku.prepaidUnits.enabled)"
                skuId          = [string]$sku.skuId
                skuPartNumber  = [string]$PrettyName
                availableUnits = [string]$sku.prepaidUnits.enabled - $sku.consumedUnits
                TermInfo       = [string]($TermInfo | ConvertTo-Json -Depth 10 -Compress)
                AssignedUsers  = ($UsersBySku.ContainsKey($SkuKey) ? @(($UsersBySku[$SkuKey])) : $null)
                AssignedGroups = ($GroupsBySku.ContainsKey($SkuKey) ? @(($GroupsBySku[$SkuKey])) : $null)
                'PartitionKey' = 'License'
                'RowKey'       = "$($singleReq.Tenant) - $($sku.skuid)"
            }
        }
    }
    return $GraphRequest
}
#EndRegion './Public/Get-CIPPLicenseOverview.ps1' 155
#Region './Public/Get-CIPPMFAState.ps1' -1


function Get-CIPPMFAState {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $APIName = 'Get MFA Status',
        $Headers
    )
    #$PerUserMFAState = Get-CIPPPerUserMFA -TenantFilter $TenantFilter -AllUsers $true
    $users = foreach ($user in (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/users?$top=999&$select=id,UserPrincipalName,DisplayName,accountEnabled,assignedLicenses,perUserMfaState' -tenantid $TenantFilter)) {
        [PSCustomObject]@{
            UserPrincipalName = $user.UserPrincipalName
            isLicensed        = [boolean]$user.assignedLicenses.skuid
            accountEnabled    = $user.accountEnabled
            DisplayName       = $user.DisplayName
            ObjectId          = $user.id
            perUserMfaState   = $user.perUserMfaState
        }
    }

    $Errors = [System.Collections.Generic.List[object]]::new()
    try {
        $SecureDefaultsState = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -tenantid $TenantFilter ).IsEnabled
    } catch {
        Write-Host "Secure Defaults not available: $($_.Exception.Message)"
        $Errors.Add(@{Step = 'SecureDefaults'; Message = $_.Exception.Message })
    }
    $CAState = [System.Collections.Generic.List[object]]::new()

    Try {
        $MFARegistration = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/reports/authenticationMethods/userRegistrationDetails' -tenantid $TenantFilter -asapp $true)
    } catch {
        $CAState.Add('Not Licensed for Conditional Access') | Out-Null
        $MFARegistration = $null
        if ($_.Exception.Message -ne "Tenant is not a B2C tenant and doesn't have premium licenses") {
            $Errors.Add(@{Step = 'MFARegistration'; Message = $_.Exception.Message })
        }
        Write-Host "User registration details not available: $($_.Exception.Message)"
    }

    if ($null -ne $MFARegistration) {
        $CASuccess = $true
        try {
            $CAPolicies = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies?$top=999' -tenantid $TenantFilter -ErrorAction Stop )
            foreach ($Policy in $CAPolicies) {
                $IsMFAControl = $policy.grantControls.builtincontrols -eq 'mfa' -or $Policy.grantControls.authenticationStrength.requirementsSatisfied -eq 'mfa' -or $Policy.grantControls.customAuthenticationFactors -eq 'RequireDuoMfa'
                $IsAllApps = [bool]($Policy.conditions.applications.includeApplications -eq 'All')
                $IsAllUsers = [bool]($Policy.conditions.users.includeUsers -eq 'All')
                $Platforms = $Policy.conditions.clientAppTypes

                if ($IsMFAControl) {
                    $CAState.Add([PSCustomObject]@{
                            DisplayName   = $Policy.displayName
                            State         = $Policy.state
                            IncludedApps  = $Policy.conditions.applications.includeApplications
                            IncludedUsers = $Policy.conditions.users.includeUsers
                            ExcludedUsers = $Policy.conditions.users.excludeUsers
                            IsAllApps     = $IsAllApps
                            IsAllUsers    = $IsAllUsers
                            Platforms     = $Platforms
                        })
                }
            }
        } catch {
            $CASuccess = $false
            $CAError = "CA policies not available: $($_.Exception.Message)"
            $Errors.Add(@{Step = 'CAPolicies'; Message = $_.Exception.Message })
        }
    }

    if ($CAState.count -eq 0) { $CAState.Add('None') | Out-Null }
    
    $assignments = New-GraphGetRequest -uri  "https://graph.microsoft.com/v1.0/roleManagement/directory/roleAssignments?`$expand=principal" -tenantid $TenantFilter -ErrorAction SilentlyContinue

    $adminObjectIds = $assignments |
    Where-Object {
        $_.principal.'@odata.type' -eq '#microsoft.graph.user'
    } |
    ForEach-Object {
        $_.principal.id
    }

    # Interact with query parameters or the body of the request.
    $GraphRequest = $Users | ForEach-Object {
        $UserCAState = [System.Collections.Generic.List[object]]::new()
        foreach ($CA in $CAState) {
            if ($CA.IncludedUsers -eq 'All' -or $CA.IncludedUsers -contains $_.ObjectId) {
                $UserCAState.Add([PSCustomObject]@{
                        DisplayName  = $CA.DisplayName
                        UserIncluded = ($CA.ExcludedUsers -notcontains $_.ObjectId)
                        AllApps      = $CA.IsAllApps
                        PolicyState  = $CA.State
                        Platforms    = $CA.Platforms -join ', '
                    })
            }
        }
        if ($UserCAState.UserIncluded -eq $true -and $UserCAState.PolicyState -eq 'enabled') {
            if ($UserCAState.UserIncluded -eq $true -and $UserCAState.PolicyState -eq 'enabled' -and $UserCAState.AllApps) {
                $CoveredByCA = 'Enforced - All Apps'
            } else {
                $CoveredByCA = 'Enforced - Specific Apps'
            }
        } else {
            if ($CASuccess -eq $false) {
                $CoveredByCA = $CAError
            } else {
                $CoveredByCA = 'Not Enforced'
            }
        }
        $IsAdmin = if ($adminObjectIds -contains $_.ObjectId) { $true } else { $false }

        $PerUser = $_.PerUserMFAState

        $MFARegUser = if ($null -eq ($MFARegistration | Where-Object -Property UserPrincipalName -EQ $_.userPrincipalName).isMFARegistered) { $false } else { ($MFARegistration | Where-Object -Property UserPrincipalName -EQ $_.userPrincipalName) }

        [PSCustomObject]@{
            Tenant          = $TenantFilter
            ID              = $_.ObjectId
            UPN             = $_.UserPrincipalName
            DisplayName     = $_.DisplayName
            AccountEnabled  = $_.accountEnabled
            PerUser         = $PerUser
            isLicensed      = $_.isLicensed
            MFARegistration = $MFARegUser.isMFARegistered
            MFACapable      = $MFARegUser.isMFACapable
            MFAMethods      = $MFARegUser.methodsRegistered
            CoveredByCA     = $CoveredByCA
            CAPolicies      = $UserCAState
            CoveredBySD     = $SecureDefaultsState
            IsAdmin         = $IsAdmin
            RowKey          = [string]($_.UserPrincipalName).replace('#', '')
            PartitionKey    = 'users'
        }
    }
    $ErrorCount = ($Errors | Measure-Object).Count
    if ($ErrorCount -gt 0) {
        if ($ErrorCount -gt 1) {
            $Text = 'errors'
        } else {
            $Text = 'an error'
        }
        Write-LogMessage -headers $Headers -API $APIName -Tenant $TenantFilter -message "The MFA report encountered $Text, see log data for details." -Sev 'Error' -LogData @($Errors.Message)
    }
    return $GraphRequest
}
#EndRegion './Public/Get-CIPPMFAState.ps1' 146
#Region './Public/Get-CIPPOutOfOffice.ps1' -1

function Get-CIPPOutOfOffice {
    [CmdletBinding()]
    param (
        $UserID,
        $TenantFilter,
        $APIName = 'Get Out of Office',
        $Headers
    )

    try {
        $OutOfOffice = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MailboxAutoReplyConfiguration' -cmdParams @{Identity = $UserID } -Anchor $UserID
        $Results = @{
            AutoReplyState  = $OutOfOffice.AutoReplyState
            StartTime       = $OutOfOffice.StartTime.ToString('yyyy-MM-dd HH:mm')
            EndTime         = $OutOfOffice.EndTime.ToString('yyyy-MM-dd HH:mm')
            InternalMessage = $OutOfOffice.InternalMessage
            ExternalMessage = $OutOfOffice.ExternalMessage
        } | ConvertTo-Json
        return $Results
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not retrieve out of office message for $($UserID). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error' -LogData $ErrorMessage
        throw $Results
    }
}
#EndRegion './Public/Get-CIPPOutOfOffice.ps1' 27
#Region './Public/Get-CIPPPartnerAzSubscriptions.ps1' -1

function Get-CIPPPartnerAzSubscriptions {
    param (
        $TenantFilter,
        $APIName = 'Get-CIPPPartnerAzSubscriptions'
    )

    try {
        if ($variable -notmatch '[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}') {
            $TenantFilter = (Invoke-RestMethod -Method GET "https://login.windows.net/$TenantFilter/.well-known/openid-configuration").token_endpoint.Split('/')[3]
        }
    } catch {
        throw "Tenant $($TenantFilter) could not be found"
    }

    $subsCache = [system.collections.generic.list[hashtable]]::new()
    try {
        try {
            $usageRecords = (New-GraphGETRequest -Uri "https://api.partnercenter.microsoft.com/v1/customers/$($TenantFilter)/subscriptions/usagerecords" -scope 'https://api.partnercenter.microsoft.com/user_impersonation').items
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            throw "Unable to retrieve usagerecord(s): $($ErrorMessage.NormalizedError)"
        }

        foreach ($usageRecord in $usageRecords) {
            # if condition probably needs more refining
            if ($usageRecord.offerId -notlike 'DZH318Z0BPS6*') {
                # Legacy subscriptions are directly accessible
                $subDetails = @{
                    tenantId       = $tenantFilter
                    subscriptionId = ($usageRecord.id).ToLower()
                    isLegacy       = $true
                    POR            = 'Legacy subscription'
                    status         = $usageRecord.status
                }

                $subsCache.Add($subDetails)
            } else {
                # For modern subscriptions we need to dig a little deeper
                try {
                    $subid = (New-GraphGETRequest -Uri "https://api.partnercenter.microsoft.com/v1/customers/$($TenantFilter)/subscriptions/$($usageRecord.id)/azureEntitlements" -scope 'https://api.partnercenter.microsoft.com/user_impersonation').items #| Where-Object { $_.status -eq "active" }

                    foreach ($id in $subid) {
                        $subDetails = @{
                            tenantId       = $tenantFilter
                            subscriptionId = ($id.id)
                            isLegacy       = $false
                            POR            = $id.partnerOnRecord
                            status         = $id.status
                        }

                        $subsCache.Add($subDetails)
                    }
                } catch {
                    # what do we do here error wise?
                    #Write-LogMessage -message "Unable to retrieve subscriptions(s) from usagerecord $($usageRecord.id): $($_.Exception.Message)" -Sev 'ERROR' -API $APINAME
                    #Write-Error "Unable to retrieve sub(s) from usagerecord $($usageRecord.id) for tenant $($tenantFilter): $($_.Exception.Message)"
                }
            }
        }

        return $subsCache
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -message "Unable to retrieve CSP Azure subscriptions for $($TenantFilter): $($ErrorMessage.NormalizedError)" -Sev 'ERROR' -API $APINAME -LogData $ErrorMessage
    }
}
#EndRegion './Public/Get-CIPPPartnerAzSubscriptions.ps1' 67
#Region './Public/Get-CIPPPerUserMFA.ps1' -1

function Get-CIPPPerUserMFA {
    [CmdletBinding()]
    param(
        $TenantFilter,
        $UserId,
        $Headers,
        $AllUsers = $false
    )
    try {
        if ($AllUsers -eq $true) {
            $AllUsers = New-GraphGetRequest -Uri "https://graph.microsoft.com/v1.0/users?`$top=999&`$select=UserPrincipalName,Id,perUserMfaState" -tenantid $TenantFilter
            return $AllUsers
        } else {
            $MFAState = New-GraphGetRequest -Uri "https://graph.microsoft.com/v1.0/users/$($UserId)?`$select=UserPrincipalName,Id,perUserMfaState" -tenantid $TenantFilter
            return [PSCustomObject]@{
                PerUserMFAState   = $MFAState.perUserMfaState
                UserPrincipalName = $UserId
            }
        }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        throw "Failed to get MFA State for $UserId : $ErrorMessage"
    }
}
#EndRegion './Public/Get-CIPPPerUserMFA.ps1' 25
#Region './Public/Get-CIPPSchemaExtensions.ps1' -1

function Get-CIPPSchemaExtensions {
    [CmdletBinding()]
    Param(
        [switch]$Update,
        $Headers
    )

    # Get definitions file
    $CIPPCore = Get-Module -Name 'CIPPCore' | Select-Object -ExpandProperty ModuleBase
    $CIPPRoot = (Get-Item -Path $CIPPCore).Parent.Parent
    $SchemaDefinitionsPath = Join-Path $CIPPRoot 'Config\schemaDefinitions.json'

    # check CustomData table for schema extensions
    $CustomDataTable = Get-CippTable -tablename 'CustomData'
    try {
        $SchemaExtensions = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'"
    } catch {
        $SchemaExtensions = @()
    }

    $SchemaDefinitions = Get-Content -Path $SchemaDefinitionsPath | ConvertFrom-Json
    $SchemaDefinitions | ForEach-Object {
        if ($SchemaExtensions -notcontains $_.id -or $Update.IsPresent) {
            Write-Information "Adding Schema Extension for $($_.id) to table"
            $Schema = @{
                PartitionKey = 'SchemaExtension'
                RowKey       = [string]$_.id
                JSON         = [string]($_ | ConvertTo-Json -Depth 5 -Compress)
            }
            Add-CIPPAzDataTableEntity @CustomDataTable -Entity $Schema -Force
        }
    }
    if (!$SchemaExtensions) {
        $SchemaExtensions = Get-CIPPAzDataTableEntity @CustomDataTable -Filter "PartitionKey eq 'SchemaExtension'"
    }

    $Schemas = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/schemaExtensions?`$filter=owner eq '$($env:ApplicationID)'" -NoAuthCheck $true -AsApp $true | Where-Object { $_.status -ne 'Deprecated' }

    foreach ($SchemaExtension in $SchemaExtensions) {
        $SchemaFound = $false
        $SchemaDefinition = $SchemaExtension.JSON | ConvertFrom-Json
        Write-Information "Processing Schema Extension for $($SchemaDefinition.id)"
        foreach ($Schema in $Schemas) {
            if ($Schema.id -match $SchemaDefinition.id) {
                Write-Verbose ($Schema | ConvertTo-Json -Depth 5)
                $Patch = @{}
                $SchemaFound = $true
                $Schema = $Schemas | Where-Object { $_.id -match $SchemaDefinition.id } | Select-Object -First 1
                if (Compare-Object -ReferenceObject ($SchemaDefinition.properties | Sort-Object name | Select-Object name, type) -DifferenceObject ($Schema.properties | Sort-Object name | Select-Object name, type)) {
                    $Patch.properties = $SchemaDefinition.properties
                }
                if ($Schema.status -ne $SchemaDefinition.status) {
                    $Patch.status = $SchemaDefinition.status
                }
                if ($Schema.targetTypes -ne $SchemaDefinition.targetTypes) {
                    $Patch.targetTypes = $SchemaDefinition.targetTypes
                }
                if ($Patch -and $Patch.Keys.Count -gt 0) {
                    Write-Information "Updating $($Schema.id)"
                    $Json = ConvertTo-Json -Depth 5 -InputObject $Patch
                    Write-Verbose $Json
                    $null = New-GraphPOSTRequest -type PATCH -Uri "https://graph.microsoft.com/v1.0/schemaExtensions/$($Schema.id)" -Body $Json -AsApp $true -NoAuthCheck $true
                    $Schema = New-GraphGETRequest -uri "https://graph.microsoft.com/v1.0/schemaExtensions/$($Schema.id)" -AsApp $true -NoAuthCheck $true
                    Write-LogMessage -headers $Headers -message "Updated Schema Extension: $($SchemaDefinition.id)" -API 'Get-CIPPSchemaExtensions' -Sev 'info' -LogData $Body
                }
                if ($Patch.status -eq 'Deprecated') {
                    Remove-AzDataTableEntity @CustomDataTable -Entity $SchemaExtension -Force
                } else {
                    $NewSchema = [string]($Schema | ConvertTo-Json -Depth 5 -Compress)
                    if ($SchemaExtension.JSON -ne $NewSchema) {
                        $SchemaExtension.JSON = $NewSchema
                        Add-CIPPAzDataTableEntity @CustomDataTable -Entity $SchemaExtension -Force
                    }
                }
                $Schema
            }
        }
        if (!$SchemaFound) {
            Write-Information "Creating Schema Extension for $($SchemaDefinition.id)"
            $Json = ConvertTo-Json -Depth 5 -InputObject ($SchemaDefinition | Select-Object -ExcludeProperty status)
            $Schema = New-GraphPOSTRequest -type POST -Uri 'https://graph.microsoft.com/v1.0/schemaExtensions' -Body $Json -AsApp $true -NoAuthCheck $true

            if ($SchemaDefinition.status -ne 'InDevelopment') {
                $Patch = [PSCustomObject]@{
                    status = $SchemaDefinition.status
                }
                $PatchJson = ConvertTo-Json -Depth 5 -InputObject $Patch
                $null = New-GraphPOSTRequest -type PATCH -Uri "https://graph.microsoft.com/v1.0/schemaExtensions/$($Schema.id)" -Body $PatchJson -AsApp $true -NoAuthCheck $true
            }
            try {
                $OldSchema = $SchemaExtensions | Where-Object { $Schema.id -match $_.RowKey }
                $OldSchema.JSON = [string]($Schema | ConvertTo-Json -Depth 5 -Compress)
                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $OldSchema -Force
            } catch {
                Write-Warning 'Failed to update schema extension in table'
                Write-Warning ($OldSchema | ConvertTo-Json -Depth 5)
            }
            Write-LogMessage -headers $Headers -message "Created Schema Extension: $($SchemaDefinition.id)" -API 'Get-CIPPSchemaExtensions' -Sev 'info' -LogData $Body
            $Schema
        }
    }
    if ($Schemas) {
        $Schemas | ForEach-Object {
            $SchemaFound = $false
            foreach ($SchemaExtension in $SchemaExtensions) {
                $SchemaDefinition = $SchemaExtension.JSON | ConvertFrom-Json
                if ($SchemaDefinition.id -match $_.id) {
                    $SchemaFound = $true
                }
            }
            if (!$SchemaFound) {
                $Json = ConvertTo-Json -Depth 5 -InputObject $_
                $SchemaEntity = @{
                    PartitionKey = 'SchemaExtension'
                    RowKey       = [string]($_.id -split '_' | Select-Object -Last 1)
                    JSON         = [string]$Json
                }
                Add-CIPPAzDataTableEntity @CustomDataTable -Entity $SchemaEntity -Force
                $_
            }
        }
    }
}
#EndRegion './Public/Get-CIPPSchemaExtensions.ps1' 124
#Region './Public/Get-CIPPSPOTenant.ps1' -1

function Get-CIPPSPOTenant {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [string]$SharepointPrefix,
        [switch]$SkipCache
    )

    if (!$SharepointPrefix) {
        # get sharepoint admin site
        $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
        $tenantName = $SharePointInfo.TenantName
        $AdminUrl = $SharePointInfo.AdminUrl
    } else {
        $tenantName = $SharepointPrefix
        $AdminUrl = "https://$($tenantName)-admin.sharepoint.com"
    }

    $Table = Get-CIPPTable -tablename 'cachespotenant'
    $Filter = "PartitionKey eq 'Tenant' and RowKey eq '$TenantFilter' and Timestamp gt datetime'$( (Get-Date).AddHours(-1).ToString('yyyy-MM-ddTHH:mm:ssZ') )'"
    if (!$SkipCache.IsPresent) {
        $CachedTenant = Get-CIPPAzDataTableEntity @Table -Filter $Filter
        if ($CachedTenant -and (Test-Json $CachedTenant.JSON)) {
            $Results = $CachedTenant.JSON | ConvertFrom-Json
            return $Results
        }
    }

    # Query tenant settings
    $XML = @'
<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="SharePoint Online PowerShell (16.0.24908.0)" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><ObjectPath Id="106" ObjectPathId="105" /><Query Id="107" ObjectPathId="105"><Query SelectAllProperties="true"><Properties /></Query></Query></Actions><ObjectPaths><Constructor Id="105" TypeId="{268004ae-ef6b-4e9b-8425-127220d84719}" /></ObjectPaths></Request>
'@
    $AdditionalHeaders = @{
        'Accept' = 'application/json;odata=verbose'
    }

    $Results = New-GraphPostRequest -scope "$($AdminUrl)/.default" -tenantid $TenantFilter -Uri "$($SharePointInfo.AdminUrl)/_vti_bin/client.svc/ProcessQuery" -Type POST -Body $XML -ContentType 'text/xml' -AddedHeaders $AdditionalHeaders

    $Results = $Results | Select-Object -Last 1 *, @{n = 'SharepointPrefix'; e = { $tenantName } }, @{n = 'TenantFilter'; e = { $TenantFilter } }

    # Cache result
    $Entity = @{
        PartitionKey = 'Tenant'
        RowKey       = $TenantFilter
        JSON         = [string]($Results | ConvertTo-Json -Depth 10 -Compress)
    }
    Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
    return $Results
}
#EndRegion './Public/Get-CIPPSPOTenant.ps1' 51
#Region './Public/Get-CIPPTenantCapabilities.ps1' -1


function Get-CIPPTenantCapabilities {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $APIName = 'Get Tenant Capabilities',
        $Headers
    )
    $ConfigTable = Get-CIPPTable -TableName 'CacheCapabilities'
    $datetime = (Get-Date).AddDays(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
    $ConfigEntries = Get-CIPPAzDataTableEntity @ConfigTable -Filter "RowKey eq '$TenantFilter' and PartitionKey eq 'Capabilities' and Timestamp ge datetime'$datetime'"
    if ($ConfigEntries) {
        $Org = $ConfigEntries.JSON | ConvertFrom-Json
    } else {
        $Org = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus' -tenantid $TenantFilter
        # Save the capabilities to the cache table
        $Entity = @{
            PartitionKey = 'Capabilities'
            RowKey       = $TenantFilter
            JSON         = "$($Org | ConvertTo-Json -Compress -Depth 10)"
        }
        Add-CIPPAzDataTableEntity @ConfigTable -Entity $Entity -Force
    }
    $Plans = $Org.servicePlans | Where-Object { $_.provisioningStatus -ne 'disabled' } | Sort-Object -Property serviceplanName -Unique | Select-Object servicePlanName, provisioningStatus
    $Results = @{}
    foreach ($Plan in $Plans) {
        $Results."$($Plan.servicePlanName)" = $Plan.provisioningStatus -ne 'disabled'
    }
    [PSCustomObject]$Results
}
#EndRegion './Public/Get-CIPPTenantCapabilities.ps1' 31
#Region './Public/Get-CIPPTextReplacement.ps1' -1

function Get-CIPPTextReplacement {
    <#
    .SYNOPSIS
        Replaces text with tenant specific values
    .DESCRIPTION
        Helper function to replace text with tenant specific values
    .PARAMETER TenantFilter
        The tenant filter to use
    .PARAMETER Text
        The text to replace
    .EXAMPLE
        Get-CIPPTextReplacement -TenantFilter 'contoso.com' -Text 'Hello %tenantname%'
    #>
    param (
        [string]$TenantFilter,
        $Text,
        [switch]$EscapeForJson
    )
    if ($Text -isnot [string]) {
        return $Text
    }

    $ReservedVariables = @(
        '%serial%',
        '%systemroot%',
        '%systemdrive%',
        '%temp%',
        '%tenantid%',
        '%tenantfilter%',
        '%initialdomain%',
        '%tenantname%',
        '%partnertenantid%',
        '%samappid%',
        '%userprofile%',
        '%username%',
        '%userdomain%',
        '%windir%',
        '%programfiles%',
        '%programfiles(x86)%',
        '%programdata%',
        '%cippuserschema%',
        '%cippurl%',
        '%defaultdomain%',
        '%organizationid%'
    )

    $Tenant = Get-Tenants -TenantFilter $TenantFilter
    $CustomerId = $Tenant.customerId

    #connect to table, get replacement map. The replacement map will allow users to create custom vars that get replaced by the actual values per tenant. Example:
    # %WallPaperPath% gets replaced by RowKey WallPaperPath which is set to C:\Wallpapers for tenant 1, and D:\Wallpapers for tenant 2

    # Global Variables
    $ReplaceTable = Get-CIPPTable -tablename 'CippReplacemap'
    $GlobalMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq 'AllTenants'"
    $Vars = @{}
    if ($GlobalMap) {
        foreach ($Var in $GlobalMap) {
            if ($EscapeForJson.IsPresent) {
                # Escape quotes for JSON if not already escaped
                $Var.Value = $Var.Value -replace '(?<!\\)"', '\"'
            }
            $Vars[$Var.RowKey] = $Var.Value
        }
    }

    if ($Tenant) {
        # Tenant Specific Variables
        $ReplaceMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$CustomerId'"
        # If no results found by customerId, try by defaultDomainName
        if (!$ReplaceMap) {
            $ReplaceMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$($Tenant.defaultDomainName)'"
        }
        if ($ReplaceMap) {
            foreach ($Var in $ReplaceMap) {
                if ($EscapeForJson.IsPresent) {
                    # Escape quotes for JSON if not already escaped
                    $Var.Value = $Var.Value -replace '(?<!\\)"', '\"'
                }
                $Vars[$Var.RowKey] = $Var.Value
            }
        }
    }
    # Replace custom variables
    foreach ($Replace in $Vars.GetEnumerator()) {
        $String = '%{0}%' -f $Replace.Key
        if ($string -notin $ReservedVariables) {
            $Text = $Text -replace $String, $Replace.Value
        }
    }
    #default replacements for all tenants: %tenantid% becomes $tenant.customerId, %tenantfilter% becomes $tenant.defaultDomainName, %tenantname% becomes $tenant.displayName
    $Text = $Text -replace '%tenantid%', $Tenant.customerId
    $Text = $Text -replace '%organizationid%', $Tenant.customerId
    $Text = $Text -replace '%tenantfilter%', $Tenant.defaultDomainName
    $Text = $Text -replace '%defaultdomain%', $Tenant.defaultDomainName
    $Text = $Text -replace '%initialdomain%', $Tenant.initialDomainName
    $Text = $Text -replace '%tenantname%', $Tenant.displayName

    # Partner specific replacements
    $Text = $Text -replace '%partnertenantid%', $env:TenantID
    $Text = $Text -replace '%samappid%', $env:ApplicationID

    if ($Text -match '%cippuserschema%') {
        $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1
        $Text = $Text -replace '%cippuserschema%', $Schema.id
    }

    if ($Text -match '%cippurl%') {
        $ConfigTable = Get-CIPPTable -tablename 'Config'
        $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'InstanceProperties' and RowKey eq 'CIPPURL'"
        if ($Config) {
            $Text = $Text -replace '%cippurl%', $Config.Value
        }
    }
    return $Text
}
#EndRegion './Public/Get-CIPPTextReplacement.ps1' 117
#Region './Public/Get-CIPPTimerFunctions.ps1' -1

function Get-CIPPTimerFunctions {
    [CmdletBinding()]
    param(
        [switch]$ResetToDefault,
        [switch]$ListAllTasks
    )

    $ConfigTable = Get-CIPPTable -tablename Config
    $Config = Get-CIPPAzDataTableEntity @ConfigTable -Filter "PartitionKey eq 'OffloadFunctions' and RowKey eq 'OffloadFunctions'"

    # Check running nodes
    $VersionTable = Get-CIPPTable -tablename 'Version'
    $Nodes = Get-CIPPAzDataTableEntity @VersionTable -Filter "PartitionKey eq 'Version' and RowKey ne 'Version' and RowKey ne 'frontend'"

    $FunctionName = $env:WEBSITE_SITE_NAME
    $MainFunctionVersion = ($Nodes | Where-Object { $_.RowKey -eq $FunctionName }).Version
    $AvailableNodes = $Nodes.RowKey | Where-Object { $_.RowKey -match '-' -and $_.Version -eq $MainFunctionVersion } | ForEach-Object { ($_ -split '-')[1] }

    # Get node name
    if ($FunctionName -match '-') {
        $Node = ($FunctionName -split '-')[1]
    } else {
        $Node = 'http'
    }

    $RunOnProcessor = $true
    if ($Config -and $Config.state -eq $true -and $AvailableNodes.Count -gt 0) {
        if ($env:CIPP_PROCESSOR -ne 'true') {
            $RunOnProcessor = $false
        }
    }

    $CIPPCoreModuleRoot = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase

    if (!('NCronTab.Advanced.CrontabSchedule' -as [type])) {
        try {
            $NCronTab = Join-Path -Path $CIPPCoreModuleRoot -ChildPath 'lib\NCrontab.Advanced.dll'
            Add-Type -Path $NCronTab
        } catch {}
    }

    $CIPPRoot = (Get-Item $CIPPCoreModuleRoot).Parent.Parent
    $CippTimers = Get-Content -Path $CIPPRoot\CIPPTimers.json
    if ($ListAllTasks) {
        $Orchestrators = $CippTimers | ConvertFrom-Json | Sort-Object -Property Priority
    } else {
        $Orchestrators = $CippTimers | ConvertFrom-Json | Where-Object { $_.RunOnProcessor -eq $RunOnProcessor } | Sort-Object -Property Priority
    }
    $Table = Get-CIPPTable -TableName 'CIPPTimers'
    $RunOnProcessorTxt = if ($RunOnProcessor) { 'true' } else { 'false' }
    if ($ListAllTasks.IsPresent) {
        $OrchestratorStatus = Get-CIPPAzDataTableEntity @Table
    } else {
        $OrchestratorStatus = Get-CIPPAzDataTableEntity @Table -Filter "RunOnProcessor eq $RunOnProcessorTxt"
    }

    $OrchestratorStatus | Where-Object { $_.RowKey -notmatch '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' } | Select-Object ETag, PartitionKey, RowKey | ForEach-Object {
        Remove-AzDataTableEntity @Table -Entity $_ -Force
    }

    foreach ($Orchestrator in $Orchestrators) {
        $Status = $OrchestratorStatus | Where-Object { $_.RowKey -eq $Orchestrator.Id }
        if ($Status.Cron) {
            $CronString = $Status.Cron
        } else {
            $CronString = $Orchestrator.Cron
        }
        $CronCount = ($CronString -split ' ' | Measure-Object).Count
        if ($CronCount -eq 5) {
            $Cron = [Ncrontab.Advanced.CrontabSchedule]::Parse($CronString)
        } elseif ($CronCount -eq 6) {
            $Cron = [Ncrontab.Advanced.CrontabSchedule]::Parse($CronString, [Ncrontab.Advanced.Enumerations.CronStringFormat]::WithSeconds)
        } else {
            Write-Warning "Invalid cron expression for $($Orchestrator.Command): $($Orchestrator.Cron)"
            continue
        }

        if (!$ListAllTasks.IsPresent) {
            if ($Orchestrator.PreferredProcessor -and $AvailableNodes -contains $Orchestrator.PreferredProcessor -and $Node -ne $Orchestrator.PreferredProcessor) {
                # only run on preferred processor when available
                continue
            } elseif ((!$Orchestrator.PreferredProcessor -or $AvailableNodes -notcontains $Orchestrator.PreferredProcessor) -and $Node -notin ('http', 'proc')) {
                # Catchall function nodes
                continue
            }
        }

        $Now = Get-Date
        if ($ListAllTasks.IsPresent) {
            $NextOccurrence = [datetime]$Cron.GetNextOccurrence($Now)
        } else {
            $NextOccurrences = $Cron.GetNextOccurrences($Now.AddMinutes(-15), $Now.AddMinutes(15))
            if (!$Status -or $Status.LastOccurrence -eq 'Never') {
                $NextOccurrence = $NextOccurrences | Where-Object { $_ -le (Get-Date) } | Select-Object -First 1
            } else {
                $NextOccurrence = $NextOccurrences | Where-Object { $_ -gt $Status.LastOccurrence.DateTime.ToLocalTime() -and $_ -le (Get-Date) } | Select-Object -First 1
            }
        }

        if (Get-Command -Name $Orchestrator.Command -Module CIPPCore -ErrorAction SilentlyContinue) {
            if ($NextOccurrence -or $ListAllTasks.IsPresent) {
                if (!$Status) {
                    $Status = [pscustomobject]@{
                        PartitionKey       = 'Timer'
                        RowKey             = $Orchestrator.Id
                        Command            = $Orchestrator.Command
                        Cron               = $CronString
                        LastOccurrence     = 'Never'
                        NextOccurrence     = $NextOccurrence.ToUniversalTime()
                        Status             = 'Not Scheduled'
                        OrchestratorId     = ''
                        RunOnProcessor     = $RunOnProcessor
                        IsSystem           = $Orchestrator.IsSystem ?? $false
                        PreferredProcessor = $Orchestrator.PreferredProcessor ?? ''
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $Status -Force
                } else {
                    if ($Orchestrator.IsSystem -eq $true -or $ResetToDefault.IsPresent) {
                        $Status.Cron = $CronString
                    }
                    $Status.NextOccurrence = $NextOccurrence.ToUniversalTime()
                    $PreferredProcessor = $Orchestrator.PreferredProcessor ?? ''
                    if ($Status.PSObject.Properites.Name -notcontains 'PreferredProcessor') {
                        $Status | Add-Member -MemberType NoteProperty -Name 'PreferredProcessor' -Value $PreferredProcessor -Force
                    } else {
                        $Status.PreferredProcessor = $PreferredProcessor
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $Status -Force
                }

                [PSCustomObject]@{
                    Id                 = $Orchestrator.Id
                    Priority           = $Orchestrator.Priority
                    Command            = $Orchestrator.Command
                    Parameters         = $Orchestrator.Parameters ?? @{}
                    Cron               = $CronString
                    NextOccurrence     = $NextOccurrence.ToUniversalTime()
                    LastOccurrence     = $Status.LastOccurrence
                    Status             = $Status.Status
                    OrchestratorId     = $Status.OrchestratorId
                    RunOnProcessor     = $Orchestrator.RunOnProcessor
                    IsSystem           = $Orchestrator.IsSystem ?? $false
                    PreferredProcessor = $Orchestrator.PreferredProcessor ?? ''
                    ErrorMsg           = $Status.ErrorMsg ?? ''
                }
            }
        } else {
            if ($Status) {
                Write-Warning "Timer function: $($Orchestrator.Command) does not exist"
                Remove-AzDataTableEntity @Table -Entity $Status
            }
        }
    }
}
#EndRegion './Public/Get-CIPPTimerFunctions.ps1' 155
#Region './Public/Get-SlackAlertBlocks.ps1' -1

function Get-SlackAlertBlocks {
    [CmdletBinding()]
    Param(
        $JSONBody
    )

    $Blocks = [system.collections.generic.list[object]]::new()

    $Payload = $JSONBody | ConvertFrom-Json

    if ($Payload.API -eq 'Alerts') {
        foreach ($Entry in $Payload) {
            # Alert log alerts
            $Blocks.Add([PSCustomObject]@{
                    type = 'header'
                    text = @{
                        type  = 'plain_text'
                        text  = 'New Alert from CIPP'
                        emoji = $true
                    }
                })
            $Blocks.Add([PSCustomObject]@{
                    type   = 'section'
                    fields = @(
                        @{
                            type = 'mrkdwn'
                            text = "*Tenant:*`n" + $Entry.Tenant
                        },
                        @{
                            type = 'mrkdwn'
                            text = "*Username:*`n" + $Entry.Username
                        },
                        @{
                            type = 'mrkdwn'
                            text = "*Timestamp:*`n" + ($Entry.Timestamp | Get-Date).ToString('yyyy-MM-dd @ hh:mm:ss tt')
                        }
                    )
                })

            $Blocks.Add([PSCustomObject]@{
                    type = 'section'
                    text = @{
                        type = 'mrkdwn'
                        text = "*Message:*`n" + $Entry.Message
                    }
                })
        }
    } elseif ($Payload.TaskInfo -is [object]) {
        #Scheduler
        $Blocks.Add([PSCustomObject]@{
                type = 'header'
                text = @{
                    type  = 'plain_text'
                    text  = 'New Alert from CIPP'
                    emoji = $true
                }
            })
        $Blocks.Add([PSCustomObject]@{
                type = 'section'
                text = @{
                    type = 'mrkdwn'
                    text = "*Task Name:*`n" + $Payload.TaskInfo.Name
                }
            })
        $Blocks.Add([PSCustomObject]@{
                type   = 'section'
                fields = @(
                    @{
                        type = 'mrkdwn'
                        text = "*Timestamp:*`n" + ($Payload.TaskInfo.Timestamp | Get-Date).ToString('yyyy-MM-dd @ hh:mm:ss tt')
                    },
                    @{
                        type = 'mrkdwn'
                        text = "*Tenant:*`n" + $Payload.Tenant
                    }
                )
            })
        $Blocks.Add([PSCustomObject]@{
                type = 'divider'
            })
        foreach ($Result in $Payload.Results) {
            # Check if results is [string] and create text section
            if ($Result -is [string]) {
                $Blocks.Add([PSCustomObject]@{
                        type = 'section'
                        text = @{
                            type = 'mrkdwn'
                            text = $Result
                        }
                    })
            } else {
                #Iterate through property names and create fields
                $Fields = [system.collections.generic.list[object]]::new()
                foreach ($Key in $Result.PSObject.Properties.Name) {
                    $Fields.Add(@{
                            type = 'mrkdwn'
                            text = "*$($Key):*`n" + $Result.$Key
                        })
                }
                $Blocks.Add([PSCustomObject]@{
                        type   = 'section'
                        fields = @($Fields)

                    })
            }
        }
    } elseif ($Payload.RawData -is [object]) {
        # Webhook alert
        $Blocks.Add([PSCustomObject]@{
                type = 'header'
                text = @{
                    type  = 'plain_text'
                    text  = 'New Alert from CIPP'
                    emoji = $true
                }
            })

        $Blocks.Add([PSCustomObject]@{
                type = 'section'
                text = @{
                    type = 'mrkdwn'
                    text = "*Title:*`n" + $Payload.Title
                }
            })
        $Blocks.Add([PSCustomObject]@{
                type     = 'actions'
                elements = @(
                    @{
                        type  = 'button'
                        text  = @{
                            type = 'plain_text'
                            text = $Payload.ActionText ?? 'Go to CIPP'
                        }
                        url   = $Payload.ActionUrl
                        style = 'primary'
                    }
                )
            })
        $Blocks.Add([PSCustomObject]@{
                type = 'divider'
            })

        $Blocks.Add([PSCustomObject]@{
                type = 'section'
                text = @{
                    type = 'mrkdwn'
                    text = '*Webhook Data:*'
                }
            })
        #loop through rawdata properties and create key value fields
        $Fields = [system.collections.generic.list[object]]::new()
        foreach ($Key in $Payload.RawData.PSObject.Properties.Name) {
            # if value is json continue to next property
            if ($Payload.RawData.$Key -is [string] -and ([string]::IsNullOrEmpty($Payload.RawData.$Key) -or (Test-Json $Payload.RawData.$Key -ErrorAction SilentlyContinue))) {
                continue
            }
            # if value is date object
            if ($Payload.RawData.$Key -is [datetime]) {
                $Fields.Add(@{
                        type = 'mrkdwn'
                        text = "*$($Key):*`n" + $Payload.RawData.$Key.ToString('yyyy-MM-dd @ hh:mm:ss tt')
                    })
            } elseif ($Payload.RawData.$Key -is [array] -and $Payload.RawData.$Key.Count -gt 0) {
                foreach ($SubKey in $Payload.RawData.$Key) {
                    if ([string]::IsNullOrEmpty($SubKey)) {
                        continue
                    } elseif ($SubKey -is [datetime]) {
                        $Fields.Add(@{
                                type = 'mrkdwn'
                                text = "*$($Key):*`n" + $SubKey.ToString('yyyy-MM-dd @ hh:mm:ss tt')
                            })
                    } else {
                        $Fields.Add(@{
                                type = 'mrkdwn'
                                text = "*$($Key):*`n" + $SubKey
                            })
                    }
                }
            } elseif ($Payload.RawData.$Key.PSObject.Properties.Name -is [array] -and $Payload.RawData.$Key.PSObject.Properties.Name.Count -gt 0) {
                foreach ($SubKey in $Payload.RawData.$Key.PSObject.Properties.Name) {
                    if ([string]::IsNullOrEmpty($Payload.RawData.$Key.$SubKey)) {
                        continue
                    } elseif ($Payload.RawData.$Key.$SubKey -is [datetime]) {
                        $Fields.Add(@{
                                type = 'mrkdwn'
                                text = "*$($Key)/$($SubKey):*`n" + $Payload.RawData.$Key.$SubKey.ToString('yyyy-MM-dd @ hh:mm:ss tt')
                            })
                    } elseif (Test-Json $Payload.RawData.$Key.$SubKey -ErrorAction SilentlyContinue) {
                        # parse json and iterate through properties
                        continue
                        <#$SubKeyData = $Payload.RawData.$Key.$SubKey | ConvertFrom-Json
                        foreach ($SubSubKey in $SubKeyData.PSObject.Properties.Name) {
                            $Fields.Add(@{
                                    type = 'mrkdwn'
                                    text = "*$($Key)/$($SubKey)/$($SubSubKey):*`n" + $SubKeyData.$SubSubKey
                                })
                        }#>
                    } else {
                        $Fields.Add(@{
                                type = 'mrkdwn'
                                text = "*$($Key)/$($SubKey):*`n" + $Payload.RawData.$Key.$SubKey
                            })
                    }
                }
            } else {
                $Fields.Add(@{
                        type = 'mrkdwn'
                        text = "*$($Key):*`n" + $Payload.RawData.$Key
                    })
            }
        }

        $FieldBatch = [system.collections.generic.list[object]]::new()
        for ($i = 0; $i -lt $Fields.Count; $i += 10) {
            $FieldBatch.Add($Fields[$i..[math]::Min($i + 9, $Fields.Count - 1)])
        }
        foreach ($Batch in $FieldBatch) {
            $Blocks.Add([PSCustomObject]@{
                    type   = 'section'
                    fields = @($Batch)
                })
        }

        # if potentiallocationinfo is present
        if ($Payload.PotentialLocationInfo) {
            # add divider
            $Blocks.Add([PSCustomObject]@{
                    type = 'divider'
                })
            # add text section for location
            $Blocks.Add([PSCustomObject]@{
                    type = 'section'
                    text = @{
                        type = 'mrkdwn'
                        text = '*Potential Location Info:*'
                    }
                })
            # loop through location properties and add fields
            $LocationFields = [system.collections.generic.list[object]]::new()
            foreach ($Key in $Payload.PotentialLocationInfo.PSObject.Properties.Name) {
                $LocationFields.Add(@{
                        type = 'mrkdwn'
                        text = "*$($Key):*`n" + $Payload.PotentialLocationInfo.$Key
                    })
            }
            # add fields to section in groups of 10
            $LocationFieldBatch = [system.collections.generic.list[object]]::new()
            for ($i = 0; $i -lt $LocationFields.Count; $i += 10) {
                $LocationFieldBatch.Add($LocationFields[$i..[math]::Min($i + 9, $LocationFields.Count - 1)])
            }
            foreach ($Batch in $LocationFieldBatch) {
                $Blocks.Add([PSCustomObject]@{
                        type   = 'section'
                        fields = @($Batch)
                    })
            }
        }
    }

    if (($Blocks | Measure-Object).Count -gt 0) {
        [PSCustomObject]@{
            blocks = $Blocks
        }
    }
}
#EndRegion './Public/Get-SlackAlertBlocks.ps1' 266
#Region './Public/Get-TenantIdFromSubscriptionId.ps1' -1

function Get-TenantIdFromSubscriptionId {
    param (
        [Parameter(Mandatory = $true)]
        [string]$SubscriptionId
    )

    # Full credit goes to Jos Lieben
    # https://www.lieben.nu/liebensraum/2020/08/get-tenant-id-using-azure-subscription-id/
    
    try {
        Invoke-WebRequest -UseBasicParsing -Uri "https://management.azure.com/subscriptions/$($SubscriptionId)`?api-version=2015-01-01" -ErrorAction Stop
    } catch {
        # The error response contains the WWW-Authenticate header with the tenant ID
        $response = $_.Exception.Response
    }
    
    # Extract tenant ID from WWW-Authenticate header
    $authHeader = $response.Headers.GetValues("WWW-Authenticate")[0]
    
    # Use regex to extract the tenant ID
    if ($authHeader -match "login\.windows\.net\/([0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})") {
        return $matches[1]
    }
    
    return $null
}
#EndRegion './Public/Get-TenantIdFromSubscriptionId.ps1' 27
#Region './Public/Get-TenantProperties.ps1' -1

function Get-TenantProperties {
    param (
        [string]$customerId
    )

    $tableName = 'TenantProperties'
    $query = "PartitionKey eq '$customerId'"
    $Table = Get-CIPPTable -TableName $tableName
    $tenantProperties = Get-CIPPAzDataTableEntity @Table -Filter $query

    $properties = @{}
    foreach ($property in $tenantProperties) {
        $properties[$property.RowKey] = $property.Value
    }

    return $properties
}
#EndRegion './Public/Get-TenantProperties.ps1' 18
#Region './Public/GraphHelper/Convert-SKUName.ps1' -1

function Convert-SKUname {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param(
        $SkuName,
        $SkuID,
        $ConvertTable
    )
    if (!$ConvertTable) {
        $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
        $ConvertTable = Import-Csv (Join-Path $ModuleBase 'lib\data\ConversionTable.csv')
    }
    if ($SkuName) { $ReturnedName = ($ConvertTable | Where-Object { $_.String_Id -eq $SkuName } | Select-Object -Last 1).'Product_Display_Name' }
    if ($SkuID) { $ReturnedName = ($ConvertTable | Where-Object { $_.guid -eq $SkuID } | Select-Object -Last 1).'Product_Display_Name' }
    if ($ReturnedName) { return $ReturnedName } else { return $SkuName, $SkuID }
}
#EndRegion './Public/GraphHelper/Convert-SKUName.ps1' 19
#Region './Public/GraphHelper/Get-AuthorisedRequest.ps1' -1


function Get-AuthorisedRequest {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    Param(
        [string]$TenantID,
        [string]$Uri
    )
    if (!$TenantID) {
        $TenantID = $env:TenantID
    }

    if ($Uri -like 'https://graph.microsoft.com/beta/contracts*' -or $Uri -like '*/customers/*' -or $Uri -eq 'https://graph.microsoft.com/v1.0/me/sendMail' -or $Uri -like '*/tenantRelationships/*' -or $Uri -like '*/security/partner/*') {
        return $true
    }
    $Tenant = Get-Tenants -IncludeErrors -TenantFilter $TenantID | Where-Object { $_.Excluded -eq $false }

    if ($Tenant) {
        return $true
    } else {
        return $false
    }
}
#EndRegion './Public/GraphHelper/Get-AuthorisedRequest.ps1' 27
#Region './Public/GraphHelper/Get-CippException.ps1' -1

function Get-CippException {
    Param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        $Exception
    )

    [PSCustomObject]@{
        Message         = $Exception.Exception.Message
        NormalizedError = Get-NormalizedError -message $Exception.Exception.Message
        Position        = $Exception.InvocationInfo.PositionMessage
        StackTrace      = ($Exception.ScriptStackTrace | Out-String)
        ScriptName      = $Exception.InvocationInfo.ScriptName
        LineNumber      = $Exception.InvocationInfo.ScriptLineNumber
        Category        = $Exception.CategoryInfo.ToString()
    }
}
#EndRegion './Public/GraphHelper/Get-CippException.ps1' 17
#Region './Public/GraphHelper/Get-CippSamPermissions.ps1' -1

function Get-CippSamPermissions {
    <#
    .SYNOPSIS
    This script retrieves the CIPP-SAM permissions.

    .DESCRIPTION
    The Get-CippSamManifest function is used to retrieve the CIPP-SAM permissions either from the manifest files or table.

    .EXAMPLE
    Get-CippSamManifest
    Retrieves the CIPP SAM manifest located in the module root

    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(ParameterSetName = 'ManifestOnly')]
        [switch]$ManifestOnly,
        [Parameter(ParameterSetName = 'Default')]
        [switch]$SavedOnly,
        [Parameter(ParameterSetName = 'Diff')]
        [switch]$NoDiff
    )

    if (!$SavedOnly.IsPresent) {
        $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
        $SamManifestFile = Get-Item (Join-Path $ModuleBase 'lib\data\SAMManifest.json')
        $AdditionalPermissions = Get-Item (Join-Path $ModuleBase 'lib\data\AdditionalPermissions.json')

        $ServicePrincipalList = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/servicePrincipals?$top=999&$select=id,appId,displayName' -tenantid $env:TenantID -NoAuthCheck $true
        $SAMManifest = Get-Content -Path $SamManifestFile.FullName | ConvertFrom-Json
        $AdditionalPermissions = Get-Content -Path $AdditionalPermissions.FullName | ConvertFrom-Json

        $RequiredResources = $SAMManifest.requiredResourceAccess

        $AppIds = ($RequiredResources.resourceAppId + $AdditionalPermissions.resourceAppId) | Sort-Object -Unique

        Write-Information "Retrieving service principals for $($AppIds.Count) applications"
        $UsedServicePrincipals = $ServicePrincipalList | Where-Object -Property appId -In $AppIds
        $Requests = $UsedServicePrincipals | ForEach-Object {
            @(
                @{
                    id     = $_.id
                    url    = 'servicePrincipals/{0}?$select=appId,displayName,appRoles,publishedPermissionScopes' -f $_.id
                    method = 'GET'
                }
            )
        }
        $BulkRequests = New-GraphBulkRequest -Requests $Requests -NoAuthCheck $true -tenantid $env:TenantID
        $ServicePrincipals = $BulkRequests | ForEach-Object {
            $_.body
        }

        $Permissions = @{}
        foreach ($AppId in $AppIds) {
            $ServicePrincipal = $ServicePrincipals | Where-Object -Property appId -EQ $AppId
            $AppPermissions = [System.Collections.Generic.List[object]]@()
            $ManifestPermissions = ($RequiredResources | Where-Object -Property resourceAppId -EQ $AppId).resourceAccess
            $UnpublishedPermissions = ($AdditionalPermissions | Where-Object -Property resourceAppId -EQ $AppId).resourceAccess

            foreach ($Permission in $ManifestPermissions) {
                $AppPermissions.Add($Permission)
            }
            if ($UnpublishedPermissions) {
                foreach ($Permission in $UnpublishedPermissions) {
                    $AppPermissions.Add($Permission)
                }
            }

            $ApplicationPermissions = [system.collections.generic.list[object]]@()
            $DelegatedPermissions = [system.collections.generic.list[object]]@()
            foreach ($Permission in $AppPermissions) {
                if ($Permission.id -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$') {
                    if ($Permission.type -eq 'Role') {
                        $PermissionName = ($ServicePrincipal.appRoles | Where-Object -Property id -EQ $Permission.id).value
                    } else {
                        $PermissionName = ($ServicePrincipal.publishedPermissionScopes | Where-Object -Property id -EQ $Permission.id).value
                    }
                } else {
                    $PermissionName = $Permission.id
                }

                if ($Permission.type -eq 'Role') {
                    $ApplicationPermissions.Add([PSCustomObject]@{
                            id    = $Permission.id
                            value = $PermissionName

                        })
                } else {
                    $DelegatedPermissions.Add([PSCustomObject]@{
                            id    = $Permission.id
                            value = $PermissionName
                        })
                }
            }

            $ServicePrincipal = $ServicePrincipals | Where-Object -Property appId -EQ $AppId
            $Permissions.$AppId = @{
                applicationPermissions = @($ApplicationPermissions | Sort-Object -Property label)
                delegatedPermissions   = @($DelegatedPermissions | Sort-Object -Property label)
            }
        }
    }
    if ($ManifestOnly) {
        return [PSCustomObject]@{
            Permissions = $Permissions
            Type        = 'Manifest'
        }
    }

    $Table = Get-CippTable -tablename 'AppPermissions'
    $SavedPermissions = Get-CippAzDataTableEntity @Table -Filter "PartitionKey eq 'CIPP-SAM' and RowKey eq 'CIPP-SAM'"
    if ($SavedPermissions.Permissions) {
        try {
            $SavedPermissions.Permissions = $SavedPermissions.Permissions | ConvertFrom-Json -ErrorAction Stop
        } catch {
            $SavedPermissions.Permissions = [PSCustomObject]@{}
        }
    } else {
        $SavedPermissions = @{
            Permissions = [PSCustomObject]@{}
        }
    }

    if ($SavedOnly.IsPresent) {
        $SavedPermissions | Add-Member -MemberType NoteProperty -Name Type -Value 'Table'
        return $SavedPermissions
    }

    if (!$NoDiff.IsPresent -and $SavedPermissions.Permissions) {
        $DiffPermissions = @{}
        foreach ($AppId in $AppIds) {
            $ManifestSpPermissions = $Permissions.$AppId
            $ServicePrincipal = $ServicePrincipals | Where-Object -Property appId -EQ $AppId
            $SavedSpPermission = $SavedPermissions.Permissions.$AppId
            $MissingApp = [System.Collections.Generic.List[object]]::new()
            $MissingDelegated = [System.Collections.Generic.List[object]]::new()
            foreach ($Permission in $ManifestSpPermissions.applicationPermissions) {
                if ($SavedSpPermission.applicationPermissions.id -notcontains $Permission.id) {
                    $AppRole = $ServicePrincipal.appRoles | Where-Object -Property id -EQ $Permission.id | Select-Object id, value
                    $MissingApp.Add($AppRole ?? $Permission)
                }
            }
            foreach ($Permission in $ManifestSpPermissions.delegatedPermissions) {
                if ($SavedSpPermission.delegatedPermissions.id -notcontains $Permission.id) {
                    $PermissionScope = $ServicePrincipal.publishedPermissionScopes | Where-Object -Property id -EQ $Permission.id | Select-Object id, value
                    $MissingDelegated.Add($PermissionScope ?? $Permission)
                }
            }
            if ($MissingApp -or $MissingDelegated) {
                $DiffPermissions.$AppId = @{
                    applicationPermissions = $MissingApp
                    delegatedPermissions   = $MissingDelegated
                }
            }
        }
    }

    $SamAppPermissions = @{}
    if (($SavedPermissions.Permissions.PSObject.Properties.Name | Measure-Object).Count -gt 0) {
        $SamAppPermissions.Permissions = $SavedPermissions.Permissions
        $SamAppPermissions.UsedServicePrincipals = $UsedServicePrincipals
        $SamAppPermissions.UpdatedBy = $SavedPermissions.UpdatedBy
        $SamAppPermissions.Timestamp = $SavedPermissions.Timestamp.DateTime.ToString('yyyy-MM-ddTHH:mm:ssZ')
        $SamAppPermissions.Type = 'Table'
    } else {
        $SamAppPermissions.Permissions = $Permissions
        $SamAppPermissions.UsedServicePrincipals = $UsedServicePrincipals
        $SamAppPermissions.Type = 'Manifest'
        $SamAppPermissions.UpdatedBy = 'CIPP'
        $SamAppPermissions.Timestamp = $SamManifestFile.LastWriteTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')

        $Entity = @{
            'PartitionKey' = 'CIPP-SAM'
            'RowKey'       = 'CIPP-SAM'
            'Permissions'  = [string]([PSCustomObject]$Permissions | ConvertTo-Json -Depth 10 -Compress)
            'UpdatedBy'    = 'CIPP'
        }
        $Table = Get-CIPPTable -TableName 'AppPermissions'
        try {
            $null = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
        } catch {
            Write-Error "Failed to save the CIPP-SAM permissions: $($_.Exception.Message)"
        }
    }

    if (!$NoDiff.IsPresent -and $SamAppPermissions.Type -eq 'Table') {
        $SamAppPermissions.MissingPermissions = $DiffPermissions
    }

    $SamAppPermissions = $SamAppPermissions | ConvertTo-Json -Depth 10 -Compress | ConvertFrom-Json

    return $SamAppPermissions
}

#EndRegion './Public/GraphHelper/Get-CippSamPermissions.ps1' 197
#Region './Public/GraphHelper/Get-CIPPTable.ps1' -1

function Get-CIPPTable {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param (
        $tablename = 'CippLogs'
    )
    $Context = New-AzDataTableContext -ConnectionString $env:AzureWebJobsStorage -TableName $tablename
    New-AzDataTable -Context $Context | Out-Null

    @{
        Context = $Context
    }
}
#EndRegion './Public/GraphHelper/Get-CIPPTable.ps1' 17
#Region './Public/GraphHelper/Get-ClassicAPIToken.ps1' -1

function Get-ClassicAPIToken($tenantID, $Resource) {
    <#
    .FUNCTIONALITY
    Internal
    #>
    $TokenKey = '{0}-{1}' -f $TenantID, $Resource
    if ($script:classictoken.$TokenKey -and [int](Get-Date -UFormat %s -Millisecond 0) -lt $script:classictoken.$TokenKey.expires_on) {
        #Write-Host 'Classic: cached token'
        return $script:classictoken.$TokenKey
    } else {
        #Write-Host 'Using classic'
        $uri = "https://login.microsoftonline.com/$($TenantID)/oauth2/token"
        $Body = @{
            client_id     = $env:ApplicationID
            client_secret = $env:ApplicationSecret
            resource      = $Resource
            refresh_token = $env:RefreshToken
            grant_type    = 'refresh_token'
        }
        try {
            if (!$script:classictoken) { $script:classictoken = [HashTable]::Synchronized(@{}) }
            $script:classictoken.$TokenKey = Invoke-RestMethod $uri -Body $body -ContentType 'application/x-www-form-urlencoded' -ErrorAction SilentlyContinue -Method post
            return $script:classictoken.$TokenKey
        } catch {
            # Track consecutive Graph API failures
            $TenantsTable = Get-CippTable -tablename Tenants
            $Filter = "PartitionKey eq 'Tenants' and (defaultDomainName eq '{0}' or customerId eq '{0}')" -f $tenantid
            $Tenant = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
            if (!$Tenant) {
                $Tenant = @{
                    GraphErrorCount     = $null
                    LastGraphTokenError = $null
                    LastGraphError      = $null
                    PartitionKey        = 'TenantFailed'
                    RowKey              = 'Failed'
                }
            }
            $Tenant.LastGraphError = $_.Exception.Message
            $Tenant.GraphErrorCount++

            Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant
            Throw "Failed to obtain Classic API Token for $TenantID - $_"
        }
    }
}
#EndRegion './Public/GraphHelper/Get-ClassicAPIToken.ps1' 46
#Region './Public/GraphHelper/Get-GraphBulkResultByID.ps1' -1

function Get-GraphBulkResultByID ($Results, $ID, [switch]$Value) {
    <#
    .FUNCTIONALITY
    Internal
    #>
    if ($Value) {
    ($Results | Where-Object { $_.id -eq $ID }).body.value
    } else {
        ($Results | Where-Object { $_.id -eq $ID }).body
    }
}
#EndRegion './Public/GraphHelper/Get-GraphBulkResultByID.ps1' 12
#Region './Public/GraphHelper/Get-GraphToken.ps1' -1

function Get-GraphToken($tenantid, $scope, $AsApp, $AppID, $AppSecret, $refreshToken, $ReturnRefresh, $SkipCache) {
    <#
    .FUNCTIONALITY
    Internal
    #>
    if (!$scope) { $scope = 'https://graph.microsoft.com/.default' }

    if (!$env:SetFromProfile) { $CIPPAuth = Get-CIPPAuthentication; Write-Host 'Could not get Refreshtoken from environment variable. Reloading token.' }
    $ConfigTable = Get-CippTable -tablename 'Config'
    $Filter = "PartitionKey eq 'AppCache' and RowKey eq 'AppCache'"
    $AppCache = Get-CIPPAzDataTableEntity @ConfigTable -Filter $Filter
    #force auth update is appId is not the same as the one in the environment variable.
    if ($AppCache.ApplicationId -and $env:ApplicationID -ne $AppCache.ApplicationId) {
        Write-Host "Setting environment variable ApplicationID to $($AppCache.ApplicationId)"
        $CIPPAuth = Get-CIPPAuthentication
    }
    $refreshToken = $env:RefreshToken
    if (!$tenantid) { $tenantid = $env:TenantID }
    #Get list of tenants that have 'directTenant' set to true
    #get directtenants directly from table, avoid get-tenants due to performance issues
    $TenantsTable = Get-CippTable -tablename 'Tenants'
    $Filter = "PartitionKey eq 'Tenants' and delegatedPrivilegeStatus eq 'directTenant'"
    $ClientType = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter | Where-Object { $_.customerId -eq $tenantid -or $_.defaultDomainName -eq $tenantid }
    if ($tenantid -ne $env:TenantID -and $clientType.delegatedPrivilegeStatus -eq 'directTenant') {
        Write-Host "Using direct tenant refresh token for $($clientType.customerId)"
        $ClientRefreshToken = Get-Item -Path "env:\$($clientType.customerId)" -ErrorAction SilentlyContinue
        $refreshToken = $ClientRefreshToken.Value
    }

    $AuthBody = @{
        client_id     = $env:ApplicationID
        client_secret = $env:ApplicationSecret
        scope         = $Scope
        refresh_token = $refreshToken
        grant_type    = 'refresh_token'
    }
    if ($asApp -eq $true) {
        $AuthBody = @{
            client_id     = $env:ApplicationID
            client_secret = $env:ApplicationSecret
            scope         = $Scope
            grant_type    = 'client_credentials'
        }
    }

    if ($null -ne $AppID -and $null -ne $refreshToken) {
        $AuthBody = @{
            client_id     = $appid
            refresh_token = $refreshToken
            scope         = $Scope
            grant_type    = 'refresh_token'
        }
    }

    if ($null -ne $AppID -and $null -ne $AppSecret) {
        $AuthBody = @{
            client_id     = $AppID
            client_secret = $AppSecret
            scope         = $Scope
            grant_type    = 'client_credentials'
        }
    }


    $TokenKey = '{0}-{1}-{2}' -f $tenantid, $scope, $asApp

    try {
        if ($script:AccessTokens.$TokenKey -and [int](Get-Date -UFormat %s -Millisecond 0) -lt $script:AccessTokens.$TokenKey.expires_on -and $SkipCache -ne $true) {
            #Write-Host 'Graph: cached token'
            $AccessToken = $script:AccessTokens.$TokenKey
        } else {
            #Write-Host 'Graph: new token'
            $AccessToken = (Invoke-RestMethod -Method post -Uri "https://login.microsoftonline.com/$($tenantid)/oauth2/v2.0/token" -Body $Authbody -ErrorAction Stop)
            $ExpiresOn = [int](Get-Date -UFormat %s -Millisecond 0) + $AccessToken.expires_in
            Add-Member -InputObject $AccessToken -NotePropertyName 'expires_on' -NotePropertyValue $ExpiresOn
            if (!$script:AccessTokens) { $script:AccessTokens = [HashTable]::Synchronized(@{}) }
            $script:AccessTokens.$TokenKey = $AccessToken
        }

        if ($ReturnRefresh) { $header = $AccessToken } else { $header = @{ Authorization = "Bearer $($AccessToken.access_token)" } }
        return $header
    } catch {
        # Track consecutive Graph API failures
        $TenantsTable = Get-CippTable -tablename Tenants
        $Filter = "PartitionKey eq 'Tenants' and (defaultDomainName eq '{0}' or customerId eq '{0}')" -f $tenantid
        $Tenant = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
        if (!$Tenant.RowKey) {
            $donotset = $true
            $Tenant = [pscustomobject]@{
                GraphErrorCount     = 0
                LastGraphTokenError = ''
                LastGraphError      = ''
                PartitionKey        = 'TenantFailed'
                RowKey              = 'Failed'
            }
        }
        $Tenant.LastGraphError = if ( $_.ErrorDetails.Message) {
            if (Test-Json $_.ErrorDetails.Message -ErrorAction SilentlyContinue) {
                $msg = $_.ErrorDetails.Message | ConvertFrom-Json
                "$($msg.error):$($msg.error_description)"
            } else {
                "$($_.ErrorDetails.Message)"
            }
        } else {
            $_.Exception.Message
        }
        $Tenant.GraphErrorCount++

        if (!$donotset) { Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant }
        throw "Could not get token: $($Tenant.LastGraphError)"
    }
}
#EndRegion './Public/GraphHelper/Get-GraphToken.ps1' 113
#Region './Public/GraphHelper/Get-GraphTokenFromCert.ps1' -1

function Get-GraphTokenFromCert {
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantId,

        [Parameter(Mandatory = $true)]
        [string]$AppId,

        [string]$Scope = 'https://graph.microsoft.com/.default',
        [Parameter(Mandatory = $true)]
        [System.Security.Cryptography.X509Certificates.X509Certificate2]$Certificate
    )
    #########################################################
    # Create Bearer Token From Certificate for HBU Graph
    #########################################################

    # get sha256 hash of certificate
    $sha256 = New-Object System.Security.Cryptography.SHA256CryptoServiceProvider
    $hash = $sha256.ComputeHash($Certificate.RawData)
    $hash = [Convert]::ToBase64String($hash)

    # Create JWT timestamp for expiration
    $StartDate = (Get-Date '1970-01-01T00:00:00Z' ).ToUniversalTime()
    $JWTExpirationTimeSpan = (New-TimeSpan -Start $StartDate -End (Get-Date).ToUniversalTime().AddMinutes(2)).TotalSeconds
    $JWTExpiration = [math]::Round($JWTExpirationTimeSpan, 0)

    # Create JWT validity start timestamp
    $NotBeforeExpirationTimeSpan = (New-TimeSpan -Start $StartDate -End ((Get-Date).ToUniversalTime())).TotalSeconds
    $NotBefore = [math]::Round($NotBeforeExpirationTimeSpan, 0)

    # Create JWT header
    $JWTHeader = @{
        alg        = 'PS256'
        typ        = 'JWT'
        # Use the CertificateBase64Hash and replace/strip to match web encoding of base64
        'x5t#S256' = $hash -replace '\+', '-' -replace '/', '_' -replace '='
    }

    # Create JWT payload
    $JWTPayLoad = @{
        # Issuer = your application
        iss = $AppId

        # What endpoint is allowed to use this JWT
        aud = "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token"

        # JWT ID: random guid
        jti = [guid]::NewGuid()

        # Expiration timestamp
        exp = $JWTExpiration

        # Not to be used before
        nbf = $NotBefore

        # JWT Subject
        sub = $AppId
    }

    # Convert header and payload to base64
    $JWTHeaderToByte = [System.Text.Encoding]::UTF8.GetBytes(($JWTHeader | ConvertTo-Json))
    $EncodedHeader = [System.Convert]::ToBase64String($JWTHeaderToByte)

    $JWTPayLoadToByte = [System.Text.Encoding]::UTF8.GetBytes(($JWTPayload | ConvertTo-Json))
    $EncodedPayload = [System.Convert]::ToBase64String($JWTPayLoadToByte)

    # Join header and Payload with "." to create a valid (unsigned) JWT
    $JWT = $EncodedHeader + '.' + $EncodedPayload

    # Get the private key object of your certificate
    # $PrivateKey = $Certificate.PrivateKey
    $PrivateKey = ([System.Security.Cryptography.X509Certificates.RSACertificateExtensions]::GetRSAPrivateKey($Certificate))

    # Define RSA signature and hashing algorithm
    $RSAPadding = [Security.Cryptography.RSASignaturePadding]::Pss
    $HashAlgorithm = [Security.Cryptography.HashAlgorithmName]::SHA256

    # Create a signature of the JWT
    $Signature = [Convert]::ToBase64String(
        $PrivateKey.SignData([System.Text.Encoding]::UTF8.GetBytes($JWT), $HashAlgorithm, $RSAPadding)
    ) -replace '\+', '-' -replace '/', '_' -replace '='

    # Join the signature to the JWT with "."
    $JWT = $JWT + '.' + $Signature

    # Create a hash with body parameters
    $Body = @{
        client_id             = $AppId
        client_assertion      = $JWT
        client_assertion_type = 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'
        scope                 = $Scope
        grant_type            = 'client_credentials'
    }

    $Url = "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token"

    # Use the self-generated JWT as Authorization
    $Header = @{
        Authorization = "Bearer $JWT"
    }

    # Splat the parameters for Invoke-Restmethod for cleaner code
    $PostSplat = @{
        ContentType = 'application/x-www-form-urlencoded'
        Method      = 'POST'
        Body        = $Body
        Uri         = $Url
        Headers     = $Header
    }

    try {
        return Invoke-RestMethod @PostSplat
    } catch {
        Write-Error $_
    }

}
#EndRegion './Public/GraphHelper/Get-GraphTokenFromCert.ps1' 118
#Region './Public/GraphHelper/Get-NormalizedError.ps1' -1

function Get-NormalizedError {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingEmptyCatchBlock', '', Justification = 'CIPP does not use this function to catch errors')]
    [CmdletBinding()]
    param (
        [string]$message
    )

    #Check if the message is valid JSON.
    try {
        $JSONMsg = $message | ConvertFrom-Json
    } catch {
    }
    #if the message is valid JSON, there can be multiple fields in which the error resides. These are:
    # $message.error.Innererror.Message
    # $message.error.Message
    # $message.error.details.message
    # $message.error.innererror.internalException.message

    #We need to check if the message is in one of these fields, and if so, return it.
    if ($JSONMsg.error.innererror.message) {
        Write-Information "innererror.message found: $($JSONMsg.error.innererror.message)"
        $message = $JSONMsg.error.innererror.message
    } elseif ($JSONMsg.error.message) {
        Write-Information "error.message found: $($JSONMsg.error.message)"
        $message = $JSONMsg.error.message
    } elseif ($JSONMsg.error.details.message) {
        Write-Information "error.details.message found: $($JSONMsg.error.details.message)"
        $message = $JSONMsg.error.details.message
    } elseif ($JSONMsg.error.innererror.internalException.message) {
        Write-Information "error.innererror.internalException.message found: $($JSONMsg.error.innererror.internalException.message)"
        $message = $JSONMsg.error.innererror.internalException.message
    }


    #finally, put the message through the translator. If it's not in the list, just return the original message
    switch -Wildcard ($message) {
        'Request not applicable to target tenant.' { 'Required license not available for this tenant' }
        "Neither tenant is B2C or tenant doesn't have premium license" { 'This feature requires a P1 license or higher' }
        'Response status code does not indicate success: 400 (Bad Request).' { 'Error 400 occured. There is an issue with the token configuration for this tenant. Please perform an access check' }
        '*Microsoft.Skype.Sync.Pstn.Tnm.Common.Http.HttpResponseException*' { 'Could not connect to Teams Admin center - Tenant might be missing a Teams license' }
        '*Provide valid credential.*' { 'Error 400: There is an issue with your Exchange Token configuration. Please perform an access check for this tenant' }
        '*This indicate that a subscription within the tenant has lapsed*' { 'There is no subscription for this service available, Check licensing information.' }
        '*User was not found.*' { 'The relationship between this tenant and the partner has been dissolved from the tenant side.' }
        '*AADSTS50020*' { 'AADSTS50020: The user you have used for your Secure Application Model is a guest in this tenant, or your are using GDAP and have not added the user to the correct group. Please delete the guest user to gain access to this tenant' }
        '*AADSTS50177' { 'AADSTS50177: The user you have used for your Secure Application Model is a guest in this tenant, or your are using GDAP and have not added the user to the correct group. Please delete the guest user to gain access to this tenant' }
        '*invalid or malformed*' { 'The request is malformed. Have you finished the Setup Wizard' }
        '*Windows Store repository apps feature is not supported for this tenant*' { 'This tenant does not have WinGet support available' }
        '*AADSTS650051*' { 'The application does not exist yet. Try again in 30 seconds.' }
        '*AppLifecycle_2210*' { 'Failed to call Intune APIs: Does the tenant have a license available?' }
        '*One or more added object references already exist for the following modified properties:*' { 'This user is already a member of this group.' }
        '*Microsoft.Exchange.Management.Tasks.MemberAlreadyExistsException*' { 'This user is already a member of this group.' }
        '*The property value exceeds the maximum allowed size (64KB)*' { 'One of the values exceeds the maximum allowed size (64KB).' }
        '*Unable to initialize the authorization context*' { 'Your GDAP configuration does not allow us to write to this tenant, please check your group mappings and tenant onboarding.' }
        '*Providers.Common.V1.CoreException*' { '403 (Access Denied) - We cannot connect to this tenant.' }
        '*Authentication failed. MFA required*' { 'Authentication failed. MFA required' }
        '*Your tenant is not licensed for this feature.*' { 'Required license not available for this tenant' }
        '*AADSTS65001*' { 'We cannot access this tenant as consent has not been given, please try refreshing the CPV permissions in the application settings menu.' }
        '*AADSTS700082*' { 'The CIPP user access token has expired. Run the Setup Wizard to refresh your tokens.' }
        '*Account is not provisioned.' { 'The account is not provisioned. You do not the correct M365 license to access this information..' }
        '*AADSTS5000224*' { 'This resource is not available - Has this tenant been deleted?' }
        '*AADSTS53003*' { 'Access has been blocked by Conditional Access policies. Please check the Conditional Access configuration documentation' }
        '*AADSTS900023*' { 'This tenant is not available for this operation. Please check the selected tenant and try again.' }
        '*AADSTS9002313*' { 'The credentials used to connect to the Graph API are not available, please retry. If this issue persists you may need to execute the SAM wizard.' }
        '*One or more platform(s) is/are not configured for the customer. Please configure the platform before trying to purchase a SKU.*' { 'One or more platform(s) is/are not configured for the customer. Please configure the platform before trying to purchase a SKU.' }
        "One or more added object references already exist for the following modified properties: 'members'." { 'This user is already a member of the selected group.' }
        default { $message }

    }
}
#EndRegion './Public/GraphHelper/Get-NormalizedError.ps1' 74
#Region './Public/GraphHelper/Get-SharePointAdminLink.ps1' -1

function Get-SharePointAdminLink {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param ($Public, $TenantFilter)

    if ($Public) {
        # Do it through domain discovery, unreliable
        try {
            # Get tenant information using autodiscover
            $body = @"
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:exm="http://schemas.microsoft.com/exchange/services/2006/messages" xmlns:ext="http://schemas.microsoft.com/exchange/services/2006/types" xmlns:a="http://www.w3.org/2005/08/addressing" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <soap:Header>
        <a:Action soap:mustUnderstand="1">http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation</a:Action>
        <a:To soap:mustUnderstand="1">https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc</a:To>
        <a:ReplyTo>
            <a:Address>http://www.w3.org/2005/08/addressing/anonymous</a:Address>
        </a:ReplyTo>
    </soap:Header>
    <soap:Body>
        <GetFederationInformationRequestMessage xmlns="http://schemas.microsoft.com/exchange/2010/Autodiscover">
            <Request>
                <Domain>$TenantFilter</Domain>
            </Request>
        </GetFederationInformationRequestMessage>
    </soap:Body>
</soap:Envelope>
"@

            # Create the headers
            $AutoDiscoverHeaders = @{
                'Content-Type' = 'text/xml; charset=utf-8'
                'SOAPAction'   = '"http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation"'
                'User-Agent'   = 'AutodiscoverClient'
            }

            # Invoke autodiscover
            $Response = Invoke-RestMethod -UseBasicParsing -Method Post -Uri 'https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc' -Body $body -Headers $AutoDiscoverHeaders

            # Get the onmicrosoft.com domain from the response
            $TenantDomains = $Response.Envelope.body.GetFederationInformationResponseMessage.response.Domains.Domain | Sort-Object
            $OnMicrosoftDomains = $TenantDomains | Where-Object { $_ -like '*.onmicrosoft.com' }

            if ($OnMicrosoftDomains.Count -eq 0) {
                throw 'Could not find onmicrosoft.com domain through autodiscover'
            } elseif ($OnMicrosoftDomains.Count -gt 1) {
                throw "Multiple onmicrosoft.com domains found through autodiscover. Cannot determine the correct one: $($OnMicrosoftDomains -join ', ')"
            } else {
                $OnMicrosoftDomain = $OnMicrosoftDomains[0]
                $tenantName = $OnMicrosoftDomain.Split('.')[0]
            }
        } catch {
            throw "Failed to get SharePoint admin URL through autodiscover: $($_.Exception.Message)"
        }
    } else {
        $tenantName = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/sites/root' -asApp $true -tenantid $TenantFilter).id.Split('.')[0]
    }

    # Return object with all needed properties
    return [PSCustomObject]@{
        AdminUrl      = "https://$tenantName-admin.sharepoint.com"
        TenantName    = $tenantName
        SharePointUrl = "https://$tenantName.sharepoint.com"
    }
}
#EndRegion './Public/GraphHelper/Get-SharePointAdminLink.ps1' 69
#Region './Public/GraphHelper/Get-Tenants.ps1' -1


function Get-Tenants {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding(DefaultParameterSetName = 'Standard')]
    param (
        [Parameter( ParameterSetName = 'Skip', Mandatory = $True )]
        [switch]$SkipList,
        [Parameter( ParameterSetName = 'Standard')]
        [switch]$IncludeAll,
        [switch]$IncludeErrors,
        [switch]$SkipDomains,
        [switch]$TriggerRefresh,
        [switch]$CleanOld,
        [string]$TenantFilter
    )

    $TenantsTable = Get-CippTable -tablename 'Tenants'
    $ExcludedFilter = "PartitionKey eq 'Tenants' and Excluded eq true"

    $SkipListCache = Get-CIPPAzDataTableEntity @TenantsTable -Filter $ExcludedFilter
    if ($SkipList) {
        return $SkipListCache
    }

    if ($IncludeAll.IsPresent) {
        $Filter = "PartitionKey eq 'Tenants'"
    } elseif ($IncludeErrors.IsPresent) {
        $Filter = "PartitionKey eq 'Tenants' and Excluded eq false"
    } else {
        $Filter = "PartitionKey eq 'Tenants' and Excluded eq false and GraphErrorCount lt 50"
    }

    if ($TenantFilter) {
        #Write-Information "Getting tenant $TenantFilter"
        if ($TenantFilter -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {
            $Filter = "{0} and customerId eq '{1}'" -f $Filter, $TenantFilter
            # create where-object scriptblock
            $IncludedTenantFilter = [scriptblock]::Create("`$_.customerId -eq '$TenantFilter'")
            $RelationshipFilter = " and customer/tenantId eq '$TenantFilter'"
        } else {
            $Filter = "{0} and defaultDomainName eq '{1}' or initialDomainName eq '{1}'" -f $Filter, $TenantFilter
            $IncludedTenantFilter = [scriptblock]::Create("`$_.defaultDomainName -eq '$TenantFilter' -or `$_.initialDomainName -eq '$TenantFilter'")
            $RelationshipFilter = ''
        }
    } else {
        $IncludedTenantFilter = [scriptblock]::Create('$true')
        $RelationshipFilter = ''
    }

    $IncludedTenantsCache = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter

    if (($IncludedTenantsCache | Measure-Object).Count -eq 0 -and $TenantFilter -ne $env:TenantID) {
        $BuildRequired = $true
    }

    if ($CleanOld.IsPresent) {
        try {
            $GDAPRelationships = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships?`$filter=status eq 'active'&`$select=customer,autoExtendDuration,endDateTime" -NoAuthCheck:$true
            # Filter out MLT relationships locally
            $GDAPRelationships = $GDAPRelationships | Where-Object { $_.displayName -notlike 'MLT_*' }
            if (!$GDAPRelationships) {
                Write-LogMessage -API 'Get-Tenants' -message 'Tried cleaning old tenants but failed to get GDAP relationships - No relationships returned' -Sev 'Critical'
                throw 'Failed to get GDAP relationships for cleaning old tenants.'
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Get-Tenants' -message "Tried cleaning old tenants but failed to get GDAP relationships - $($_.Exception.Message)" -Sev 'Critical' -LogData $ErrorMessage
            throw $_
        }
        $GDAPList = foreach ($Relationship in $GDAPRelationships) {
            [PSCustomObject]@{
                customerId      = $Relationship.customer.tenantId
                displayName     = $Relationship.customer.displayName
                autoExtend      = ($Relationship.autoExtendDuration -ne 'PT0S')
                relationshipEnd = $Relationship.endDateTime
            }
        }
        $CurrentTenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter "PartitionKey eq 'Tenants' and Excluded eq false and delegatedPrivilegeStatus ne 'directTenant'"
        $CurrentTenants | Where-Object { $_.customerId -notin $GDAPList.customerId -and $_.customerId -ne $env:TenantID } | ForEach-Object {
            Remove-AzDataTableEntity -Force @TenantsTable -Entity $_
        }
    }
    $PartnerModeTable = Get-CippTable -tablename 'tenantMode'
    $PartnerTenantState = Get-CIPPAzDataTableEntity @PartnerModeTable

    if (($BuildRequired -or $TriggerRefresh.IsPresent) -and $PartnerTenantState.state -ne 'owntenant') {
        # Get TenantProperties table
        $PropertiesTable = Get-CippTable -TableName 'TenantProperties'
        if (!$env:RefreshToken) {
            throw 'RefreshToken not set. Cannot get tenant list.'
        }
        #get the full list of tenants
        $GDAPRelationships = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/tenantRelationships/delegatedAdminRelationships?`$filter=status eq 'active'$RelationshipFilter&`$select=customer,autoExtendDuration,endDateTime" -NoAuthCheck:$true
        # Filter out MLT relationships locally
        $GDAPRelationships = $GDAPRelationships | Where-Object { $_.displayName -notlike 'MLT_*' }
        Write-Host "GDAP relationships found: $($GDAPRelationships.Count)"
        Write-Information "GDAP relationships found: $($GDAPRelationships.Count)"
        $totalTenants = $GDAPRelationships.customer.tenantId | Select-Object -Unique
        Write-Information "Total tenants found in relationships result: $($totalTenants.count)"
        $GDAPList = foreach ($Relationship in $GDAPRelationships) {
            [PSCustomObject]@{
                customerId      = $Relationship.customer.tenantId
                displayName     = $Relationship.customer.displayName
                autoExtend      = ($Relationship.autoExtendDuration -ne 'PT0S')
                relationshipEnd = $Relationship.endDateTime
            }
        }

        $ActiveRelationships = $GDAPList | Where-Object $IncludedTenantFilter | Where-Object { $_.customerId -notin $SkipListCache.customerId }
        $TenantList = $ActiveRelationships | Group-Object -Property customerId | ForEach-Object {

            # Write-Host (ConvertTo-Json -InputObject $_ -Depth 10)
            # Write-Host "Processing $($_.Name), $($_.displayName) to add to tenant list."
            $ExistingTenantInfo = Get-CIPPAzDataTableEntity @TenantsTable -Filter "PartitionKey eq 'Tenants' and RowKey eq '$($_.Name)'"

            $Alias = (Get-AzDataTableEntity @PropertiesTable -Filter "PartitionKey eq '$($_.Name)' and RowKey eq 'Alias'").Value

            if ($Alias) {
                Write-Host "Alias found for $($_.Name) - $Alias."
            }

            if ($TriggerRefresh.IsPresent -and $ExistingTenantInfo.customerId) {
                # Reset error count
                Write-Host "Resetting error count for $($_.Name)"
                $ExistingTenantInfo.GraphErrorCount = 0
                Add-CIPPAzDataTableEntity @TenantsTable -Entity $ExistingTenantInfo -Force | Out-Null
            }

            if ($ExistingTenantInfo -and $ExistingTenantInfo.RequiresRefresh -eq $false -and ($ExistingTenantInfo.displayName -eq $LatestRelationship.displayName -or $ExistingTenantInfo.displayName -eq $Alias)) {
                Write-Host 'Existing tenant found. We already have it cached, skipping.'

                $DisplayNameUpdated = $false
                if (![string]::IsNullOrEmpty($Alias)) {
                    if ($Alias -ne $ExistingTenantInfo.displayName) {
                        Write-Host "Alias found for $($_.Name)."
                        $ExistingTenantInfo.displayName = $Alias
                        $DisplayNameUpdated = $true
                    }
                } else {
                    if ($LatestRelationship.displayName -ne $ExistingTenantInfo.displayName) {
                        Write-Host 'Display name changed from relationship, updating.'
                        $ExistingTenantInfo.displayName = $LatestRelationship.displayName
                        $DisplayNameUpdated = $true
                    }
                }

                if ($DisplayNameUpdated) {
                    $ExistingTenantInfo.displayName = $LatestRelationship.displayName
                    Add-CIPPAzDataTableEntity @TenantsTable -Entity $ExistingTenantInfo -Force | Out-Null
                }

                $ExistingTenantInfo
                return
            }
            $LatestRelationship = $_.Group | Sort-Object -Property relationshipEnd | Select-Object -Last 1
            $AutoExtend = ($_.Group | Where-Object { $_.autoExtend -eq $true } | Measure-Object).Count -gt 0
            if (!$SkipDomains.IsPresent) {
                try {
                    Write-Host "Getting domains for $($_.Name)."
                    $Domains = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/domains?$top=999' -tenantid $LatestRelationship.customerId -NoAuthCheck:$true -ErrorAction Stop
                    $defaultDomainName = ($Domains | Where-Object { $_.isDefault -eq $true }).id
                    $initialDomainName = ($Domains | Where-Object { $_.isInitial -eq $true }).id
                } catch {
                    try {
                        #doing alternative method to temporarily get domains. Nightly refresh will fix this as it will be marked for renew.
                        Write-Host 'Main method failed, trying alternative method.'
                        Write-Host "Domain variable is $Domain"
                        $Domain = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/tenantRelationships/findTenantInformationByTenantId(tenantId='$($LatestRelationship.customerId)')" -NoAuthCheck:$true ).defaultDomainName
                        Write-Host "Alternative method worked, got domain $Domain."
                        $RequiresRefresh = $true
                    } catch {
                        $ErrorMessage = Get-CippException -Exception $_
                        Write-LogMessage -API 'Get-Tenants' -message "Tried adding $($LatestRelationship.customerId) to tenant list but failed to get domains - $($_.Exception.Message)" -Sev 'Critical' -LogData $ErrorMessage
                        $Domain = 'Invalid'
                    } finally {
                        $defaultDomainName = $Domain
                        $initialDomainName = $Domain
                    }
                }
                Write-Host 'finished getting domain'

                if (![string]::IsNullOrEmpty($Alias)) {
                    Write-Information "Setting display name to $Alias."
                    $displayName = $Alias
                } else {
                    $displayName = $LatestRelationship.displayName
                }

                $Obj = [PSCustomObject]@{
                    PartitionKey             = 'Tenants'
                    RowKey                   = $_.Name
                    customerId               = $_.Name
                    displayName              = $displayName
                    relationshipEnd          = $LatestRelationship.relationshipEnd
                    relationshipCount        = $_.Count
                    defaultDomainName        = $defaultDomainName
                    initialDomainName        = $initialDomainName
                    hasAutoExtend            = $AutoExtend
                    delegatedPrivilegeStatus = 'granularDelegatedAdminPrivileges'
                    domains                  = ''
                    Excluded                 = $false
                    ExcludeUser              = ''
                    ExcludeDate              = ''
                    GraphErrorCount          = 0
                    LastGraphError           = ''
                    RequiresRefresh          = [bool]$RequiresRefresh
                    LastRefresh              = (Get-Date).ToUniversalTime()
                }
                if ($Obj.defaultDomainName -eq 'Invalid' -or !$Obj.defaultDomainName) {
                    Write-Host "We're skipping $($Obj.displayName) as it has an invalid default domain name. Something is up with this instance."
                    return
                }
                Write-Host "Adding $($_.Name) to tenant list."
                Add-CIPPAzDataTableEntity @TenantsTable -Entity $Obj -Force | Out-Null

                $Obj
            }
        }
        $IncludedTenantsCache = [system.collections.generic.list[object]]::new()
        if ($PartnerTenantState.state -eq 'PartnerTenantAvailable') {
            # Add partner tenant if env is set
            $Domains = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/domains?$top=999' -tenantid $env:TenantID -NoAuthCheck:$true
            $PartnerTenant = [PSCustomObject]@{
                RowKey            = $env:TenantID
                PartitionKey      = 'Tenants'
                customerId        = $env:TenantID
                defaultDomainName = ($Domains | Where-Object { $_.isDefault -eq $true }).id
                initialDomainName = ($Domains | Where-Object { $_.isInitial -eq $true }).id
                displayName       = '*Partner Tenant'
                domains           = 'PartnerTenant'
                Excluded          = $false
                ExcludeUser       = ''
                ExcludeDate       = ''
                GraphErrorCount   = 0
                LastGraphError    = ''
                RequiresRefresh   = [bool]$RequiresRefresh
                LastRefresh       = (Get-Date).ToUniversalTime()
            }
            $IncludedTenantsCache.Add($PartnerTenant)
            Add-AzDataTableEntity @TenantsTable -Entity $PartnerTenant -Force | Out-Null

        }
        foreach ($Tenant in $TenantList) {
            if ($Tenant.defaultDomainName -eq 'Invalid' -or [string]::IsNullOrWhiteSpace($Tenant.defaultDomainName)) {
                Write-LogMessage -API 'Get-Tenants' -message "We're skipping $($Tenant.displayName) as it has an invalid default domain name. Something is up with this instance." -level 'Critical'
                continue
            }
            $IncludedTenantsCache.Add($Tenant)
        }
    }
    if ($PartnerTenantState.state -eq 'owntenant' -and $IncludedTenantsCache.RowKey.count -eq 0) {
        $Domains = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/domains' -tenantid $env:TenantID -NoAuthCheck:$true

        $IncludedTenantsCache = @([PSCustomObject]@{
                RowKey            = $env:TenantID
                PartitionKey      = 'Tenants'
                customerId        = $env:TenantID
                defaultDomainName = ($Domains | Where-Object { $_.isInitial -eq $true }).id
                initialDomainName = ($Domains | Where-Object { $_.isInitial -eq $true }).id
                displayName       = ($Domains | Where-Object { $_.isInitial -eq $true }).id
                domains           = 'PartnerTenant'
                Excluded          = $false
                ExcludeUser       = ''
                ExcludeDate       = ''
                GraphErrorCount   = 0
                LastGraphError    = ''
                RequiresRefresh   = [bool]$RequiresRefresh
                LastRefresh       = (Get-Date).ToUniversalTime()
            })
        if ($IncludedTenantsCache) {
            Add-CIPPAzDataTableEntity @TenantsTable -Entity $IncludedTenantsCache -Force | Out-Null
        }
    }

    # Limit tenant list to allowed tenants if set in script scope from New-CippCoreRequest
    if ($script:CippAllowedTenantsStorage -and $script:CippAllowedTenantsStorage.Value) {
        $IncludedTenantsCache = $IncludedTenantsCache | Where-Object { $script:CippAllowedTenantsStorage.Value -contains $_.customerId }
    }

    return $IncludedTenantsCache | Where-Object { ($null -ne $_.defaultDomainName -and ($_.defaultDomainName -notmatch 'Domain Error' -or $IncludeAll.IsPresent)) } | Where-Object $IncludedTenantFilter | Sort-Object -Property displayName
}
#EndRegion './Public/GraphHelper/Get-Tenants.ps1' 285
#Region './Public/GraphHelper/New-ClassicAPIGetRequest.ps1' -1


function New-ClassicAPIGetRequest($TenantID, $Uri, $Method = 'GET', $Resource = 'https://admin.microsoft.com', $ContentType = 'application/json') {
    <#
    .FUNCTIONALITY
    Internal
    #>
    if ((Get-AuthorisedRequest -Uri $uri -TenantID $tenantid)) {
        $token = Get-ClassicAPIToken -Tenant $tenantID -Resource $Resource

        $NextURL = $Uri
        $ReturnedData = do {
            try {
                $Data = Invoke-RestMethod -ContentType "$ContentType;charset=UTF-8" -Uri $NextURL -Method $Method -Headers @{
                    Authorization            = "Bearer $($token.access_token)"
                    'x-ms-client-request-id' = [guid]::NewGuid().ToString()
                    'x-ms-client-session-id' = [guid]::NewGuid().ToString()
                    'x-ms-correlation-id'    = [guid]::NewGuid()
                    'X-Requested-With'       = 'XMLHttpRequest'
                }
                $Data
                if ($noPagination -or $null -eq $data.NextLink) { $nextURL = $null } else { $nextURL = $data.NextLink }
            } catch {
                throw "Failed to make Classic Get Request $_"
            }
        } until ($null -eq $NextURL -or ' ' -eq $NextURL)
        return $ReturnedData
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-ClassicAPIGetRequest.ps1' 31
#Region './Public/GraphHelper/New-DeviceLogin.ps1' -1

function New-DeviceLogin {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param (
        [string]$clientid,
        [string]$scope,
        [switch]$FirstLogon,
        [string]$device_code,
        [string]$TenantId
    )
    $encodedscope = [uri]::EscapeDataString($scope)
    if ($FirstLogon) {
        if ($TenantID) {
            $ReturnCode = Invoke-RestMethod -Uri "https://login.microsoftonline.com/$($TenantID)/oauth2/v2.0/devicecode" -Method POST -Body "client_id=$($Clientid)&scope=$encodedscope+offline_access+profile+openid"

        } else {
            $ReturnCode = Invoke-RestMethod -Uri 'https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode' -Method POST -Body "client_id=$($Clientid)&scope=$encodedscope+offline_access+profile+openid"
        }
    } else {
        $Checking = Invoke-RestMethod -SkipHttpErrorCheck -Uri 'https://login.microsoftonline.com/organizations/oauth2/v2.0/token' -Method POST -Body "client_id=$($Clientid)&scope=$encodedscope+offline_access+profile+openid&grant_type=device_code&device_code=$($device_code)"
        if ($checking.refresh_token) {
            $ReturnCode = $Checking
        } else {
            $returncode = $Checking.error
        }
    }
    return $ReturnCode
}
#EndRegion './Public/GraphHelper/New-DeviceLogin.ps1' 32
#Region './Public/GraphHelper/New-ExoBulkRequest.ps1' -1

function New-ExoBulkRequest {
    <#
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        $tenantid,
        $cmdletArray,
        $useSystemMailbox,
        $Anchor,
        $NoAuthCheck,
        $Select,
        $ReturnWithCommand,
        [switch]$Compliance,
        [switch]$AsApp
    )

    if ((Get-AuthorisedRequest -TenantID $tenantid) -or $NoAuthCheck -eq $True) {
        if ($Compliance.IsPresent) {
            $Resource = 'https://ps.compliance.protection.outlook.com'
        } else {
            $Resource = 'https://outlook.office365.com'
        }
        $Token = Get-GraphToken -Tenantid $tenantid -scope "$Resource/.default" -AsApp:$AsApp.IsPresent

        $Tenant = Get-Tenants -IncludeErrors | Where-Object { $_.defaultDomainName -eq $tenantid -or $_.customerId -eq $tenantid }
        $Headers = @{
            Authorization             = $Token.Authorization
            Prefer                    = 'odata.maxpagesize = 1000;odata.continue-on-error'
            'parameter-based-routing' = $true
            'X-AnchorMailbox'         = $Anchor
        }

        if ($Compliance.IsPresent) {
            # Compliance URL logic (omitted for brevity)
        }

        try {
            if ($Select) { $Select = "`$select=$Select" }
            $URL = "$Resource/adminapi/beta/$($Tenant.customerId)/InvokeCommand?$Select"
            $BatchURL = "$Resource/adminapi/beta/$($Tenant.customerId)/`$batch"

            # Initialize the ID to Cmdlet Name mapping
            $IdToCmdletName = @{}
            $IdToOperationGuid = @{}  # Track operation GUIDs when provided

            # Split the cmdletArray into batches of 10
            $batches = [System.Collections.Generic.List[object]]::new()
            for ($i = 0; $i -lt $cmdletArray.Length; $i += 10) {
                $batches.Add($cmdletArray[$i..[math]::Min($i + 9, $cmdletArray.Length - 1)])
            }

            $ReturnedData = [System.Collections.Generic.List[object]]::new()
            foreach ($batch in $batches) {
                $BatchBodyObj = @{
                    requests = @()
                }
                foreach ($cmd in $batch) {
                    $cmdparams = $cmd.CmdletInput.Parameters
                    if ($cmdparams.Identity) { $Anchor = $cmdparams.Identity }
                    if ($cmdparams.anr) { $Anchor = $cmdparams.anr }
                    if ($cmdparams.User) { $Anchor = $cmdparams.User }
                    if (!$Anchor -or $useSystemMailbox) {
                        $OnMicrosoft = $Tenant.initialDomainName
                        $Anchor = "UPN:SystemMailbox{8cc370d3-822a-4ab8-a926-bb94bd0641a9}@$($OnMicrosoft)"
                    }
                    $Headers['X-AnchorMailbox'] = "APP:SystemMailbox{bb558c35-97f1-4cb9-8ff7-d53741dc928c}@$($tenant.customerId)"
                    $Headers['X-CmdletName'] = $cmd.CmdletInput.CmdletName
                    $Headers['Accept'] = 'application/json; odata.metadata=minimal'
                    $Headers['Accept-Encoding'] = 'gzip'

                    # Use provided OperationGuid if available, otherwise generate one
                    $RequestId = if ($cmd.OperationGuid) {
                        $cmd.OperationGuid
                    } else {
                        [Guid]::NewGuid().ToString()
                    }

                    # Create clean cmdlet object for API (without OperationGuid)
                    $CleanCmd = @{
                        CmdletInput = $cmd.CmdletInput
                    }

                    $BatchRequest = @{
                        url     = $URL
                        method  = 'POST'
                        body    = $CleanCmd
                        headers = $Headers.Clone()
                        id      = $RequestId
                    }
                    $BatchBodyObj['requests'] = $BatchBodyObj['requests'] + $BatchRequest

                    # Map the Request ID to the Cmdlet Name and Operation GUID (if provided)
                    $IdToCmdletName[$RequestId] = $cmd.CmdletInput.CmdletName
                    if ($cmd.OperationGuid) {
                        $IdToOperationGuid[$RequestId] = $cmd.OperationGuid
                    }
                }
                $BatchBodyJson = ConvertTo-Json -InputObject $BatchBodyObj -Depth 10
                $BatchBodyJson = Get-CIPPTextReplacement -TenantFilter $tenantid -Text $BatchBodyJson
                $Results = Invoke-RestMethod $BatchURL -ResponseHeadersVariable responseHeaders -Method POST -Body $BatchBodyJson -Headers $Headers -ContentType 'application/json; charset=utf-8'
                foreach ($Response in $Results.responses) {
                    $ReturnedData.Add($Response)
                }

                Write-Host "Batch #$($batches.IndexOf($batch) + 1) of $($batches.Count) processed"
            }
        } catch {
            # Error handling (omitted for brevity)
        }

        #Write-Information ($responseHeaders | ConvertTo-Json -Depth 10)

        # Process the returned data
        if ($ReturnWithCommand) {
            $FinalData = @{}
            foreach ($item in $ReturnedData) {
                $itemId = $item.id
                $CmdletName = $IdToCmdletName[$itemId]
                $OperationGuid = $IdToOperationGuid[$itemId]  # Will be $null if not provided
                $body = $item.body.PSObject.Copy()

                if ($body.'@adminapi.warnings') {
                    Write-Warning ($body.'@adminapi.warnings' | Out-String)
                }
                if (![string]::IsNullOrEmpty($body.error.details.message) -or ![string]::IsNullOrEmpty($body.error.message)) {
                    if ($body.error.details.message) {
                        $msg = [pscustomobject]@{ error = $body.error.details.message; target = $body.error.details.target }
                    } else {
                        $msg = [pscustomobject]@{ error = $body.error.message; target = $body.error.details.target }
                    }

                    # Add OperationGuid to error if it was provided
                    if ($OperationGuid) {
                        $msg | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                    }

                    $body | Add-Member -MemberType NoteProperty -Name 'value' -Value $msg -Force
                } else {
                    # Handle successful operations - add OperationGuid if provided
                    if ($body.value) {
                        # Add GUID to existing results if provided
                        if ($OperationGuid) {
                            if ($body.value -is [array]) {
                                foreach ($val in $body.value) {
                                    $val | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                                }
                            } else {
                                $body.value | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                            }
                        }
                    } else {
                        # Create success indicators when GUID was provided (caller wants tracking)
                        if ($OperationGuid) {
                            $body | Add-Member -MemberType NoteProperty -Name 'value' -Value ([pscustomobject]@{
                                Success = $true
                                OperationGuid = $OperationGuid
                            }) -Force
                        }
                    }
                }

                $resultValues = $body.value
                foreach ($resultValue in $resultValues) {
                    if (-not $FinalData.ContainsKey($CmdletName)) {
                        $FinalData[$CmdletName] = [System.Collections.Generic.List[object]]::new()
                        $FinalData[$CmdletName].Add($resultValue)
                    } else {
                        $FinalData[$CmdletName].Add($resultValue)
                    }
                }
            }
        } else {
            $FinalData = foreach ($item in $ReturnedData) {
                $OperationGuid = $IdToOperationGuid[$item.id]  # Will be $null if not provided
                $body = $item.body.PSObject.Copy()

                if ($body.'@adminapi.warnings') {
                    Write-Warning ($body.'@adminapi.warnings' | Out-String)
                }
                if (![string]::IsNullOrEmpty($body.error.details.message) -or ![string]::IsNullOrEmpty($body.error.message)) {
                    if ($body.error.details.message) {
                        $msg = [pscustomobject]@{ error = $body.error.details.message; target = $body.error.details.target }
                    } else {
                        $msg = [pscustomobject]@{ error = $body.error.message; target = $body.error.details.target }
                    }

                    # Add OperationGuid to error if it was provided
                    if ($OperationGuid) {
                        $msg | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                    }

                    $body | Add-Member -MemberType NoteProperty -Name 'value' -Value $msg -Force
                } else {
                    # Handle successful operations
                    if ($body.value) {
                        # Add GUID to existing results if provided
                        if ($OperationGuid) {
                            if ($body.value -is [array]) {
                                foreach ($val in $body.value) {
                                    $val | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                                }
                            } else {
                                $body.value | Add-Member -MemberType NoteProperty -Name 'OperationGuid' -Value $OperationGuid -Force
                            }
                        }
                    } else {
                        # Create success indicators when GUID was provided (caller wants tracking)
                        if ($OperationGuid) {
                            $body | Add-Member -MemberType NoteProperty -Name 'value' -Value ([pscustomobject]@{
                                Success = $true
                                OperationGuid = $OperationGuid
                            }) -Force
                        }
                    }
                }
                $body.value
            }
        }
        return $FinalData

    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-ExoBulkRequest.ps1' 227
#Region './Public/GraphHelper/New-ExoRequest.ps1' -1

function New-ExoRequest {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding(DefaultParameterSetName = 'ExoRequest')]
    param(
        [Parameter(Mandatory = $true, ParameterSetName = 'ExoRequest')]
        [string]$cmdlet,

        [Parameter(Mandatory = $false, ParameterSetName = 'ExoRequest')]
        $cmdParams,

        [Parameter(Mandatory = $false, ParameterSetName = 'ExoRequest')]
        [string]$Select,

        [Parameter(Mandatory = $false, ParameterSetName = 'ExoRequest')]
        [string]$Anchor,

        [Parameter(Mandatory = $false, ParameterSetName = 'ExoRequest')]
        [bool]$useSystemMailbox,

        [string]$tenantid,

        [bool]$NoAuthCheck,

        [switch]$Compliance,
        [ValidateSet('v1.0', 'beta')]
        [string]$ApiVersion = 'beta',

        [Parameter(ParameterSetName = 'AvailableCmdlets')]
        [switch]$AvailableCmdlets,

        $ModuleVersion = '3.7.1',
        [switch]$AsApp
    )
    if ((Get-AuthorisedRequest -TenantID $tenantid) -or $NoAuthCheck -eq $True) {
        if ($Compliance.IsPresent) {
            $Resource = 'https://ps.compliance.protection.outlook.com'
        } else {
            $Resource = 'https://outlook.office365.com'
        }
        $token = Get-GraphToken -Tenantid $tenantid -scope "$Resource/.default" -AsApp:$AsApp.IsPresent

        if ($cmdParams) {
            #if cmdParams is a pscustomobject, convert to hashtable, otherwise leave as is
            $Params = $cmdParams
        } else {
            $Params = @{}
        }
        $ExoBody = ConvertTo-Json -Depth 5 -Compress -InputObject @{
            CmdletInput = @{
                CmdletName = $cmdlet
                Parameters = $Params
            }
        }
        $ExoBody = Get-CIPPTextReplacement -TenantFilter $tenantid -Text $ExoBody -EscapeForJson

        $Tenant = Get-Tenants -IncludeErrors | Where-Object { $_.defaultDomainName -eq $tenantid -or $_.customerId -eq $tenantid }
        if (-not $Tenant -and $NoAuthCheck -eq $true) {
            $Tenant = [PSCustomObject]@{
                customerId = $tenantid
            }
        }
        if (!$Anchor) {
            $MailboxGuid = 'bb558c35-97f1-4cb9-8ff7-d53741dc928c'
            if ($cmdlet -in 'Set-AdminAuditLogConfig') {
                $MailboxGuid = '8cc370d3-822a-4ab8-a926-bb94bd0641a9'
            }
            if ($Compliance.IsPresent) {
                $Anchor = "UPN:SystemMailbox{$MailboxGuid}@$($tenant.initialDomainName)"
            } else {
                $anchor = "APP:SystemMailbox{$MailboxGuid}@$($tenant.customerId)"
            }
        }
        #if the anchor is a GUID, try looking up the user.
        if ($Anchor -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$') {
            Write-Verbose "Anchor is a GUID, looking up user. GUID is $Anchor"
            $NewAnchor = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$Anchor/?`$select=UserPrincipalName,id" -tenantid $tenantid -NoAuthCheck $NoAuthCheck
            if ($NewAnchor) {
                $Anchor = $NewAnchor.UserPrincipalName
                Write-Verbose "Found GUID, using $Anchor"
            } else {
                Write-Error "Failed to find user with GUID $Anchor"
            }
        }

        Write-Verbose "Using $Anchor"

        $Headers = @{
            Authorization     = $Token.Authorization
            Prefer            = 'odata.maxpagesize=1000'
            'X-AnchorMailbox' = $anchor
        }

        # Compliance API trickery. Capture Location headers on redirect, extract subdomain and prepend to compliance URL
        if ($Compliance.IsPresent) {
            if (!$Tenant.ComplianceUrl) {
                Write-Verbose "Getting Compliance URL for $($tenant.defaultDomainName)"
                $URL = "$Resource/adminapi/$ApiVersion/$($tenant.customerId)/EXOBanner('AutogenSession')?Version=$ModuleVersion"
                Invoke-RestMethod -ResponseHeadersVariable ComplianceHeaders -MaximumRedirection 0 -ErrorAction SilentlyContinue -Uri $URL -Headers $Headers -SkipHttpErrorCheck | Out-Null
                $RedirectedHost = ([System.Uri]($ComplianceHeaders.Location | Select-Object -First 1)).Host
                $RedirectedHostname = '{0}.ps.compliance.protection.outlook.com' -f ($RedirectedHost -split '\.' | Select-Object -First 1)
                $Resource = "https://$($RedirectedHostname)"
                try {
                    $null = [System.Uri]$Resource
                    $Tenant | Add-Member -MemberType NoteProperty -Name ComplianceUrl -Value $Resource
                    $TenantTable = Get-CIPPTable -tablename 'Tenants'
                    Add-CIPPAzDataTableEntity @TenantTable -Entity $Tenant -Force
                } catch {
                    Write-Error "Failed to get the Compliance URL for $($tenant.defaultDomainName), invalid URL - check the Anchor and try again."
                    return
                }
            } else {
                $Resource = $Tenant.ComplianceUrl
            }
            Write-Verbose "Redirecting to $Resource"
        }

        if ($PSCmdlet.ParameterSetName -eq 'AvailableCmdlets') {
            $Headers.CommandName = '*'
            $URL = "$Resource/adminapi/v1.0/$($tenant.customerId)/EXOModuleFile?Version=$ModuleVersion"
            Write-Verbose "GET [ $URL ]"
            return (Invoke-RestMethod -Uri $URL -Headers $Headers).value.exportedCmdlets -split ',' | Where-Object { $_ } | Sort-Object
        }

        if ($PSCmdlet.ParameterSetName -eq 'ExoRequest') {
            try {
                if ($Select) { $Select = "?`$select=$Select" }
                $URL = "$Resource/adminapi/$ApiVersion/$($tenant.customerId)/InvokeCommand$Select"

                Write-Verbose "POST [ $URL ]"
                $ReturnedData = do {
                    $ExoRequestParams = @{
                        Uri         = $URL
                        Method      = 'POST'
                        Body        = $ExoBody
                        Headers     = $Headers
                        ContentType = 'application/json; charset=utf-8'
                    }

                    $Return = Invoke-RestMethod @ExoRequestParams -ResponseHeadersVariable ResponseHeaders
                    $URL = $Return.'@odata.nextLink'
                    $Return
                } until ($null -eq $URL)

                Write-Verbose ($ResponseHeaders | ConvertTo-Json)
                if ($ReturnedData.'@adminapi.warnings' -and $null -eq $ReturnedData.value) {
                    $ReturnedData.value = $ReturnedData.'@adminapi.warnings'
                }
            } catch {
                $ErrorMess = $($_.Exception.Message)
                try {
                    $ReportedError = ($_.ErrorDetails.Message | ConvertFrom-Json -ErrorAction SilentlyContinue)
                    $Message = if ($ReportedError.error.details.message) {
                        $ReportedError.error.details.message
                    } elseif ($ReportedError.error.innererror) {
                        $ReportedError.error.innererror.internalException.message
                    } elseif ($ReportedError.error.message) { $ReportedError.error.message }
                } catch { $Message = $_.ErrorDetails }
                if ($null -eq $Message) { $Message = $ErrorMess }
                throw $Message
            }
            return $ReturnedData.value
        }
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-ExoRequest.ps1' 170
#Region './Public/GraphHelper/New-GraphBulkRequest.ps1' -1

function New-GraphBulkRequest {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param(
        $tenantid,
        $NoAuthCheck,
        $scope,
        $asapp,
        $Requests,
        $NoPaginateIds = @(),
        [ValidateSet('v1.0', 'beta')]
        $Version = 'beta'
    )

    if ($NoAuthCheck -or (Get-AuthorisedRequest -Uri $uri -TenantID $tenantid)) {
        $headers = Get-GraphToken -tenantid $tenantid -scope $scope -AsApp $asapp

        if ($script:XMsThrottlePriority) {
            $headers['x-ms-throttle-priority'] = $script:XMsThrottlePriority
        }

        $URL = "https://graph.microsoft.com/$Version/`$batch"

        # Track consecutive Graph API failures
        $TenantsTable = Get-CippTable -tablename Tenants
        $Filter = "PartitionKey eq 'Tenants' and (defaultDomainName eq '{0}' or customerId eq '{0}')" -f $tenantid
        $Tenant = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
        if (!$Tenant) {
            $Tenant = @{
                GraphErrorCount = 0
                LastGraphError  = ''
                PartitionKey    = 'TenantFailed'
                RowKey          = 'Failed'
            }
        }
        try {
            $ReturnedData = for ($i = 0; $i -lt $Requests.count; $i += 20) {
                $req = @{}
                # Use select to create hashtables of id, method and url for each call
                $req['requests'] = ($Requests[$i..($i + 19)])
                $ReqBody = (ConvertTo-Json -InputObject $req -Compress -Depth 100)
                $Return = Invoke-RestMethod -Uri $URL -Method POST -Headers $headers -ContentType 'application/json; charset=utf-8' -Body $ReqBody
                if ($Return.headers.'retry-after') {
                    #Revist this when we are pushing this data into our custom schema instead.
                    $headers = Get-GraphToken -tenantid $tenantid -scope $scope -AsApp $asapp
                    Invoke-RestMethod -Uri $URL -Method POST -Headers $headers -ContentType 'application/json; charset=utf-8' -Body $ReqBody
                }
                $Return
            }
            foreach ($MoreData in $ReturnedData.Responses | Where-Object { $_.body.'@odata.nextLink' }) {
                if ($NoPaginateIds -contains $MoreData.id) {
                    continue
                }
                Write-Host 'Getting more'
                Write-Host $MoreData.body.'@odata.nextLink'
                $AdditionalValues = New-GraphGetRequest -ComplexFilter -uri $MoreData.body.'@odata.nextLink' -tenantid $tenantid -NoAuthCheck $NoAuthCheck -scope $scope -AsApp $asapp
                $NewValues = [System.Collections.Generic.List[PSCustomObject]]$MoreData.body.value
                $AdditionalValues | ForEach-Object { $NewValues.add($_) }
                $MoreData.body.value = $NewValues
            }

        } catch {
            # Try to parse ErrorDetails.Message as JSON
            if ($_.ErrorDetails.Message) {
                try {
                    $ErrorJson = $_.ErrorDetails.Message | ConvertFrom-Json -ErrorAction Stop
                    $Message = $ErrorJson.error.message
                } catch {
                    $Message = $_.ErrorDetails.Message
                }
            }

            if ([string]::IsNullOrEmpty($Message)) {
                $Message = $_.Exception.Message
            }

            if ($Message -ne 'Request not applicable to target tenant.') {
                $Tenant.LastGraphError = $Message ?? ''
                $Tenant.GraphErrorCount++
                Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant
            }
            throw $Message
        }

        if ($Tenant.PSObject.Properties.Name -notcontains 'LastGraphError') {
            $Tenant | Add-Member -MemberType NoteProperty -Name 'LastGraphError' -Value '' -Force
        } else {
            $Tenant.LastGraphError = ''
        }
        Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant

        return $ReturnedData.responses
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-GraphBulkRequest.ps1' 100
#Region './Public/GraphHelper/New-GraphGetRequest.ps1' -1

function New-GraphGetRequest {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param(
        [string]$uri,
        [string]$tenantid,
        [string]$scope,
        $AsApp,
        [bool]$noPagination,
        $NoAuthCheck = $false,
        [bool]$skipTokenCache,
        $Caller,
        [switch]$ComplexFilter,
        [switch]$CountOnly,
        [switch]$IncludeResponseHeaders,
        [hashtable]$extraHeaders,
        [switch]$ReturnRawResponse
    )

    if ($NoAuthCheck -eq $false) {
        $IsAuthorised = Get-AuthorisedRequest -Uri $uri -TenantID $tenantid
    } else {
        $IsAuthorised = $true
    }

    if ($NoAuthCheck -eq $true -or $IsAuthorised) {
        if ($scope -eq 'ExchangeOnline') {
            $headers = Get-GraphToken -tenantid $tenantid -scope 'https://outlook.office365.com/.default' -AsApp $asapp -SkipCache $skipTokenCache
        } else {
            $headers = Get-GraphToken -tenantid $tenantid -scope $scope -AsApp $asapp -SkipCache $skipTokenCache
        }

        if ($ComplexFilter) {
            $headers['ConsistencyLevel'] = 'eventual'
        }

        if ($script:XMsThrottlePriority) {
            $headers['x-ms-throttle-priority'] = $script:XMsThrottlePriority
        }

        $nextURL = $uri
        if ($extraHeaders) {
            foreach ($key in $extraHeaders.Keys) {
                $headers[$key] = $extraHeaders[$key]
            }
        }
        # Track consecutive Graph API failures
        $TenantsTable = Get-CippTable -tablename Tenants
        $Filter = "PartitionKey eq 'Tenants' and (defaultDomainName eq '{0}' or customerId eq '{0}')" -f $tenantid
        $Tenant = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter
        if (!$Tenant) {
            $Tenant = @{
                GraphErrorCount = 0
                LastGraphError  = ''
                PartitionKey    = 'TenantFailed'
                RowKey          = 'Failed'
            }
        }

        $ReturnedData = do {
            $RetryCount = 0
            $MaxRetries = 3
            $RequestSuccessful = $false
            Write-Information "GET [ $nextURL ] | tenant: $tenantid | attempt: $($RetryCount + 1) of $MaxRetries"
            do {
                try {
                    $GraphRequest = @{
                        Uri         = $nextURL
                        Method      = 'GET'
                        Headers     = $headers
                        ContentType = 'application/json; charset=utf-8'
                    }

                    if ($ReturnRawResponse) {
                        $GraphRequest.SkipHttpErrorCheck = $true
                        $Data = Invoke-WebRequest @GraphRequest
                    } else {
                        $GraphRequest.ResponseHeadersVariable = 'ResponseHeaders'
                        $Data = (Invoke-RestMethod @GraphRequest)
                        $script:LastGraphResponseHeaders = $ResponseHeaders
                    }

                    # If we reach here, the request was successful
                    $RequestSuccessful = $true

                    if ($ReturnRawResponse) {
                        if (Test-Json -Json $Data.Content) {
                            $Content = $Data.Content | ConvertFrom-Json
                        } else {
                            $Content = $Data.Content
                        }

                        $Data | Select-Object -Property StatusCode, StatusDescription, @{Name = 'Content'; Expression = { $Content } }
                        $nextURL = $null
                    } elseif ($CountOnly) {
                        $Data.'@odata.count'
                        $NextURL = $null
                    } else {
                        if ($Data.PSObject.Properties.Name -contains 'value') { $data.value } else { $Data }
                        if ($noPagination -eq $true) {
                            if ($Caller -eq 'Get-GraphRequestList') {
                                @{ 'nextLink' = $data.'@odata.nextLink' }
                            }
                            $nextURL = $null
                        } else {
                            $NextPageUriFound = $false
                            if ($IncludeResponseHeaders) {
                                if ($ResponseHeaders.NextPageUri) {
                                    $NextURL = $ResponseHeaders.NextPageUri
                                    $NextPageUriFound = $true
                                }
                            }
                            if (!$NextPageUriFound) {
                                $nextURL = $data.'@odata.nextLink'
                            }
                        }
                    }
                } catch {
                    $ShouldRetry = $false
                    $WaitTime = 0
                    try {
                        $MessageObj = $_.ErrorDetails.Message | ConvertFrom-Json -ErrorAction SilentlyContinue
                        if ($MessageObj.error) {
                            $MessageObj | Add-Member -NotePropertyName 'url' -NotePropertyValue $nextURL -Force
                            $Message = $MessageObj.error.message -ne '' ? $MessageObj.error.message : $MessageObj.error.code
                        }
                    } catch { $Message = $null }

                    if ([string]::IsNullOrEmpty($Message)) {
                        $Message = $($_.Exception.Message)
                        $MessageObj = @{
                            error = @{
                                code    = $_.Exception.GetType().FullName
                                message = $Message
                                url     = $nextURL
                            }
                        }
                    }

                    # Check for 429 Too Many Requests
                    if ($_.Exception.Response.StatusCode -eq 429) {
                        $RetryAfterHeader = $_.Exception.Response.Headers['Retry-After']
                        if ($RetryAfterHeader) {
                            $WaitTime = [int]$RetryAfterHeader
                            Write-Warning "Rate limited (429). Waiting $WaitTime seconds before retry. Attempt $($RetryCount + 1) of $MaxRetries"
                            $ShouldRetry = $true
                        }
                    }
                    # Check for "Resource temporarily unavailable"
                    elseif ($Message -like '*Resource temporarily unavailable*') {
                        if ($RetryCount -lt $MaxRetries) {
                            $WaitTime = Get-Random -Minimum 1.1 -Maximum 3.1  # Random sleep between 1-2 seconds
                            Write-Warning "Resource temporarily unavailable. Waiting $WaitTime seconds before retry. Attempt $($RetryCount + 1) of $MaxRetries"
                            $ShouldRetry = $true
                        }
                    }

                    if ($ShouldRetry -and $RetryCount -lt $MaxRetries) {
                        $RetryCount++
                        Start-Sleep -Seconds $WaitTime
                    } else {
                        # Final failure - update tenant error tracking and throw
                        if ($Message -ne 'Request not applicable to target tenant.' -and $Tenant) {
                            $Tenant.LastGraphError = [string]($MessageObj | ConvertTo-Json -Compress)
                            if ($Tenant.PSObject.Properties.Name -notcontains 'GraphErrorCount') {
                                $Tenant | Add-Member -MemberType NoteProperty -Name 'GraphErrorCount' -Value 0 -Force
                            }
                            $Tenant.GraphErrorCount++
                            Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant
                        }
                        throw $Message
                    }
                }
            } while (-not $RequestSuccessful -and $RetryCount -le $MaxRetries)
        } until ([string]::IsNullOrEmpty($NextURL) -or $NextURL -is [object[]] -or ' ' -eq $NextURL)
        if ($Tenant.PSObject.Properties.Name -notcontains 'LastGraphError') {
            $Tenant | Add-Member -MemberType NoteProperty -Name 'LastGraphError' -Value '' -Force
        } else {
            $Tenant.LastGraphError = ''
        }
        if ($Tenant.PSObject.Properties.Name -notcontains 'GraphErrorCount') {
            $Tenant | Add-Member -MemberType NoteProperty -Name 'GraphErrorCount' -Value 0 -Force
        } else {
            $Tenant.GraphErrorCount = 0
        }
        Update-AzDataTableEntity -Force @TenantsTable -Entity $Tenant
        return $ReturnedData
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-GraphGetRequest.ps1' 195
#Region './Public/GraphHelper/New-GraphPOSTRequest.ps1' -1


function New-GraphPOSTRequest {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param(
        $uri,
        $tenantid,
        $body,
        $type = 'POST',
        $scope,
        $AsApp,
        $NoAuthCheck,
        $skipTokenCache,
        $AddedHeaders,
        $contentType,
        $IgnoreErrors = $false,
        $returnHeaders = $false,
        $maxRetries = 1
    )

    if ($NoAuthCheck -or (Get-AuthorisedRequest -Uri $uri -TenantID $tenantid)) {
        $headers = Get-GraphToken -tenantid $tenantid -scope $scope -AsApp $asapp -SkipCache $skipTokenCache
        if ($AddedHeaders) {
            foreach ($header in $AddedHeaders.GetEnumerator()) {
                $headers.Add($header.Key, $header.Value)
            }
        }

        if (!$contentType) {
            $contentType = 'application/json; charset=utf-8'
        }

        $body = Get-CIPPTextReplacement -TenantFilter $tenantid -Text $body -EscapeForJson

        $x = 0
        do {
            try {
                Write-Information "$($type.ToUpper()) [ $uri ] | tenant: $tenantid | attempt: $($x + 1) of $maxRetries"
                $success = $false
                $ReturnedData = (Invoke-RestMethod -Uri $($uri) -Method $TYPE -Body $body -Headers $headers -ContentType $contentType -SkipHttpErrorCheck:$IgnoreErrors -ResponseHeadersVariable responseHeaders)
                $success = $true
            } catch {

                $Message = if ($_.ErrorDetails.Message) {
                    Get-NormalizedError -Message $_.ErrorDetails.Message
                } else {
                    $_.Exception.message
                }
                $x++
                Start-Sleep -Seconds (2 * $x)
            }
        } while (($x -lt $maxRetries) -and ($success -eq $false))

        if ($success -eq $false) {
            throw $Message
        }

        if ($returnHeaders) {
            return $responseHeaders
        } else {
            return $ReturnedData
        }
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-GraphPOSTRequest.ps1' 69
#Region './Public/GraphHelper/New-passwordString.ps1' -1

function New-passwordString {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [CmdletBinding()]
    param (
        [int]$count = 12
    )
    $SettingsTable = Get-CippTable -tablename 'Settings'
    $PasswordType = (Get-CIPPAzDataTableEntity @SettingsTable).passwordType
    if ($PasswordType -eq 'Correct-Battery-Horse') {
        $Words = Get-Content .\words.txt
        (Get-Random -InputObject $words -Count 4) -join '-'
    } else {
        # Generate a complex password with a maximum of 100 tries
        $maxTries = 100
        $tryCount = 0

        do {
            $Password = -join ('abcdefghkmnrstuvwxyzABCDEFGHKLMNPRSTUVWXYZ23456789$%&*#'.ToCharArray() | Get-Random -Count $count)

            $containsUppercase = $Password -cmatch '[A-Z]'
            $containsLowercase = $Password -cmatch '[a-z]'
            $containsDigit = $Password -cmatch '\d'
            $containsSpecialChar = $Password -cmatch '[$%&*#]'

            $isComplex = $containsUppercase -and $containsLowercase -and $containsDigit -and $containsSpecialChar

            $tryCount++
        } while (!$isComplex -and ($tryCount -lt $maxTries))

        $Password
    }
}
#EndRegion './Public/GraphHelper/New-passwordString.ps1' 36
#Region './Public/GraphHelper/New-TeamsAPIGetRequest.ps1' -1

function New-TeamsAPIGetRequest($Uri, $tenantID, $Method = 'GET', $Resource = '48ac35b8-9aa8-4d74-927d-1f4a14a0b239', $ContentType = 'application/json') {
    <#
    .FUNCTIONALITY
    Internal
    #>

    if ((Get-AuthorisedRequest -Uri $uri -TenantID $tenantid)) {
        $token = Get-GraphToken -TenantID $tenantID -Scope "$Resource/.default"
        $NextURL = $Uri
        $ReturnedData = do {
            $handler = $null
            $httpClient = $null
            $response = $null
            try {
                # Create handler and client with compression disabled
                $handler = New-Object System.Net.Http.HttpClientHandler
                $handler.AutomaticDecompression = [System.Net.DecompressionMethods]::None
                $httpClient = New-Object System.Net.Http.HttpClient($handler)

                # Add all required headers
                $headers = @{
                    'Authorization'          = $token.Authorization
                    'x-ms-client-request-id' = [guid]::NewGuid().ToString()
                    'x-ms-client-session-id' = [guid]::NewGuid().ToString()
                    'x-ms-correlation-id'    = [guid]::NewGuid().ToString()
                    'X-Requested-With'       = 'XMLHttpRequest'
                    'x-ms-tnm-applicationid' = '045268c0-445e-4ac1-9157-d58f67b167d9'
                    'Accept'                 = 'application/json'
                    'Accept-Encoding'        = 'identity'
                    'User-Agent'             = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36'
                }

                foreach ($header in $headers.GetEnumerator()) {
                    $httpClient.DefaultRequestHeaders.Add($header.Key, $header.Value)
                }

                $response = $httpClient.GetAsync($NextURL).Result
                $contentString = $response.Content.ReadAsStringAsync().Result

                # Parse JSON and return data
                $Data = $contentString | ConvertFrom-Json

                $Data
                if ($noPagination) { $nextURL = $null } else { $nextURL = $data.NextLink }
            } catch {
                throw "Failed to make Teams API Get Request $_"
            } finally {
                # Proper cleanup in finally block to ensure disposal even on exceptions
                if ($response) { $response.Dispose() }
                if ($httpClient) { $httpClient.Dispose() }
                if ($handler) { $handler.Dispose() }
            }
        } until ($null -eq $NextURL)
        return $ReturnedData
    } else {
        Write-Error 'Not allowed. You cannot manage your own tenant or tenants not under your scope'
    }
}
#EndRegion './Public/GraphHelper/New-TeamsAPIGetRequest.ps1' 59
#Region './Public/GraphHelper/New-TeamsRequest.ps1' -1

function New-TeamsRequest {
    [CmdletBinding()]
    Param(
        $TenantFilter,
        $Cmdlet,
        $CmdParams = @{},
        [switch]$AvailableCmdlets
    )

    if ($AvailableCmdlets) {
        Get-Command -Module MicrosoftTeams | Select-Object Name
        return
    }
    if (Get-Command -Module MicrosoftTeams -Name $Cmdlet) {
        $TeamsToken = (Get-GraphToken -tenantid $TenantFilter -scope '48ac35b8-9aa8-4d74-927d-1f4a14a0b239/.default').Authorization -replace 'Bearer '
        $GraphToken = (Get-GraphToken -tenantid $TenantFilter).Authorization -replace 'Bearer '

        $null = Connect-MicrosoftTeams -AccessTokens @($TeamsToken, $GraphToken)
        & $Cmdlet @CmdParams
    } else {
        Write-Error "Cmdlet $Cmdlet not found in MicrosoftTeams module"
    }
}
#EndRegion './Public/GraphHelper/New-TeamsRequest.ps1' 24
#Region './Public/GraphHelper/Read-JwtAccessDetails.ps1' -1

function Read-JwtAccessDetails {
    <#
    .FUNCTIONALITY
    Internal
    #>
    [cmdletbinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Token
    )

    # Default token object
    $TokenDetails = [PSCustomObject]@{
        AppId             = ''
        AppName           = ''
        Audience          = ''
        AuthMethods       = ''
        IPAddress         = ''
        Name              = ''
        Scope             = ''
        Roles             = ''
        TenantId          = ''
        UserPrincipalName = ''
    }

    if (!$Token.Contains('.') -or !$token.StartsWith('eyJ')) { return $TokenDetails }

    # Get token payload
    $tokenPayload = $token.Split('.')[1].Replace('-', '+').Replace('_', '/')
    while ($tokenPayload.Length % 4) {
        $tokenPayload = '{0}=' -f $tokenPayload
    }

    # Convert base64 to json to object
    $tokenByteArray = [System.Convert]::FromBase64String($tokenPayload)
    $tokenArray = [System.Text.Encoding]::UTF8.GetString($tokenByteArray)
    $TokenObj = $tokenArray | ConvertFrom-Json

    # Convert token details to human readable
    $TokenDetails.AppId = $TokenObj.appid
    $TokenDetails.AppName = $TokenObj.app_displayname
    $TokenDetails.Audience = $TokenObj.aud
    $TokenDetails.AuthMethods = $TokenObj.amr
    $TokenDetails.IPAddress = $TokenObj.ipaddr
    $TokenDetails.Name = $TokenObj.name
    $TokenDetails.Scope = $TokenObj.scp -split ' '
    $TokenDetails.Roles = $TokenObj.roles
    $TokenDetails.TenantId = $TokenObj.tid
    $TokenDetails.UserPrincipalName = $TokenObj.upn

    return $TokenDetails
}
#EndRegion './Public/GraphHelper/Read-JwtAccessDetails.ps1' 53
#Region './Public/GraphHelper/Remove-CIPPCache.ps1' -1

function Remove-CIPPCache {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param (
        $TenantsOnly
    )
    # Remove all tenants except excluded
    $TenantsTable = Get-CippTable -tablename 'Tenants'
    $Filter = "PartitionKey eq 'Tenants' and Excluded eq false and delegatedPrivilegeStatus eq 'granularDelegatedAdminPrivileges'"
    $ClearIncludedTenants = Get-CIPPAzDataTableEntity @TenantsTable -Filter $Filter -Property PartitionKey, RowKey
    if ($ClearIncludedTenants) {
        Remove-AzDataTableEntity -Force @TenantsTable -Entity $ClearIncludedTenants
    }
    "Removed $($ClearIncludedTenants.Count) tenants"

    if ($TenantsOnly -eq $false) {
        'Clearing all cached table data'
        $Context = New-AzDataTableContext -ConnectionString $env:AzureWebJobsStorage
        $Tables = Get-AzDataTable -Context $Context
        foreach ($Table in $Tables) {
            if ($Table -match '^cache') {
                "Removing cache table $Table"
                $TableContext = Get-CIPPTable -TableName $Table
                Remove-AzDataTable @TableContext
            }
        }

        'Clearing domain analyser results'
        # Remove Domain Analyser cached results
        $DomainsTable = Get-CippTable -tablename 'Domains'
        $Filter = "PartitionKey eq 'TenantDomains'"
        $ClearDomainAnalyserRows = Get-CIPPAzDataTableEntity @DomainsTable -Filter $Filter | ForEach-Object {
            $_ | Add-Member -MemberType NoteProperty -Name DomainAnalyser -Value '' -Force
            $_
        }
        if ($ClearDomainAnalyserRows) {
            Update-AzDataTableEntity -Force @DomainsTable -Entity $ClearDomainAnalyserRows
        }

        $env:SetFromProfile = $null
        $Script:SkipListCache = $Null
        $Script:SkipListCacheEmpty = $Null
        $Script:IncludedTenantsCache = $Null
    }
    'Cache cleanup complete'
}
#EndRegion './Public/GraphHelper/Remove-CIPPCache.ps1' 49
#Region './Public/GraphHelper/Write-AlertMessage.ps1' -1

function Write-AlertMessage($message, $tenant = 'None', $tenantId = $null, $LogData = @{}) {
    <#
    .FUNCTIONALITY
    Internal
    #>
    #Do duplicate detection, if no duplicate, write.
    $Table = Get-CIPPTable -tablename CippLogs
    $PartitionKey = Get-Date -UFormat '%Y%m%d'
    $Filter = "PartitionKey eq '{0}' and Message eq '{1}' and Tenant eq '{2}'" -f $PartitionKey, $message.Replace("'", "''"), $tenant
    $ExistingMessage = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    if (!$ExistingMessage) {
        Write-Host 'No duplicate message found, writing to log'
        Write-LogMessage -message $message -tenant $tenant -sev 'Alert' -tenantId $tenantId -API 'Alerts' -LogData $LogData
    } else {
        Write-Host 'Alerts: Duplicate entry found, not writing to log'

    }
}
#EndRegion './Public/GraphHelper/Write-AlertMessage.ps1' 19
#Region './Public/GraphHelper/Write-AlertTrace.ps1' -1

function Write-AlertTrace {
    <#
    .FUNCTIONALITY
    Internal function. Pleases most of Write-AlertTrace for alerting purposes
    #>
    param(
        $cmdletName,
        $data,
        $tenantFilter,
        [string]$PartitionKey = (Get-Date -UFormat '%Y%m%d').ToString(),
        [string]$AlertComment = $null
    )
    $Table = Get-CIPPTable -tablename AlertLastRun
    #Get current row and compare the $logData object. If it's the same, don't write it.
    $Row = Get-CIPPAzDataTableEntity @table -Filter "RowKey eq '$($tenantFilter)-$($cmdletName)' and PartitionKey eq '$PartitionKey'"
    try {
        $RowData = $Row.LogData
        $Compare = Compare-Object $RowData (ConvertTo-Json -InputObject $data -Compress -Depth 10 | Out-String)
        if ($Compare) {
            $LogData = ConvertTo-Json -InputObject $data -Compress -Depth 10 | Out-String
            $TableRow = @{
                'PartitionKey' = $PartitionKey
                'RowKey'       = "$($tenantFilter)-$($cmdletName)"
                'CmdletName'   = "$cmdletName"
                'Tenant'       = "$tenantFilter"
                'LogData'      = [string]$LogData
                'AlertComment' = [string]$AlertComment
            }
            $Table.Entity = $TableRow
            Add-CIPPAzDataTableEntity @Table -Force | Out-Null
            return $data
        }
    } catch {
        $LogData = ConvertTo-Json -InputObject $data -Compress -Depth 10 | Out-String
        $TableRow = @{
            'PartitionKey' = $PartitionKey
            'RowKey'       = "$($tenantFilter)-$($cmdletName)"
            'CmdletName'   = "$cmdletName"
            'Tenant'       = "$tenantFilter"
            'LogData'      = [string]$LogData
            'AlertComment' = [string]$AlertComment
        }
        $Table.Entity = $TableRow
        Add-CIPPAzDataTableEntity @Table -Force | Out-Null
        return $data
    }

}
#EndRegion './Public/GraphHelper/Write-AlertTrace.ps1' 49
#Region './Public/GraphHelper/Write-CippFunctionStats.ps1' -1

function Write-CippFunctionStats {
    <#
    .FUNCTIONALITY
    Internal
    #>
    Param(
        [string]$FunctionType,
        $Entity,
        [datetime]$Start,
        [datetime]$End,
        [string]$ErrorMsg = ''
    )
    try {
        $Table = Get-CIPPTable -tablename CippFunctionStats
        $RowKey = [string](New-Guid).Guid
        $TimeSpan = New-TimeSpan -Start $Start -End $End
        $Duration = [int]$TimeSpan.TotalSeconds
        $DurationMS = [int]$TimeSpan.TotalMilliseconds

        $StatEntity = @{}
        # Flatten data to json string
        $StatEntity.PartitionKey = $FunctionType
        $StatEntity.RowKey = $RowKey
        $StatEntity.Start = $Start.ToUniversalTime()
        $StatEntity.End = $End.ToUniversalTime()
        $StatEntity.Duration = $Duration
        $StatEntity.DurationMS = $DurationMS
        $StatEntity.ErrorMsg = $ErrorMsg
        $Entity = [PSCustomObject]$Entity
        $DesiredProperties = @('FunctionName', 'Command', 'DurableName')

        foreach ($Property in $Entity.PSObject.Properties.Name) {
            if ($Entity.$Property) {
                if ($Property -in $DesiredProperties) {
                    $StatEntity.$Property = $Entity.$Property
                }
            }
        }
        $StatEntity = [PSCustomObject]$StatEntity

        Add-CIPPAzDataTableEntity @Table -Entity $StatEntity -Force
    } catch {
        Write-Host "Exception logging stats $($_.Exception.Message)"
    }
}
#EndRegion './Public/GraphHelper/Write-CippFunctionStats.ps1' 46
#Region './Public/GraphHelper/Write-LogMessage.ps1' -1

function Write-LogMessage {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param(
        $message,
        $tenant = 'None',
        $API = 'None',
        $tenantId = $null,
        $headers,
        $user,
        $sev,
        $LogData = ''
    )
    if ($Headers.'x-ms-client-principal-idp' -eq 'azureStaticWebApps' -or !$Headers.'x-ms-client-principal-idp') {
        $user = $headers.'x-ms-client-principal'
        $username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails
    } elseif ($Headers.'x-ms-client-principal-idp' -eq 'aad') {
        $Table = Get-CIPPTable -TableName 'ApiClients'
        $Client = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($headers.'x-ms-client-principal-name')'"
        $username = $Client.AppName ?? 'CIPP-API'
        $AppId = $headers.'x-ms-client-principal-name'
    } else {
        try {
            $username = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($user)) | ConvertFrom-Json).userDetails
        } catch {
            $username = $user
        }
    }

    if ($headers.'x-forwarded-for') {
        $ForwardedFor = $headers.'x-forwarded-for' -split ',' | Select-Object -First 1
        $IPRegex = '^(?<IP>(?:\d{1,3}(?:\.\d{1,3}){3}|\[[0-9a-fA-F:]+\]|[0-9a-fA-F:]+))(?::\d+)?$'
        $IPAddress = $ForwardedFor -replace $IPRegex, '$1' -replace '[\[\]]', ''
    }

    if ($LogData) { $LogData = ConvertTo-Json -InputObject $LogData -Depth 10 -Compress }

    $Table = Get-CIPPTable -tablename CippLogs

    if (!$tenant) { $tenant = 'None' }
    if (!$username) { $username = 'CIPP' }
    if ($sev -eq 'Debug' -and $env:DebugMode -ne $true) {
        return
    }
    $PartitionKey = (Get-Date -UFormat '%Y%m%d').ToString()
    $TableRow = @{
        'Tenant'       = [string]$tenant
        'API'          = [string]$API
        'Message'      = [string]$message
        'Username'     = [string]$username
        'Severity'     = [string]$sev
        'sentAsAlert'  = $false
        'PartitionKey' = [string]$PartitionKey
        'RowKey'       = [string]([guid]::NewGuid()).ToString()
        'FunctionNode' = [string]$env:WEBSITE_SITE_NAME
        'LogData'      = [string]$LogData
    }
    if ($IPAddress) {
        $TableRow.IP = [string]$IPAddress
    }
    if ($AppId) {
        $TableRow.AppId = [string]$AppId
    }
    if ($tenantId) {
        $TableRow.Add('TenantID', [string]$tenantId)
    }
    if ($script:CippStandardInfoStorage -and $script:CippStandardInfoStorage.Value) {
        $TableRow.Standard = [string]$script:CippStandardInfoStorage.Value.Standard
        $TableRow.StandardTemplateId = [string]$script:CippStandardInfoStorage.Value.StandardTemplateId
        if ($script:CippStandardInfoStorage.Value.IntuneTemplateId) {
            $TableRow.IntuneTemplateId = [string]$script:CippStandardInfoStorage.Value.IntuneTemplateId
        }
        if ($script:CippStandardInfoStorage.Value.ConditionalAccessTemplateId) {
            $TableRow.ConditionalAccessTemplateId = [string]$script:CippStandardInfoStorage.Value.ConditionalAccessTemplateId
        }
    }
    if ($script:CippScheduledTaskIdStorage -and $script:CippScheduledTaskIdStorage.Value) {
        $TableRow.ScheduledTaskId = [string]$script:CippScheduledTaskIdStorage.Value
    }

    $Table.Entity = $TableRow
    Add-CIPPAzDataTableEntity @Table | Out-Null
}
#EndRegion './Public/GraphHelper/Write-LogMessage.ps1' 86
#Region './Public/GraphHelper/Write-StandardsAlert.ps1' -1

function Write-StandardsAlert {
    <#
    .FUNCTIONALITY
    Internal
    #>
    Param(
        $object,
        $tenant = 'None',
        $standardName = 'None',
        $standardId = $null,
        $message
    )
    $Table = Get-CIPPTable -tablename CippStandardsAlerts
    $JSONobject = $object | ConvertTo-Json -Depth 10 -Compress
    $PartitionKey = (Get-Date -UFormat '%Y%m%d').ToString()
    $TableRow = @{
        'tenant'       = [string]$tenant
        'standardName' = [string]$standardName
        'object'       = [string]$JSONobject
        'message'      = [string]$message
        'standardId'   = [string]$standardId
        'sentAsAlert'  = $false
        'PartitionKey' = [string]$PartitionKey
        'RowKey'       = [string]([guid]::NewGuid()).ToString()
    }
    $Table.Entity = $TableRow
    Add-CIPPAzDataTableEntity @Table -Force | Out-Null
}
#EndRegion './Public/GraphHelper/Write-StandardsAlert.ps1' 29
#Region './Public/GraphRequests/Get-GraphRequestList.ps1' -1

function Get-GraphRequestList {
    <#
    .SYNOPSIS
    Execute a Graph query

    .PARAMETER TenantFilter
    Tenant to query (or AllTenants)

    .PARAMETER Endpoint
    Graph API endpoint

    .PARAMETER Parameters
    API Parameters

    .PARAMETER QueueId
    Queue Id

    .PARAMETER CippLink
    Reference link for queueing

    .PARAMETER Version
    API Version - v1.0 or beta

    .PARAMETER QueueNameOverride
    Queue name to set

    .PARAMETER SkipCache
    Skip Caching

    .PARAMETER ClearCache
    Clear cached results

    .PARAMETER NoPagination
    Disable pagination

    .PARAMETER ManualPagination
    Enable manual pagination using nextLink

    .PARAMETER CountOnly
    Only return count of results

    .PARAMETER NoAuthCheck
    Skip auth check

    .PARAMETER ReverseTenantLookup
    Perform reverse tenant lookup

    .PARAMETER ReverseTenantLookupProperty
    Property to perform reverse tenant lookup

    .PARAMETER AsApp
    Run the request as an application

    .PARAMETER Caller
    Name of the calling function

    .PARAMETER UseBatchExpand
    Perform a batch lookup using the $expand query parameter to avoid 20 item max

    #>
    [CmdletBinding()]
    param(
        [string]$TenantFilter = $env:TenantID,
        [Parameter(Mandatory = $true)]
        [string]$Endpoint,
        [string]$nextLink,
        [hashtable]$Parameters = @{},
        [string]$QueueId,
        [string]$CippLink,
        [ValidateSet('v1.0', 'beta')]
        [string]$Version = 'beta',
        [string]$QueueNameOverride,
        [switch]$SkipCache,
        [switch]$ClearCache,
        [switch]$NoPagination,
        [switch]$ManualPagination,
        [switch]$CountOnly,
        [switch]$NoAuthCheck,
        [switch]$ReverseTenantLookup,
        [string]$ReverseTenantLookupProperty = 'tenantId',
        [boolean]$AsApp = $false,
        [string]$Caller = 'Get-GraphRequestList',
        [switch]$UseBatchExpand
    )

    $SingleTenantThreshold = 8000
    Write-Information "Tenant: $TenantFilter"
    $TableName = ('cache{0}' -f ($Endpoint -replace '[^A-Za-z0-9]'))[0..62] -join ''
    $Endpoint = $Endpoint -replace '^/', ''
    $DisplayName = ($Endpoint -split '/')[0]

    if ($QueueNameOverride) {
        $QueueName = $QueueNameOverride
    } else {
        $TextInfo = (Get-Culture).TextInfo
        $QueueName = $TextInfo.ToTitleCase($DisplayName -csplit '(?=[A-Z])' -ne '' -join ' ')
    }

    $GraphQuery = [System.UriBuilder]('https://graph.microsoft.com/{0}/{1}' -f $Version, $Endpoint)
    $ParamCollection = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
    foreach ($Item in ($Parameters.GetEnumerator() | Sort-Object -CaseSensitive -Property Key)) {
        if ($Item.Value -is [System.Boolean]) {
            $Item.Value = $Item.Value.ToString().ToLower()
        }
        if ($Item.Value) {
            if ($Item.Key -eq '$select' -or $Item.Key -eq 'select') {
                $Columns = $Item.Value -split ','
                $ActualCols = foreach ($Col in $Columns) {
                    $Col -split '\.' | Select-Object -First 1
                }
                $Value = ($ActualCols | Sort-Object -Unique) -join ','
            } else {
                $Value = $Item.Value
            }

            if ($UseBatchExpand.IsPresent -and ($Item.Key -eq '$expand' -or $Item.Key -eq 'expand')) {
                $BatchExpandQuery = $Item.Value
            } else {
                $ParamCollection.Add($Item.Key, $Value)
            }
        }
    }
    $GraphQuery.Query = $ParamCollection.ToString()
    $PartitionKey = Get-StringHash -String (@($Endpoint, $ParamCollection.ToString(), 'v2') -join '-')

    # Perform $count check before caching
    $Count = 0
    if ($TenantFilter -ne 'AllTenants') {
        $GraphRequest = @{
            uri           = $GraphQuery.ToString()
            tenantid      = $TenantFilter
            ComplexFilter = $true
        }
        if ($NoPagination.IsPresent -or $ManualPagination.IsPresent) {
            $GraphRequest.noPagination = $true
        }
        if ($CountOnly.IsPresent) {
            $GraphRequest.CountOnly = $CountOnly.IsPresent
        }
        if ($NoAuthCheck.IsPresent) {
            $GraphRequest.noauthcheck = $NoAuthCheck.IsPresent
        }
        if ($AsApp) {
            $GraphRequest.asApp = $AsApp
        }

        if ($Endpoint -match '%' -or $Parameters.Values -match '%') {
            $TenantId = (Get-Tenants -IncludeErrors | Where-Object { $_.defaultDomainName -eq $TenantFilter -or $_.customerId -eq $TenantFilter }).customerId
            $Endpoint = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $Endpoint
            $GraphQuery = [System.UriBuilder]('https://graph.microsoft.com/{0}/{1}' -f $Version, $Endpoint)
            $ParamCollection = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
            foreach ($Item in ($Parameters.GetEnumerator() | Sort-Object -CaseSensitive -Property Key)) {
                if ($Item.Key -eq '$select' -or $Item.Key -eq 'select') {
                    $Columns = $Item.Value -split ','
                    $ActualCols = foreach ($Col in $Columns) {
                        $Col -split '\.' | Select-Object -First 1
                    }
                    $Value = ($ActualCols | Sort-Object -Unique) -join ','
                } else {
                    $Value = $Item.Value
                }
                $Value = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $Value
                $ParamCollection.Add($Item.Key, $Value)
            }
            $GraphQuery.Query = $ParamCollection.ToString()
            $GraphRequest.uri = $GraphQuery.ToString()
        }

        if ($Parameters.'$count' -and !$SkipCache.IsPresent -and !$NoPagination.IsPresent) {
            $Count = New-GraphGetRequest @GraphRequest -CountOnly -ErrorAction Stop
            if ($CountOnly.IsPresent) { return $Count }
            Write-Information "Total results (`$count): $Count"
        }
    }
    #Write-Information ( 'GET [ {0} ]' -f $GraphQuery.ToString())

    try {
        if ($QueueId) {
            $Table = Get-CIPPTable -TableName $TableName
            $Filter = "QueueId eq '{0}'" -f $QueueId
            $Rows = Get-CIPPAzDataTableEntity @Table -Filter $Filter
            $Type = 'Queue'
            Write-Information "Cached: $(($Rows | Measure-Object).Count) rows (Type: $($Type))"
            $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
            $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -ne 'Completed' -and $_.Status -ne 'Failed' }
        } elseif (!$SkipCache.IsPresent -and !$ClearCache.IsPresent -and !$CountOnly.IsPresent) {
            if ($TenantFilter -eq 'AllTenants' -or $Count -gt $SingleTenantThreshold) {
                $Table = Get-CIPPTable -TableName $TableName
                $Timestamp = (Get-Date).AddHours(-1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK')
                if ($TenantFilter -eq 'AllTenants') {
                    $Filter = "PartitionKey eq '{0}' and Timestamp ge datetime'{1}'" -f $PartitionKey, $Timestamp
                } else {
                    $Filter = "PartitionKey eq '{0}' and (RowKey eq '{1}' or OriginalEntityId eq '{1}') and Timestamp ge datetime'{2}'" -f $PartitionKey, $TenantFilter, $Timestamp
                }
                $Tenants = Get-Tenants -IncludeErrors
                $Rows = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object { $_.OriginalEntityId -in $Tenants.defaultDomainName -or $_.RowKey -in $Tenants.defaultDomainName }
                $Type = 'Cache'
                Write-Information "Table: $TableName | PK: $PartitionKey | Cached: $(($Rows | Measure-Object).Count) rows (Type: $($Type))"
                $QueueReference = '{0}-{1}' -f $TenantFilter, $PartitionKey
                $RunningQueue = Invoke-ListCippQueue -Reference $QueueReference | Where-Object { $_.Status -notmatch 'Completed' -and $_.Status -notmatch 'Failed' }
            }
        }
    } catch {
        Write-Information $_.InvocationInfo.PositionMessage
    }

    if (!$Rows) {
        switch ($TenantFilter) {
            'AllTenants' {
                if ($SkipCache) {
                    Get-Tenants -IncludeErrors | ForEach-Object -Parallel {
                        Import-Module AzBobbyTables
                        Import-Module CIPPCore

                        $GraphRequestParams = @{
                            TenantFilter                = $_.defaultDomainName
                            Endpoint                    = $using:Endpoint
                            Parameters                  = $using:Parameters
                            NoPagination                = $false
                            ReverseTenantLookupProperty = $using:ReverseTenantLookupProperty
                            ReverseTenantLookup         = $using:ReverseTenantLookup.IsPresent
                            NoAuthCheck                 = $using:NoAuthCheck.IsPresent
                            AsApp                       = $using:AsApp
                            SkipCache                   = $true
                        }

                        try {
                            $DefaultDomainName = $_.defaultDomainName
                            Write-Host "Default domain name is $DefaultDomainName"
                            Get-GraphRequestList @GraphRequestParams | Select-Object *, @{l = 'Tenant'; e = { $_.defaultDomainName } }, @{l = 'CippStatus'; e = { 'Good' } }
                        } catch {
                            [PSCustomObject]@{
                                Tenant     = $DefaultDomainName
                                CippStatus = "Could not connect to tenant. $($_.Exception.message)"
                            }
                        }
                    }
                } else {
                    if ($RunningQueue) {
                        Write-Information 'Queue currently running'
                        Write-Information ($RunningQueue | ConvertTo-Json)
                        [PSCustomObject]@{
                            QueueMessage = 'Data still processing, please wait'
                            QueueId      = $RunningQueue.RowKey
                            Queued       = $true
                        }
                    } else {
                        $TenantList = Get-Tenants -IncludeErrors
                        $Queue = New-CippQueueEntry -Name "$QueueName (All Tenants)" -Link $CippLink -Reference $QueueReference -TotalTasks ($TenantList | Measure-Object).Count
                        [PSCustomObject]@{
                            QueueMessage = 'Loading data for all tenants. Please check back after the job completes'
                            Queued       = $true
                            QueueId      = $Queue.RowKey
                        }
                        Write-Information 'Pushing output bindings'
                        try {
                            $Batch = $TenantList | ForEach-Object {
                                $TenantFilter = $_.defaultDomainName
                                [PSCustomObject]@{
                                    FunctionName                = 'ListGraphRequestQueue'
                                    TenantFilter                = $TenantFilter
                                    Endpoint                    = $Endpoint
                                    QueueId                     = $Queue.RowKey
                                    QueueName                   = $TenantFilter
                                    QueueType                   = 'AllTenants'
                                    Parameters                  = $Parameters
                                    PartitionKey                = $PartitionKey
                                    NoPagination                = $NoPagination.IsPresent
                                    NoAuthCheck                 = $NoAuthCheck.IsPresent
                                    AsApp                       = $AsApp
                                    ReverseTenantLookupProperty = $ReverseTenantLookupProperty
                                    ReverseTenantLookup         = $ReverseTenantLookup.IsPresent
                                }

                            }

                            $InputObject = @{
                                OrchestratorName = 'GraphRequestOrchestrator'
                                Batch            = @($Batch)
                            }
                            #Write-Information  ($InputObject | ConvertTo-Json -Depth 5)
                            $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)
                        } catch {
                            Write-Information "QUEUE ERROR: $($_.Exception.Message)"
                        }
                    }
                }
            }
            default {
                try {
                    $QueueThresholdExceeded = $false

                    if ($Parameters.'$count' -and !$SkipCache -and !$NoPagination.IsPresent -and !$ManualPagination.IsPresent) {
                        if ($Count -gt $singleTenantThreshold) {
                            $QueueThresholdExceeded = $true
                            if ($RunningQueue) {
                                Write-Information 'Queue currently running'
                                Write-Information ($RunningQueue | ConvertTo-Json)
                                [PSCustomObject]@{
                                    QueueMessage = 'Data still processing, please wait'
                                    QueueId      = $RunningQueue.RowKey
                                    Queued       = $true
                                }
                            } else {
                                $Queue = New-CippQueueEntry -Name $QueueName -Link $CippLink -Reference $QueueReference -TotalTasks 1
                                $QueueTenant = [PSCustomObject]@{
                                    FunctionName                = 'ListGraphRequestQueue'
                                    TenantFilter                = $TenantFilter
                                    Endpoint                    = $Endpoint
                                    QueueId                     = $Queue.RowKey
                                    QueueName                   = $TenantFilter
                                    QueueType                   = 'SingleTenant'
                                    Parameters                  = $Parameters
                                    PartitionKey                = $PartitionKey
                                    NoAuthCheck                 = $NoAuthCheck.IsPresent
                                    ReverseTenantLookupProperty = $ReverseTenantLookupProperty
                                    ReverseTenantLookup         = $ReverseTenantLookup.IsPresent
                                }

                                $InputObject = @{
                                    OrchestratorName = 'GraphRequestOrchestrator'
                                    Batch            = @($QueueTenant)
                                }
                                $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject ($InputObject | ConvertTo-Json -Depth 5 -Compress)

                                [PSCustomObject]@{
                                    QueueMessage = ('Loading {0} rows for {1}. Please check back after the job completes' -f $Count, $TenantFilter)
                                    QueueId      = $Queue.RowKey
                                    Queued       = $true
                                }
                            }
                        }
                    }

                    if (!$QueueThresholdExceeded) {
                        #nextLink should ONLY be used in direct calls with manual pagination. It should not be used in queueing
                        if ($ManualPagination.IsPresent -and $nextLink -match '^https://.+') { $GraphRequest.uri = $nextLink }

                        $GraphRequestResults = New-GraphGetRequest @GraphRequest -Caller $Caller -ErrorAction Stop
                        $GraphRequestResults = $GraphRequestResults | Select-Object *, @{n = 'Tenant'; e = { $TenantFilter } }, @{n = 'CippStatus'; e = { 'Good' } }

                        if ($UseBatchExpand.IsPresent -and ![string]::IsNullOrEmpty($BatchExpandQuery)) {
                            if ($BatchExpandQuery -match '' -and ![string]::IsNullOrEmpty($GraphRequestResults.id)) {
                                # Convert $expand format to actual batch query e.g. members($select=id,displayName) to members?$select=id,displayName
                                $BatchExpandQuery = $BatchExpandQuery -replace '\(\$?([^=]+)=([^)]+)\)', '?$$$1=$2' -replace ';', '&'

                                # Extract property name from expand
                                $Property = $BatchExpandQuery -replace '\?.*$', '' -replace '^.*\/', ''
                                Write-Information "Performing batch expansion for property '$Property'..."

                                if ($Property -eq 'assignedLicenses') {
                                    $LicenseDetails = Get-CIPPLicenseOverview -TenantFilter $TenantFilter
                                    $GraphRequestResults = foreach ($GraphRequestResult in $GraphRequestResults) {
                                        $NewLicenses = [system.collections.generic.list[string]]::new()
                                        foreach ($License in $GraphRequestResult.assignedLicenses) {
                                            $LicenseInfo = $LicenseDetails | Where-Object { $_.skuId -eq $License.skuId } | Select-Object -First 1
                                            if ($LicenseInfo) {
                                                $NewLicenses.Add($LicenseInfo.License)
                                            }
                                        }
                                        $GraphRequestResult | Add-Member -MemberType NoteProperty -Name $Property -Value @($NewLicenses) -Force
                                        $GraphRequestResult
                                    }
                                } else {

                                    $Uri = "$Endpoint/{0}/$BatchExpandQuery"

                                    $Requests = foreach ($Result in $GraphRequestResults) {
                                        @{
                                            id     = $Result.id
                                            url    = $Uri -f $Result.id
                                            method = 'GET'
                                        }
                                    }
                                    $BatchResults = New-GraphBulkRequest -Requests @($Requests) -tenantid $TenantFilter -NoAuthCheck $NoAuthCheck.IsPresent -asapp $AsApp

                                    $GraphRequestResults = foreach ($Result in $GraphRequestResults) {
                                        $PropValue = $BatchResults | Where-Object { $_.id -eq $Result.id } | Select-Object -ExpandProperty body
                                        $Result | Add-Member -MemberType NoteProperty -Name $Property -Value ($PropValue.value ?? $PropValue)
                                        $Result
                                    }
                                }
                            }
                        }

                        if ($ReverseTenantLookup -and $GraphRequestResults) {
                            $ReverseLookupRequests = $GraphRequestResults.$ReverseTenantLookupProperty | Sort-Object -Unique | ForEach-Object {
                                @{
                                    id     = $_
                                    url    = "tenantRelationships/findTenantInformationByTenantId(tenantId='$_')"
                                    method = 'GET'
                                }
                            }
                            $TenantInfo = New-GraphBulkRequest -Requests @($ReverseLookupRequests) -tenantid $env:TenantID -NoAuthCheck $true -asapp $true

                            $GraphRequestResults | Select-Object @{n = 'TenantInfo'; e = { Get-GraphBulkResultByID -Results @($TenantInfo) -ID $_.$ReverseTenantLookupProperty } }, *

                        } else {
                            $GraphRequestResults
                        }
                    }

                } catch {
                    $Message = ('Exception at {0}:{1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
                    throw $Message
                }
            }
        }
    } else {
        foreach ($Row in $Rows) {
            if ($Row.Data) {
                try {
                    $Row.Data | ConvertFrom-Json -ErrorAction Stop
                } catch {
                    Write-Warning "Could not convert data to JSON: $($_.Exception.Message)"
                    #Write-Information ($Row | ConvertTo-Json)
                    continue
                }
            }
        }
    }
}
#EndRegion './Public/GraphRequests/Get-GraphRequestList.ps1' 423
#Region './Public/New-CIPPAlertTemplate.ps1' -1

function New-CIPPAlertTemplate {
    param(
        [Parameter(Mandatory = $true)]
        $Data,
        [Parameter(Mandatory = $true)]
        $Format,
        $InputObject = 'auditlog',
        $LocationInfo,
        $ActionResults,
        $CIPPURL,
        $Tenant,
        $AuditLogLink,
        $AlertComment
    )
    $Appname = '[{"Application Name":"ACOM Azure Website","Application IDs":"23523755-3a2b-41ca-9315-f81f3f566a95"},{"Application Name":"AEM-DualAuth","Application IDs":"69893ee3-dd10-4b1c-832d-4870354be3d8"},{"Application Name":"ASM Campaign Servicing","Application IDs":"0cb7b9ec-5336-483b-bc31-b15b5788de71"},{"Application Name":"Azure Advanced Threat Protection","Application IDs":"7b7531ad-5926-4f2d-8a1d-38495ad33e17"},{"Application Name":"Azure Data Lake","Application IDs":"e9f49c6b-5ce5-44c8-925d-015017e9f7ad"},{"Application Name":"Azure Lab Services Portal","Application IDs":"835b2a73-6e10-4aa5-a979-21dfda45231c"},{"Application Name":"Azure Portal","Application IDs":"c44b4083-3bb0-49c1-b47d-974e53cbdf3c"},{"Application Name":"AzureSupportCenter","Application IDs":"37182072-3c9c-4f6a-a4b3-b3f91cacffce"},{"Application Name":"Bing","Application IDs":"9ea1ad79-fdb6-4f9a-8bc3-2b70f96e34c7"},{"Application Name":"CPIM Service","Application IDs":"bb2a2e3a-c5e7-4f0a-88e0-8e01fd3fc1f4"},{"Application Name":"CRM Power BI Integration","Application IDs":"e64aa8bc-8eb4-40e2-898b-cf261a25954f"},{"Application Name":"Dataverse","Application IDs":"00000007-0000-0000-c000-000000000000"},{"Application Name":"Enterprise Roaming and Backup","Application IDs":"60c8bde5-3167-4f92-8fdb-059f6176dc0f"},{"Application Name":"IAM Supportability","Application IDs":"a57aca87-cbc0-4f3c-8b9e-dc095fdc8978"},{"Application Name":"IrisSelectionFrontDoor","Application IDs":"16aeb910-ce68-41d1-9ac3-9e1673ac9575"},{"Application Name":"MCAPI Authorization Prod","Application IDs":"d73f4b35-55c9-48c7-8b10-651f6f2acb2e"},{"Application Name":"Media Analysis and Transformation Service","Application IDs":"944f0bd1-117b-4b1c-af26-804ed95e767e<br>0cd196ee-71bf-4fd6-a57c-b491ffd4fb1e"},{"Application Name":"Microsoft 365 Support Service","Application IDs":"ee272b19-4411-433f-8f28-5c13cb6fd407"},{"Application Name":"Microsoft App Access Panel","Application IDs":"0000000c-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Approval Management","Application IDs":"65d91a3d-ab74-42e6-8a2f-0add61688c74<br>38049638-cc2c-4cde-abe4-4479d721ed44"},{"Application Name":"Microsoft Authentication Broker","Application IDs":"29d9ed98-a469-4536-ade2-f981bc1d605e"},{"Application Name":"Microsoft Azure CLI","Application IDs":"04b07795-8ddb-461a-bbee-02f9e1bf7b46"},{"Application Name":"Microsoft Azure PowerShell","Application IDs":"1950a258-227b-4e31-a9cf-717495945fc2"},{"Application Name":"Microsoft Bing Search","Application IDs":"cf36b471-5b44-428c-9ce7-313bf84528de"},{"Application Name":"Microsoft Bing Search for Microsoft Edge","Application IDs":"2d7f3606-b07d-41d1-b9d2-0d0c9296a6e8"},{"Application Name":"Microsoft Bing Default Search Engine","Application IDs":"1786c5ed-9644-47b2-8aa0-7201292175b6"},{"Application Name":"Microsoft Defender for Cloud Apps","Application IDs":"3090ab82-f1c1-4cdf-af2c-5d7a6f3e2cc7"},{"Application Name":"Microsoft Docs","Application IDs":"18fbca16-2224-45f6-85b0-f7bf2b39b3f3"},{"Application Name":"Microsoft Dynamics ERP","Application IDs":"00000015-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Edge Insider Addons Prod","Application IDs":"6253bca8-faf2-4587-8f2f-b056d80998a7"},{"Application Name":"Microsoft Exchange Online Protection","Application IDs":"00000007-0000-0ff1-ce00-000000000000"},{"Application Name":"Microsoft Forms","Application IDs":"c9a559d2-7aab-4f13-a6ed-e7e9c52aec87"},{"Application Name":"Microsoft Graph","Application IDs":"00000003-0000-0000-c000-000000000000"},{"Application Name":"Microsoft Intune Web Company Portal","Application IDs":"74bcdadc-2fdc-4bb3-8459-76d06952a0e9"},{"Application Name":"Microsoft Intune Windows Agent","Application IDs":"fc0f3af4-6835-4174-b806-f7db311fd2f3"},{"Application Name":"Microsoft Learn","Application IDs":"18fbca16-2224-45f6-85b0-f7bf2b39b3f3"},{"Application Name":"Microsoft Office","Application IDs":"d3590ed6-52b3-4102-aeff-aad2292ab01c"},{"Application Name":"Microsoft Office 365 Portal","Application IDs":"00000006-0000-0ff1-ce00-000000000000"},{"Application Name":"Microsoft Office Web Apps Service","Application IDs":"67e3df25-268a-4324-a550-0de1c7f97287"},{"Application Name":"Microsoft Online Syndication Partner Portal","Application IDs":"d176f6e7-38e5-40c9-8a78-3998aab820e7"},{"Application Name":"Microsoft password reset service","Application IDs":"93625bc8-bfe2-437a-97e0-3d0060024faa"},{"Application Name":"Microsoft Power BI","Application IDs":"871c010f-5e61-4fb1-83ac-98610a7e9110"},{"Application Name":"Microsoft Storefronts","Application IDs":"28b567f6-162c-4f54-99a0-6887f387bbcc"},{"Application Name":"Microsoft Stream Portal","Application IDs":"cf53fce8-def6-4aeb-8d30-b158e7b1cf83"},{"Application Name":"Microsoft Substrate Management","Application IDs":"98db8bd6-0cc0-4e67-9de5-f187f1cd1b41"},{"Application Name":"Microsoft Support","Application IDs":"fdf9885b-dd37-42bf-82e5-c3129ef5a302"},{"Application Name":"Microsoft Teams","Application IDs":"1fec8e78-bce4-4aaf-ab1b-5451cc387264"},{"Application Name":"Microsoft Teams Services","Application IDs":"cc15fd57-2c6c-4117-a88c-83b1d56b4bbe"},{"Application Name":"Microsoft Teams Web Client","Application IDs":"5e3ce6c0-2b1f-4285-8d4b-75ee78787346"},{"Application Name":"Microsoft Whiteboard Services","Application IDs":"95de633a-083e-42f5-b444-a4295d8e9314"},{"Application Name":"O365 Suite UX","Application IDs":"4345a7b9-9a63-4910-a426-35363201d503"},{"Application Name":"Office 365 Exchange Online","Application IDs":"00000002-0000-0ff1-ce00-000000000000"},{"Application Name":"Office 365 Management","Application IDs":"00b41c95-dab0-4487-9791-b9d2c32c80f2"},{"Application Name":"Office 365 Search Service","Application IDs":"66a88757-258c-4c72-893c-3e8bed4d6899"},{"Application Name":"Office 365 SharePoint Online","Application IDs":"00000003-0000-0ff1-ce00-000000000000"},{"Application Name":"Office Delve","Application IDs":"94c63fef-13a3-47bc-8074-75af8c65887a"},{"Application Name":"Office Online Add-in SSO","Application IDs":"93d53678-613d-4013-afc1-62e9e444a0a5"},{"Application Name":"Office Online Client AAD- Augmentation Loop","Application IDs":"2abdc806-e091-4495-9b10-b04d93c3f040"},{"Application Name":"Office Online Client AAD- Loki","Application IDs":"b23dd4db-9142-4734-867f-3577f640ad0c"},{"Application Name":"Office Online Client AAD- Maker","Application IDs":"17d5e35f-655b-4fb0-8ae6-86356e9a49f5"},{"Application Name":"Office Online Client MSA- Loki","Application IDs":"b6e69c34-5f1f-4c34-8cdf-7fea120b8670"},{"Application Name":"Office Online Core SSO","Application IDs":"243c63a3-247d-41c5-9d83-7788c43f1c43"},{"Application Name":"Office Online Search","Application IDs":"a9b49b65-0a12-430b-9540-c80b3332c127"},{"Application Name":"Office.com","Application IDs":"4b233688-031c-404b-9a80-a4f3f2351f90"},{"Application Name":"Office365 Shell WCSS-Client","Application IDs":"89bee1f7-5e6e-4d8a-9f3d-ecd601259da7"},{"Application Name":"OfficeClientService","Application IDs":"0f698dd4-f011-4d23-a33e-b36416dcb1e6"},{"Application Name":"OfficeHome","Application IDs":"4765445b-32c6-49b0-83e6-1d93765276ca"},{"Application Name":"OfficeShredderWacClient","Application IDs":"4d5c2d63-cf83-4365-853c-925fd1a64357"},{"Application Name":"OMSOctopiPROD","Application IDs":"62256cef-54c0-4cb4-bcac-4c67989bdc40"},{"Application Name":"OneDrive SyncEngine","Application IDs":"ab9b8c07-8f02-4f72-87fa-80105867a763"},{"Application Name":"OneNote","Application IDs":"2d4d3d8e-2be3-4bef-9f87-7875a61c29de"},{"Application Name":"Outlook Mobile","Application IDs":"27922004-5251-4030-b22d-91ecd9a37ea4"},{"Application Name":"Partner Customer Delegated Admin Offline Processor","Application IDs":"a3475900-ccec-4a69-98f5-a65cd5dc5306"},{"Application Name":"Password Breach Authenticator","Application IDs":"bdd48c81-3a58-4ea9-849c-ebea7f6b6360"},{"Application Name":"Power BI Service","Application IDs":"00000009-0000-0000-c000-000000000000"},{"Application Name":"SharedWithMe","Application IDs":"ffcb16e8-f789-467c-8ce9-f826a080d987"},{"Application Name":"SharePoint Online Web Client Extensibility","Application IDs":"08e18876-6177-487e-b8b5-cf950c1e598c"},{"Application Name":"Signup","Application IDs":"b4bddae8-ab25-483e-8670-df09b9f1d0ea"},{"Application Name":"Skype for Business Online","Application IDs":"00000004-0000-0ff1-ce00-000000000000"},{"Application Name":"Sway","Application IDs":"905fcf26-4eb7-48a0-9ff0-8dcc7194b5ba"},{"Application Name":"Universal Store Native Client","Application IDs":"268761a2-03f3-40df-8a8b-c3db24145b6b"},{"Application Name":"Vortex [wsfed enabled]","Application IDs":"5572c4c0-d078-44ce-b81c-6cbf8d3ed39e"},{"Application Name":"Windows Azure Active Directory","Application IDs":"00000002-0000-0000-c000-000000000000"},{"Application Name":"Windows Azure Service Management API","Application IDs":"797f4846-ba00-4fd7-ba43-dac1f8f63013"},{"Application Name":"WindowsDefenderATP Portal","Application IDs":"a3b79187-70b2-4139-83f9-6016c58cd27b"},{"Application Name":"Windows Search","Application IDs":"26a7ee05-5602-4d76-a7ba-eae8b7b67941"},{"Application Name":"Windows Spotlight","Application IDs":"1b3c667f-cde3-4090-b60b-3d2abd0117f0"},{"Application Name":"Windows Store for Business","Application IDs":"45a330b1-b1ec-4cc1-9161-9f03992aa49f"},{"Application Name":"Yammer","Application IDs":"00000005-0000-0ff1-ce00-000000000000"},{"Application Name":"Yammer Web","Application IDs":"c1c74fed-04c9-4704-80dc-9f79a2e515cb"},{"Application Name":"Yammer Web Embed","Application IDs":"e1ef36fd-b883-4dbf-97f0-9ece4b576fc6"}]' | ConvertFrom-Json | Where-Object -Property 'Application IDs' -EQ $data.applicationId
    $HTMLTemplate = Get-Content 'TemplateEmail.html' -Raw | Out-String
    $Title = ''
    $IntroText = ''
    $ButtonUrl = ''
    $ButtonText = ''
    $AfterButtonText = ''
    $RuleTable = ''
    $Table = ''
    $LocationInfo = $LocationInfo ?? $Data.CIPPLocationInfo | ConvertFrom-Json -ErrorAction SilentlyContinue | Select-Object * -ExcludeProperty Etag, PartitionKey, TimeStamp
    if ($Data -is [string]) {
        $Data = @{ message = $Data }
    }
    if ($Data -is [array] -and $Data[0] -is [string]) {
        $Data = $Data | ForEach-Object { @{ message = $_ } }
    }
    if ($InputObject -eq 'driftStandard') {
        $Title = "CIPP Alert - Standard Drift Detected for $($Tenant)"
        $DataHTML = ($Data | ConvertTo-Html | Out-String).Replace('<table>', ' <table class="table-modern">')
        $IntroText = "<p>You've setup your instance to receive alerts when a tenant is drifting away from your standard. This seems to have happened! We've found the following deviations. </p>$dataHTML"
        $ButtonUrl = "$CIPPURL/tenant/manage/drift?tenantFilter=$($Tenant)&templateId=$($AuditLogLink)"
        $ButtonText = 'Investigate and remediate deviations'
        $AfterButtonText = 'Click the button above to go to the logbook and investigate the deviations. You can also use the standards page to remediate the deviations.'
    }

    if ($InputObject -eq 'sherwebmig') {
        $DataHTML = ($Data | ConvertTo-Html | Out-String).Replace('<table>', ' <table class="table-modern">')
        $IntroText = "<p>The following licenses have not yet been found at Sherweb, and are expiring within 7 days:</p>$dataHTML"
        if ($data.SherwebMig -like '*buy*') {
            $introText = "<p>The following licenses have not yet been found at Sherweb, and are expiring within 7 days. We have started the process to automatically buy these licenses:</p>$dataHTML"
        }
    }
    if ($InputObject -eq 'sherwebmigfailcancel') {
        $DataHTML = ($Data | ConvertTo-Html | Out-String).Replace('<table>', ' <table class="table-modern">')
        $IntroText = "<p>The following licenses have not been cancelled due to an API error at the old provider:</p>$dataHTML"
    }
    if ($InputObject -eq 'sherwebmigBuyFail') {
        $DataHTML = ($Data | ConvertTo-Html | Out-String).Replace('<table>', ' <table class="table-modern">')
        $IntroText = "<p>The following licenses have not been bought as we could not find a correctly matching license. Please login and buy the license:</p>$dataHTML"
    }
    if ($InputObject -eq 'table') {
        #data can be a array of strings or a string, if it is, we need to convert it to an object so it shows up nicely, that object will have one header: message.

        $DataHTML = ($Data | Select-Object * -ExcludeProperty Etag, PartitionKey, TimeStamp | ConvertTo-Html | Out-String).Replace('<table>', ' <table class="table-modern">')
        $IntroText = "<p>You've configured CIPP to send you alerts based on the logbook. The following alerts match your configured rules</p>$dataHTML"

        # Add alert comment if provided
        if ($AlertComment) {
            $IntroText = "$IntroText<div style='background-color: #f8f9fa; border-left: 4px solid #007bff; padding: 15px; margin: 15px 0;'><h4 style='margin-top: 0; color: #007bff;'>Alert Information</h4><p style='margin-bottom: 0;'>$AlertComment</p></div>"
        }

        $ButtonUrl = "$CIPPURL/cipp/logs"
        $ButtonText = 'Check logbook information'
    }
    if ($InputObject -eq 'standards') {
        $DataHTML = foreach ($object in $data) {
            "<p>For the standard $($object.standardName) we've detected the following:</p> <li>$($object.message)</li>"
            if ($object.object) {
                $StandardObject = $object.object | ConvertFrom-Json
                $StandardObject = $StandardObject | Select-Object * -ExcludeProperty Etag, PartitionKey, TimeStamp
                if ($StandardObject.compare) {
                    '<p>The following differences have been detected:</p>'
                    ($StandardObject.compare | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                } else {
                    ($StandardObject | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                }
            }

        }
        $IntroText = "<p>You're receiving this email because you've set your standards to alert when they are out of sync with your expected baseline.</p>$dataHTML"
        $ButtonUrl = "$CIPPURL/standards/list-standards"
        $ButtonText = 'Check Standards configuration'
    }
    if ($InputObject -eq 'auditlog') {
        $ButtonUrl = "$CIPPURL/identity/administration/users/user/bec?userId=$($data.ObjectId)&tenantFilter=$Tenant"
        $ButtonText = 'User Management'
        $AfterButtonText = '<p>If this is incorrect, use the user management screen to block the user and revoke the sessions</p>'
        switch ($Data.Operation) {
            'New-InboxRule' {
                # Test if the rule is a forwarding or redirect rule
                $ForwardProperties = @('ForwardTo', 'RedirectTo')
                foreach ($ForwardProperty in $ForwardProperties) {
                    if ($Data.PSobject.Properties.Name -contains $ForwardProperty) {
                        $FoundForwarding = $true
                    }
                }
                if ($FoundForwarding -eq $true) {
                    $Title = "$($TenantFilter) - New forwarding or redirect Rule Detected for $($data.UserId)"
                } else {
                    $Title = "$($TenantFilter) - New Rule Detected for $($data.UserId)"
                }
                $RuleTable = ($Data.CIPPParameters | ConvertFrom-Json | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')

                $IntroText = "<p>A new rule has been created for the user $($data.UserId). You should check if this rule is not malicious. The rule information can be found in the table below.</p>$RuleTable"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users/user/bec?userId=$($data.UserId)&tenantFilter=$Tenant"
                $ButtonText = 'Start BEC Investigation'
                $AfterButtonText = '<p>If you believe this is a suspect rule, you can click the button above to start the investigation.</p>'
            }
            'Set-InboxRule' {
                $Title = "$($TenantFilter) - Rule Edit Detected for $($data.UserId)"
                $RuleTable = ($Data.CIPPParameters | ConvertFrom-Json | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                $IntroText = "<p>A rule has been edited for the user $($data.UserId). You should check if this rule is not malicious. The rule information can be found in the table below.</p>$RuleTable"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users/user/bec?userId=$($data.UserId)&tenantFilter=$Tenant"
                $ButtonText = 'Start BEC Investigation'
                $AfterButtonText = '<p>If you believe this is a suspect rule, you can click the button above to start the investigation.</p>'
            }
            'Add member to role.' {
                $Title = "$($TenantFilter) - Role change detected for $($data.ObjectId)"
                $Table = ($data.CIPPModifiedProperties | ConvertFrom-Json | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                $IntroText = "<p>$($data.UserId) has added $($data.ObjectId) to the $(($data.'Role.DisplayName')) role. The information about the role can be found in the table below.</p>$Table"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/roles?customerId=$($data.OrganizationId)"
                $ButtonText = 'Role Management'
                $AfterButtonText = '<p>If this role is incorrect, or you need more information, use the button to jump to the Role Management page.</p>'

            }
            'Disable account.' {
                $Title = "$($TenantFilter) - $($data.ObjectId) has been disabled"
                $IntroText = "$($data.ObjectId) has been disabled by $($data.UserId)."
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users?customerId=$($data.OrganizationId)"
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to unblock the users sign-in</p>'
            }
            'Enable account.' {
                $Title = "$($TenantFilter) - $($data.ObjectId) has been enabled"
                $IntroText = "$($data.ObjectId) has been enabled by $($data.UserId)."
                $ButtonUrl = "$CIPPURL/identity/administration/users?customerId=$($data.OrganizationId)"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to unblock the users sign-in</p>'
            }
            'Update StsRefreshTokenValidFrom Timestamp.' {
                $Title = "$($TenantFilter) - $($data.ObjectId) has had all sessions revoked"
                $IntroText = "$($data.ObjectId) has had their sessions revoked by $($data.UserId)."
                $ButtonUrl = "$CIPPURL/identity/administration/users?customerId=$($data.OrganizationId)"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to unblock the users sign-in</p>'
            }
            'Disable Strong Authentication.' {
                $Title = "$($TenantFilter) - $($data.ObjectId) has been MFA disabled"
                $IntroText = "$($data.ObjectId) MFA has been disabled by $($data.UserId)."
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users?customerId=$($data.OrganizationId)"
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to reenable MFA</p>'
            }
            'Remove Member from a role.' {
                $Title = "$($TenantFilter) - Role change detected for $($data.ObjectId)"
                $Table = ($data.CIPPModifiedProperties | ConvertFrom-Json | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                $IntroText = "<p>$($data.UserId) has removed $($data.ObjectId) to the $(($data.ModifiedProperties | Where-Object -Property Name -EQ 'Role.DisplayName').NewValue) role. The information about the role can be found in the table below.</p>$Table"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/roles?customerId=$($data.OrganizationId)"
                $ButtonText = 'Role Management'
                $AfterButtonText = '<p>If this role change is incorrect, or you need more information, use the button to jump to the Role Management page.</p>'

            }

            'Reset user password.' {
                $Title = "$($TenantFilter) - $($data.ObjectId) has had their password reset"
                $IntroText = "$($data.ObjectId) has had their password reset by $($data.userId)."
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users?customerId=$($data.OrganizationId)"
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to unblock the users sign-in</p>'

            }
            'Add service principal.' {
                if ($Appname) { $AppName = $AppName.'Application Name' } else { $appName = $data.ApplicationId }
                $Title = "$($TenantFilter) - Service Principal $($data.ObjectId) has been added."
                $Table = ($data.ModifiedProperties | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $IntroText = "$($data.ObjectId) has been added by $($data.UserId)."
                $ButtonUrl = "$CIPPURL/tenant/administration/enterprise-apps?customerId=?customerId=$($data.OrganizationId)"
                $ButtonText = 'Enterprise Apps'
            }
            'Remove service principal.' {
                if ($Appname) { $AppName = $AppName.'Application Name' } else { $appName = $data.ApplicationId }
                $Title = "$($TenantFilter) - Service Principal $($data.ObjectId) has been removed."
                $Table = ($data.CIPPModifiedProperties | ConvertFrom-Json | ConvertTo-Html -Fragment | Out-String).Replace('<table>', ' <table class="table-modern">')
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $IntroText = "$($data.ObjectId) has been added by $($data.UserId)."
                $ButtonUrl = "$CIPPURL/tenant/administration/enterprise-apps?customerId=?customerId=$($data.OrganizationId)"
                $ButtonText = 'Enterprise Apps'
            }
            'UserLoggedIn' {
                $Table = ($data | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                if ($Appname) { $AppName = $AppName.'Application Name' } else { $appName = $data.ApplicationId }
                $Title = "$($TenantFilter) - a user has logged on from a location you've set up to receive alerts for."
                $IntroText = "$($data.UserId) ($($data.Userkey)) has logged on from IP $($data.ClientIP) to the application $($Appname). According to our database this is located in $($LocationInfo.Country) - $($LocationInfo.City). <br/><br> You have set up alerts to be notified when this happens. See the table below for more info.$Table"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users/user/bec?userId=$($data.ObjectId)&tenantFilter=$Tenant"
                $ButtonText = 'User Management'
                $AfterButtonText = '<p>If this is incorrect, use the user management screen to block the user and revoke the sessions</p>'
            }
            default {
                $Title = 'A custom alert has occured'
                $Table = ($data | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                $IntroText = "<p>You have setup CIPP to send you a custom alert for the audit events that follow this filter: $($data.cippclause) </p>$Table"
                if ($ActionResults) { $IntroText = $IntroText + "<p>Based on the rule, the following actions have been taken: $($ActionResults -join '<br/>' )</p>" }
                if ($LocationInfo) {
                    $LocationTable = ($LocationInfo | ConvertTo-Html -Fragment -As List | Out-String).Replace('<table>', ' <table class="table-modern">')
                    $IntroText = $IntroText + "<p>The (potential) location information for this IP is as follows:</p>$LocationTable"
                }
                $ButtonUrl = "$CIPPURL/identity/administration/users?tenantFilter=$Tenant"
                $ButtonText = 'User Management'
            }
        }
    }

    if ($Format -eq 'html') {
        return  [pscustomobject]@{
            title       = $Title
            htmlcontent = $HTMLTemplate -f $Title, $IntroText, $ButtonUrl, $ButtonText, $AfterButtonText, $AuditLogLink
        }
    } elseif ($Format -eq 'json') {
        if ($InputObject -eq 'auditlog') {
            return [pscustomobject]@{
                title = $Title
                html  = $IntroText
                data  = $data
            }
        }
        return [pscustomobject]@{
            title        = $Title
            buttonurl    = $ButtonUrl
            buttontext   = $ButtonText
            auditlog     = $AuditLogLink
            alertcomment = $AlertComment
        }
    }
}
#EndRegion './Public/New-CIPPAlertTemplate.ps1' 298
#Region './Public/New-CIPPApplicationCopy.ps1' -1

function New-CIPPApplicationCopy {
    [CmdletBinding()]
    param(
        $App,
        $Tenant
    )

    Write-Information "Copying application $($App) to tenant $Tenant"
    $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/v1.0/servicePrincipals?$top=999' -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true

    if ($CurrentInfo.appId -notcontains $App) {
        Write-Information "Application $($App) not found in partner tenant. Cannot copy permissions."
        throw 'We cannot copy permissions for this application because is not registered in the partner tenant.'
    }

    try {
        try {
            $ExistingApp = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/applications(appId='$($app)')" -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true
            $Type = 'Application'
        } catch {
            $ExistingApp = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals(appId='$($app)')/oauth2PermissionGrants" -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true
            $ExistingAppRoleAssignments = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/servicePrincipals(appId='$($app)')/appRoleAssignments" -tenantid $env:TenantID -NoAuthCheck $true -AsApp $true
            $Type = 'ServicePrincipal'
        }
        if (!$ExistingApp -and !$ExistingAppRoleAssignments) {
            Write-LogMessage -message "Failed to add $App to tenant. This app does not exist or does not have any consented permissions." -tenant $tenant -API 'Application Copy' -sev error
            continue
        }
        if ($Type -eq 'Application') {
            Write-Information 'App type: Application'
            $DelegateResourceAccess = $Existingapp.requiredResourceAccess
            $ApplicationResourceAccess = $Existingapp.requiredResourceAccess
            $NoTranslateRequired = $false
        } else {
            Write-Information 'App type: ServicePrincipal'
            $DelegateResourceAccess = $ExistingApp | Group-Object -Property resourceId | ForEach-Object {
                [pscustomobject]@{ resourceAppId = ($CurrentInfo | Where-Object -Property id -EQ $_.Name).appId; resourceAccess = @($_.Group | ForEach-Object { [pscustomobject]@{ id = $_.scope; type = 'Scope' } } )
                }
            }
            $ApplicationResourceAccess = $ExistingappRoleAssignments | Group-Object -Property ResourceId | ForEach-Object {
                [pscustomobject]@{ resourceAppId = ($CurrentInfo | Where-Object -Property id -EQ $_.Name).appId; resourceAccess = @($_.Group | ForEach-Object { [pscustomobject]@{ id = $_.appRoleId; type = 'Role' } } )
                }
            }
            $NoTranslateRequired = $true
        }
        $TenantInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/servicePrincipals?$top=999' -tenantid $Tenant -NoAuthCheck $true -AsApp $true

        if ($App -Notin $TenantInfo.appId) {
            Write-Information "Creating service principal with ID: $($App)"
            $Body = @{
                appId = $App
            }
            $Body = $Body | ConvertTo-Json -Compress
            Write-Information ($Body | ConvertTo-Json -Depth 10)
            $null = New-GraphPostRequest 'https://graph.microsoft.com/v1.0/servicePrincipals' -type POST -tenantid $Tenant -body $Body -AsApp $true
            Write-LogMessage -message "Added $App as a service principal" -tenant $tenant -API 'Application Copy' -sev Info

        } else {
            Write-Information "Service principal with ID: $($App) already exists in tenant $Tenant"
        }

        if ($DelegateResourceAccess) {
            Add-CIPPDelegatedPermission -RequiredResourceAccess $ApplicationResourceAccess -ApplicationId $App -Tenantfilter $Tenant
        }
        if ($ApplicationResourceAccess) {
            Add-CIPPApplicationPermission -RequiredResourceAccess $ApplicationResourceAccess -ApplicationId $App -Tenantfilter $Tenant
        }
        Write-LogMessage -message "Added permissions to $app" -tenant $tenant -API 'Application Copy' -sev Info

        return $Results
    } catch {
        Write-Warning "Failed to copy application $($App) to tenant $Tenant. Error: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        Write-Information ($_.ScriptStackTrace | Out-String)
        throw $_.Exception.Message
    }
}
#EndRegion './Public/New-CIPPApplicationCopy.ps1' 78
#Region './Public/New-CIPPAssignmentFilter.ps1' -1

function New-CIPPAssignmentFilter {
    <#
    .SYNOPSIS
    Creates a new assignment filter in Microsoft Intune

    .DESCRIPTION
    Unified function for creating assignment filters that handles all platform types consistently.
    Used by both direct filter creation and assignment filter template application.

    .PARAMETER FilterObject
    Object containing filter properties (displayName, description, platform, rule, etc.)

    .PARAMETER TenantFilter
    The tenant domain name where the filter should be created

    .PARAMETER APIName
    The API name for logging purposes

    .PARAMETER ExecutingUser
    The user executing the request (for logging)

    .EXAMPLE
    New-CIPPAssignmentFilter -FilterObject $FilterData -TenantFilter 'contoso.com' -APIName 'AddAssignmentFilter'

    .NOTES
    Supports all platform types: Windows10AndLater, iOS, Android, macOS, etc.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$FilterObject,

        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $false)]
        [string]$APIName = 'New-CIPPAssignmentFilter',

        [Parameter(Mandatory = $false)]
        [string]$ExecutingUser = 'CIPP'

    )

    try {
        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Creating assignment filter $($FilterObject.displayName) for platform $($FilterObject.platform)" -Sev Info

        # Build the request body for Graph API
        $BodyParams = [PSCustomObject]@{
            '@odata.type'                    = '#microsoft.graph.deviceAndAppManagementAssignmentFilter'
            'displayName'                    = $FilterObject.displayName
            'description'                    = $FilterObject.description ?? ''
            'platform'                       = $FilterObject.platform
            'rule'                           = $FilterObject.rule
            'assignmentFilterManagementType' = $FilterObject.assignmentFilterManagementType ?? 'devices'
        }

        # Create the assignment filter via Graph API
        $GraphRequest = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters' -tenantid $TenantFilter -type POST -body (ConvertTo-Json -InputObject $BodyParams -Depth 10)

        $Result = [PSCustomObject]@{
            Success  = $true
            Message  = "Successfully created assignment filter $($FilterObject.displayName)"
            FilterId = $GraphRequest.id
            Platform = $FilterObject.platform
        }

        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Created assignment filter $($FilterObject.displayName) with id $($Result.FilterId)" -Sev Info
        return $Result

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Assignment filter creation failed for $($FilterObject.displayName): $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage

        return [PSCustomObject]@{
            Success  = $false
            Message  = "Failed to create assignment filter $($FilterObject.displayName): $($ErrorMessage.NormalizedError)"
            Error    = $ErrorMessage.NormalizedError
            Platform = $FilterObject.platform
        }
    }
}
#EndRegion './Public/New-CIPPAssignmentFilter.ps1' 82
#Region './Public/New-CIPPBackup.ps1' -1

function New-CIPPBackup {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        $backupType,
        $StorageOutput = 'default',
        $TenantFilter,
        $ScheduledBackupValues,
        $APIName = 'CIPP Backup',
        $Headers
    )

    $BackupData = switch ($backupType) {
        #If backup type is CIPP, create CIPP backup.
        'CIPP' {
            try {
                $BackupTables = @(
                    'AppPermissions'
                    'AccessRoleGroups'
                    'ApiClients'
                    'CippReplacemap'
                    'CustomData'
                    'CustomRoles'
                    'Config'
                    'CommunityRepos'
                    'Domains'
                    'GraphPresets'
                    'GDAPRoles'
                    'GDAPRoleTemplates'
                    'ExcludedLicenses'
                    'templates'
                    'standards'
                    'SchedulerConfig'
                    'Extensions'
                    'WebhookRules'
                    'ScheduledTasks'
                    'TenantProperties'
                )
                $CSVfile = foreach ($CSVTable in $BackupTables) {
                    $Table = Get-CippTable -tablename $CSVTable
                    Get-AzDataTableEntity @Table | Select-Object * -ExcludeProperty DomainAnalyser, table, Timestamp, ETag, Results | Select-Object *, @{l = 'table'; e = { $CSVTable } }
                }
                $RowKey = 'CIPPBackup' + '_' + (Get-Date).ToString('yyyy-MM-dd-HHmm')
                $CSVfile
                $CSVFile = [string]($CSVfile | ConvertTo-Json -Compress -Depth 100)
                $entity = @{
                    PartitionKey = 'CIPPBackup'
                    RowKey       = [string]$RowKey
                    TenantFilter = 'CIPPBackup'
                    Backup       = $CSVfile
                }
                $Table = Get-CippTable -tablename 'CIPPBackup'
                try {
                    if ($PSCmdlet.ShouldProcess('CIPP Backup', 'Create')) {
                        $null = Add-CIPPAzDataTableEntity @Table -Entity $entity -Force
                        Write-LogMessage -headers $Headers -API $APINAME -message 'Created CIPP Backup' -Sev 'Debug'
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -headers $Headers -API $APINAME -message "Failed to create backup for CIPP: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
                    [pscustomobject]@{'Results' = "Backup Creation failed: $($ErrorMessage.NormalizedError)" }
                }

            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -headers $Headers -API $APINAME -message "Failed to create backup: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
                [pscustomobject]@{'Results' = "Backup Creation failed: $($ErrorMessage.NormalizedError)" }
            }
        }

        #If Backup type is ConditionalAccess, create Conditional Access backup.
        'Scheduled' {
            #Do a sub switch here based on the ScheduledBackupValues?
            #Store output in tablestorage for Recovery
            $RowKey = $TenantFilter + '_' + (Get-Date).ToString('yyyy-MM-dd-HHmm')
            $entity = @{
                PartitionKey = 'ScheduledBackup'
                RowKey       = $RowKey
                TenantFilter = $TenantFilter
            }
            Write-Information "Scheduled backup value psproperties: $(([pscustomobject]$ScheduledBackupValues).psobject.Properties)"
            foreach ($ScheduledBackup in ([pscustomobject]$ScheduledBackupValues).psobject.Properties.Name) {
                try {
                    $BackupResult = New-CIPPBackupTask -Task $ScheduledBackup -TenantFilter $TenantFilter | ConvertTo-Json -Depth 100 -Compress | Out-String
                    $entity[$ScheduledBackup] = "$BackupResult"
                } catch {
                    Write-Information "Failed to create backup for $ScheduledBackup - $($_.Exception.Message)"
                }
            }
            $Table = Get-CippTable -tablename 'ScheduledBackup'
            try {
                $null = Add-CIPPAzDataTableEntity @Table -entity $entity -Force
                Write-LogMessage -headers $Headers -API $APINAME -message 'Created backup' -Sev 'Debug'
                $State = 'Backup finished successfully'
            } catch {
                $State = 'Failed to write backup to table storage'
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -headers $Headers -API $APINAME -message "Failed to create tenant backup: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
                [pscustomobject]@{'Results' = "Backup Creation failed: $($ErrorMessage.NormalizedError)" }
            }
        }

    }
    return @([pscustomobject]@{
            BackupName  = $RowKey
            BackupState = $State
        })
}

#EndRegion './Public/New-CIPPBackup.ps1' 109
#Region './Public/New-CIPPBackupTask.ps1' -1

function New-CIPPBackupTask {
    [CmdletBinding()]
    param (
        $Task,
        $TenantFilter
    )

    $FunctionStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    Write-Host "CIPPBACKUP: Starting backup task: $Task for tenant: $TenantFilter"

    $BackupData = switch ($Task) {
        'CippCustomVariables' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backing up Custom Variables for $TenantFilter"
            $ReplaceTable = Get-CIPPTable -tablename 'CippReplacemap'

            # Get tenant-specific variables
            $Tenant = Get-Tenants -TenantFilter $TenantFilter
            $CustomerId = $Tenant.customerId

            $TenantVariables = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$CustomerId'"

            # If backing up AllTenants, also get global variables
            if ($TenantFilter -eq 'AllTenants') {
                $GlobalVariables = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq 'AllTenants'"
                $AllVariables = @($TenantVariables) + @($GlobalVariables)
                $TaskStopwatch.Stop()
                Write-Host "CIPPBACKUP: CippCustomVariables backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
                $AllVariables
            } else {
                $TaskStopwatch.Stop()
                Write-Host "CIPPBACKUP: CippCustomVariables backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
                $TenantVariables
            }
        }
        'users' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup users for $TenantFilter"
            $Users = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/users?$top=999' -tenantid $TenantFilter | Select-Object * -ExcludeProperty mail, provisionedPlans, onPrem*, *passwordProfile*, *serviceProvisioningErrors*, isLicenseReconciliationNeeded, isManagementRestricted, isResourceAccount, *date*, *external*, identities, deletedDateTime, isSipEnabled, assignedPlans, cloudRealtimeCommunicationInfo, deviceKeys, provisionedPlan, securityIdentifier
            #remove the property if the value is $null
            $users = $Users | ForEach-Object {
                $_.psobject.properties | Where-Object { $null -eq $_.Value } | ForEach-Object {
                    $_.psobject.properties.Remove($_.Name)
                }
            }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Users backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $Users

        }
        'groups' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup groups for $TenantFilter"
            $Groups = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups?$top=999' -tenantid $TenantFilter
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Groups backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $Groups
        }
        'ca' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Conditional Access Policies for $TenantFilter"
            $Policies = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/conditionalAccess/policies?$top=999' -tenantid $TenantFilter -AsApp $true
            Write-Host 'CIPPBACKUP: Creating templates for found Conditional Access Policies'
            foreach ($policy in $policies) {
                try {
                    New-CIPPCATemplate -TenantFilter $TenantFilter -JSON $policy
                } catch {
                    "Failed to create a template of the Conditional Access Policy with ID: $($policy.id). Error: $($_.Exception.Message)"
                }
            }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Conditional Access backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
        }
        'intuneconfig' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Intune Configuration Policies for $TenantFilter"
            $GraphURLS = @("https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations?`$select=id,displayName,lastModifiedDateTime,roleScopeTagIds,microsoft.graph.unsupportedDeviceConfiguration/originalEntityTypeName&`$expand=assignments&top=1000"
                'https://graph.microsoft.com/beta/deviceManagement/windowsDriverUpdateProfiles'
                "https://graph.microsoft.com/beta/deviceManagement/groupPolicyConfigurations?`$expand=assignments&top=999"
                "https://graph.microsoft.com/beta/deviceAppManagement/mobileAppConfigurations?`$expand=assignments&`$filter=microsoft.graph.androidManagedStoreAppConfiguration/appSupportsOemConfig%20eq%20true"
                'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'
                'https://graph.microsoft.com/beta/deviceManagement/windowsFeatureUpdateProfiles'
                'https://graph.microsoft.com/beta/deviceManagement/windowsQualityUpdatePolicies'
                'https://graph.microsoft.com/beta/deviceManagement/windowsQualityUpdateProfiles'
            )

            foreach ($url in $GraphURLS) {
                try {
                    $Policies = New-GraphGetRequest -uri "$($url)" -tenantid $TenantFilter
                    $URLName = (($url).split('?') | Select-Object -First 1) -replace 'https://graph.microsoft.com/beta/deviceManagement/', ''
                    foreach ($Policy in $Policies) {
                        try {
                            New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName $URLName -ID $Policy.ID
                        } catch {
                            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                            "Failed to create a template of the Intune Configuration Policy with ID: $($Policy.id). Error: $ErrorMessage"
                        }
                    }
                } catch {
                    Write-Host "CIPPBACKUP: Failed to backup $url"
                }
            }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Intune Configuration backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
        }
        'intunecompliance' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Intune Configuration Policies for $TenantFilter"

            New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/deviceCompliancePolicies?$top=999' -tenantid $TenantFilter | ForEach-Object {
                New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName 'deviceCompliancePolicies' -ID $_.ID
            }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Intune Compliance backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
        }

        'intuneprotection' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Intune Configuration Policies for $TenantFilter"

            New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceAppManagement/managedAppPolicies?$top=999' -tenantid $TenantFilter | ForEach-Object {
                New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName 'managedAppPolicies' -ID $_.ID
            }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Intune Protection backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
        }

        'antispam' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Anti-Spam Policies for $TenantFilter"

            $Policies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
            $Rules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterRule' | Select-Object * -ExcludeProperty *odata*, *data.type*

            $Policies | ForEach-Object {
                $_.psobject.properties | Where-Object { $null -eq $_.Value } | ForEach-Object {
                    $_.psobject.properties.Remove($_.Name)
                }
            }

            $Rules | ForEach-Object {
                $_.psobject.properties | Where-Object { $null -eq $_.Value } | ForEach-Object {
                    $_.psobject.properties.Remove($_.Name)
                }
            }

            $JSON = @{ policies = $Policies; rules = $Rules } | ConvertTo-Json -Depth 10
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Anti-Spam backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $JSON
        }

        'antiphishing' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Anti-Phishing Policies for $TenantFilter"

            $Policies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-AntiPhishPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
            $Rules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-AntiPhishRule' | Select-Object * -ExcludeProperty *odata*, *data.type*

            $Policies | ForEach-Object {
                $_.psobject.properties | Where-Object { $null -eq $_.Value } | ForEach-Object {
                    $_.psobject.properties.Remove($_.Name)
                }
            }

            $Rules | ForEach-Object {
                $_.psobject.properties | Where-Object { $null -eq $_.Value } | ForEach-Object {
                    $_.psobject.properties.Remove($_.Name)
                }
            }

            $JSON = @{ policies = $Policies; rules = $Rules } | ConvertTo-Json -Depth 10
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Anti-Phishing backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $JSON
        }

        'CippWebhookAlerts' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Webhook Alerts for $TenantFilter"
            $WebhookTable = Get-CIPPTable -TableName 'WebhookRules'
            $WebhookData = Get-CIPPAzDataTableEntity @WebhookTable | Where-Object { $TenantFilter -in ($_.Tenants | ConvertFrom-Json).value }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Webhook Alerts backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $WebhookData
        }
        'CippScriptedAlerts' {
            $TaskStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            Write-Host "CIPPBACKUP: Backup Scripted Alerts for $TenantFilter"
            $ScheduledTasks = Get-CIPPTable -TableName 'ScheduledTasks'
            $ScriptedAlerts = Get-CIPPAzDataTableEntity @ScheduledTasks | Where-Object { $_.hidden -eq $true -and $_.command -like 'Get-CippAlert*' -and $TenantFilter -in $_.Tenant }
            $TaskStopwatch.Stop()
            Write-Host "CIPPBACKUP: Scripted Alerts backup completed in $($TaskStopwatch.Elapsed.TotalSeconds) seconds"
            $ScriptedAlerts
        }
    }

    $FunctionStopwatch.Stop()
    Write-Host "CIPPBACKUP: Total backup task completed in $($FunctionStopwatch.Elapsed.TotalSeconds) seconds"
    return $BackupData
}

#EndRegion './Public/New-CIPPBackupTask.ps1' 203
#Region './Public/New-CIPPCAPolicy.ps1' -1


function New-CIPPCAPolicy {
    [CmdletBinding()]
    param (
        $RawJSON,
        $TenantFilter,
        $State,
        $Overwrite,
        $ReplacePattern = 'none',
        $DisableSD = $false,
        $CreateGroups = $false,
        $APIName = 'Create CA Policy',
        $Headers
    )

    function Remove-EmptyArrays ($Object) {
        if ($Object -is [Array]) {
            foreach ($Item in $Object) { Remove-EmptyArrays $Item }
        } elseif ($Object -is [HashTable]) {
            foreach ($Key in @($Object.get_Keys())) {
                if ($Object[$Key] -is [Array] -and $Object[$Key].get_Count() -eq 0) {
                    $Object.Remove($Key)
                } else { Remove-EmptyArrays $Object[$Key] }
            }
        } elseif ($Object -is [PSCustomObject]) {
            foreach ($Name in @($Object.psobject.properties.Name)) {
                if ($Object.$Name -is [Array] -and $Object.$Name.get_Count() -eq 0) {
                    $Object.PSObject.Properties.Remove($Name)
                } elseif ($null -eq $object.$name) {
                    $Object.PSObject.Properties.Remove($Name)
                } else { Remove-EmptyArrays $Object.$Name }
            }
        }
    }
    # Function to check if a string is a GUID
    function Test-IsGuid($string) {
        return [guid]::tryparse($string, [ref][guid]::Empty)
    }
    # Helper function to replace group display names with GUIDs
    function Replace-GroupNameWithId {
        param($TenantFilter, $groupNames, $CreateGroups, $GroupTemplates)

        $GroupIds = [System.Collections.Generic.List[string]]::new()
        $groupNames | ForEach-Object {
            if (Test-IsGuid $_) {
                Write-LogMessage -Headers $Headers -API 'Create CA Policy' -message "Already GUID, no need to replace: $_" -Sev 'Debug'
                $GroupIds.Add($_) # it's a GUID, so we keep it
            } else {
                $groupId = ($groups | Where-Object -Property displayName -EQ $_).id # it's a display name, so we get the group ID
                if ($groupId) {
                    foreach ($gid in $groupId) {
                        Write-Warning "Replaced group name $_ with ID $gid"
                        $null = Write-LogMessage -Headers $Headers -API 'Create CA Policy' -message "Replaced group name $_ with ID $gid" -Sev 'Debug'
                        $GroupIds.Add($gid) # add the ID to the list
                    }
                } elseif ($CreateGroups) {
                    Write-Warning "Creating group $_ as it does not exist in the tenant"
                    if ($GroupTemplates.displayName -eq $_) {
                        Write-Information "Creating group from template for $_"
                        $GroupTemplate = $GroupTemplates | Where-Object -Property displayName -EQ $_
                        $NewGroup = New-CIPPGroup -GroupObject $GroupTemplate -TenantFilter $TenantFilter -APIName 'New-CIPPCAPolicy'
                        $GroupIds.Add($NewGroup.GroupId)
                    } else {
                        Write-Information "No template found, creating security group for $_"
                        $username = $_ -replace '[^a-zA-Z0-9]', ''
                        if ($username.Length -gt 64) {
                            $username = $username.Substring(0, 64)
                        }
                        $GroupObject = @{
                            groupType       = 'generic'
                            displayName     = $_
                            username        = $username
                            securityEnabled = $true
                        }
                        $NewGroup = New-CIPPGroup -GroupObject $GroupObject -TenantFilter $TenantFilter -APIName 'New-CIPPCAPolicy'
                        $GroupIds.Add($NewGroup.GroupId)
                    }
                } else {
                    Write-Warning "Group $_ not found in the tenant"
                }
            }
        }
        return $GroupIds
    }

    function Replace-UserNameWithId {
        param($userNames)

        $UserIds = [System.Collections.Generic.List[string]]::new()
        $userNames | ForEach-Object {
            if (Test-IsGuid $_) {
                Write-LogMessage -Headers $User -API 'Create CA Policy' -message "Already GUID, no need to replace: $_" -Sev 'Debug'
                $UserIds.Add($_) # it's a GUID, so we keep it
            } else {
                $userId = ($users | Where-Object -Property displayName -EQ $_).id # it's a display name, so we get the user ID
                if ($userId) {
                    foreach ($uid in $userId) {
                        Write-Warning "Replaced user name $_ with ID $uid"
                        $null = Write-LogMessage -Headers $User -API 'Create CA Policy' -message "Replaced user name $_ with ID $uid" -Sev 'Debug'
                        $UserIds.Add($uid) # add the ID to the list
                    }
                } else {
                    Write-Warning "User $_ not found in the tenant"
                }
            }
        }
        return $UserIds
    }

    $displayname = ($RawJSON | ConvertFrom-Json).Displayname

    $JSONobj = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty ID, GUID, *time*
    Remove-EmptyArrays $JSONobj
    #Remove context as it does not belong in the payload.
    try {
        $JSONobj.grantControls.PSObject.Properties.Remove('authenticationStrength@odata.context')
        $JSONobj.templateId ? $JSONobj.PSObject.Properties.Remove('templateId') : $null
        if ($JSONobj.conditions.users.excludeGuestsOrExternalUsers.externalTenants.Members) {
            $JSONobj.conditions.users.excludeGuestsOrExternalUsers.externalTenants.PSObject.Properties.Remove('@odata.context')
        }
        if ($State -and $State -ne 'donotchange') {
            $JSONobj.state = $State
        }
    } catch {
        # no issues here.
    }

    #If Grant Controls contains authenticationstrength, create these and then replace the id
    if ($JSONobj.GrantControls.authenticationStrength.policyType -eq 'custom' -or $JSONobj.GrantControls.authenticationStrength.policyType -eq 'BuiltIn') {
        $ExistingStrength = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/authenticationStrength/policies/' -tenantid $TenantFilter -asApp $true | Where-Object -Property displayName -EQ $JSONobj.GrantControls.authenticationStrength.displayName
        if ($ExistingStrength) {
            $JSONobj.GrantControls.authenticationStrength = @{ id = $ExistingStrength.id }

        } else {
            $Body = ConvertTo-Json -InputObject $JSONobj.GrantControls.authenticationStrength
            $GraphRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/authenticationStrength/policies' -body $body -Type POST -tenantid $tenantfilter -asApp $true
            $JSONobj.GrantControls.authenticationStrength = @{ id = $ExistingStrength.id }
            Write-LogMessage -Headers $User -API $APINAME -message "Created new Authentication Strength Policy: $($JSONobj.GrantControls.authenticationStrength.displayName)" -Sev 'Info'
        }
    }

    #if we have excluded or included applications, we need to remove any appIds that do not have a service principal in the tenant

    if (($JSONobj.conditions.applications.includeApplications -and $JSONobj.conditions.applications.includeApplications -notcontains 'All') -or ($JSONobj.conditions.applications.excludeApplications -and $JSONobj.conditions.applications.excludeApplications -notcontains 'All')) {
        $AllServicePrincipals = New-GraphGETRequest -uri 'https://graph.microsoft.com/v1.0/servicePrincipals?$select=appId' -tenantid $TenantFilter -asApp $true

        if ($JSONobj.conditions.applications.excludeApplications -and $JSONobj.conditions.applications.excludeApplications -notcontains 'All') {
            $ValidExclusions = [system.collections.generic.list[string]]::new()
            foreach ($appId in $JSONobj.conditions.applications.excludeApplications) {
                if ($AllServicePrincipals.appId -contains $appId) {
                    $ValidExclusions.Add($appId)
                }
            }
            $JSONobj.conditions.applications.excludeApplications = $ValidExclusions
        }
        if ($JSONobj.conditions.applications.includeApplications -and $JSONobj.conditions.applications.includeApplications -notcontains 'All') {
            $ValidInclusions = [system.collections.generic.list[string]]::new()
            foreach ($appId in $JSONobj.conditions.applications.includeApplications) {
                if ($AllServicePrincipals.appId -contains $appId) {
                    $ValidInclusions.Add($appId)
                }
            }
            $JSONobj.conditions.applications.includeApplications = $ValidInclusions
        }
    }

    #for each of the locations, check if they exist, if not create them. These are in $JSONobj.LocationInfo
    $LocationLookupTable = foreach ($locations in $JSONobj.LocationInfo) {
        if (!$locations) { continue }
        foreach ($location in $locations) {
            if (!$location.displayName) { continue }
            $CheckExisting = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -tenantid $TenantFilter -asApp $true
            if ($Location.displayName -in $CheckExisting.displayName) {
                [pscustomobject]@{
                    id         = ($CheckExisting | Where-Object -Property displayName -EQ $Location.displayName).id
                    name       = ($CheckExisting | Where-Object -Property displayName -EQ $Location.displayName).displayName
                    templateId = $location.id
                }
                Write-LogMessage -Tenant $TenantFilter -Headers $User -API $APINAME -message "Matched a CA policy with the existing Named Location: $($location.displayName)" -Sev 'Info'

            } else {
                if ($location.countriesAndRegions) { $location.countriesAndRegions = @($location.countriesAndRegions) }
                $location | Select-Object * -ExcludeProperty id
                Remove-ODataProperties -Object $location
                $Body = ConvertTo-Json -InputObject $Location
                $GraphRequest = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -body $body -Type POST -tenantid $tenantfilter -asApp $true
                $retryCount = 0
                do {
                    Write-Host "Checking for location $($GraphRequest.id) attempt $retryCount. $TenantFilter"
                    $LocationRequest = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -tenantid $tenantfilter -asApp $true | Where-Object -Property id -EQ $GraphRequest.id
                    Write-Host "LocationRequest: $($LocationRequest.id)"
                    Start-Sleep -Seconds 2
                    $retryCount++
                } while ((!$LocationRequest -or !$LocationRequest.id) -and ($retryCount -lt 5))
                Write-LogMessage -Tenant $TenantFilter -Headers $User -API $APINAME -message "Created new Named Location: $($location.displayName)" -Sev 'Info'
                [pscustomobject]@{
                    id   = $GraphRequest.id
                    name = $GraphRequest.displayName
                }
            }
        }
    }
    Write-Information 'Location Lookup Table:'
    Write-Information ($LocationLookupTable | ConvertTo-Json -Depth 10)

    foreach ($location in $JSONobj.conditions.locations.includeLocations) {
        $lookup = $LocationLookupTable | Where-Object { $_.name -eq $location -or $_.displayName -eq $location -or $_.templateId -eq $location }
        if (!$lookup) { continue }
        Write-Information "Replacing named location - $location"
        $index = [array]::IndexOf($JSONobj.conditions.locations.includeLocations, $location)
        $JSONobj.conditions.locations.includeLocations[$index] = $lookup.id
    }

    foreach ($location in $JSONobj.conditions.locations.excludeLocations) {
        $lookup = $LocationLookupTable | Where-Object { $_.name -eq $location -or $_.displayName -eq $location -or $_.templateId -eq $location }
        if (!$lookup) { continue }
        Write-Information "Replacing named location - $location"
        $index = [array]::IndexOf($JSONobj.conditions.locations.excludeLocations, $location)
        $JSONobj.conditions.locations.excludeLocations[$index] = $lookup.id
    }
    switch ($ReplacePattern) {
        'none' {
            Write-Information 'Replacement pattern for inclusions and exclusions is none'
            break
        }
        'AllUsers' {
            Write-Information 'Replacement pattern for inclusions and exclusions is All users. This policy will now apply to everyone.'
            if ($JSONobj.conditions.users.includeUsers -ne 'All') { $JSONobj.conditions.users.includeUsers = @('All') }
            if ($JSONobj.conditions.users.excludeUsers) { $JSONobj.conditions.users.excludeUsers = @() }
            if ($JSONobj.conditions.users.includeGroups) { $JSONobj.conditions.users.includeGroups = @() }
            if ($JSONobj.conditions.users.excludeGroups) { $JSONobj.conditions.users.excludeGroups = @() }
        }
        'displayName' {
            $TemplatesTable = Get-CIPPTable -tablename 'templates'
            $GroupTemplates = Get-CIPPAzDataTableEntity @TemplatesTable -filter "PartitionKey eq 'GroupTemplate'" | ForEach-Object {
                if ($_.JSON -and (Test-Json -Json $_.JSON -ErrorAction SilentlyContinue)) {
                    $Group = $_.JSON | ConvertFrom-Json
                    $Group
                }
            }
            try {
                Write-Information 'Replacement pattern for inclusions and exclusions is displayName.'
                $Requests = @(
                    @{
                        url    = 'users?$select=id,displayName&$top=999'
                        method = 'GET'
                        id     = 'users'
                    }
                    @{
                        url    = 'groups?$select=id,displayName&$top=999'
                        method = 'GET'
                        id     = 'groups'
                    }
                )
                $BulkResults = New-GraphBulkRequest -Requests $Requests -tenantid $TenantFilter -asapp $true

                $users = ($BulkResults | Where-Object { $_.id -eq 'users' }).body.value
                $groups = ($BulkResults | Where-Object { $_.id -eq 'groups' }).body.value

                foreach ($userType in 'includeUsers', 'excludeUsers') {
                    if ($JSONobj.conditions.users.PSObject.Properties.Name -contains $userType -and $JSONobj.conditions.users.$userType -notin 'All', 'None', 'GuestOrExternalUsers') {
                        $JSONobj.conditions.users.$userType = @(Replace-UserNameWithId -userNames $JSONobj.conditions.users.$userType)
                    }
                }

                # Check the included and excluded groups
                foreach ($groupType in 'includeGroups', 'excludeGroups') {
                    if ($JSONobj.conditions.users.PSObject.Properties.Name -contains $groupType) {
                        $JSONobj.conditions.users.$groupType = @(Replace-GroupNameWithId -groupNames $JSONobj.conditions.users.$groupType -CreateGroups $CreateGroups -TenantFilter $TenantFilter -GroupTemplates $GroupTemplates)
                    }
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $TenantFilter -message "Failed to replace displayNames for conditional access rule $($JSONobj.displayName). Error: $($ErrorMessage.NormalizedError)" -sev 'Error' -LogData $ErrorMessage
                throw "Failed to replace displayNames for conditional access rule $($JSONobj.displayName): $($ErrorMessage.NormalizedError)"
            }
        }
    }
    $JSONobj.PSObject.Properties.Remove('LocationInfo')
    foreach ($condition in $JSONobj.conditions.users.PSObject.Properties.Name) {
        $value = $JSONobj.conditions.users.$condition
        if ($null -eq $value) {
            $JSONobj.conditions.users.$condition = @()
            continue
        }
        if ($value -is [string]) {
            if ([string]::IsNullOrWhiteSpace($value)) {
                $JSONobj.conditions.users.$condition = @()
                continue
            }
        }
        if ($value -is [array]) {
            $nonWhitespaceItems = $value | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
            if ($nonWhitespaceItems.Count -eq 0) {
                $JSONobj.conditions.users.$condition = @()
                continue
            }
        }
    }
    if ($DisableSD -eq $true) {
        #Send request to disable security defaults.
        $body = '{ "isEnabled": false }'
        try {
            $null = New-GraphPostRequest -tenantid $TenantFilter -Uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -Type patch -Body $body -asApp $true -ContentType 'application/json'
            Write-LogMessage -Headers $User -API 'Create CA Policy' -tenant $TenantFilter -message "Disabled Security Defaults for tenant $($TenantFilter)" -Sev 'Info'
            Start-Sleep 3
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Information "Failed to disable security defaults for tenant $($TenantFilter): $($ErrorMessage.NormalizedError)"
        }
    }
    $RawJSON = ConvertTo-Json -InputObject $JSONobj -Depth 10 -Compress
    Write-Information $RawJSON
    try {
        Write-Information 'Checking for existing policies'
        $CheckExisting = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies' -tenantid $TenantFilter -asApp $true | Where-Object -Property displayName -EQ $displayname
        if ($CheckExisting) {
            if ($Overwrite -ne $true) {
                throw "Conditional Access Policy with Display Name $($Displayname) Already exists"
                return $false
            } else {
                if ($State -eq 'donotchange') {
                    $JSONobj.state = $CheckExisting.state
                    $RawJSON = ConvertTo-Json -InputObject $JSONobj -Depth 10 -Compress
                }
                # Preserve any exclusion groups named "Vacation Exclusion - <PolicyDisplayName>" from existing policy
                try {
                    $ExistingVacationGroup = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/groups?`$filter=startsWith(displayName,'Vacation Exclusion')&`$select=id,displayName&`$top=999&`$count=true" -ComplexFilter -tenantid $TenantFilter -asApp $true |
                        Where-Object { $CheckExisting.conditions.users.excludeGroups -contains $_.id }
                    if ($ExistingVacationGroup) {
                        if (-not ($JSONobj.conditions.users.PSObject.Properties.Name -contains 'excludeGroups')) {
                            $JSONobj.conditions.users | Add-Member -NotePropertyName 'excludeGroups' -NotePropertyValue @() -Force
                        }
                        if ($JSONobj.conditions.users.excludeGroups -notcontains $ExistingVacationGroup.id) {
                            Write-Information "Preserving vacation exclusion group $($ExistingVacationGroup.displayName)"
                            $NewExclusions = [system.collections.generic.list[string]]::new()
                            # Convert each item to string explicitly to avoid type conversion issues
                            foreach ($group in $JSONobj.conditions.users.excludeGroups) {
                                $NewExclusions.Add([string]$group)
                            }
                            $NewExclusions.Add($ExistingVacationGroup.id)
                            $JSONobj.conditions.users.excludeGroups = $NewExclusions
                        }
                        # Re-render RawJSON after modification
                        $RawJSON = ConvertTo-Json -InputObject $JSONobj -Depth 10 -Compress
                    }
                } catch {
                    Write-Information "Failed to preserve vacation exclusion group: $($_.Exception.Message)"
                }
                Write-Information "overwriting $($CheckExisting.id)"
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($CheckExisting.id)" -tenantid $tenantfilter -type PATCH -body $RawJSON -asApp $true
                Write-LogMessage -Headers $User -API 'Create CA Policy' -tenant $($Tenant) -message "Updated Conditional Access Policy $($JSONobj.Displayname) to the template standard." -Sev 'Info'
                return "Updated policy $displayname for $tenantfilter"
            }
        } else {
            Write-Information 'Creating new policy'
            if ($JSOObj.GrantControls.authenticationStrength.policyType -or $JSONobj.$JSONobj.LocationInfo) {
                Start-Sleep 3
            }
            $null = New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies' -tenantid $tenantfilter -type POST -body $RawJSON -asApp $true
            Write-LogMessage -Headers $User -API 'Create CA Policy' -tenant $($Tenant) -message "Added Conditional Access Policy $($JSONobj.Displayname)" -Sev 'Info'
            return "Created policy $displayname for $tenantfilter"
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $TenantFilter -message "Failed to create or update conditional access rule $($JSONobj.displayName): $($ErrorMessage.NormalizedError) " -sev 'Error' -LogData $ErrorMessage

        Write-Warning "Failed to create or update conditional access rule $($JSONobj.displayName): $($ErrorMessage.NormalizedError)"
        Write-Information $_.InvocationInfo.PositionMessage
        Write-Information ($JSONobj | ConvertTo-Json -Depth 10)
        throw "Failed to create or update conditional access rule $($JSONobj.displayName): $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/New-CIPPCAPolicy.ps1' 374
#Region './Public/New-CIPPCATemplate.ps1' -1

function New-CIPPCATemplate {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $JSON,
        $APIName = 'Add CIPP CA Template',
        $Headers
    )

    $JSON = ([pscustomobject]$JSON) | ForEach-Object {
        $NonEmptyProperties = $_.psobject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
        $_ | Select-Object -Property $NonEmptyProperties
    }
    $users = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$top=999&`$select=displayName,id" -tenantid $TenantFilter)
    $groups = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups?`$top=999&`$select=displayName,id" -tenantid $TenantFilter)
    $includelocations = New-Object System.Collections.ArrayList
    $IncludeJSON = foreach ($Location in $JSON.conditions.locations.includeLocations) {
        $locationinfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -tenantid $TenantFilter | Where-Object -Property id -EQ $location | Select-Object * -ExcludeProperty id, *time*
        $null = if ($locationinfo) { $includelocations.add($locationinfo.displayName) } else { $includelocations.add($location) }
        $locationinfo
    }
    if ($includelocations) { $JSON.conditions.locations.includeLocations = $includelocations }


    $excludelocations = New-Object System.Collections.ArrayList
    $ExcludeJSON = foreach ($Location in $JSON.conditions.locations.excludeLocations) {
        $locationinfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations' -tenantid $TenantFilter | Where-Object -Property id -EQ $location | Select-Object * -ExcludeProperty id, *time*
        $null = if ($locationinfo) { $excludelocations.add($locationinfo.displayName) } else { $excludelocations.add($location) }
        $locationinfo
    }

    if ($excludelocations) { $JSON.conditions.locations.excludeLocations = $excludelocations }
    if ($JSON.conditions.users.includeUsers) {
        $JSON.conditions.users.includeUsers = @($JSON.conditions.users.includeUsers | ForEach-Object {
                $originalID = $_
                if ($_ -in 'All', 'None', 'GuestOrExternalUsers') { return $_ }
                try {
                    ($users | Where-Object { $_.id -eq $_ }).displayName
                } catch {
                    return $originalID
                }
            })
    }

    if ($JSON.conditions.users.excludeUsers) {
        $JSON.conditions.users.excludeUsers = @($JSON.conditions.users.excludeUsers | ForEach-Object {
                if ($_ -in 'All', 'None', 'GuestOrExternalUsers') { return $_ }
                $originalID = $_

                try {
                    ($users | Where-Object { $_.id -eq $_ }).displayName
                } catch {
                    return $originalID
                }
            })
    }

    # Function to check if a string is a GUID
    function Test-IsGuid($string) {
        return [guid]::tryparse($string, [ref][guid]::Empty)
    }

    if ($JSON.conditions.users.includeGroups) {
        $JSON.conditions.users.includeGroups = @($JSON.conditions.users.includeGroups | ForEach-Object {
                $originalID = $_
                if ($_ -in 'All', 'None', 'GuestOrExternalUsers' -or -not (Test-IsGuid $_)) { return $_ }
                try {
                    ($groups | Where-Object { $_.id -eq $_ }).displayName
                } catch {
                    return $originalID
                }
            })
    }
    if ($JSON.conditions.users.excludeGroups) {
        $JSON.conditions.users.excludeGroups = @($JSON.conditions.users.excludeGroups | ForEach-Object {
                $originalID = $_

                if ($_ -in 'All', 'None', 'GuestOrExternalUsers' -or -not (Test-IsGuid $_)) { return $_ }
                try {
                    ($groups | Where-Object { $_.id -eq $_ }).displayName
                } catch {
                    return $originalID

                }
            })
    }

    $JSON | Add-Member -NotePropertyName 'LocationInfo' -NotePropertyValue @($IncludeJSON, $ExcludeJSON)

    $JSON = (ConvertTo-Json -Compress -Depth 100 -InputObject $JSON)
    return $JSON
}

#EndRegion './Public/New-CIPPCATemplate.ps1' 94
#Region './Public/New-CIPPDeviceAction.ps1' -1

function New-CIPPDeviceAction {
    [CmdletBinding()]
    param(
        $Action,
        $ActionBody = '{}',
        $DeviceFilter,
        $TenantFilter,
        $Headers,
        $APIName
    )
    try {
        if ($Action -eq 'delete') {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices/$DeviceFilter" -type DELETE -tenantid $TenantFilter
        } elseif ($Action -eq 'users') {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices('$DeviceFilter')/$($Action)/`$ref" -type POST -tenantid $TenantFilter -body $ActionBody
            $regex = "(?<=\(')([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})(?='|\))"
            $PrimaryUser = $ActionBody | Select-String -Pattern $regex -AllMatches | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
            $Result = "Changed primary user on device $DeviceFilter to $PrimaryUser"
        } else {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/managedDevices('$DeviceFilter')/$($Action)" -type POST -tenantid $TenantFilter -body $ActionBody
            $Result = "Queued $Action on $DeviceFilter"
        }

        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Info
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to queue action $Action on $DeviceFilter : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev Error -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/New-CIPPDeviceAction.ps1' 33
#Region './Public/New-CIPPGroup.ps1' -1

function New-CIPPGroup {
    <#
    .SYNOPSIS
    Creates a new group in Microsoft 365 or Exchange Online

    .DESCRIPTION
    Unified function for creating groups that handles all group types consistently.
    Used by both direct group creation and group template application.

    .PARAMETER GroupObject
    Object containing group properties (displayName, description, groupType, etc.)

    .PARAMETER TenantFilter
    The tenant domain name where the group should be created

    .PARAMETER APIName
    The API name for logging purposes

    .PARAMETER ExecutingUser
    The user executing the request (for logging)

    .EXAMPLE
    New-CIPPGroup -GroupObject $GroupData -TenantFilter 'contoso.com' -APIName 'AddGroup'

    .NOTES
    Supports all group types: Generic, Security, AzureRole, Dynamic, M365, Distribution, DynamicDistribution
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$GroupObject,

        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $false)]
        [string]$APIName = 'New-CIPPGroup',

        [Parameter(Mandatory = $false)]
        [string]$ExecutingUser = 'CIPP'
    )

    try {
        # Normalize group type for consistent handling (accept camelCase from templates)
        $NormalizedGroupType = switch -Wildcard ($GroupObject.groupType.ToLower()) {
            'mail-enabled security' { 'Security'; break }
            '*dynamicdistribution*' { 'DynamicDistribution'; break }  # Check this first before *dynamic* and *distribution*
            '*dynamic*' { 'Dynamic'; break }
            '*generic*' { 'Generic'; break }
            '*security*' { 'Security'; break }
            '*azurerole*' { 'AzureRole'; break }
            '*m365*' { 'M365'; break }
            '*unified*' { 'M365'; break }
            '*microsoft*' { 'M365'; break }
            '*distribution*' { 'Distribution'; break }
            '*mail*' { 'Distribution'; break }
            default { $GroupObject.groupType }
        }

        # Determine if this group type needs an email address
        $GroupTypesNeedingEmail = @('M365', 'Distribution', 'DynamicDistribution', 'Security')
        $NeedsEmail = $NormalizedGroupType -in $GroupTypesNeedingEmail

        # Determine email address only for group types that need it
        $Email = if ($NeedsEmail) {
            if ($GroupObject.primDomain.value) {
                "$($GroupObject.username)@$($GroupObject.primDomain.value)"
            } elseif ($GroupObject.primaryEmailAddress) {
                $GroupObject.primaryEmailAddress
            } elseif ($GroupObject.username -like '*@*') {
                # Username already contains an email address (e.g., from templates with @%tenantfilter%)
                $GroupObject.username
            } else {
                "$($GroupObject.username)@$($TenantFilter)"
            }
        } else {
            $null
        }

        # Extract local part of username if exists and remove special characters for mailNickname
        if ($GroupObject.username -like '*@*') {
            $MailNickname = ($GroupObject.username -split '@')[0]
        } else {
            $MailNickname = $GroupObject.username
        }

        # Remove forbidden characters per Microsoft 365 mailNickname requirements:
        # ASCII 0-127 only, excluding: @ () / [] ' ; : <> , SPACE and any non-ASCII
        $MailNickname = $MailNickname -replace "[@()\[\]/'`;:<>,\s]|[^\x00-\x7F]", ''

        # Ensure max length of 64 characters
        if ($MailNickname.Length -gt 64) {
            $MailNickname = $MailNickname.Substring(0, 64)
        }

        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Creating group $($GroupObject.displayName) of type $NormalizedGroupType$(if ($NeedsEmail) { " with email $Email" })" -Sev Info

        # Handle Graph API groups (Security, Generic, AzureRole, Dynamic, M365)
        if ($NormalizedGroupType -in @('Generic', 'AzureRole', 'Dynamic', 'M365')) {
            Write-Information "Creating group $($GroupObject.displayName) of type $NormalizedGroupType$(if ($NeedsEmail) { " with email $Email" })"
            $BodyParams = [PSCustomObject]@{
                'displayName'        = $GroupObject.displayName
                'description'        = $GroupObject.description
                'mailNickname'       = $MailNickname
                'mailEnabled'        = ($NormalizedGroupType -eq 'M365')
                'securityEnabled'    = $true
                'isAssignableToRole' = ($NormalizedGroupType -eq 'AzureRole')
            }

            # Handle dynamic membership
            if ($GroupObject.membershipRules) {
                $BodyParams | Add-Member -NotePropertyName 'membershipRule' -NotePropertyValue $GroupObject.membershipRules
                $BodyParams | Add-Member -NotePropertyName 'membershipRuleProcessingState' -NotePropertyValue 'On'

                if ($NormalizedGroupType -eq 'M365') {
                    $BodyParams | Add-Member -NotePropertyName 'groupTypes' -NotePropertyValue @('Unified', 'DynamicMembership')
                    $BodyParams.mailEnabled = $true
                } else {
                    $BodyParams | Add-Member -NotePropertyName 'groupTypes' -NotePropertyValue @('DynamicMembership')
                }

                # Skip adding static members for dynamic groups
                $SkipStaticMembers = $true
            } elseif ($NormalizedGroupType -eq 'M365') {
                # Static M365 group
                $BodyParams | Add-Member -NotePropertyName 'groupTypes' -NotePropertyValue @('Unified')
                $BodyParams.mailEnabled = $true
            }

            # Add owners
            if ($GroupObject.owners -and $GroupObject.owners.Count -gt 0) {
                $OwnerBindings = $GroupObject.owners | ForEach-Object {
                    if ($_.value) {
                        "https://graph.microsoft.com/v1.0/users/$($_.value)"
                    } elseif ($_ -is [string]) {
                        "https://graph.microsoft.com/v1.0/users/$_"
                    }
                } | Where-Object { $_ }

                if ($OwnerBindings) {
                    $BodyParams | Add-Member -NotePropertyName 'owners@odata.bind' -NotePropertyValue @($OwnerBindings)
                }
            }

            # Add members (only for non-dynamic groups)
            if ($GroupObject.members -and $GroupObject.members.Count -gt 0 -and -not $SkipStaticMembers) {
                $MemberBindings = $GroupObject.members | ForEach-Object {
                    if ($_.value) {
                        "https://graph.microsoft.com/v1.0/users/$($_.value)"
                    } elseif ($_ -is [string]) {
                        "https://graph.microsoft.com/v1.0/users/$_"
                    }
                } | Where-Object { $_ }

                if ($MemberBindings) {
                    $BodyParams | Add-Member -NotePropertyName 'members@odata.bind' -NotePropertyValue @($MemberBindings)
                }
            }

            # Create the group via Graph API
            $GraphRequest = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/groups' -tenantid $TenantFilter -type POST -body (ConvertTo-Json -InputObject $BodyParams -Depth 10)

            $Result = [PSCustomObject]@{
                Success   = $true
                Message   = "Successfully created group $($GroupObject.displayName)"
                GroupId   = $GraphRequest.id
                GroupType = $NormalizedGroupType
                Email     = if ($NeedsEmail) { $Email } else { $null }
            }
            if ($GroupObject.subscribeMembers) {
                #Waiting for group to become available in Exo.
                Start-Sleep -Seconds 10
                $SubParams = @{
                    Identity                  = $GraphRequest.id
                    'autoSubscribeNewMembers' = $true
                }
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-UnifiedGroup' -cmdParams $SubParams
            }
        } else {
            # Handle Exchange Online groups (Distribution, DynamicDistribution)

            if ($NormalizedGroupType -eq 'DynamicDistribution') {
                Write-Information "Creating dynamic distribution group $($GroupObject.displayName) with email $Email"
                $ExoParams = @{
                    Name               = $GroupObject.displayName
                    RecipientFilter    = $GroupObject.membershipRules
                    PrimarySmtpAddress = $Email
                }
                $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-DynamicDistributionGroup' -cmdParams $ExoParams

                # Set external sender restrictions if specified
                if ($null -ne $GroupObject.allowExternal -and $GroupObject.allowExternal -eq $true -and $GraphRequest.Identity) {
                    $SetParams = @{
                        RequireSenderAuthenticationEnabled = [bool]!$GroupObject.allowExternal
                        Identity                           = $GraphRequest.Identity
                    }
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-DynamicDistributionGroup' -cmdParams $SetParams
                }

            } else {
                # Regular Distribution Group
                Write-Information "Creating distribution group $($GroupObject.displayName) with email $Email"

                $ExoParams = @{
                    Name                               = $GroupObject.displayName
                    Alias                              = $MailNickname
                    Description                        = $GroupObject.description
                    PrimarySmtpAddress                 = $Email
                    Type                               = $GroupObject.groupType
                    RequireSenderAuthenticationEnabled = [bool]!$GroupObject.allowExternal
                }

                if ($NormalizedGroupType -eq 'Security') {
                    $ExoParams.Type = 'Security'
                }

                # Add owners
                if ($GroupObject.owners -and $GroupObject.owners.Count -gt 0) {
                    $OwnerEmails = $GroupObject.owners | ForEach-Object {
                        if ($_.value) { $_.value } elseif ($_ -is [string]) { $_ }
                    } | Where-Object { $_ }

                    if ($OwnerEmails) {
                        $ExoParams.ManagedBy = @($OwnerEmails)
                    }
                }

                # Add members
                if ($GroupObject.members -and $GroupObject.members.Count -gt 0) {
                    $MemberEmails = $GroupObject.members | ForEach-Object {
                        if ($_.value) { $_.value } elseif ($_ -is [string]) { $_ }
                    } | Where-Object { $_ }

                    if ($MemberEmails) {
                        $ExoParams.Members = @($MemberEmails)
                    }
                }

                $GraphRequest = New-ExoRequest -tenantid $TenantFilter -cmdlet 'New-DistributionGroup' -cmdParams $ExoParams
            }

            $Result = [PSCustomObject]@{
                Success   = $true
                Message   = "Successfully created group $($GroupObject.displayName)"
                GroupId   = $GraphRequest.Identity
                GroupType = $NormalizedGroupType
                Email     = $Email
            }
        }

        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Created group $($GroupObject.displayName) with id $($Result.GroupId)" -Sev Info
        return $Result

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API $APIName -tenant $TenantFilter -message "Group creation failed for $($GroupObject.displayName): $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage

        return [PSCustomObject]@{
            Success   = $false
            Message   = "Failed to create group $($GroupObject.displayName): $($ErrorMessage.NormalizedError)"
            Error     = $ErrorMessage.NormalizedError
            GroupType = $NormalizedGroupType
        }
    }
}
#EndRegion './Public/New-CIPPGroup.ps1' 266
#Region './Public/New-CIPPIntuneTemplate.ps1' -1

function New-CIPPIntuneTemplate {
    param(
        $urlname,
        $id,
        $TenantFilter,
        $ActionResults,
        $CIPPURL,
        $ODataType
    )
    if ($ODataType) {
        switch -wildcard ($ODataType) {
            '*CompliancePolicy' {
                $URLName = 'deviceCompliancePolicies'
            }
            '*managedAppPolicies' {
                $URLName = 'managedAppPolicies'
            }
            '*configurationPolicies' {
                $URLName = 'configurationPolicies'
            }
            '*windowsDriverUpdateProfiles' {
                $URLName = 'windowsDriverUpdateProfiles'
            }
            '*deviceConfigurations' {
                $URLName = 'deviceConfigurations'
            }
            '*groupPolicyConfigurations' {
                $URLName = 'groupPolicyConfigurations'
            }
        }
    }
    switch ($URLName) {
        'deviceCompliancePolicies' {
            $Type = 'deviceCompliancePolicies'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)?`$expand=scheduledActionsForRule(`$expand=scheduledActionConfigurations)" -tenantid $TenantFilter
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'managedAppPolicies' {
            $Type = 'AppProtection'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/$($urlname)('$($ID)')" -tenantid $TenantFilter
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'mobileAppConfigurations' {
            $Type = 'AppConfiguration'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/$($urlname)('$($ID)')" -tenantid $TenantFilter
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'configurationPolicies' {
            $Type = 'Catalog'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)('$($ID)')?`$expand=settings" -tenantid $TenantFilter | Select-Object name, description, settings, platforms, technologies, templateReference
            $TemplateJson = $Template | ConvertTo-Json -Depth 100
            $DisplayName = $Template.name

        }
        'windowsDriverUpdateProfiles' {
            $Type = 'windowsDriverUpdateProfiles'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)" -tenantid $TenantFilter | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'deviceConfigurations' {
            $Type = 'Device'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)" -tenantid $TenantFilter | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'groupPolicyConfigurations' {
            $Type = 'Admin'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)('$($ID)')" -tenantid $TenantFilter
            $DisplayName = $Template.displayName
            $TemplateJsonItems = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)('$($ID)')/definitionValues?`$expand=definition" -tenantid $TenantFilter
            $TemplateJsonSource = foreach ($TemplateJsonItem in $TemplateJsonItems) {
                $presentationValues = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)('$($ID)')/definitionValues('$($TemplateJsonItem.id)')/presentationValues?`$expand=presentation" -tenantid $TenantFilter | ForEach-Object {
                    $obj = $_
                    if ($obj.id) {
                        $PresObj = @{
                            id                        = $obj.id
                            'presentation@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($TemplateJsonItem.definition.id)')/presentations('$($obj.presentation.id)')"
                        }
                        if ($obj.values) { $PresObj['values'] = $obj.values }
                        if ($obj.value) { $PresObj['value'] = $obj.value }
                        if ($obj.'@odata.type') { $PresObj['@odata.type'] = $obj.'@odata.type' }
                        [pscustomobject]$PresObj
                    }
                }
                [PSCustomObject]@{
                    'definition@odata.bind' = "https://graph.microsoft.com/beta/deviceManagement/groupPolicyDefinitions('$($TemplateJsonItem.definition.id)')"
                    enabled                 = $TemplateJsonItem.enabled
                    presentationValues      = @($presentationValues)
                }
            }
            $inputvar = [pscustomobject]@{
                added      = @($TemplateJsonSource)
                updated    = @()
                deletedIds = @()

            }


            $TemplateJson = (ConvertTo-Json -InputObject $inputvar -Depth 100 -Compress)
        }
        'windowsFeatureUpdateProfiles' {
            $Type = 'windowsFeatureUpdateProfiles'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)" -tenantid $TenantFilter | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'windowsQualityUpdatePolicies' {
            $Type = 'windowsQualityUpdatePolicies'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)" -tenantid $TenantFilter | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
        'windowsQualityUpdateProfiles' {
            $Type = 'windowsQualityUpdateProfiles'
            $Template = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/$($urlname)/$($ID)" -tenantid $TenantFilter | Select-Object * -ExcludeProperty id, lastModifiedDateTime, '@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime'
            $DisplayName = $Template.displayName
            $TemplateJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
        }
    }
    return [PSCustomObject]@{
        TemplateJson = $TemplateJson
        DisplayName  = $DisplayName
        Description  = $Template.description
        Type         = $Type
    }
}
#EndRegion './Public/New-CIPPIntuneTemplate.ps1' 131
#Region './Public/New-CIPPOneDriveShortCut.ps1' -1


function New-CIPPOneDriveShortCut {
    [CmdletBinding()]
    param (
        $Username,
        $UserId,
        $URL,
        $TenantFilter,
        $APIName = 'Create OneDrive shortcut',
        $Headers
    )
    Write-Host "Received $Username and $UserId. We're using $URL and $TenantFilter"
    try {
        $SiteInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/sites/' -tenantid $TenantFilter -asapp $true | Where-Object -Property weburl -EQ $URL
        $ListItemUniqueId = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/sites/$($SiteInfo.id)/drive?`$select=SharepointIds" -tenantid $TenantFilter -asapp $true).SharePointIds
        $body = [PSCustomObject]@{
            name                                = 'Documents'
            remoteItem                          = @{
                sharepointIds = @{
                    listId           = $($ListItemUniqueId.listid)
                    listItemUniqueId = 'root'
                    siteId           = $($ListItemUniqueId.siteId)
                    siteUrl          = $($ListItemUniqueId.siteUrl)
                    webId            = $($ListItemUniqueId.webId)
                }
            }
            '@microsoft.graph.conflictBehavior' = 'rename'
        } | ConvertTo-Json -Depth 10
        New-GraphPOSTRequest -method POST "https://graph.microsoft.com/beta/users/$Username/drive/root/children" -body $Body -tenantid $TenantFilter -asapp $true
        Write-LogMessage -API $APIName -headers $Headers -message "Created OneDrive shortcut called $($SiteInfo.displayName) for $($Username)" -Sev 'info'
        return "Successfully created OneDrive Shortcut for $Username called $($SiteInfo.displayName) "
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Could not add Onedrive shortcut to $Username : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        throw $Result
    }
}


#EndRegion './Public/New-CIPPOneDriveShortCut.ps1' 41
#Region './Public/New-CIPPRestore.ps1' -1

function New-CIPPRestore {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $Type = 'Scheduled',
        $RestoreValues,
        $APIName = 'CIPP Restore',
        $Headers
    )

    Write-Host "Scheduled Restore psproperties: $(([pscustomobject]$RestoreValues).psobject.Properties)"
    Write-LogMessage -headers $Headers -API $APINAME -message 'Restored backup' -Sev 'Debug'
    $RestoreData = foreach ($ScheduledBackup in ([pscustomobject]$RestoreValues).psobject.Properties.Name | Where-Object { $_ -notin 'email', 'webhook', 'psa', 'backup', 'overwrite' }) {
        New-CIPPRestoreTask -Task $ScheduledBackup -TenantFilter $TenantFilter -backup $RestoreValues.backup -overwrite $RestoreValues.overwrite -Headers $Headers -APIName $APIName
    }
    return $RestoreData
}

#EndRegion './Public/New-CIPPRestore.ps1' 19
#Region './Public/New-CIPPRestoreTask.ps1' -1

function New-CIPPRestoreTask {
    [CmdletBinding()]
    param (
        $Task,
        $TenantFilter,
        $backup,
        $overwrite,
        $APINAME,
        $Headers
    )
    $Table = Get-CippTable -tablename 'ScheduledBackup'
    $BackupData = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$backup'"
    $RestoreData = switch ($Task) {
        'CippCustomVariables' {
            Write-Host "Restore Custom Variables for $TenantFilter"
            $ReplaceTable = Get-CIPPTable -TableName 'CippReplacemap'
            $Backup = $BackupData.CippCustomVariables | ConvertFrom-Json

            $Tenant = Get-Tenants -TenantFilter $TenantFilter
            $CustomerId = $Tenant.customerId

            try {
                foreach ($variable in $Backup) {
                    $entity = @{
                        PartitionKey = $CustomerId
                        RowKey       = $variable.RowKey
                        Value        = $variable.Value
                        Description  = $variable.Description
                    }

                    if ($overwrite) {
                        Add-CIPPAzDataTableEntity @ReplaceTable -Entity $entity -Force
                        Write-LogMessage -message "Restored custom variable $($variable.RowKey) from backup" -Sev 'info'
                        "Restored custom variable $($variable.RowKey) from backup"
                    } else {
                        # Check if variable already exists
                        $existing = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$CustomerId' and RowKey eq '$($variable.RowKey)'"
                        if (!$existing) {
                            Add-CIPPAzDataTableEntity @ReplaceTable -Entity $entity -Force
                            Write-LogMessage -message "Restored custom variable $($variable.RowKey) from backup" -Sev 'info'
                            "Restored custom variable $($variable.RowKey) from backup"
                        } else {
                            Write-LogMessage -message "Custom variable $($variable.RowKey) already exists and overwrite is disabled" -Sev 'info'
                            "Custom variable $($variable.RowKey) already exists and overwrite is disabled"
                        }
                    }
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                "Could not restore Custom Variables: $ErrorMessage"
                Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Custom Variables: $ErrorMessage" -Sev 'Error'
            }
        }
        'users' {
            $currentUsers = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/users?$top=999&select=id,userPrincipalName' -tenantid $TenantFilter
            $backupUsers = $BackupData.users | ConvertFrom-Json
            $BackupUsers | ForEach-Object {
                try {
                    $JSON = $_ | ConvertTo-Json -Depth 100 -Compress
                    $DisplayName = $_.displayName
                    $UPN = $_.userPrincipalName
                    if ($overwrite) {
                        if ($_.id -in $currentUsers.id) {
                            New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/users/$($_.id)" -tenantid $TenantFilter -body $JSON -type PATCH
                            Write-LogMessage -message "Restored $($UPN) from backup by patching the existing object." -Sev 'info'
                            "The user existed. Restored $($UPN) from backup"
                        } else {
                            New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/users' -tenantid $TenantFilter -body $JSON -type POST
                            Write-LogMessage -message "Restored $($UPN) from backup by creating a new object." -Sev 'info'
                            "The user did not exist. Restored $($UPN) from backup"
                        }
                    }
                    if (!$overwrite) {
                        if ($_.id -notin $backupUsers.id) {
                            New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/users' -tenantid $TenantFilter -body $JSON -type POST
                            Write-LogMessage -message "Restored $($UPN) from backup" -Sev 'info'
                            "Restored $($UPN) from backup"
                        } else {
                            Write-LogMessage -message "User $($UPN) already exists in tenant $TenantFilter and overwrite is disabled" -Sev 'info'
                            "User $($UPN) already exists in tenant $TenantFilter and overwrite is disabled"
                        }
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore user $($UPN): $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore user $($UPN): $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }
        'groups' {
            Write-Host "Restore groups for $TenantFilter"
            $backupGroups = $BackupData.groups | ConvertFrom-Json
            $Groups = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups?$top=999' -tenantid $TenantFilter
            $BackupGroups | ForEach-Object {
                try {
                    $JSON = $_ | ConvertTo-Json -Depth 100 -Compress
                    $DisplayName = $_.displayName
                    if ($overwrite) {
                        if ($_.id -in $Groups.id) {
                            New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/groups/$($_.id)" -tenantid $TenantFilter -body $JSON -type PATCH
                            Write-LogMessage -message "Restored $DisplayName from backup by patching the existing object." -Sev 'info'
                            "The group existed. Restored $DisplayName from backup"
                        } else {
                            New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/groups' -tenantid $TenantFilter -body $JSON -type POST
                            Write-LogMessage -message "Restored $DisplayName from backup" -Sev 'info'
                            "Restored $DisplayName from backup"
                        }
                    }
                    if (!$overwrite) {
                        if ($_.id -notin $Groups.id) {
                            New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/groups' -tenantid $TenantFilter -body $JSON -type POST
                            Write-LogMessage -message "Restored $DisplayName from backup" -Sev 'info'
                            "Restored $DisplayName from backup"
                        } else {
                            Write-LogMessage -message "Group $DisplayName already exists in tenant $TenantFilter and overwrite is disabled" -Sev 'info'
                            "Group $DisplayName already exists in tenant $TenantFilter and overwrite is disabled"
                        }
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore group $DisplayName : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore group $DisplayName : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }
        'ca' {
            Write-Host "Restore Conditional Access Policies for $TenantFilter"
            $BackupCAPolicies = $BackupData.ca | ConvertFrom-Json
            $BackupCAPolicies | ForEach-Object {
                $JSON = $_
                try {
                    New-CIPPCAPolicy -replacePattern 'displayName' -Overwrite $overwrite -TenantFilter $TenantFilter -state 'donotchange' -RawJSON $JSON -APIName 'CIPP Restore' -ErrorAction SilentlyContinue
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Conditional Access Policy $DisplayName : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Conditional Access Policy $DisplayName : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }
        'intuneconfig' {
            $BackupConfig = $BackupData.intuneconfig | ConvertFrom-Json
            foreach ($backup in $backupConfig) {
                try {
                    Set-CIPPIntunePolicy -TemplateType $backup.Type -TenantFilter $TenantFilter -DisplayName $backup.DisplayName -Description $backup.Description -RawJSON ($backup.TemplateJson) -Headers $Headers -APINAME $APINAME -ErrorAction SilentlyContinue
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Intune Configuration $DisplayName : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Intune Configuration $DisplayName : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
            #Convert the manual method to a function
        }
        'intunecompliance' {
            $BackupConfig = $BackupData.intunecompliance | ConvertFrom-Json
            foreach ($backup in $backupConfig) {
                try {
                    Set-CIPPIntunePolicy -TemplateType $backup.Type -TenantFilter $TenantFilter -DisplayName $backup.DisplayName -Description $backup.Description -RawJSON ($backup.TemplateJson) -Headers $Headers -APINAME $APINAME -ErrorAction SilentlyContinue
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Intune Compliance $DisplayName : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Intune Configuration $DisplayName : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }

        }

        'intuneprotection' {
            $BackupConfig = $BackupData.intuneprotection | ConvertFrom-Json
            foreach ($backup in $backupConfig) {
                try {
                    Set-CIPPIntunePolicy -TemplateType $backup.Type -TenantFilter $TenantFilter -DisplayName $backup.DisplayName -Description $backup.Description -RawJSON ($backup.TemplateJson) -Headers $Headers -APINAME $APINAME -ErrorAction SilentlyContinue
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Intune Protection $DisplayName : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Intune Configuration $DisplayName : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }

        }

        'antispam' {
            try {
                $BackupConfig = $BackupData.antispam | ConvertFrom-Json | ConvertFrom-Json
                $BackupPolicies = $BackupConfig.policies
                $BackupRules = $BackupConfig.rules
                $CurrentPolicies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
                $CurrentRules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-HostedContentFilterRule' | Select-Object * -ExcludeProperty *odata*, *data.type*
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                "Could not obtain Anti-Spam Configuration: $($ErrorMessage.NormalizedError) "
                Write-LogMessage -Headers $Headers -API $APINAME -message "Could not obtain Anti-Spam Configuration: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
            }

            $policyparams = @(
                'AddXHeaderValue',
                'AdminDisplayName',
                'AllowedSenderDomains',
                'AllowedSenders',
                'BlockedSenderDomains',
                'BlockedSenders',
                'BulkQuarantineTag',
                'BulkSpamAction',
                'BulkThreshold',
                'DownloadLink',
                'EnableEndUserSpamNotifications',
                'EnableLanguageBlockList',
                'EnableRegionBlockList',
                'EndUserSpamNotificationCustomFromAddress',
                'EndUserSpamNotificationCustomFromName',
                'EndUserSpamNotificationCustomSubject',
                'EndUserSpamNotificationFrequency',
                'EndUserSpamNotificationLanguage',
                'EndUserSpamNotificationLimit',
                'HighConfidencePhishAction',
                'HighConfidencePhishQuarantineTag',
                'HighConfidenceSpamAction',
                'HighConfidenceSpamQuarantineTag',
                'IncreaseScoreWithBizOrInfoUrls',
                'IncreaseScoreWithImageLinks',
                'IncreaseScoreWithNumericIps',
                'IncreaseScoreWithRedirectToOtherPort',
                'InlineSafetyTipsEnabled',
                'IntraOrgFilterState',
                'LanguageBlockList',
                'MarkAsSpamBulkMail',
                'MarkAsSpamEmbedTagsInHtml',
                'MarkAsSpamEmptyMessages',
                'MarkAsSpamFormTagsInHtml',
                'MarkAsSpamFramesInHtml',
                'MarkAsSpamFromAddressAuthFail',
                'MarkAsSpamJavaScriptInHtml',
                'MarkAsSpamNdrBackscatter',
                'MarkAsSpamObjectTagsInHtml',
                'MarkAsSpamSensitiveWordList',
                'MarkAsSpamSpfRecordHardFail',
                'MarkAsSpamWebBugsInHtml',
                'ModifySubjectValue',
                'PhishQuarantineTag',
                'PhishSpamAction',
                'PhishZapEnabled',
                'QuarantineRetentionPeriod',
                'RedirectToRecipients',
                'RegionBlockList',
                'SpamAction',
                'SpamQuarantineTag',
                'SpamZapEnabled',
                'TestModeAction',
                'TestModeBccToRecipients'
            )

            $ruleparams = @(
                'Name',
                'HostedContentFilterPolicy',
                'Comments',
                'Enabled',
                'ExceptIfRecipientDomainIs',
                'ExceptIfSentTo',
                'ExceptIfSentToMemberOf',
                'Priority',
                'RecipientDomainIs',
                'SentTo',
                'SentToMemberOf'
            )

            foreach ($policy in $BackupPolicies) {
                try {
                    if ($policy.Identity -in $CurrentPolicies.Identity) {
                        if ($overwrite) {
                            $cmdparams = @{
                                Identity = $policy.Identity
                            }

                            foreach ($param in $policyparams) {
                                if ($policy.PSObject.Properties[$param]) {
                                    if ($param -eq 'IntraOrgFilterState' -and $policy.$param -eq 'Default') {
                                        $cmdparams[$param] = 'HighConfidencePhish'
                                    } else {
                                        $cmdparams[$param] = $policy.$param
                                    }
                                }
                            }

                            New-ExoRequest -TenantId $Tenantfilter -cmdlet 'Set-HostedContentFilterPolicy' -cmdparams $cmdparams -UseSystemMailbox $true

                            Write-LogMessage -message "Restored $($policy.Identity) from backup" -Sev 'info'
                            "Restored $($policy.Identity) from backup."
                        }
                    } else {
                        $cmdparams = @{
                            Name = $policy.Name
                        }

                        foreach ($param in $policyparams) {
                            if ($policy.PSObject.Properties[$param]) {
                                if ($param -eq 'IntraOrgFilterState' -and $policy.$param -eq 'Default') {
                                    $cmdparams[$param] = 'HighConfidencePhish'
                                } else {
                                    $cmdparams[$param] = $policy.$param
                                }
                            }
                        }

                        New-ExoRequest -TenantId $Tenantfilter -cmdlet 'New-HostedContentFilterPolicy' -cmdparams $cmdparams -UseSystemMailbox $true

                        Write-LogMessage -message "Restored $($policy.Identity) from backup" -Sev 'info'
                        "Restored $($policy.Identity) from backup."
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Anti-spam policy $($policy.Identity) : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Anti-spam policy $($policy.Identity) : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }

            foreach ($rule in $BackupRules) {
                try {
                    if ($rule.Identity -in $CurrentRules.Identity) {
                        if ($overwrite) {
                            $cmdparams = @{
                                Identity = $rule.Identity
                            }

                            foreach ($param in $ruleparams) {
                                if ($rule.PSObject.Properties[$param]) {
                                    if ($param -eq 'Enabled') {
                                        $cmdparams[$param] = if ($rule.State -eq 'Enabled') { $true } else { $false }
                                    } else {
                                        $cmdparams[$param] = $rule.$param
                                    }
                                }
                            }

                            New-ExoRequest -TenantId $Tenantfilter -cmdlet 'Set-HostedContentFilterRule' -cmdparams $cmdparams -UseSystemMailbox $true

                            Write-LogMessage -message "Restored $($rule.Identity) from backup" -Sev 'info'
                            "Restored $($rule.Identity) from backup."
                        }
                    } else {
                        $cmdparams = @{
                            Name = $rule.Name
                        }

                        foreach ($param in $ruleparams) {
                            if ($rule.PSObject.Properties[$param]) {
                                if ($param -eq 'Enabled') {
                                    $cmdparams[$param] = if ($rule.State -eq 'Enabled') { $true } else { $false }
                                } else {
                                    $cmdparams[$param] = $rule.$param
                                }
                            }
                        }

                        New-ExoRequest -TenantId $Tenantfilter -cmdlet 'New-HostedContentFilterRule' -cmdparams $cmdparams -UseSystemMailbox $true

                        Write-LogMessage -message "Restored $($rule.Identity) from backup" -Sev 'info'
                        "Restored $($rule.Identity) from backup."
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Anti-spam rule $($rule.Identity) : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Anti-spam rule $($rule.Identity) : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }

        'antiphishing' {
            try {
                $BackupConfig = $BackupData.antiphishing | ConvertFrom-Json | ConvertFrom-Json
                $BackupPolicies = $BackupConfig.policies
                $BackupRules = $BackupConfig.rules
                $CurrentPolicies = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-AntiPhishPolicy' | Select-Object * -ExcludeProperty *odata*, *data.type*
                $CurrentRules = New-ExoRequest -tenantid $Tenantfilter -cmdlet 'Get-AntiPhishRule' | Select-Object * -ExcludeProperty *odata*, *data.type*
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                "Could not obtain Anti-Phishing Configuration: $($ErrorMessage.NormalizedError) "
                Write-LogMessage -Headers $Headers -API $APINAME -message "Could not obtain Anti-Phishing Configuration: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
            }

            $policyparams = @(
                'AdminDisplayName',
                'AuthenticationFailAction',
                'DmarcQuarantineAction',
                'DmarcRejectAction',
                'EnableFirstContactSafetyTips',
                'EnableMailboxIntelligence',
                'EnableMailboxIntelligenceProtection',
                'EnableOrganizationDomainsProtection',
                'EnableSimilarDomainsSafetyTips',
                'EnableSimilarUsersSafetyTips',
                'EnableSpoofIntelligence',
                'EnableTargetedDomainsProtection',
                'EnableTargetedUserProtection',
                'EnableUnauthenticatedSender',
                'EnableUnusualCharactersSafetyTips',
                'EnableViaTag',
                'ExcludedDomains',
                'ExcludedSenders',
                'HonorDmarcPolicy',
                'ImpersonationProtectionState',
                'MailboxIntelligenceProtectionAction',
                'MailboxIntelligenceProtectionActionRecipients',
                'MailboxIntelligenceQuarantineTag',
                'PhishThresholdLevel',
                'SimilarUsersSafetyTipsCustomText',
                'SpoofQuarantineTag',
                'TargetedDomainActionRecipients',
                'TargetedDomainProtectionAction',
                'TargetedDomainQuarantineTag',
                'TargetedDomainsToProtect',
                'TargetedUserActionRecipients',
                'TargetedUserProtectionAction',
                'TargetedUserQuarantineTag',
                'TargetedUsersToProtect'
            )

            $ruleparams = @(
                'Name',
                'AntiPhishPolicy',
                'Comments',
                'Enabled',
                'ExceptIfRecipientDomainIs',
                'ExceptIfSentTo',
                'ExceptIfSentToMemberOf',
                'Priority',
                'RecipientDomainIs',
                'SentTo',
                'SentToMemberOf'
            )

            foreach ($policy in $BackupPolicies) {
                try {
                    if ($policy.Identity -in $CurrentPolicies.Identity) {
                        if ($overwrite) {
                            $cmdparams = @{
                                Identity = $policy.Identity
                            }

                            foreach ($param in $policyparams) {
                                if ($policy.PSObject.Properties[$param]) {
                                    $cmdparams[$param] = $policy.$param
                                }
                            }

                            New-ExoRequest -TenantId $Tenantfilter -cmdlet 'Set-AntiPhishPolicy' -cmdparams $cmdparams -UseSystemMailbox $true

                            Write-LogMessage -message "Restored $($policy.Identity) from backup" -Sev 'info'
                            "Restored $($policy.Identity) from backup."
                        }
                    } else {
                        $cmdparams = @{
                            Name = $policy.Name
                        }

                        foreach ($param in $policyparams) {
                            if ($policy.PSObject.Properties[$param]) {
                                $cmdparams[$param] = $policy.$param
                            }
                        }

                        New-ExoRequest -TenantId $Tenantfilter -cmdlet 'New-AntiPhishPolicy' -cmdparams $cmdparams -UseSystemMailbox $true

                        Write-LogMessage -message "Restored $($policy.Identity) from backup" -Sev 'info'
                        "Restored $($policy.Identity) from backup."
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Anti-phishing policy $($policy.Identity) : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Anti-phishing policy $($policy.Identity) : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }

            foreach ($rule in $BackupRules) {
                try {
                    if ($rule.Identity -in $CurrentRules.Identity) {
                        if ($overwrite) {
                            $cmdparams = @{
                                Identity = $rule.Identity
                            }

                            foreach ($param in $ruleparams) {
                                if ($rule.PSObject.Properties[$param]) {
                                    if ($param -eq 'Enabled') {
                                        $cmdparams[$param] = if ($rule.State -eq 'Enabled') { $true } else { $false }
                                    } else {
                                        $cmdparams[$param] = $rule.$param
                                    }
                                }
                            }

                            New-ExoRequest -TenantId $Tenantfilter -cmdlet 'Set-AntiPhishRule' -cmdparams $cmdparams -UseSystemMailbox $true

                            Write-LogMessage -message "Restored $($rule.Identity) from backup" -Sev 'info'
                            "Restored $($rule.Identity) from backup."
                        }
                    } else {
                        $cmdparams = @{
                            Name = $rule.Name
                        }

                        foreach ($param in $ruleparams) {
                            if ($rule.PSObject.Properties[$param]) {
                                if ($param -eq 'Enabled') {
                                    $cmdparams[$param] = if ($rule.State -eq 'Enabled') { $true } else { $false }
                                } else {
                                    $cmdparams[$param] = $rule.$param
                                }
                            }
                        }

                        New-ExoRequest -TenantId $Tenantfilter -cmdlet 'New-AntiPhishRule' -cmdparams $cmdparams -UseSystemMailbox $true

                        Write-LogMessage -message "Restored $($rule.Identity) from backup" -Sev 'info'
                        "Restored $($rule.Identity) from backup."
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    "Could not restore Anti-phishing rule $($rule.Identity) : $($ErrorMessage.NormalizedError) "
                    Write-LogMessage -Headers $Headers -API $APINAME -message "Could not restore Anti-phishing rule $($rule.Identity) : $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
                }
            }
        }
        'CippWebhookAlerts' {
            Write-Host "Restore Webhook Alerts for $TenantFilter"
            $WebhookTable = Get-CIPPTable -TableName 'WebhookRules'
            $Backup = $BackupData.CippWebhookAlerts | ConvertFrom-Json
            try {
                Add-CIPPAzDataTableEntity @WebhookTable -Entity $Backup -Force
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                "Could not restore Webhook Alerts $ErrorMessage"
            }
        }
        'CippScriptedAlerts' {
            Write-Host "Restore Scripted Alerts for $TenantFilter"
            $ScheduledTasks = Get-CIPPTable -TableName 'ScheduledTasks'
            $Backup = $BackupData.CippScriptedAlerts | ConvertFrom-Json
            try {
                Add-CIPPAzDataTableEntity @ScheduledTasks -Entity $Backup -Force
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                "Could not restore Scripted Alerts $ErrorMessage "
            }
        }
    }
    return $RestoreData
}

#EndRegion './Public/New-CIPPRestoreTask.ps1' 548
#Region './Public/New-CIPPSharepointSite.ps1' -1

function New-CIPPSharepointSite {
    <#
    .SYNOPSIS
    Create a new SharePoint site

    .DESCRIPTION
    Create a new SharePoint site using the Modern REST API

    .PARAMETER SiteName
    The name of the site

    .PARAMETER SiteDescription
    The description of the site

    .PARAMETER SiteOwner
    The username of the site owner

    .PARAMETER TemplateName
    The template to use for the site. Default is Communication

    .PARAMETER SiteDesign
    The design to use for the site. Default is Topic

    .PARAMETER WebTemplateExtensionId
    The web template extension ID to use

    .PARAMETER SensitivityLabel
    The Purview sensitivity label to apply to the site

    .PARAMETER TenantFilter
    The tenant associated with the site

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$SiteName,

        [Parameter(Mandatory = $true)]
        [string]$SiteDescription,

        [Parameter(Mandatory = $true)]
        [string]$SiteOwner,

        [Parameter(Mandatory = $false)]
        [ValidateSet('Communication', 'Team')]
        [string]$TemplateName = 'Communication',

        [Parameter(Mandatory = $false)]
        [ValidateSet('Topic', 'Showcase', 'Blank', 'Custom')]
        [string]$SiteDesign = 'Showcase',

        [Parameter(Mandatory = $false)]
        [ValidatePattern('(\{|\()?[A-Za-z0-9]{4}([A-Za-z0-9]{4}\-?){4}[A-Za-z0-9]{12}(\}|\()?')]
        [string]$WebTemplateExtensionId,

        [Parameter(Mandatory = $false)]
        [string]$SensitivityLabel,

        [string]$Classification,

        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        $APIName = 'Create SharePoint Site',
        $Headers
    )

    $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
    $SitePath = $SiteName -replace ' ' -replace '[^A-Za-z0-9-]'
    $SiteUrl = "https://$($SharePointInfo.TenantName).sharepoint.com/sites/$SitePath"

    switch ($TemplateName) {
        'Communication' {
            $WebTemplate = 'SITEPAGEPUBLISHING#0'
        }
        'Team' {
            $WebTemplate = 'STS#3'
        }
    }

    $WebTemplateExtensionId = '00000000-0000-0000-0000-000000000000'
    $DefaultSiteDesignIds = @( '96c933ac-3698-44c7-9f4a-5fd17d71af9e', '6142d2a0-63a5-4ba0-aede-d9fefca2c767', 'f6cc5403-0d63-442e-96c0-285923709ffc')

    switch ($SiteDesign) {
        'Topic' {
            $SiteDesignId = '96c933ac-3698-44c7-9f4a-5fd17d71af9e'
        }
        'Showcase' {
            $SiteDesignId = '6142d2a0-63a5-4ba0-aede-d9fefca2c767'
        }
        'Blank' {
            $SiteDesignId = 'f6cc5403-0d63-442e-96c0-285923709ffc'
        }
        'Custom' {
            if ($WebTemplateExtensionId -match '^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$') {
                if ($WebTemplateExtensionId -notin $DefaultSiteDesignIds) {
                    $WebTemplateExtensionId = $SiteDesign
                    $SiteDesignId = '00000000-0000-0000-0000-000000000000'
                } else {
                    $SiteDesignId = $WebTemplateExtensionId
                }
            } else {
                $SiteDesignId = '96c933ac-3698-44c7-9f4a-5fd17d71af9e'
            }
        }
    }

    # Create the request body
    $Request = @{
        Title                  = $SiteName
        Url                    = $SiteUrl
        Lcid                   = 1033
        ShareByEmailEnabled    = $false
        Description            = $SiteDescription
        WebTemplate            = $WebTemplate
        SiteDesignId           = $SiteDesignId
        Owner                  = $SiteOwner
        WebTemplateExtensionId = $WebTemplateExtensionId
    }

    # Set the sensitivity label if provided
    if ($SensitivityLabel) {
        $Request.SensitivityLabel = $SensitivityLabel
    }
    if ($Classification) {
        $Request.Classification = $Classification
    }

    Write-Verbose (ConvertTo-Json -InputObject $Request -Compress -Depth 10)

    $body = @{
        request = $Request
    }

    # Create the site
    if ($PSCmdlet.ShouldProcess($SiteName, 'Create new SharePoint site')) {
        $AddedHeaders = @{
            'accept'        = 'application/json;odata.metadata=none'
            'odata-version' = '4.0'
        }
        try {
            $Results = New-GraphPOSTRequest -scope "$($SharePointInfo.AdminUrl)/.default" -uri "$($SharePointInfo.AdminUrl)/_api/SPSiteManager/create" -body (ConvertTo-Json -Depth 10 -InputObject $body) -tenantid $TenantFilter -AddedHeaders $AddedHeaders
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Result = "Failed to create new SharePoint site $SiteName with URL $SiteUrl. Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error -LogData $ErrorMessage
            throw $Result
        }
    }

    # Check the results. This response is weird. https://learn.microsoft.com/en-us/sharepoint/dev/apis/site-creation-rest
    switch ($Results.SiteStatus) {
        '0' {
            $Result = "Failed to create new SharePoint site $SiteName with URL $SiteUrl. The site doesn't exist."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error
            throw $Result
        }
        '1' {
            $Result = "Successfully created new SharePoint site $SiteName with URL $SiteUrl. The site is however currently being provisioned. Please wait for it to finish."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            return $Result
        }
        '2' {
            $Result = "Successfully created new SharePoint site $SiteName with URL $SiteUrl"
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            return $Result
        }
        '3' {
            $Result = "Failed to create new SharePoint site $SiteName with URL $SiteUrl. An error occurred while provisioning the site."
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error
            throw $Result
        }
        '4' {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error
            $Result = "Failed to create new SharePoint site $SiteName with URL $SiteUrl. The site already exists."
            throw $Result
        }
        default {}
    }


}
#EndRegion './Public/New-CIPPSharepointSite.ps1' 184
#Region './Public/New-CippStandardsDriftClone.ps1' -1

function New-CippStandardsDriftClone {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string]$TemplateId,
        [Parameter(Mandatory)][switch]$UpgradeToDrift,
        $Headers
    )

    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'StandardsTemplateV2' and RowKey eq '$TemplateId'"
    $Entity = Get-CIPPAzDataTableEntity @Table -Filter $Filter
    $data = $Entity.JSON | ConvertFrom-Json
    $data.excludedTenants = @() #blank excluded Tenants
    $data.tenantFilter = @(@{ value = 'Copied Standard'; label = 'Copied Standard' })
    $data.GUID = [guid]::NewGuid().ToString()
    $data.templateName = "$($data.templateName) (Drift Clone)"
    if ($UpgradeToDrift) {
        try {
            $data | Add-Member -MemberType NoteProperty -Name 'type' -Value 'drift' -Force
            if ($null -ne $data.standards) {
                foreach ($prop in $data.standards.PSObject.Properties) {
                    $actions = $prop.Value.action
                    if ($actions -and $actions.Count -gt 0) {
                        if ($actions | Where-Object { $_.value -eq 'remediate' }) {
                            $prop.Value | Add-Member -MemberType NoteProperty -Name 'autoRemediate' -Value $true -Force
                        }
                        # Set action to Report using add-member to avoid issues with readonly arrays
                        $prop.Value | Add-Member -MemberType NoteProperty -Name 'action' -Value @(@{ 'label' = 'Report'; 'value' = 'Report' }) -Force
                    }
                }
            }
            $Entity.JSON = "$(ConvertTo-Json -InputObject $data -Compress -Depth 100)"
            $Entity.RowKey = "$($data.GUID)"
            $Entity.GUID = $data.GUID
            $update = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
            return 'Clone Completed successfully'
        } catch {
            return "Failed to Clone template to Drift Template: $_"
        }
    }
}
#EndRegion './Public/New-CippStandardsDriftClone.ps1' 42
#Region './Public/New-CIPPTAP.ps1' -1

function New-CIPPTAP {
    [CmdletBinding()]
    param (
        $UserID,
        $TenantFilter,
        $APIName = 'Create TAP',
        $Headers,
        $LifetimeInMinutes,
        [bool]$IsUsableOnce,
        $StartDateTime
    )

    try {
        # Build the request body based on provided parameters
        $RequestBody = @{}

        if ($LifetimeInMinutes) {
            $RequestBody.lifetimeInMinutes = [int]$LifetimeInMinutes
        }

        if ($null -ne $IsUsableOnce) {
            $RequestBody.isUsableOnce = $IsUsableOnce
        }

        if ($StartDateTime) {
            # Convert Unix timestamp to DateTime if it's a number
            if ($StartDateTime -match '^\d+$') {
                $dateTime = [DateTimeOffset]::FromUnixTimeSeconds([int]$StartDateTime).DateTime
                $RequestBody.startDateTime = Get-Date $dateTime -Format 'o'
            } else {
                # If it's already a date string, format it properly
                $dateTime = Get-Date $StartDateTime
                $RequestBody.startDateTime = Get-Date $dateTime -Format 'o'
            }
        }

        # Convert request body to JSON
        $BodyJson = if ($RequestBody) { $RequestBody | ConvertTo-Json } else { '{}' }
        $GraphRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserID)/authentication/temporaryAccessPassMethods" -tenantid $TenantFilter -type POST -body $BodyJson -verbose

        # Build log message parts based on actual response values
        $logParts = [System.Collections.Generic.List[string]]::new()
        $logParts.Add("Lifetime: $($GraphRequest.lifetimeInMinutes) minutes")

        $logParts.Add($GraphRequest.isUsableOnce ? 'one-time use' : 'multi-use')

        $logParts.Add($StartDateTime ? "starts at $(Get-Date $GraphRequest.startDateTime -Format 'yyyy-MM-dd HH:mm:ss') UTC" : 'starts immediately')

        # Create parameter string for logging
        $paramString = ' with ' + ($logParts -join ', ')

        Write-LogMessage -headers $Headers -API $APIName -message "Created Temporary Access Password (TAP) for $UserID$paramString" -Sev 'Info' -tenant $TenantFilter

        # Build result text with parameters
        $resultText = "The TAP for $UserID is $($GraphRequest.temporaryAccessPass) - This TAP is usable for the next $($GraphRequest.LifetimeInMinutes) minutes"
        $resultText += $GraphRequest.isUsableOnce ? ' (one-time use only)' : ''
        $resultText += $StartDateTime ? " starting at $(Get-Date $GraphRequest.startDateTime -Format 'yyyy-MM-dd HH:mm:ss') UTC" : ''

        return @{
            resultText          = $resultText
            userId              = $UserID
            copyField           = $GraphRequest.temporaryAccessPass
            temporaryAccessPass = $GraphRequest.temporaryAccessPass
            lifetimeInMinutes   = $GraphRequest.LifetimeInMinutes
            startDateTime       = $GraphRequest.startDateTime
            isUsableOnce        = $GraphRequest.isUsableOnce
            state               = 'success'
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create Temporary Access Password (TAP) for $($UserID): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}

#EndRegion './Public/New-CIPPTAP.ps1' 78
#Region './Public/New-CIPPTemplateRun.ps1' -1

function New-CIPPTemplateRun {
    [CmdletBinding()]
    param (
        $TemplateSettings,
        $TenantFilter
    )
    $Table = Get-CippTable -tablename 'templates'
    $ExistingTemplates = (Get-CIPPAzDataTableEntity @Table) | ForEach-Object {
        try {
            $data = $_.JSON | ConvertFrom-Json -ErrorAction SilentlyContinue -Depth 100
            $data | Add-Member -NotePropertyName 'GUID' -NotePropertyValue $_.RowKey -Force -ErrorAction Stop
            $data | Add-Member -NotePropertyName 'PartitionKey' -NotePropertyValue $_.PartitionKey -Force -ErrorAction Stop
            $data | Add-Member -NotePropertyName 'SHA' -NotePropertyValue $_.SHA -Force -ErrorAction Stop
            $data
        } catch {
            return
        }
    } | Sort-Object -Property displayName

    function Get-SanitizedFilename {
        param (
            [string]$filename
        )
        $filename = $filename -replace '\s', '_' -replace '[^\w\d_]', ''
        return $filename
    }

    $Tasks = foreach ($key in $TemplateSettings.Keys) {
        if ($TemplateSettings[$key] -eq $true) {
            $key
        }
    }
    if ($TemplateSettings.templateRepo) {
        Write-Information 'Grabbing data from community repo'
        try {
            $Files = (Get-GitHubFileTree -FullName $TemplateSettings.templateRepo.value -Branch $TemplateSettings.templateRepoBranch.value).tree | Where-Object { $_.path -match '.json$' -and $_.path -notmatch 'NativeImport' } | Select-Object *, @{n = 'html_url'; e = { "https://github.com/$($SplatParams.FullName)/tree/$($SplatParams.Branch)/$($_.path)" } }, @{n = 'name'; e = { ($_.path -split '/')[ -1 ] -replace '\.json$', '' } }
            #if there is a migration table file, file the file. Store the file contents in $migrationtable
            $MigrationTable = $Files | Where-Object { $_.name -eq 'MigrationTable' } | Select-Object -Last 1
            if ($MigrationTable) {
                $MigrationTable = (Get-GitHubFileContents -FullName $TemplateSettings.templateRepo.value -Branch $TemplateSettings.templateRepoBranch.value -Path $MigrationTable.path).content | ConvertFrom-Json
            }
            $NamedLocations = $Files | Where-Object { $_.name -match 'ALLOWED COUNTRIES' }
            $LocationData = foreach ($Location in $NamedLocations) {
                (Get-GitHubFileContents -FullName $TemplateSettings.templateRepo.value -Branch $TemplateSettings.templateRepoBranch.value -Path $Location.path).content | ConvertFrom-Json
            }

            foreach ($File in $Files) {
                if ($File.name -eq 'MigrationTable' -or $file.name -match 'ALLOWED COUNTRIES') { continue }
                Write-Information "Processing template file $($File.name) - Sanitized as $(Get-SanitizedFilename -filename $File.name)"
                $ExistingTemplate = $ExistingTemplates | Where-Object { (![string]::IsNullOrEmpty($_.displayName) -and (Get-SanitizedFilename -filename $_.displayName) -eq (Get-SanitizedFilename -filename $File.name)) -or (![string]::IsNullOrEmpty($_.templateName) -and (Get-SanitizedFilename -filename $_.templateName) -eq (Get-SanitizedFilename -filename $File.name) ) -and ![string]::IsNullOrEmpty($_.SHA) } | Select-Object -First 1

                $UpdateNeeded = $false
                if ($ExistingTemplate -and $ExistingTemplate.SHA -ne $File.sha) {
                    $Name = $ExistingTemplate.displayName ?? $ExistingTemplate.templateName
                    Write-Information "Existing template $($Name) found, but SHA is different. Updating template."
                    $UpdateNeeded = $true
                    "Template $($Name) needs to be updated as the SHA is different"
                } elseif ($ExistingTemplate -and $ExistingTemplate.SHA -eq $File.sha) {
                    Write-Information "Existing template $($File.name) found, but SHA is the same. No update needed."
                    "Template $($File.name) found, but SHA is the same. No update needed."
                }

                if (!$ExistingTemplate -or $UpdateNeeded) {
                    $Template = (Get-GitHubFileContents -FullName $TemplateSettings.templateRepo.value -Branch $TemplateSettings.templateRepoBranch.value -Path $File.path).content | ConvertFrom-Json
                    Import-CommunityTemplate -Template $Template -SHA $File.sha -MigrationTable $MigrationTable -LocationData $LocationData
                    if ($UpdateNeeded) {
                        Write-Information "Template $($File.name) needs to be updated as the SHA is different"
                        "Template $($File.name) updated"
                    } else {
                        Write-Information "Template $($File.name) needs to be created"
                        "Template $($File.name) created"
                    }
                }
            }
        } catch {
            $Message = "Failed to get data from community repo $($TemplateSettings.templateRepo.value). Error: $($_.Exception.Message)"
            Write-LogMessage -API 'Community Repo' -tenant $TenantFilter -message $Message -sev Error
            Write-Information $_.InvocationInfo.PositionMessage
            return "Failed to get data from community repo $($TemplateSettings.templateRepo.value). Error: $($_.Exception.Message)"
        }
    } else {
        foreach ($Task in $Tasks) {
            Write-Information "Working on task $Task"
            switch ($Task) {
                'ca' {
                    Write-Information "Template Conditional Access Policies for $TenantFilter"
                    $Policies = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/conditionalAccess/policies?$top=999' -tenantid $TenantFilter
                    Write-Information 'Creating templates for found Conditional Access Policies'
                    foreach ($policy in $policies) {
                        try {
                            $Template = New-CIPPCATemplate -TenantFilter $TenantFilter -JSON $policy
                            #check existing templates, if the displayName is the same, overwrite it.
                            $ExistingPolicy = $ExistingTemplates | Where-Object { $_.displayName -eq $policy.displayName } | Select-Object -First 1
                            if ($ExistingPolicy -and $ExistingPolicy.PartitionKey -eq 'CATemplate') {
                                "Policy $($policy.displayName) found, updating template"
                                Add-CIPPAzDataTableEntity @Table -Entity @{
                                    JSON         = "$Template"
                                    RowKey       = $ExistingPolicy.GUID
                                    PartitionKey = 'CATemplate'
                                    GUID         = $ExistingPolicy.GUID
                                } -Force
                            } else {
                                "Policy $($policy.displayName) not found in existing templates, creating new template"
                                $GUID = (New-Guid).GUID
                                Add-CIPPAzDataTableEntity @Table -Entity @{
                                    JSON         = "$Template"
                                    RowKey       = "$GUID"
                                    PartitionKey = 'CATemplate'
                                    GUID         = "$GUID"
                                }
                            }

                        } catch {
                            "Failed to create a template of the Conditional Access Policy with ID: $($policy.id). Error: $($_.Exception.Message)"
                        }
                    }
                }
                'intuneconfig' {
                    Write-Information "Backup Intune Configuration Policies for $TenantFilter"
                    $GraphURLS = @("https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations?`$select=id,displayName,lastModifiedDateTime,roleScopeTagIds,microsoft.graph.unsupportedDeviceConfiguration/originalEntityTypeName&`$expand=assignments&top=1000"
                        'https://graph.microsoft.com/beta/deviceManagement/windowsDriverUpdateProfiles'
                        "https://graph.microsoft.com/beta/deviceManagement/groupPolicyConfigurations?`$expand=assignments&top=999"
                        "https://graph.microsoft.com/beta/deviceAppManagement/mobileAppConfigurations?`$expand=assignments&`$filter=microsoft.graph.androidManagedStoreAppConfiguration/appSupportsOemConfig%20eq%20true"
                        'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'
                        'https://graph.microsoft.com/beta/deviceManagement/windowsFeatureUpdateProfiles'
                        'https://graph.microsoft.com/beta/deviceManagement/windowsQualityUpdatePolicies'
                        'https://graph.microsoft.com/beta/deviceManagement/windowsQualityUpdateProfiles'
                    )

                    $Policies = foreach ($url in $GraphURLS) {
                        try {
                            $Policies = New-GraphGetRequest -uri "$($url)" -tenantid $TenantFilter
                            $URLName = (($url).split('?') | Select-Object -First 1) -replace 'https://graph.microsoft.com/beta/deviceManagement/', ''
                            foreach ($Policy in $Policies) {
                                try {
                                    $Template = New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName $URLName -ID $Policy.ID
                                    $ExistingPolicy = $ExistingTemplates | Where-Object { $_.displayName -eq $Template.DisplayName } | Select-Object -First 1
                                    if ($ExistingPolicy -and $ExistingPolicy.PartitionKey -eq 'IntuneTemplate') {
                                        "Policy $($Template.DisplayName) found, updating template"
                                        $object = [PSCustomObject]@{
                                            Displayname = $Template.DisplayName
                                            Description = $Template.Description
                                            RAWJson     = $Template.TemplateJson
                                            Type        = $Template.Type
                                            GUID        = $ExistingPolicy.GUID
                                        } | ConvertTo-Json

                                        Add-CIPPAzDataTableEntity @Table -Entity @{
                                            JSON         = "$object"
                                            RowKey       = $ExistingPolicy.GUID
                                            PartitionKey = 'IntuneTemplate'
                                        } -Force
                                    } else {
                                        "Policy  $($Template.DisplayName) not found in existing templates, creating new template"
                                        $GUID = (New-Guid).GUID
                                        $object = [PSCustomObject]@{
                                            Displayname = $Template.DisplayName
                                            Description = $Template.Description
                                            RAWJson     = $Template.TemplateJson
                                            Type        = $Template.Type
                                            GUID        = $GUID
                                        } | ConvertTo-Json

                                        Add-CIPPAzDataTableEntity @Table -Entity @{
                                            JSON         = "$object"
                                            RowKey       = "$GUID"
                                            PartitionKey = 'IntuneTemplate'
                                        } -Force
                                    }
                                } catch {
                                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                                    "Failed to create a template of the Intune Configuration Policy with ID: $($Policy.id). Error: $ErrorMessage"
                                }
                            }
                        } catch {
                            Write-Information "Failed to backup $url"
                        }
                    }
                }
                'intunecompliance' {
                    Write-Information "Backup Intune Compliance Policies for $TenantFilter"
                    New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/deviceCompliancePolicies?$top=999' -tenantid $TenantFilter | ForEach-Object {
                        $Template = New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName 'deviceCompliancePolicies' -ID $_.ID
                        $ExistingPolicy = $ExistingTemplates | Where-Object { $_.displayName -eq $Template.DisplayName } | Select-Object -First 1
                        if ($ExistingPolicy -and $ExistingPolicy.PartitionKey -eq 'IntuneTemplate') {
                            "Policy $($Template.DisplayName) found, updating template"
                            $object = [PSCustomObject]@{
                                Displayname = $Template.DisplayName
                                Description = $Template.Description
                                RAWJson     = $Template.TemplateJson
                                Type        = $Template.Type
                                GUID        = $ExistingPolicy.GUID
                            } | ConvertTo-Json

                            Add-CIPPAzDataTableEntity @Table -Entity @{
                                JSON         = "$object"
                                RowKey       = $ExistingPolicy.GUID
                                PartitionKey = 'IntuneTemplate'
                            } -Force
                        } else {
                            "Policy  $($Template.DisplayName) not found in existing templates, creating new template"
                            $GUID = (New-Guid).GUID
                            $object = [PSCustomObject]@{
                                Displayname = $Template.DisplayName
                                Description = $Template.Description
                                RAWJson     = $Template.TemplateJson
                                Type        = $Template.Type
                                GUID        = $GUID
                            } | ConvertTo-Json

                            Add-CIPPAzDataTableEntity @Table -Entity @{
                                JSON         = "$object"
                                RowKey       = "$GUID"
                                PartitionKey = 'IntuneTemplate'
                            } -Force
                        }

                    }
                }

                'intuneprotection' {
                    Write-Information "Backup Intune Protection Policies for $TenantFilter"
                    New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceAppManagement/managedAppPolicies?$top=999' -tenantid $TenantFilter | ForEach-Object {
                        $Template = New-CIPPIntuneTemplate -TenantFilter $TenantFilter -URLName 'managedAppPolicies' -ID $_.ID
                        $ExistingPolicy = $ExistingTemplates | Where-Object { $_.displayName -eq $Template.DisplayName } | Select-Object -First 1
                        if ($ExistingPolicy -and $ExistingPolicy.PartitionKey -eq 'IntuneTemplate') {
                            "Policy $($Template.DisplayName) found, updating template"
                            $object = [PSCustomObject]@{
                                Displayname = $Template.DisplayName
                                Description = $Template.Description
                                RAWJson     = $Template.TemplateJson
                                Type        = $Template.Type
                                GUID        = $ExistingPolicy.GUID
                            } | ConvertTo-Json

                            Add-CIPPAzDataTableEntity @Table -Entity @{
                                JSON         = "$object"
                                RowKey       = $ExistingPolicy.GUID
                                PartitionKey = 'IntuneTemplate'
                            } -Force
                        } else {
                            "Policy  $($Template.DisplayName) not found in existing templates, creating new template"
                            $GUID = (New-Guid).GUID
                            $object = [PSCustomObject]@{
                                Displayname = $Template.DisplayName
                                Description = $Template.Description
                                RAWJson     = $Template.TemplateJson
                                Type        = $Template.Type
                                GUID        = $GUID
                            } | ConvertTo-Json

                            Add-CIPPAzDataTableEntity @Table -Entity @{
                                JSON         = "$object"
                                RowKey       = "$GUID"
                                PartitionKey = 'IntuneTemplate'
                            } -Force
                        }
                    }
                }

            }
        }
    }
    return $BackupData
}

#EndRegion './Public/New-CIPPTemplateRun.ps1' 267
#Region './Public/New-CippUser.ps1' -1

function New-CIPPUser {
    [CmdletBinding()]
    param (
        $UserObj,
        $Aliases = 'Scheduled',
        $RestoreValues,
        $APIName = 'New User',
        $Headers
    )

    try {
        $UserObj = $UserObj | ConvertTo-Json -Depth 10 | ConvertFrom-Json -Depth 10
        Write-Host $UserObj.PrimDomain.value
        $Aliases = ($UserObj.AddedAliases) -split '\s'
        $password = if ($UserObj.password) { $UserObj.password } else { New-passwordString }
        $UserPrincipalName = "$($UserObj.username)@$($UserObj.Domain ? $UserObj.Domain : $UserObj.PrimDomain.value)"
        Write-Host "Creating user $UserPrincipalName"
        Write-Host "tenant filter is $($UserObj.tenantFilter)"
        $BodyToship = [pscustomobject] @{
            'givenName'         = $UserObj.givenName
            'surname'           = $UserObj.surname
            'accountEnabled'    = $true
            'displayName'       = $UserObj.displayName
            'department'        = $UserObj.department
            'mailNickname'      = $UserObj.username ? $UserObj.username : $UserObj.mailNickname
            'userPrincipalName' = $UserPrincipalName
            'usageLocation'     = $UserObj.usageLocation.value ? $UserObj.usageLocation.value : $UserObj.usageLocation
            'otherMails'        = $UserObj.otherMails ? @($UserObj.otherMails) : @()
            'jobTitle'          = $UserObj.jobTitle
            'mobilePhone'       = $UserObj.mobilePhone
            'streetAddress'     = $UserObj.streetAddress
            'city'              = $UserObj.city
            'state'             = $UserObj.state
            'country'           = $UserObj.country
            'postalCode'        = $UserObj.postalCode
            'companyName'       = $UserObj.companyName
            'passwordProfile'   = @{
                'forceChangePasswordNextSignIn' = [bool]$UserObj.MustChangePass
                'password'                      = $password
            }
        }
        if ($UserObj.businessPhones) { $bodytoShip | Add-Member -NotePropertyName businessPhones -NotePropertyValue @($UserObj.businessPhones) }
        if ($UserObj.defaultAttributes) {
            $UserObj.defaultAttributes | Get-Member -MemberType NoteProperty | ForEach-Object {
                Write-Host "Editing user and adding $($_.Name) with value $($UserObj.defaultAttributes.$($_.Name).value)"
                if (-not [string]::IsNullOrWhiteSpace($UserObj.defaultAttributes.$($_.Name).value)) {
                    Write-Host 'adding body to ship'
                    $BodyToShip | Add-Member -NotePropertyName $_.Name -NotePropertyValue $UserObj.defaultAttributes.$($_.Name).value -Force
                }
            }
        }
        if ($UserObj.customData) {
            $UserObj.customData | Get-Member -MemberType NoteProperty | ForEach-Object {
                Write-Host "Editing user and adding custom data $($_.Name) with value $($UserObj.customData.$($_.Name))"
                if (-not [string]::IsNullOrWhiteSpace($UserObj.customData.$($_.Name))) {
                    Write-Host 'adding custom data to body'
                    $BodyToShip | Add-Member -NotePropertyName $_.Name -NotePropertyValue $UserObj.customData.$($_.Name) -Force
                }
            }
        }
        $bodyToShip = ConvertTo-Json -Depth 10 -InputObject $BodyToship -Compress
        Write-Host "Shipping: $bodyToShip"
        $GraphRequest = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/users' -tenantId $UserObj.tenantFilter -type POST -body $BodyToship -verbose
        Write-LogMessage -headers $Headers -API $APIName -tenant $($UserObj.tenantFilter) -message "Created user $($UserObj.displayName) with id $($GraphRequest.id)" -Sev 'Info'

        try {
            $PasswordLink = New-PwPushLink -Payload $password
            if ($PasswordLink) {
                $password = $PasswordLink
            }
        } catch {

        }
        $Results = @{
            Results  = ('Created New User.')
            Username = $UserPrincipalName
            Password = $password
            User     = $GraphRequest
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to create user. Error:$($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($UserObj.tenantFilter) -message "Failed to create user. Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        $Results = @{ Results = $Result }
        throw $Result
    }
    return $Results
}

#EndRegion './Public/New-CippUser.ps1' 90
#Region './Public/New-CIPPUserTask.ps1' -1

function New-CIPPUserTask {
    [CmdletBinding()]
    param (
        $UserObj,
        $APIName = 'New User Task',
        $TenantFilter,
        $Headers
    )
    $Results = [System.Collections.Generic.List[string]]::new()

    try {
        $CreationResults = New-CIPPUser -UserObj $UserObj -APIName $APIName -Headers $Headers
        $Results.Add('Created New User.')
        $Results.Add("Username: $($CreationResults.Username)")
        $Results.Add("Password: $($CreationResults.Password)")
    } catch {
        $Results.Add("Failed to create user. $($_.Exception.Message)" )
        return @{'Results' = $Results }
    }

    try {
        if ($UserObj.licenses.value) {
            if ($UserObj.sherwebLicense.value) {
                $License = Set-SherwebSubscription -Headers $Headers -TenantFilter $UserObj.tenantFilter -SKU $UserObj.sherwebLicense.value -Add 1
                $null = $results.Add('Added Sherweb License, scheduling assignment')
                $taskObject = [PSCustomObject]@{
                    TenantFilter  = $UserObj.tenantFilter
                    Name          = "Assign License: $UserPrincipalName"
                    Command       = @{
                        value = 'Set-CIPPUserLicense'
                    }
                    Parameters    = [pscustomobject]@{
                        UserId      = $CreationResults.Username
                        APIName     = 'Sherweb License Assignment'
                        AddLicenses = $UserObj.licenses.value
                    }
                    ScheduledTime = 0 #right now, which is in the next 15 minutes and should cover most cases.
                    PostExecution = @{
                        Webhook = [bool]$Request.Body.PostExecution.webhook
                        Email   = [bool]$Request.Body.PostExecution.email
                        PSA     = [bool]$Request.Body.PostExecution.psa
                    }
                }
                Add-CIPPScheduledTask -Task $taskObject -hidden $false -Headers $Headers
            } else {
                $LicenseResults = Set-CIPPUserLicense -UserId $CreationResults.Username -TenantFilter $UserObj.tenantFilter -AddLicenses $UserObj.licenses.value -Headers $Headers
                $Results.Add($LicenseResults)
            }
        }
    } catch {
        Write-LogMessage -headers $Headers -API $APIName -tenant $($UserObj.tenantFilter) -message "Failed to assign the license. Error:$($_.Exception.Message)" -Sev 'Error'
        $Results.Add("Failed to assign the license. $($_.Exception.Message)")
    }

    try {
        if ($UserObj.AddedAliases) {
            $AliasResults = Add-CIPPAlias -User $CreationResults.Username -Aliases ($UserObj.AddedAliases -split '\s') -UserPrincipalName $CreationResults.Username -TenantFilter $UserObj.tenantFilter -APIName $APIName -Headers $Headers
            $Results.Add($AliasResults)
        }
    } catch {
        Write-LogMessage -headers $Headers -API $APIName -tenant $($UserObj.tenantFilter) -message "Failed to create the Aliases. Error:$($_.Exception.Message)" -Sev 'Error'
        $Results.Add("Failed to create the Aliases: $($_.Exception.Message)")
    }
    if ($UserObj.copyFrom.value) {
        Write-Host "Copying from $($UserObj.copyFrom.value)"
        $CopyFrom = Set-CIPPCopyGroupMembers -Headers $Headers -CopyFromId $UserObj.copyFrom.value -UserID $CreationResults.Username -TenantFilter $UserObj.tenantFilter
        $CopyFrom.Success | ForEach-Object { $Results.Add($_) }
        $CopyFrom.Error | ForEach-Object { $Results.Add($_) }
    }

    if ($UserObj.setManager) {
        $ManagerResult = Set-CIPPManager -User $CreationResults.Username -Manager $UserObj.setManager.value -TenantFilter $UserObj.tenantFilter -Headers $Headers
        $Results.Add($ManagerResult)
    }

    if ($UserObj.setSponsor) {
        $SponsorResult = Set-CIPPSponsor -User $CreationResults.Username -Sponsor $UserObj.setSponsor.value -TenantFilter $UserObj.tenantFilter -Headers $Headers
        $Results.Add($SponsorResult)
    }

    return @{
        Results  = $Results
        Username = $CreationResults.Username
        Password = $CreationResults.Password
        CopyFrom = $CopyFrom
        User     = $CreationResults.User
    }
}
#EndRegion './Public/New-CIPPUserTask.ps1' 89
#Region './Public/Remove-CIPPAutopilotProfile.ps1' -1

function Remove-CIPPAutopilotProfile {
    param(
        $ProfileId,
        $DisplayName,
        $TenantFilter,
        $Assignments,
        $Headers,
        $APIName = 'Remove Autopilot Profile'
    )


    try {

        try {
            $DisplayName = $null -eq $DisplayName ? $ProfileId : $DisplayName
            if ($Assignments.Count -gt 0) {
                Write-Host "Profile $ProfileId has $($Assignments.Count) assignments, removing them first"
                throw
            }

            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$ProfileId" -tenantid $TenantFilter -type DELETE
            $Result = "Successfully deleted Autopilot profile '$($DisplayName)'"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
            return $Result
        } catch {

            # Profile could not be deleted, there is probably an assignment still referencing it. The error is bloody useless here, and we just need to try some stuff
            if ($null -eq $Assignments) {
                $Assignments = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$ProfileId/assignments" -tenantid $TenantFilter
            }

            # Remove all assignments
            if ($Assignments -and $Assignments.Count -gt 0) {
                foreach ($Assignment in $Assignments) {
                    try {
                        # Use the assignment ID directly as provided by the API
                        $AssignmentId = $Assignment.id
                        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$ProfileId/assignments/$AssignmentId" -tenantid $TenantFilter -type DELETE

                    } catch {
                        # Handle the case where the assignment might reference a deleted group
                        try {
                            if ($Assignment.target -and $Assignment.target.'@odata.type' -eq '#microsoft.graph.groupAssignmentTarget') {
                                $GroupId = $Assignment.target.groupId
                                $AlternativeAssignmentId = "${ProfileId}_${GroupId}"
                                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$ProfileId/assignments/$AlternativeAssignmentId" -tenantid $TenantFilter -type DELETE
                            }
                        } catch {
                            throw "Could not remove assignment $AssignmentId"
                        }
                    }
                }
            }
            # Retry deleting the profile after removing assignments
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$ProfileId" -tenantid $TenantFilter -type DELETE
            $Result = "Successfully deleted Autopilot profile '$($DisplayName)' "
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
            return $Result
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $ErrorText = "Failed to delete Autopilot profile $ProfileId. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $ErrorText -Sev 'Error' -LogData $ErrorMessage
        throw $ErrorText
    }
}
#EndRegion './Public/Remove-CIPPAutopilotProfile.ps1' 68
#Region './Public/Remove-CIPPCalendarInvites.ps1' -1

function Remove-CIPPCalendarInvites {
    [CmdletBinding()]
    param(
        $UserID,
        $TenantFilter,
        $Username,
        $APIName = 'Remove Calendar Invites',
        $Headers
    )

    try {
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-CalendarEvents' -Anchor $Username -cmdParams @{Identity = $Username; QueryWindowInDays = 730 ; CancelOrganizedMeetings = $true ; Confirm = $false }
        $Result = "Successfully cancelled all calendar invites for $($Username)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info' -tenant $TenantFilter
        return $Result

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to cancel calendar invites for $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Remove-CIPPCalendarInvites.ps1' 24
#Region './Public/Remove-CIPPGroup.ps1' -1

function Remove-CIPPGroup {
    [CmdletBinding()]
    param (
        $Headers,
        $GroupType,
        $ID,
        $DisplayName,
        $APIName = 'Remove Group',
        $TenantFilter
    )

    try {
        if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-DistributionGroup' -cmdParams @{Identity = $ID; BypassSecurityGroupManagerCheck = $true } -useSystemMailbox $true
            Write-LogMessage -headers $Headers -API $APINAME -tenant $($TenantFilter) -message "$($DisplayName) Deleted" -Sev 'Info'
            return "Successfully Deleted $($GroupType) group $($DisplayName)"

        } elseif ($GroupType -eq 'Microsoft 365' -or $GroupType -eq 'Security') {
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/groups/$($ID)" -tenantid $TenantFilter -type Delete -verbose
            Write-LogMessage -headers $Headers -API $APINAME -tenant $($TenantFilter) -message "$($DisplayName) Deleted" -Sev 'Info'
            return "Successfully Deleted $($GroupType) group $($DisplayName)"
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Could not delete $DisplayName. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}



#EndRegion './Public/Remove-CIPPGroup.ps1' 34
#Region './Public/Remove-CIPPGroupMember.ps1' -1

function Remove-CIPPGroupMember {
    <#
    .SYNOPSIS
    Removes members from a Microsoft 365 group.

    .DESCRIPTION
    Removes one or more members from Security Groups, Distribution Groups, or Mail-Enabled Security Groups.
    Uses bulk request operations for Exchange groups to improve performance.

    .PARAMETER Headers
    The headers for the API request, typically containing authentication information.

    .PARAMETER TenantFilter
    The tenant identifier for the target tenant.

    .PARAMETER GroupType
    The type of group. Valid values: 'Distribution list', 'Mail-Enabled Security', or standard security groups.

    .PARAMETER GroupId
    The unique identifier (GUID or name) of the group.

    .PARAMETER Member
    An array of member identifiers (user GUIDs or UPNs) to remove from the group.

    .PARAMETER APIName
    The API operation name for logging purposes. Default: 'Remove Group Member'.

    .EXAMPLE
    Remove-CIPPGroupMember -Headers $Headers -TenantFilter 'contoso.onmicrosoft.com' -GroupType 'Distribution list' -GroupId 'Sales-DL' -Member @('user1@contoso.com', 'user2@contoso.com') -APIName 'Remove DL Members'

    .EXAMPLE
    Remove-CIPPGroupMember -Headers $Headers -TenantFilter 'contoso.onmicrosoft.com' -GroupType 'Security' -GroupId '12345-guid' -Member @('user1-guid')
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $true)]
        [string]$GroupType,

        [Parameter(Mandatory = $true)]
        [string]$GroupId,

        [Parameter(Mandatory = $true)]
        [string[]]$Member,

        [Parameter(Mandatory = $false)]
        [string]$APIName = 'Remove Group Member',

        $Headers
    )

    try {
        $Requests = foreach ($m in $Member) {
            if ($m -like '*#EXT#*') { $m = [System.Web.HttpUtility]::UrlEncode($m) }
            @{
                id     = $m
                url    = "users/$($m)?`$select=id,userPrincipalName"
                method = 'GET'
            }
        }
        $Users = New-GraphBulkRequest -Requests @($Requests) -tenantid $TenantFilter

        if ($GroupType -eq 'Distribution list' -or $GroupType -eq 'Mail-Enabled Security') {
            $ExoBulkRequests = [System.Collections.Generic.List[object]]::new()
            $ExoLogs = [System.Collections.Generic.List[object]]::new()

            foreach ($User in $Users) {
                $Params = @{ Identity = $GroupId; Member = $User.body.userPrincipalName; BypassSecurityGroupManagerCheck = $true }
                $ExoBulkRequests.Add(@{
                        CmdletInput = @{
                            CmdletName = 'Remove-DistributionGroupMember'
                            Parameters = $Params
                        }
                    })
                $ExoLogs.Add(@{
                        message = "Removed member $($User.body.userPrincipalName) from $($GroupId) group"
                        target  = $User.body.userPrincipalName
                    })
            }

            if ($ExoBulkRequests.Count -gt 0) {
                $RawExoRequest = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($ExoBulkRequests)
                $LastError = $RawExoRequest | Select-Object -Last 1

                foreach ($ExoError in $LastError.error) {
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoError -Sev 'Error'
                    throw $ExoError
                }

                foreach ($ExoLog in $ExoLogs) {
                    $ExoError = $LastError | Where-Object { $ExoLog.target -in $_.target -and $_.error }
                    if (!$LastError -or ($LastError.error -and $LastError.target -notcontains $ExoLog.target)) {
                        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoLog.message -Sev 'Info'
                    }
                }
            }
        } else {
            $RemovalRequests = foreach ($User in $Users) {
                @{
                    id     = $User.body.id
                    method = 'DELETE'
                    url    = "/groups/$($GroupId)/members/$($User.body.id)/`$ref"
                }
            }
            $RemovalResults = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($RemovalRequests)
            foreach ($Result in $RemovalResults) {
                if ($Result.status -ne 204) {
                    throw "Failed to remove member $($Result.id): $($Result.body.error.message)"
                }
            }
        }
        $UserList = ($Users.body.userPrincipalName -join ', ')
        $Results = "Successfully removed user $UserList from $($GroupId)."
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev Info
        return $Results

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $UserList = if ($Users) { ($Users.body.userPrincipalName -join ', ') } else { ($Member -join ', ') }
        $Results = "Failed to remove user $UserList from $($GroupId): $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -Sev Error -LogData $ErrorMessage
        throw $Results
    }
}
#EndRegion './Public/Remove-CIPPGroupMember.ps1' 127
#Region './Public/Remove-CIPPGroups.ps1' -1

function Remove-CIPPGroups {
    [CmdletBinding()]
    param(
        $Username,
        $TenantFilter,
        $APIName = 'Remove From Groups',
        $Headers,
        $UserID
    )

    if (-not $userid) {
        $UserID = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Username)" -tenantid $TenantFilter).id
    }
    $AllGroups = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups/?`$select=displayName,mailEnabled,id,groupTypes,assignedLicenses,onPremisesSyncEnabled,membershipRule&`$top=999" -tenantid $TenantFilter)

    # Get user's groups
    $UserGroups = (New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserID)/GetMemberGroups" -tenantid $TenantFilter -type POST -body '{"securityEnabledOnly": false}').value

    if (-not $UserGroups) {
        $Returnval = "$($Username) is not a member of any groups."
        Write-LogMessage -headers $Headers -API $APIName -message "$($Username) is not a member of any groups" -Sev 'Info' -tenant $TenantFilter
        return $Returnval
    }

    # Initialize bulk request arrays and results
    $BulkRequests = [System.Collections.Generic.List[object]]::new()
    $ExoBulkRequests = [System.Collections.Generic.List[object]]::new()
    $GraphLogs = [System.Collections.Generic.List[object]]::new()
    $ExoLogs = [System.Collections.Generic.List[object]]::new()
    $Results = [System.Collections.Generic.List[string]]::new()

    # Process each group and prepare bulk requests
    foreach ($Group in $UserGroups) {
        $GroupInfo = $AllGroups | Where-Object -Property id -EQ $Group
        $GroupName = $GroupInfo.displayName
        $IsMailEnabled = $GroupInfo.mailEnabled
        $IsM365Group = $null -ne ($AllGroups | Where-Object { $_.id -eq $Group -and $_.groupTypes -contains 'Unified' })
        $IsLicensed = $GroupInfo.assignedLicenses.Count -gt 0
        $IsDynamic = -not [string]::IsNullOrWhiteSpace($GroupInfo.membershipRule)

        if ($IsLicensed) {
            $Results.Add("Could not remove $Username from group '$GroupName' because it has assigned licenses. These groups are removed during the license removal step.")
            Write-LogMessage -headers $Headers -API $APIName -message "Could not remove $Username from group '$GroupName' because it has assigned licenses. These groups are removed during the license removal step." -Sev 'Warning' -tenant $TenantFilter
        } elseif ($IsDynamic) {
            $Results.Add("Error: Could not remove $Username from group '$GroupName' because it is a Dynamic Group.")
            Write-LogMessage -headers $Headers -API $APIName -message "Could not remove $Username from group '$GroupName' because it is a Dynamic Group." -Sev 'Warning' -tenant $TenantFilter
        } elseif ($GroupInfo.onPremisesSyncEnabled) {
            $Results.Add("Error: Could not remove $Username from group '$GroupName' because it is synced with Active Directory.")
            Write-LogMessage -headers $Headers -API $APIName -message "Could not remove $Username from group '$GroupName' because it is synced with Active Directory." -Sev 'Warning' -tenant $TenantFilter
        } else {
            if ($IsM365Group -or (-not $IsMailEnabled)) {
                # Use Graph API for M365 Groups and Security Groups
                $BulkRequests.Add(@{
                        id     = "removeFromGroup-$Group"
                        method = 'DELETE'
                        url    = "groups/$Group/members/$UserID/`$ref"
                    })
                $GraphLogs.Add(@{
                        message   = "Removed $Username from $GroupName"
                        id        = "removeFromGroup-$Group"
                        groupName = $GroupName
                    })
            } elseif ($IsMailEnabled) {
                # Use Exchange Online for Distribution Lists
                $Params = @{
                    Identity                        = $GroupName
                    Member                          = $UserID
                    BypassSecurityGroupManagerCheck = $true
                }
                $ExoBulkRequests.Add(@{
                        CmdletInput = @{
                            CmdletName = 'Remove-DistributionGroupMember'
                            Parameters = $Params
                        }
                    })
                $ExoLogs.Add(@{
                        message   = "Removed $Username from $GroupName"
                        target    = $UserID
                        groupName = $GroupName
                    })
            }
        }
    }

    # Execute Graph bulk requests
    if ($BulkRequests.Count -gt 0) {
        try {
            $RawGraphRequest = New-GraphBulkRequest -tenantid $TenantFilter -scope 'https://graph.microsoft.com/.default' -Requests @($BulkRequests) -asapp $true

            foreach ($GraphLog in $GraphLogs) {
                $GraphError = $RawGraphRequest | Where-Object { $_.id -eq $GraphLog.id -and $_.status -notmatch '^2[0-9]+' }
                if ($GraphError) {
                    $Message = Get-NormalizedError -message $GraphError.body.error
                    $Results.Add("Could not remove $Username from group '$($GraphLog.groupName)': $Message. This is likely because it's a Dynamic Group or synced with Active Directory")
                    Write-LogMessage -headers $Headers -API $APIName -message "Could not remove $Username from group '$($GraphLog.groupName)': $Message" -Sev 'Error' -tenant $TenantFilter
                } else {
                    $Results.Add("Successfully removed $Username from group '$($GraphLog.groupName)'")
                    Write-LogMessage -headers $Headers -API $APIName -message $GraphLog.message -Sev 'Info' -tenant $TenantFilter
                }
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -headers $Headers -API $APIName -message "Error executing Graph bulk requests: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            $Results.Add("Error executing bulk removal requests: $($ErrorMessage.NormalizedError)")
        }
    }

    # Execute Exchange Online bulk requests
    if ($ExoBulkRequests.Count -gt 0) {
        try {
            $RawExoRequest = New-ExoBulkRequest -tenantid $TenantFilter -cmdletArray @($ExoBulkRequests)
            $LastError = $RawExoRequest | Select-Object -Last 1

            foreach ($ExoError in $LastError.error) {
                $Results.Add("Error - $ExoError")
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoError -Sev 'Error'
            }

            foreach ($ExoLog in $ExoLogs) {
                $ExoError = $LastError | Where-Object { $ExoLog.target -in $_.target -and $_.error }
                if (!$LastError -or ($LastError.error -and $LastError.target -notcontains $ExoLog.target)) {
                    $Results.Add("Successfully removed $Username from group $($ExoLog.groupName)")
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $ExoLog.message -Sev 'Info'
                } else {
                    $Results.Add("Could not remove $Username from $($ExoLog.groupName). This is likely because its a Dynamic Group or synched with active directory")
                    Write-LogMessage -headers $Headers -API $APIName -message "Could not remove $Username from $($ExoLog.groupName)" -Sev 'Error' -tenant $TenantFilter
                }
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -headers $Headers -API $APIName -message "Error executing Exchange bulk requests: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            $Results.Add("Error executing bulk Exchange requests: $($ErrorMessage.NormalizedError)")
        }
    }

    return $Results
}
#EndRegion './Public/Remove-CIPPGroups.ps1' 138
#Region './Public/Remove-CIPPLicense.ps1' -1

function Remove-CIPPLicense {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        $Headers,
        $userid,
        $username,
        $APIName = 'Remove License',
        $TenantFilter,
        [switch]$Schedule
    )

    if ($Schedule.IsPresent) {
        $ScheduledTask = @{
            TenantFilter  = $TenantFilter
            Name          = "Remove License: $Username"
            Command       = @{
                value = 'Remove-CIPPLicense'
            }
            Parameters    = [pscustomobject]@{
                userid   = $userid
                username = $username
                APIName  = 'Scheduled License Removal'
                Headers  = $Headers
            }
            ScheduledTime = [int64](([datetime]::UtcNow).AddMinutes(5) - (Get-Date '1/1/1970')).TotalSeconds
            PostExecution = @{
                Webhook = $false
                Email   = $false
                PSA     = $false
            }
        }
        Add-CIPPScheduledTask -Task $ScheduledTask -hidden $false
        return "Scheduled license removal for $username"
    } else {
        try {
            $ModuleBase = Get-Module -Name CIPPCore | Select-Object -ExpandProperty ModuleBase
            $ConvertTable = Import-Csv (Join-Path $ModuleBase 'lib\data\ConversionTable.csv')
            $User = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($userid)" -tenantid $tenantFilter
            $GroupMemberships = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($userid)/memberOf/microsoft.graph.group?`$select=id,displayName,assignedLicenses" -tenantid $tenantFilter
            $LicenseGroups = $GroupMemberships | Where-Object { ($_.assignedLicenses | Measure-Object).Count -gt 0 }

            if ($LicenseGroups) {
                # remove user from groups with licenses, these can only be graph groups
                $RemoveRequests = foreach ($LicenseGroup in $LicenseGroups) {
                    @{
                        id     = $LicenseGroup.id
                        method = 'DELETE'
                        url    = "groups/$($LicenseGroup.id)/members/$($User.id)/`$ref"
                    }
                }

                Write-Information 'Removing user from groups with licenses'
                $RemoveResults = New-GraphBulkRequest -tenantid $tenantFilter -requests @($RemoveRequests)
                Write-Information ($RemoveResults | ConvertTo-Json -Depth 5)
                $RemoveResults | ForEach-Object {
                    $Group = $GroupMemberships | Where-Object { $_.id -eq $_.id }
                    $GroupName = $Group | Select-Object -ExpandProperty displayName

                    if ($_.status -eq 204) {
                        Write-LogMessage -headers $Headers -API $APIName -message "Removed $($User.displayName) from license group $GroupName" -Sev 'Info' -tenant $TenantFilter
                        "Removed $($User.displayName) from license group $GroupName"
                    } else {
                        Write-LogMessage -headers $Headers -API $APIName -message "Failed to remove $($User.displayName) from license group $GroupName. This is likely because its a Dynamic Group or synced with active directory." -Sev 'Error' -tenant $TenantFilter
                        "Failed to remove $($User.displayName) from license group $GroupName. This is likely because its a Dynamic Group or synced with active directory."
                    }
                }
            }

            if (!$username) { $username = $User.userPrincipalName }
            $CurrentLicenses = $User.assignedlicenses.skuid
            $ConvertedLicense = $(($ConvertTable | Where-Object { $_.guid -in $CurrentLicenses }).'Product_Display_Name' | Sort-Object -Unique) -join ', '
            if ($CurrentLicenses) {
                $LicensePayload = [PSCustomObject]@{
                    addLicenses    = @()
                    removeLicenses = @($CurrentLicenses)
                }
                if ($PSCmdlet.ShouldProcess($userid, "Remove licenses: $ConvertedLicense")) {
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($userid)/assignlicense" -tenantid $tenantFilter -type POST -body (ConvertTo-Json -InputObject $LicensePayload -Compress -Depth 5) -verbose
                    Write-LogMessage -headers $Headers -API $APIName -message "Removed licenses for $($username): $ConvertedLicense" -Sev 'Info' -tenant $TenantFilter
                }
                return "Removed licenses for $($Username): $ConvertedLicense"
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "No licenses to remove for $username" -Sev 'Info' -tenant $TenantFilter
                return "No licenses to remove for $username"
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -headers $Headers -API $APIName -message "Could not remove license for $username. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            return "Could not remove license for $($username). Error: $($ErrorMessage.NormalizedError)"
        }
    }
}
#EndRegion './Public/Remove-CIPPLicense.ps1' 93
#Region './Public/Remove-CIPPMailboxPermissions.ps1' -1

function Remove-CIPPMailboxPermissions {
    [CmdletBinding()]
    param (
        $userid,
        $AccessUser,
        $TenantFilter,
        $PermissionsLevel,
        $APIName = 'Manage Shared Mailbox Access',
        $Headers
    )

    try {
        if ($userid -eq 'AllUsers') {
            $Mailboxes = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -Select UserPrincipalName
            $Mailboxes | ForEach-Object -Parallel {
                Import-Module '.\Modules\AzBobbyTables'
                Import-Module '.\Modules\CIPPCore'
                Write-Host "Removing permissions from mailbox $($_.UserPrincipalName)"
                Remove-CIPPMailboxPermissions -PermissionsLevel @('FullAccess', 'SendAs', 'SendOnBehalf') -userid $_.UserPrincipalName -AccessUser $using:AccessUser -TenantFilter $using:TenantFilter -APIName $using:APINAME -Headers $using:Headers
            } -ThrottleLimit 10
        } else {
            $Results = $PermissionsLevel | ForEach-Object {
                switch ($_) {
                    'SendOnBehalf' {
                        $MailboxPerms = New-ExoRequest -Anchor $UserId -tenantid $Tenantfilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $userid; GrantSendonBehalfTo = @{'@odata.type' = '#Exchange.GenericHashTable'; remove = $AccessUser }; }
                        if ($MailboxPerms -notlike '*completed successfully but no settings of*') {
                            Write-LogMessage -headers $Headers -API $APIName -message "Removed SendOnBehalf permissions for $($AccessUser) from $($userid)'s mailbox." -Sev 'Info' -tenant $TenantFilter
                            "Removed SendOnBehalf permissions for $($AccessUser) from $($userid)'s mailbox."
                        }
                    }
                    'SendAS' {
                        $MailboxPerms = New-ExoRequest -Anchor $userId -tenantid $Tenantfilter -cmdlet 'Remove-RecipientPermission' -cmdParams @{Identity = $userid; Trustee = $AccessUser; accessRights = @('SendAs') }
                        if ($MailboxPerms -notlike "*because the ACE isn't present*") {
                            Write-LogMessage -headers $Headers -API $APIName -message "Removed SendAs permissions for $($AccessUser) from $($userid)'s mailbox." -Sev 'Info' -tenant $TenantFilter
                            "Removed SendAs permissions for $($AccessUser) from $($userid)'s mailbox."
                        }
                    }
                    'FullAccess' {
                        $ExoRequest = @{
                            tenantid  = $TenantFilter
                            cmdlet    = 'Remove-MailboxPermission'
                            cmdParams = @{
                                Identity     = $userid
                                user         = $AccessUser
                                accessRights = @('FullAccess')
                                Verbose      = $true
                            }
                            Anchor    = $userid
                        }
                        $permissions = New-ExoRequest @ExoRequest

                        if ($permissions -notlike "*because the ACE doesn't exist on the object.*") {
                            Write-LogMessage -headers $Headers -API $APIName -message "Removed FullAccess permissions for $($AccessUser) from $($userid)'s mailbox." -Sev 'Info' -tenant $TenantFilter
                            "Removed FullAccess permissions for $($AccessUser) from $($userid)'s mailbox."
                        }
                    }
                }
            }
        }
        return $Results
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Could not remove mailbox permissions for $($userid). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        return "Could not remove mailbox permissions for $($userid). Error: $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Remove-CIPPMailboxPermissions.ps1' 67
#Region './Public/Remove-CIPPMailboxRule.ps1' -1

function Remove-CIPPMailboxRule {
    [CmdletBinding()]
    param (
        $UserId,
        $Username,
        $TenantFilter,
        $APIName = 'Mailbox Rules Removal',
        $Headers,
        $RuleId,
        $RuleName,
        [switch]$RemoveAllRules
    )

    if ($RemoveAllRules.IsPresent -eq $true) {
        # Delete all rules
        try {
            Write-Host "Checking rules for $Username"
            $Rules = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-InboxRule' -cmdParams @{Mailbox = $Username; IncludeHidden = $true } | Where-Object { $_.Name -ne 'Junk E-Mail Rule' -and $_.Name -notlike 'Microsoft.Exchange.OOF.*' }
            Write-Host "$($Rules.count) rules found"
            if ($null -eq $Rules) {
                $Message = "No rules found for $($Username) to delete"
                Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Info' -tenant $TenantFilter
                return $Message
            } else {
                ForEach ($rule in $Rules) {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-InboxRule' -Anchor $Username -cmdParams @{Identity = $rule.Identity }
                }
                $Message = "Successfully deleted all rules for $($Username)"
                Write-LogMessage -headers $Headers -API $APIName -message "Deleted rules for $($Username)" -Sev 'Info' -tenant $TenantFilter
                return $Message
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Message = "Failed to delete rules for $($Username). Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            throw $Message
        }
    } else {
        # Only delete 1 rule
        try {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-InboxRule' -Anchor $Username -cmdParams @{Identity = $RuleId }
            $Message = "Successfully deleted mailbox rule $($RuleName) for $($Username)"
            Write-LogMessage -headers $Headers -API $APIName -message "Deleted mailbox rule $($RuleName) for $($Username)" -Sev 'Info' -tenant $TenantFilter
            return $Message
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Message = "Failed to delete rule for $($Username). Error: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            throw $Message
        }
    }
}
#EndRegion './Public/Remove-CIPPMailboxRule.ps1' 53
#Region './Public/Remove-CIPPMobileDevice.ps1' -1

function Remove-CIPPMobileDevice {
    [CmdletBinding()]
    param(
        $UserId,
        $TenantFilter,
        $Username,
        $APIName = 'Remove Mobile',
        $Headers
    )

    try {
        $RemovedDevices = [System.Collections.Generic.List[string]]::new()
        $ErrorDevices = [System.Collections.Generic.List[string]]::new()
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-MobileDevice' -Anchor $Username -cmdParams @{mailbox = $Username } | ForEach-Object {
            try {
                $MobileDevice = $_
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-MobileDevice' -Anchor $Username -cmdParams @{Identity = $MobileDevice.Identity }
                $RemovedDevices.Add("$($MobileDevice.FriendlyName)")
            } catch {
                $ErrorDevices.Add("$($MobileDevice.FriendlyName)")
            }
        }
        if ($ErrorDevices.Count -eq 0) {
            $Message = "Successfully removed $($RemovedDevices.Count) mobile devices for $($Username): $($RemovedDevices -join '; ')"
        } else {
            $Message = "Failed to remove all mobile devices for $($Username). Successfully removed $($RemovedDevices.Count) mobile devices: $($RemovedDevices -join '; '). Failed to remove $($ErrorDevices.Count) mobile devices: $($ErrorDevices -join '; ')"
            Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter
        }
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to remove mobile devices for $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}

#EndRegion './Public/Remove-CIPPMobileDevice.ps1' 38
#Region './Public/Remove-CIPPUser.ps1' -1

function Remove-CIPPUser {
    [CmdletBinding()]
    param (
        $Headers,
        [parameter(Mandatory = $true)]
        [string]$UserID,
        [string]$Username,
        $APIName = 'Remove User',
        $TenantFilter
    )



    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserID)" -type DELETE -tenant $TenantFilter
        $Result = "Successfully deleted user with ID: '$UserID'"
        if (-not [string]::IsNullOrEmpty($Username)) { $Result += " and Username: '$Username'" }
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info' -tenant $TenantFilter
        return $Result

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to delete user with ID: '$UserID'. Error: $($ErrorMessage.NormalizedError)"
        if (-not [string]::IsNullOrEmpty($Username)) { $Result += " and Username: '$Username'" }
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}

#EndRegion './Public/Remove-CIPPUser.ps1' 30
#Region './Public/Remove-CIPPUserMFA.ps1' -1

function Remove-CIPPUserMFA {
    <#
    .SYNOPSIS
    Remove MFA methods for a user

    .DESCRIPTION
    Remove MFA methods for a user using bulk requests to the Microsoft Graph API

    .PARAMETER UserPrincipalName
    UserPrincipalName of the user to remove MFA methods for

    .PARAMETER TenantFilter
    Tenant where the user resides

    .EXAMPLE
    Remove-CIPPUserMFA -UserPrincipalName testuser@contoso.com -TenantFilter contoso.com

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$UserPrincipalName,
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $false)]
        $Headers,
        [Parameter(Mandatory = $false)]
        $APIName = 'Remove MFA Methods'
    )

    Write-Information "Getting auth methods for $UserPrincipalName"
    try {
        $AuthMethods = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$UserPrincipalName/authentication/methods" -tenantid $TenantFilter -AsApp $true
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to get MFA methods for user $UserPrincipalName. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -sev 'Error' -LogData $ErrorMessage
        throw $Message
    }

    $Requests = [System.Collections.Generic.List[object]]::new()
    foreach ($Method in $AuthMethods) {
        if ($Method.'@odata.type' -and $Method.'@odata.type' -ne '#microsoft.graph.passwordAuthenticationMethod') {
            $MethodType = ($Method.'@odata.type' -split '\.')[-1] -replace 'Authentication', ''
            $Requests.Add(@{
                    id     = "$MethodType-$($Method.id)"
                    method = 'DELETE'
                    url    = ('users/{0}/authentication/{1}s/{2}' -f $UserPrincipalName, $MethodType, $Method.id)
                })
        }
    }

    if (($Requests | Measure-Object).Count -eq 0) {
        $Results = "No MFA methods found for user $UserPrincipalName"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Results -sev 'Info'
        return $Results
    } else {
        if ($PSCmdlet.ShouldProcess("Remove MFA methods for $UserPrincipalName")) {
            try {
                $Results = New-GraphBulkRequest -Requests $Requests -tenantid $TenantFilter -asapp $true -ErrorAction Stop
                if ($Results.status -eq 204) {
                    $Message = "Successfully removed MFA methods for user $UserPrincipalName. User must supply MFA at next logon"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -sev 'Info'
                    return $Message
                } else {
                    $FailedAuthMethods = (($Results | Where-Object { $_.status -ne 204 }).id -split '-')[0] -join ', '
                    $Message = "Failed to remove MFA methods for $FailedAuthMethods on user $UserPrincipalName"
                    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -sev 'Error'
                    throw $Message
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                $Message = "Failed to remove MFA methods for user $UserPrincipalName. Error: $($ErrorMessage.NormalizedError)"
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -sev 'Error' -LogData $ErrorMessage
                throw $Message
            }
        }
    }
}
#EndRegion './Public/Remove-CIPPUserMFA.ps1' 80
#Region './Public/Remove-CIPPUserTeamsPhoneDIDs.ps1' -1

#using namespace System.Net
#using namespace System.Collections.Generic

function Remove-CIPPUserTeamsPhoneDIDs {
    [CmdletBinding()]
    param (
        $Headers,
        [parameter(Mandatory = $true)]
        [string]$UserID,
        [string]$Username,
        $APIName = 'Remove User Teams Phone DIDs',
        [parameter(Mandatory = $true)]
        $TenantFilter
    )

    try {

        # Set Username to UserID if not provided
        if ([string]::IsNullOrEmpty($Username)) {
            $Username = $UserID
        }

        # Initialize collections for results
        $Results = [List[string]]::new()
        $SuccessCount = 0
        $ErrorCount = 0

        # Get all tenant DIDs
        $TeamsPhoneDIDs = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/admin/teams/telephoneNumberManagement/numberAssignments" -tenant $TenantFilter

        if (-not $TeamsPhoneDIDs -or $TeamsPhoneDIDs.Count -eq 0) {
            $Result = "No Teams Phone DIDs found in tenant"
            $Results.Add($Result)
            return $Results.ToArray()
        }

        # Filter DIDs assigned to the specific user
        $UserDIDs = $TeamsPhoneDIDs | Where-Object { $_.assignmentTargetId -eq $UserID -and $_.assignmentStatus -ne 'unassigned' }

        if (-not $UserDIDs -or $UserDIDs.Count -eq 0) {
            $Result = "No Teams Phone DIDs found assigned to user: '$Username' - '$UserID'"
            $Results.Add($Result)
            return $Results.ToArray()
        }

        # Prepare bulk requests for all DIDs
        $RemoveRequests = foreach ($DID in $UserDIDs) {
            @{
                id     = $DID.telephoneNumber
                method = 'POST'
                url    = "admin/teams/telephoneNumberManagement/numberAssignments/unassignNumber"
                body   = @{
                    telephoneNumber = $DID.telephoneNumber
                    numberType      = $DID.numberType
                }
            }
        }

        # Execute bulk request
        $RemoveResults = New-GraphBulkRequest -tenantid $TenantFilter -requests @($RemoveRequests)

        # Process results
        $RemoveResults | ForEach-Object {
            $PhoneNumber = $_.id

            if ($_.status -eq 204) {
                $SuccessResult = "Successfully removed Teams Phone DID: '$PhoneNumber' from: '$Username' - '$UserID'"
                Write-LogMessage -headers $Headers -API $APIName -message $SuccessResult -Sev 'Info' -tenant $TenantFilter
                $Results.Add($SuccessResult)
                $SuccessCount++
            } else {
                $ErrorMessage = if ($_.body.error.message) {
                    $_.body.error.message
                } else {
                    "HTTP Status: $($_.status)"
                }

                $ErrorResult = "Failed to remove Teams Phone DID: '$PhoneNumber' from: '$Username' - '$UserID'. Error: $ErrorMessage"
                Write-LogMessage -headers $Headers -API $APIName -message $ErrorResult -Sev 'Error' -tenant $TenantFilter
                $Results.Add($ErrorResult)
                $ErrorCount++
            }
        }

        # Add summary result
        $SummaryResult = "Completed processing $($UserDIDs.Count) DIDs for user '$Username': $SuccessCount successful, $ErrorCount failed"
        Write-LogMessage -headers $Headers -API $APIName -message $SummaryResult -Sev 'Info' -tenant $TenantFilter
        $Results.Add($SummaryResult)

        return $Results.ToArray()

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to process Teams Phone DIDs removal for: '$Username' - '$UserID'. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Remove-CIPPUserTeamsPhoneDIDs.ps1' 99
#Region './Public/Request-CIPPSPOPersonalSite.ps1' -1

function Request-CIPPSPOPersonalSite {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [string[]]$UserEmails,
        [string]$Headers = 'CIPP',
        [string]$APIName = 'Request-CIPPSPOPersonalSite'
    )
    $UserList = [System.Collections.Generic.List[string]]::new()
    foreach ($User in $UserEmails) {
        $UserList.Add("<Object Type='String'>$User</Object>")
    }

    $XML = @"
<Request xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009" AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName=".NET Library">
    <Actions>
        <ObjectPath Id="4" ObjectPathId="3" />
        <ObjectPath Id="6" ObjectPathId="5" />
        <Query Id="7" ObjectPathId="5">
            <Query SelectAllProperties="true">
                <Properties />
            </Query>
        </Query>
    </Actions>
    <ObjectPaths>
        <Constructor Id="3" TypeId="{268004ae-ef6b-4e9b-8425-127220d84719}" />
        <Method Id="5" ParentId="3" Name="RequestPersonalSites">
            <Parameters>
                <Parameter Type="Array">
                    $($UserList -join '')
                </Parameter>
            </Parameters>
        </Method>
    </ObjectPaths>
</Request>
"@

    $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
    try {
        $Request = New-GraphPostRequest -scope "$($SharePointInfo.AdminUrl)/.default" -tenantid $TenantFilter -Uri "$($SharePointInfo.AdminUrl)/_vti_bin/client.svc/ProcessQuery" -Type POST -Body $XML -ContentType 'text/xml'
        if (!$Request.IsComplete) { throw }
        Write-LogMessage -headers $Headers -API $APIName -message "Requested personal site for $($UserEmails -join ', ')" -Sev 'Info' -tenant $TenantFilter
        return "Successfully requested personal site for $($UserEmails -join ', ')"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to request personal site for $($UserEmails -join ', '). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Request-CIPPSPOPersonalSite.ps1' 53
#Region './Public/Revoke-CIPPSessions.ps1' -1

function Revoke-CIPPSessions {
    [CmdletBinding()]
    param (
        $Headers,
        $UserID,
        $Username,
        $APIName = 'Revoke Sessions',
        $TenantFilter
    )

    try {
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($UserID)/invalidateAllRefreshTokens" -tenantid $TenantFilter -type POST -body '{}' -verbose
        $Result = "Successfully revoked sessions for $($Username)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Info' -tenant $TenantFilter
        return $Result

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to revoke sessions for $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Revoke-CIPPSessions.ps1' 24
#Region './Public/Send-CIPPAlert.ps1' -1


function Send-CIPPAlert {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        $Type,
        $Title,
        $HTMLContent,
        $JSONContent,
        $TenantFilter,
        $altEmail,
        $altWebhook,
        $APIName = 'Send Alert',
        $Headers,
        $TableName,
        $RowKey = [string][guid]::NewGuid()
    )
    Write-Information 'Shipping Alert'
    $Table = Get-CIPPTable -TableName SchedulerConfig
    $Filter = "RowKey eq 'CippNotifications' and PartitionKey eq 'CippNotifications'"
    $Config = [pscustomobject](Get-CIPPAzDataTableEntity @Table -Filter $Filter)

    if ($HTMLContent) {
        $HTMLContent = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $HTMLContent
    }

    if ($Type -eq 'email') {
        Write-Information 'Trying to send email'
        try {
            if ($Config.email -like '*@*' -or $altEmail -like '*@*') {
                $Recipients = if ($AltEmail) {
                    [pscustomobject]@{EmailAddress = @{Address = $AltEmail } }
                } else {
                    $Config.email.split($(if ($Config.email -like '*,*') { ',' } else { ';' })).trim() | ForEach-Object {
                        if ($_ -like '*@*') {
                            ($Alias, $Domain) = $_ -split '@'
                            if ($Alias -match '%') {
                                # Allow for text replacement in alias portion of email address
                                $Alias = Get-CIPPTextReplacement -Text $Alias -Tenant $TenantFilter
                                $Recipient = "$Alias@$Domain"
                            } else {
                                $Recipient = $_
                            }
                            [pscustomobject]@{EmailAddress = @{Address = $Recipient } }
                        }
                    }
                }

                $PowerShellBody = [PSCustomObject]@{
                    message         = @{
                        subject      = $Title
                        body         = @{
                            contentType = 'HTML'
                            content     = $HTMLcontent
                        }
                        toRecipients = @($Recipients)
                    }
                    saveToSentItems = 'true'
                }

                $JSONBody = ConvertTo-Json -Compress -Depth 10 -InputObject $PowerShellBody

                if ($PSCmdlet.ShouldProcess($($Recipients.EmailAddress.Address -join ', '), 'Sending email')) {
                    $null = New-GraphPostRequest -uri 'https://graph.microsoft.com/v1.0/me/sendMail' -tenantid $env:TenantID -NoAuthCheck $true -type POST -body ($JSONBody)
                }

                $LogData = @{
                    Recipients = $Recipients
                }
                Write-LogMessage -API 'Webhook Alerts' -message "Sent an email alert: $Title" -tenant $TenantFilter -sev info -LogData $LogData
                return "Sent an email alert: $Title"
            }

        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Information "Could not send webhook alert to email: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -API 'Webhook Alerts' -message "Could not send webhook alerts to email. $($ErrorMessage.NormalizedError)" -tenant $TenantFilter -sev Error -LogData $ErrorMessage
            return "Could not send webhook alert to email: $($ErrorMessage.NormalizedError)"
        }
    }

    if ($Type -eq 'table' -and $TableName) {
        Write-Information 'Trying to send to Table'
        try {
            $Table = Get-CIPPTable -TableName $TableName
            $Alert = @{
                PartitionKey = $TenantFilter ?? 'Alert'
                RowKey       = $RowKey
                Title        = $Title
                Data         = [string]$JSONContent
                Tenant       = $TenantFilter
            }
            Add-CIPPAzDataTableEntity @Table -Entity $Alert
            return $Alert.RowKey
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Information "Could not send alerts to table: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -API 'Webhook Alerts' -message "Could not send alerts to table: $($ErrorMessage.NormalizedError)" -tenant $TenantFilter -sev Error -LogData $ErrorMessage
        }
    }

    if ($Type -eq 'webhook') {
        Write-Information 'Trying to send webhook'
        $JSONBody = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $JSONContent -EscapeForJson
        try {
            if (![string]::IsNullOrWhiteSpace($Config.webhook) -or ![string]::IsNullOrWhiteSpace($AltWebhook)) {
                if ($PSCmdlet.ShouldProcess($Config.webhook, 'Sending webhook')) {
                    $webhook = if ($AltWebhook) { $AltWebhook } else { $Config.webhook }
                    switch -wildcard ($webhook) {
                        '*webhook.office.com*' {
                            $JSONBody = "{`"text`": `"You've setup your alert policies to be alerted whenever specific events happen. We've found some of these events in the log. <br><br>$JSONContent`"}"
                            Invoke-RestMethod -Uri $webhook -Method POST -ContentType 'Application/json' -Body $JSONBody
                        }
                        '*discord.com*' {
                            $JSONBody = "{`"content`": `"You've setup your alert policies to be alerted whenever specific events happen. We've found some of these events in the log. $JSONContent`"}"
                            Invoke-RestMethod -Uri $webhook -Method POST -ContentType 'Application/json' -Body $JSONBody
                        }
                        '*slack.com*' {
                            $SlackBlocks = Get-SlackAlertBlocks -JSONBody $JSONContent
                            if ($SlackBlocks.blocks) {
                                $JSONBody = $SlackBlocks | ConvertTo-Json -Depth 10 -Compress
                            } else {
                                $JSONBody = "{`"text`": `"You've setup your alert policies to be alerted whenever specific events happen. We've found some of these events in the log. $JSONContent`"}"
                            }
                            Invoke-RestMethod -Uri $webhook -Method POST -ContentType 'Application/json' -Body $JSONBody
                        }
                        default {
                            Invoke-RestMethod -Uri $webhook -Method POST -ContentType 'Application/json' -Body $JSONContent
                        }
                    }
                }
                Write-LogMessage -API 'Webhook Alerts' -message "Sent Webhook alert $title to External webhook" -tenant $TenantFilter -sev info
            } else {
                Write-LogMessage -API 'Webhook Alerts' -message 'No webhook URL configured' -sev warning
            }

        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-Information "Could not send alerts to webhook: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -API 'Webhook Alerts' -message "Could not send alerts to webhook: $($ErrorMessage.NormalizedError)" -tenant $TenantFilter -sev error -LogData $ErrorMessage
        }
    }

    if ($Type -eq 'psa') {
        Write-Information 'Trying to send to PSA'
        if ($config.sendtoIntegration) {
            if ($PSCmdlet.ShouldProcess('PSA', 'Sending alert')) {
                try {
                    $Alert = @{
                        TenantId   = $TenantFilter
                        AlertText  = "$HTMLContent"
                        AlertTitle = "$($Title)"
                    }
                    New-CippExtAlert -Alert $Alert
                    Write-LogMessage -API 'Webhook Alerts' -tenant $TenantFilter -message "Sent PSA alert $title" -sev info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-Information "Could not send alerts to ticketing system: $($ErrorMessage.NormalizedError)"
                    Write-LogMessage -API 'Webhook Alerts' -tenant $TenantFilter -message "Could not send alerts to ticketing system: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
            }
        }
    }
}
#EndRegion './Public/Send-CIPPAlert.ps1' 164
#Region './Public/Set-CIPPAlwaysShowFrom.ps1' -1


Function Set-CIPPAlwaysShowFrom {
    <#
    .SYNOPSIS
        Sets the "Always Show From" property for a user or all users in a tenant.

    .DESCRIPTION
        The Set-CIPPAlwaysShowFrom function is used to set the "Always Show From" property for a specified user or all users in a specified tenant. The "Always Show From" property determines whether the from field is always shown in Outlook.

    .PARAMETER UserID
        Specifies the user ID for which to set the "Always Show From" property. This can be UserPrincipalName, SamAccountName, GUID or Email address.
        This parameter is mandatory unless the RunOnAllUsersInTenant switch is used.

    .PARAMETER TenantFilter
        Specifies the tenant for which to set the "Always Show From" property. This parameter is mandatory.

    .PARAMETER APIName
        Specifies the name of the API. The default value is "Always Show From".

    .PARAMETER Headers
        Specifies the user who is executing the function.

    .PARAMETER AlwaysShowFrom
        Specifies whether to set the "Always Show From" property to true or false. This parameter is mandatory.

    .PARAMETER RunOnAllUsersInTenant
        If this switch is present, the function will set the "Always Show From" property for all users in the specified tenant.

    .EXAMPLE
        Set-CIPPAlwaysShowFrom -UserID "john.doe@example.com" -TenantFilter "example.com" -AlwaysShowFrom $true
        Sets the "Always Show From" property to true for the user "john.doe@example.com" in the "example.com" tenant.

    .EXAMPLE
        Set-CIPPAlwaysShowFrom -TenantFilter "example.com" -AlwaysShowFrom $true -RunOnAllUsersInTenant
        Sets the "Always Show From" property to true for all users in the "example.com" tenant.
    #>
    [CmdletBinding(DefaultParameterSetName = 'User')]
    param (
        [Parameter(Mandatory = $true, ParameterSetName = 'User')]
        [Parameter(Mandatory = $false, ParameterSetName = 'AllUsers')]
        [Alias('Username')][string]$UserID,

        [Parameter(Mandatory = $true, ParameterSetName = 'User')]
        [Parameter(Mandatory = $true, ParameterSetName = 'AllUsers')]
        $TenantFilter,

        [Parameter(ParameterSetName = 'User')]
        [Parameter(ParameterSetName = 'AllUsers')]
        $APIName = 'Always Show From',

        [Parameter(ParameterSetName = 'User')]
        [Parameter(ParameterSetName = 'AllUsers')]
        $Headers,

        [Parameter(Mandatory = $true, ParameterSetName = 'User')]
        [Parameter(Mandatory = $true, ParameterSetName = 'AllUsers')]
        [bool]$AlwaysShowFrom,

        [Parameter(ParameterSetName = 'AllUsers')]
        [switch]$RunOnAllUsersInTenant
    )


    if ($RunOnAllUsersInTenant.IsPresent -eq $true) {
        $AllUsers = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Get-Mailbox' -cmdParams @{ ResultSize = 'Unlimited' }
        Write-LogMessage -headers $Headers -API $APIName -message "Setting Always Show From to $AlwaysShowFrom for all $($AllUsers.Count) users in $TenantFilter" -Sev 'Info' -tenant $TenantFilter
        $ErrorCount = 0
        foreach ($User in $AllUsers) {
            try {
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxMessageConfiguration' -anchor $User.UserPrincipalName -cmdParams @{AlwaysShowFrom = $AlwaysShowFrom; Identity = $User.UserPrincipalName }
                # Write-Information "Set Always Show From to $AlwaysShowFrom for $($User.UserPrincipalName)"
            } catch {
                $ErrorCount++
            }
        }
        Write-LogMessage -headers $Headers -API $APIName -message "Set Always Show From to $AlwaysShowFrom for $($AllUsers.Count - $ErrorCount) users in $TenantFilter" -Sev 'Info' -tenant $TenantFilter
        return "Set Always Show From to $AlwaysShowFrom for $($AllUsers.Count - $ErrorCount) users in $TenantFilter"
    } else {
        try {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxMessageConfiguration' -anchor $UserID -cmdParams @{AlwaysShowFrom = $AlwaysShowFrom; Identity = $UserID }
            Write-LogMessage -headers $Headers -API $APIName -message "Set Always Show From to $AlwaysShowFrom for $UserID" -Sev 'Info' -tenant $TenantFilter
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -headers $Headers -API $APIName -message "Could not set Always Show From to $AlwaysShowFrom for $UserID. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
            return "Could not set Always Show From to $AlwaysShowFrom for $UserID. Error: $($ErrorMessage.NormalizedError)"
        }
        return "Set Always Show From to $AlwaysShowFrom for $UserID"
    }
}
#EndRegion './Public/Set-CIPPAlwaysShowFrom.ps1' 90
#Region './Public/Set-CIPPAssignedApplication.ps1' -1

function Set-CIPPAssignedApplication {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $GroupName,
        $Intent,
        $AppType,
        $ApplicationId,
        $TenantFilter,
        $GroupIds,
        $AssignmentMode = 'replace',
        $APIName = 'Assign Application',
        $Headers
    )
    Write-Host "GroupName: $GroupName Intent: $Intent AppType: $AppType ApplicationId: $ApplicationId TenantFilter: $TenantFilter APIName: $APIName"
    try {
        $assignmentSettings = $null
        if ($AppType) {
            $assignmentSettings = @{
                '@odata.type' = "#microsoft.graph.$($AppType)AppAssignmentSettings"
            }

            switch ($AppType) {
                'Win32Lob' {
                    $assignmentSettings.notifications = 'hideAll'
                }
                'WinGet' {
                    $assignmentSettings.notifications = 'hideAll'
                }
                'macOsVpp' {
                    $assignmentSettings.useDeviceLicensing = $true
                }
                'iosVpp' {
                    $assignmentSettings.useDeviceLicensing = $true
                }
                default {
                    # No additional settings
                }
            }
        }

        # Build the assignment object
        $MobileAppAssignment = switch ($GroupName) {
            'AllUsers' {
                @(@{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = @{
                            '@odata.type' = '#microsoft.graph.allLicensedUsersAssignmentTarget'
                        }
                        intent        = $Intent
                        settings      = $assignmentSettings
                    })
                break
            }
            'AllDevices' {
                @(@{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = @{
                            '@odata.type' = '#microsoft.graph.allDevicesAssignmentTarget'
                        }
                        intent        = $Intent
                        settings      = $assignmentSettings
                    })
                break
            }
            'AllDevicesAndUsers' {
                @(
                    @{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = @{
                            '@odata.type' = '#microsoft.graph.allLicensedUsersAssignmentTarget'
                        }
                        intent        = $Intent
                        settings      = $assignmentSettings
                    },
                    @{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = @{
                            '@odata.type' = '#microsoft.graph.allDevicesAssignmentTarget'
                        }
                        intent        = $Intent
                        settings      = $assignmentSettings
                    }
                )
            }
            default {
                $resolvedGroupIds = @()
                if ($PSBoundParameters.ContainsKey('GroupIds') -and $GroupIds) {
                    $resolvedGroupIds = $GroupIds
                } else {
                    $GroupNames = $GroupName.Split(',')
                    $resolvedGroupIds = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups' -tenantid $TenantFilter | ForEach-Object {
                        $Group = $_
                        foreach ($SingleName in $GroupNames) {
                            if ($_.displayName -like $SingleName) {
                                $group.id
                            }
                        }
                    }
                    Write-Information "found $($resolvedGroupIds) groups"
                }

                # We ain't found nothing so we panic
                if (-not $resolvedGroupIds) {
                    throw 'No matching groups resolved for assignment request.'
                }

                foreach ($Group in $resolvedGroupIds) {
                    @{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = @{
                            '@odata.type' = '#microsoft.graph.groupAssignmentTarget'
                            groupId       = $Group
                        }
                        intent        = $Intent
                        settings      = $assignmentSettings
                    }
                }
            }
        }

        # If we're appending, we need to get existing assignments
        if ($AssignmentMode -eq 'append') {
            try {
                $ExistingAssignments = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$($ApplicationId)/assignments" -tenantid $TenantFilter
            } catch {
                Write-Warning "Unable to retrieve existing assignments for $ApplicationId. Proceeding with new assignments only. Error: $($_.Exception.Message)"
                $ExistingAssignments = @()
            }
        }

        # Deduplicate current assignments so the new ones override existing ones
        if ($ExistingAssignments) {
            $ExistingAssignments = $ExistingAssignments | ForEach-Object {
                $ExistingAssignment = $_
                switch ($ExistingAssignment.target.'@odata.type') {
                    '#microsoft.graph.groupAssignmentTarget' {
                        if ($ExistingAssignment.target.groupId -notin $MobileAppAssignment.target.groupId) {
                            $ExistingAssignment
                        }
                    }
                    default {
                        if ($ExistingAssignment.target.'@odata.type' -notin $MobileAppAssignment.target.'@odata.type') {
                            $ExistingAssignment
                        }
                    }
                }
            }
        }

        $FinalAssignments = [System.Collections.Generic.List[object]]::new()
        if ($AssignmentMode -eq 'append' -and $ExistingAssignments) {
            $ExistingAssignments | ForEach-Object {
                $FinalAssignments.Add(@{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = $_.target
                        intent        = $_.intent
                        settings      = $_.settings
                    })
            }

            $MobileAppAssignment | ForEach-Object {
                $FinalAssignments.Add(@{
                        '@odata.type' = '#microsoft.graph.mobileAppAssignment'
                        target        = $_.target
                        intent        = $_.intent
                        settings      = $_.settings
                    })
            }
        } else {
            $FinalAssignments = $MobileAppAssignment
        }

        $DefaultAssignmentObject = [PSCustomObject]@{
            mobileAppAssignments = @(
                $FinalAssignments
            )
        }
        if ($PSCmdlet.ShouldProcess($GroupName, "Assigning Application $ApplicationId")) {
            Start-Sleep -Seconds 1
            # Write-Information (ConvertTo-Json $DefaultAssignmentObject -Depth 10)
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceAppManagement/mobileApps/$($ApplicationId)/assign" -tenantid $TenantFilter -type POST -body ($DefaultAssignmentObject | ConvertTo-Json -Compress -Depth 10)
            Write-LogMessage -headers $Headers -API $APIName -message "Assigned Application $ApplicationId to $($GroupName)" -Sev 'Info' -tenant $TenantFilter
        }
        return "Assigned Application $ApplicationId to $($GroupName)"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Could not assign application $ApplicationId to $GroupName. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw "Could not assign application $ApplicationId to $GroupName. Error: $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPAssignedApplication.ps1' 191
#Region './Public/Set-CIPPAssignedPolicy.ps1' -1

function Set-CIPPAssignedPolicy {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $GroupName,
        $ExcludeGroup,
        $PolicyId,
        $Type,
        $TenantFilter,
        $PlatformType = 'deviceManagement',
        $APIName = 'Assign Policy',
        $Headers,
        $AssignmentFilterName,
        $AssignmentFilterType = 'include',
        $GroupIds,
        $GroupNames,
        $AssignmentMode = 'replace'
    )

    Write-Host "Assigning policy $PolicyId ($PlatformType/$Type) to $GroupName"

    try {
        # Resolve assignment filter name to ID if provided
        $ResolvedFilterId = $null
        if ($AssignmentFilterName) {
            Write-Host "Looking up assignment filter by name: $AssignmentFilterName"
            $AllFilters = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters' -tenantid $TenantFilter
            $MatchingFilter = $AllFilters | Where-Object { $_.displayName -like $AssignmentFilterName } | Select-Object -First 1

            if ($MatchingFilter) {
                $ResolvedFilterId = $MatchingFilter.id
                Write-Host "Found assignment filter: $($MatchingFilter.displayName) with ID: $ResolvedFilterId"
            } else {
                $ErrorMessage = "No assignment filter found matching the name: $AssignmentFilterName. Policy assigned without filter."
                Write-LogMessage -headers $Headers -API $APIName -message $ErrorMessage -Sev 'Warning' -tenant $TenantFilter
                Write-Host $ErrorMessage
            }
        }

        $assignmentsList = [System.Collections.Generic.List[object]]::new()
        switch ($GroupName) {
            'allLicensedUsers' {
                $assignmentsList.Add(
                    @{
                        target = @{
                            '@odata.type' = '#microsoft.graph.allLicensedUsersAssignmentTarget'
                        }
                    }
                )
            }
            'AllDevices' {
                $assignmentsList.Add(
                    @{
                        target = @{
                            '@odata.type' = '#microsoft.graph.allDevicesAssignmentTarget'
                        }
                    }
                )
            }
            'AllDevicesAndUsers' {
                $assignmentsList.Add(
                    @{
                        target = @{
                            '@odata.type' = '#microsoft.graph.allDevicesAssignmentTarget'
                        }
                    }
                )
                $assignmentsList.Add(
                    @{
                        target = @{
                            '@odata.type' = '#microsoft.graph.allLicensedUsersAssignmentTarget'
                        }
                    }
                )
            }
            default {
                # Use GroupIds if provided, otherwise resolve by name
                $resolvedGroupIds = @()
                if ($GroupIds -and @($GroupIds).Count -gt 0) {
                    $resolvedGroupIds = @($GroupIds)
                    Write-Host "Using provided GroupIds: $($resolvedGroupIds -join ', ')"
                } elseif ($GroupName) {
                    $GroupNames = $GroupName.Split(',').Trim()
                    $resolvedGroupIds = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups?$select=id,displayName&$top=999' -tenantid $TenantFilter |
                        ForEach-Object {
                            foreach ($SingleName in $GroupNames) {
                                if ($_.displayName -like $SingleName) {
                                    $_.id
                                }
                            }
                        }
                }

                if (-not $resolvedGroupIds -or $resolvedGroupIds.Count -eq 0) {
                    $ErrorMessage = "No groups found matching the specified name(s): $GroupName. Policy not assigned."
                    Write-LogMessage -headers $Headers -API $APIName -message $ErrorMessage -Sev 'Warning' -tenant $TenantFilter
                    throw $ErrorMessage
                }

                foreach ($gid in $resolvedGroupIds) {
                    $assignmentsList.Add(
                        @{
                            target = @{
                                '@odata.type' = '#microsoft.graph.groupAssignmentTarget'
                                groupId       = $gid
                            }
                        }
                    )
                }
            }
        }
        if ($ExcludeGroup) {
            Write-Host "We're supposed to exclude a custom group. The group is $ExcludeGroup"
            $ExcludeGroupNames = $ExcludeGroup.Split(',').Trim()
            $ExcludeGroupIds = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/groups?$select=id,displayName&$top=999' -tenantid $TenantFilter |
                ForEach-Object {
                    foreach ($SingleName in $ExcludeGroupNames) {
                        if ($_.displayName -like $SingleName) {
                            $_.id
                        }
                    }
                }

            foreach ($egid in $ExcludeGroupIds) {
                $assignmentsList.Add(
                    @{
                        target = @{
                            '@odata.type' = '#microsoft.graph.exclusionGroupAssignmentTarget'
                            groupId       = $egid
                        }
                    }
                )
            }
        }

        # Add assignment filter to each assignment if specified
        if ($ResolvedFilterId) {
            Write-Host "Adding assignment filter $ResolvedFilterId with type $AssignmentFilterType to assignments"
            foreach ($assignment in $assignmentsList) {
                # Don't add filters to exclusion targets
                if ($assignment.target.'@odata.type' -ne '#microsoft.graph.exclusionGroupAssignmentTarget') {
                    $assignment.target.deviceAndAppManagementAssignmentFilterId = $ResolvedFilterId
                    $assignment.target.deviceAndAppManagementAssignmentFilterType = $AssignmentFilterType
                }
            }
        }

        # If we're appending, we need to get existing assignments
        $ExistingAssignments = @()
        if ($AssignmentMode -eq 'append') {
            try {
                $uri = "https://graph.microsoft.com/beta/$($PlatformType)/$Type('$($PolicyId)')/assignments"
                $ExistingAssignments = New-GraphGetRequest -uri $uri -tenantid $TenantFilter
                Write-Host "Found $($ExistingAssignments.Count) existing assignments for policy $PolicyId"
            } catch {
                Write-Warning "Unable to retrieve existing assignments for $PolicyId. Proceeding with new assignments only. Error: $($_.Exception.Message)"
                $ExistingAssignments = @()
            }
        }

        # Deduplicate current assignments so the new ones override existing ones
        if ($ExistingAssignments -and $ExistingAssignments.Count -gt 0) {
            $ExistingAssignments = $ExistingAssignments | ForEach-Object {
                $ExistingAssignment = $_
                switch ($ExistingAssignment.target.'@odata.type') {
                    '#microsoft.graph.groupAssignmentTarget' {
                        if ($ExistingAssignment.target.groupId -notin $assignmentsList.target.groupId) {
                            $ExistingAssignment
                        }
                    }
                    '#microsoft.graph.exclusionGroupAssignmentTarget' {
                        if ($ExistingAssignment.target.groupId -notin $assignmentsList.target.groupId) {
                            $ExistingAssignment
                        }
                    }
                    default {
                        if ($ExistingAssignment.target.'@odata.type' -notin $assignmentsList.target.'@odata.type') {
                            $ExistingAssignment
                        }
                    }
                }
            }
        }

        # Build final assignments list
        $FinalAssignments = [System.Collections.Generic.List[object]]::new()
        if ($AssignmentMode -eq 'append' -and $ExistingAssignments) {
            foreach ($existing in $ExistingAssignments) {
                $FinalAssignments.Add(@{
                        target = $existing.target
                    })
            }
        }

        foreach ($newAssignment in $assignmentsList) {
            $FinalAssignments.Add($newAssignment)
        }

        # Determine the assignment property name based on type
        $AssignmentPropertyName = switch ($Type) {
            'deviceHealthScripts' { 'deviceHealthScriptAssignments' }
            'deviceManagementScripts' { 'deviceManagementScriptAssignments' }
            'deviceShellScripts' { 'deviceManagementScriptAssignments' }
            default { 'assignments' }
        }

        $assignmentsObject = @{ $AssignmentPropertyName = @($FinalAssignments) }

        $AssignJSON = ConvertTo-Json -InputObject $assignmentsObject -Depth 10 -Compress
        if ($PSCmdlet.ShouldProcess($GroupName, "Assigning policy $PolicyId")) {
            $uri = "https://graph.microsoft.com/beta/$($PlatformType)/$Type('$($PolicyId)')/assign"
            $null = New-GraphPOSTRequest -uri $uri -tenantid $TenantFilter -type POST -body $AssignJSON

            # Build a friendly display name for the assigned groups
            $AssignedGroupsDisplay = if ($GroupNames -and @($GroupNames).Count -gt 0) {
                ($GroupNames -join ', ')
            } elseif ($GroupName) {
                $GroupName
            } else {
                'specified groups'
            }

            if ($ExcludeGroup) {
                Write-LogMessage -headers $Headers -API $APIName -message "Assigned group '$AssignedGroupsDisplay' and excluded group '$ExcludeGroup' on Policy $PolicyId" -Sev 'Info' -tenant $TenantFilter
                return "Successfully assigned group '$AssignedGroupsDisplay' and excluded group '$ExcludeGroup' on Policy $PolicyId"
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "Assigned group '$AssignedGroupsDisplay' on Policy $PolicyId" -Sev 'Info' -tenant $TenantFilter
                return "Successfully assigned group '$AssignedGroupsDisplay' on Policy $PolicyId"
            }
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to assign $GroupName to Policy $PolicyId, using Platform $PlatformType and $Type. The error is:$($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        return "Failed to assign $GroupName to Policy $PolicyId. Error: $ErrorMessage"
    }
}
#EndRegion './Public/Set-CIPPAssignedPolicy.ps1' 237
#Region './Public/Set-CIPPAuditLogUserExclusion.ps1' -1

function Set-CIPPAuditLogUserExclusion {
    <#
    .SYNOPSIS
        Sets user exclusions for Audit Log alerting.
    .DESCRIPTION
        This function allows you to add or remove user exclusions for Audit Log alerting in a specified tenant
        by updating the AuditLogUserExclusions CIPP table.
    .PARAMETER TenantFilter
        The tenant identifier for which to set the user exclusions.
    .PARAMETER Users
        An array of user identifiers (GUIDs or UPNs) to be added or removed from the exclusion list.
    .PARAMETER Action
        The action to perform: 'Add' to add users to the exclusion list, 'Remove' to remove users from the exclusion list.
    .PARAMETER Headers
        The headers to include in the request, typically containing authentication tokens. This is supplied automatically by the API.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [string[]]$Users,
        [ValidateSet('Add', 'Remove')]
        [string]$Action = 'Add',
        [ValidateSet('Location')]
        [string]$Type = 'Location',
        $Headers
    )

    $AuditLogExclusionsTable = Get-CIPPTable -tablename 'AuditLogUserExclusions'
    $ExistingEntries = Get-CIPPAzDataTableEntity @AuditLogExclusionsTable -Filter "PartitionKey eq '$TenantFilter'"

    $Results = foreach ($User in $Users) {
        if ($Action -eq 'Add') {
            $ExistingUser = $ExistingEntries | Where-Object { $_.RowKey -eq $User -and $_.PartitionKey -eq $TenantFilter -and $_.Type -eq $Type }
            if (!$ExistingUser) {
                $NewEntry = [PSCustomObject]@{
                    PartitionKey = $TenantFilter
                    RowKey       = $User
                    ExcludedOn   = (Get-Date).ToString('o')
                    Type         = $Type
                }
                if ($PSCmdlet.ShouldProcess("Adding exclusion for user: $User")) {
                    Add-CIPPAzDataTableEntity @AuditLogExclusionsTable -Entity $NewEntry
                    "Added audit log exclusion for user: $User"
                    Write-LogMessage -headers $Headers -API 'Set-CIPPAuditLogUserExclusion' -message "Added audit log exclusion for user: $User" -Sev 'Info' -tenant $TenantFilter -LogData $NewEntry
                }
            } else {
                "User $User is already excluded."
            }
        } elseif ($Action -eq 'Remove') {
            if ($ExistingEntries.RowKey -contains $User) {
                if ($PSCmdlet.ShouldProcess("Removing exclusion for user: $User")) {
                    $Entity = $ExistingEntries | Where-Object { $_.RowKey -eq $User -and $_.PartitionKey -eq $TenantFilter -and $_.Type -eq $Type }
                    Remove-AzDataTableEntity @AuditLogExclusionsTable -Entity $Entity
                    Write-LogMessage -headers $Headers -API 'Set-CIPPAuditLogUserExclusion' -message "Removed audit log exclusion for user: $User" -Sev 'Info' -tenant $TenantFilter -LogData $Entity
                    "Removed audit log exclusion for user: $User"
                }
            } else {
                "User $User is not in the exclusion list."
            }
        }
    }
    return @($Results)
}

#EndRegion './Public/Set-CIPPAuditLogUserExclusion.ps1' 67
#Region './Public/Set-CIPPAuthenticationPolicy.ps1' -1

function Set-CIPPAuthenticationPolicy {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]$Tenant,
        [Parameter(Mandatory = $true)][ValidateSet('FIDO2', 'MicrosoftAuthenticator', 'SMS', 'TemporaryAccessPass', 'HardwareOATH', 'softwareOath', 'Voice', 'Email', 'x509Certificate', 'QRCodePin')]$AuthenticationMethodId,
        [Parameter(Mandatory = $true)][bool]$Enabled, # true = enabled or false = disabled
        $MicrosoftAuthenticatorSoftwareOathEnabled,
        $TAPMinimumLifetime = 60, #Minutes
        $TAPMaximumLifetime = 480, #minutes
        $TAPDefaultLifeTime = 60, #minutes
        $TAPDefaultLength = 8, #TAP password generated length in chars
        $TAPisUsableOnce = $true,
        [Parameter()][ValidateRange(1, 395)]$QRCodeLifetimeInDays = 365,
        [Parameter()][ValidateRange(8, 20)]$QRCodePinLength = 8,
        $APIName = 'Set Authentication Policy',
        $Headers
    )

    # Convert bool input to usable string
    $State = if ($Enabled) { 'enabled' } else { 'disabled' }
    # Get current state of the called authentication method and Set state of authentication method to input state
    try {
        $CurrentInfo = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/$AuthenticationMethodId" -tenantid $Tenant
        $CurrentInfo.state = $State
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Could not get CurrentInfo for $AuthenticationMethodId. Error:$($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        Return "Could not get CurrentInfo for $AuthenticationMethodId. Error:$($ErrorMessage.NormalizedError)"
    }

    switch ($AuthenticationMethodId) {

        # FIDO2
        'FIDO2' {
            if ($State -eq 'enabled') {
                $CurrentInfo.isAttestationEnforced = $true
                $CurrentInfo.isSelfServiceRegistrationAllowed = $true
            }
        }

        # Microsoft Authenticator
        'MicrosoftAuthenticator' {
            # Remove numberMatchingRequiredState property if it exists
            $CurrentInfo.featureSettings.PSObject.Properties.Remove('numberMatchingRequiredState')

            if ($State -eq 'enabled') {
                $CurrentInfo.featureSettings.displayAppInformationRequiredState.state = $State
                $CurrentInfo.featureSettings.displayLocationInformationRequiredState.state = $State
                # Set MS authenticator OTP state if parameter is passed in
                if ($null -ne $MicrosoftAuthenticatorSoftwareOathEnabled ) {
                    $CurrentInfo.isSoftwareOathEnabled = $MicrosoftAuthenticatorSoftwareOathEnabled
                    $OptionalLogMessage = "and MS Authenticator software OTP to $MicrosoftAuthenticatorSoftwareOathEnabled"
                }
            }
        }

        # SMS
        'SMS' {
            if ($State -eq 'enabled') {
                Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Setting $AuthenticationMethodId to enabled is not allowed" -sev Error
                throw "Setting $AuthenticationMethodId to enabled is not allowed"
            }
        }

        # Temporary Access Pass
        'TemporaryAccessPass' {
            if ($State -eq 'enabled') {
                $CurrentInfo.isUsableOnce = [System.Convert]::ToBoolean($TAPisUsableOnce)
                $CurrentInfo.minimumLifetimeInMinutes = $TAPMinimumLifetime
                $CurrentInfo.maximumLifetimeInMinutes = $TAPMaximumLifetime
                $CurrentInfo.defaultLifetimeInMinutes = $TAPDefaultLifeTime
                $CurrentInfo.defaultLength = $TAPDefaultLength
                $OptionalLogMessage = "with TAP isUsableOnce set to $TAPisUsableOnce"
            }
        }

        # Hardware OATH tokens (Preview)
        'HardwareOATH' {
            # Nothing special to do here
        }

        # Third-party software OATH tokens
        'softwareOath' {
            # Nothing special to do here
        }

        # Voice call
        'Voice' {
            # Disallow enabling voice
            if ($State -eq 'enabled') {
                Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Setting $AuthenticationMethodId to enabled is not allowed" -sev Error
                throw "Setting $AuthenticationMethodId to enabled is not allowed"
            }
        }

        # Email OTP
        'Email' {
            if ($State -eq 'enabled') {
                Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Setting $AuthenticationMethodId to enabled is not allowed" -sev Error
                throw "Setting $AuthenticationMethodId to enabled is not allowed"
            }
        }

        # Certificate-based authentication
        'x509Certificate' {
            # Nothing special to do here
        }

        # QR code
        'QRCodePin' {
            if ($State -eq 'enabled') {
                Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Setting $AuthenticationMethodId to enabled is not allowed" -sev Error
                throw "Setting $AuthenticationMethodId to enabled is not allowed"
            }
        }
        Default {
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Somehow you hit the default case with an input of $AuthenticationMethodId . You probably made a typo in the input for AuthenticationMethodId. It`'s case sensitive." -sev Error
            throw "Somehow you hit the default case with an input of $AuthenticationMethodId . You probably made a typo in the input for AuthenticationMethodId. It`'s case sensitive."
        }
    }
    # Set state of the authentication method
    try {
        if ($PSCmdlet.ShouldProcess($AuthenticationMethodId, "Set state to $State $OptionalLogMessage")) {
            # Convert body to JSON and send request
            $null = New-GraphPostRequest -tenantid $Tenant -Uri "https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/$AuthenticationMethodId" -Type PATCH -Body (ConvertTo-Json -InputObject $CurrentInfo -Compress -Depth 10) -ContentType 'application/json'
            Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Set $AuthenticationMethodId state to $State $OptionalLogMessage" -sev Info
        }
        return "Set $AuthenticationMethodId state to $State $OptionalLogMessage"

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $Tenant -message "Failed to $State $AuthenticationMethodId Support: $ErrorMessage" -sev Error -LogData $ErrorMessage
        throw "Failed to $State $AuthenticationMethodId Support. Error: $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPAuthenticationPolicy.ps1' 136
#Region './Public/Set-CIPPCAExclusion.ps1' -1

function Set-CIPPCAExclusion {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter,
        $ExclusionType,
        $UserID,
        $PolicyId,
        $Username,
        $Users,
        $Groups,
        $Headers
    )
    try {
        $CheckExisting = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($PolicyId)" -tenantid $TenantFilter -AsApp $true
        if ($ExclusionType -eq 'add') {
            if ($Groups) {
                # Handle group exclusions
                $Groupnames = $Groups.addedFields.displayName
                $ExcludeGroups = [System.Collections.Generic.List[string]]::new()
                foreach ($Group in $CheckExisting.conditions.users.excludeGroups) {
                    $ExcludeGroups.Add($Group)
                }
                foreach ($Group in $Groups.value) {
                    if ($Group -and $Group -ne '' -and $ExcludeGroups -notcontains $Group) {
                        $ExcludeGroups.Add($Group)
                    }
                }
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeGroups = $ExcludeGroups
                        }
                    }
                }
            } elseif ($Users) {
                $Username = $Users.addedFields.userPrincipalName
                $ExcludeUsers = [System.Collections.Generic.List[string]]::new()
                foreach ($User in $CheckExisting.conditions.users.excludeUsers) {
                    $ExcludeUsers.Add($User)
                }
                foreach ($User in $Users.value) {
                    if ($User -and $User -ne '' -and $ExcludeUsers -notcontains $User) {
                        $ExcludeUsers.Add($User)
                    }
                }
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeUsers = $ExcludeUsers
                        }
                    }
                }
            } elseif ($UserID) {
                if ($UserID -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$') {
                    $Username = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)" -tenantid $TenantFilter).userPrincipalName
                }
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeUsers = @($CheckExisting.conditions.users.excludeUsers + $UserID)
                        }
                    }
                }
            }

            $RawJson = ConvertTo-Json -Depth 10 -InputObject $NewExclusions

            if ($Groups) {
                $Identifier = ($Groupnames -join ', ')
                $IdentifierType = 'group'
            } elseif ($Users) {
                $Identifier = ($Username -join ', ')
                $IdentifierType = 'user'
            } else {
                $Identifier = $UserID
                $IdentifierType = 'user'
            }
            if ($PSCmdlet.ShouldProcess($PolicyId, "Add exclusion for $IdentifierType $Identifier")) {
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($CheckExisting.id)" -tenantid $tenantfilter -type PATCH -body $RawJSON -AsApp $true
            }
        }

        if ($ExclusionType -eq 'remove') {
            if ($Groups) {
                # Handle group exclusions removal
                $GroupID = $Groups.value | Where-Object { $_ -and $_ -ne '' }
                $Groupnames = $Groups.addedFields.displayName
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeGroups = @($CheckExisting.conditions.users.excludeGroups | Where-Object { $GroupID -notcontains $_ })
                        }
                    }
                }
            } elseif ($Users) {
                $UserID = $Users.value | Where-Object { $_ -and $_ -ne '' }
                $Username = $Users.addedFields.userPrincipalName
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeUsers = @($CheckExisting.conditions.users.excludeUsers | Where-Object { $UserID -notcontains $_ })
                        }
                    }
                }
            } else {
                if ($UserID -match '^[a-f0-9]{8}-([a-f0-9]{4}-){3}[a-f0-9]{12}$') {
                    $Username = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)" -tenantid $TenantFilter).userPrincipalName
                }
                $UserID = @($UserID)
                $NewExclusions = [pscustomobject]@{
                    conditions = [pscustomobject]@{ users = [pscustomobject]@{
                            excludeUsers = @($CheckExisting.conditions.users.excludeUsers | Where-Object { $UserID -notcontains $_ })
                        }
                    }
                }
            }
            $RawJson = ConvertTo-Json -Depth 10 -InputObject $NewExclusions

            if ($Groups) {
                $Identifier = ($Groupnames -join ', ')
                $IdentifierType = 'group'
            } elseif ($Users) {
                $Identifier = ($Username -join ', ')
                $IdentifierType = 'user'
            } else {
                $Identifier = $UserID
                $IdentifierType = 'user'
            }
            if ($PSCmdlet.ShouldProcess($PolicyId, "Remove exclusion for $IdentifierType $Identifier")) {
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($CheckExisting.id)" -tenantid $tenantfilter -type PATCH -body $RawJSON -AsApp $true
            }
        }

        if ($Groups) {
            foreach ($Group in $Groupnames) {
                "Successfully performed $($ExclusionType) exclusion for group $Group from policy $($CheckExisting.displayName)"
                Write-LogMessage -headers $Headers -API 'Set-CIPPCAExclusion' -message "Successfully performed $($ExclusionType) exclusion for group $Group from policy $($CheckExisting.displayName)" -Sev 'Info' -tenant $TenantFilter
            }
        } else {
            foreach ($User in $Username) {
                "Successfully performed $($ExclusionType) exclusion for $User from policy $($CheckExisting.displayName)"
                Write-LogMessage -headers $Headers -API 'Set-CIPPCAExclusion' -message "Successfully performed $($ExclusionType) exclusion for $User from policy $($CheckExisting.displayName)" -Sev 'Info' -tenant $TenantFilter
            }
        }
    } catch {
        if ($Groups) {
            foreach ($Group in $Groupnames) {
                "Failed to $($ExclusionType) group exclusion for $Group from policy $($CheckExisting.displayName): $($_.Exception.Message)"
                Write-LogMessage -headers $Headers -API 'Set-CIPPCAExclusion' -message "Failed to $($ExclusionType) group exclusion for $Group from policy $($CheckExisting.displayName): $_" -Sev 'Error' -tenant $TenantFilter -LogData (Get-CippException -Exception $_)
            }
        } else {
            foreach ($User in $Username) {
                "Failed to $($ExclusionType) user exclusion for $User from policy $($CheckExisting.displayName): $($_.Exception.Message)"
                Write-LogMessage -headers $Headers -API 'Set-CIPPCAExclusion' -message "Failed to $($ExclusionType) user exclusion for $User from policy $($CheckExisting.displayName): $_" -Sev 'Error' -tenant $TenantFilter -LogData (Get-CippException -Exception $_)
            }
        }
    }
}

#EndRegion './Public/Set-CIPPCAExclusion.ps1' 155
#Region './Public/Set-CIPPCalendarPermission.ps1' -1

function Set-CIPPCalendarPermission {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $APIName = 'Set Calendar Permissions',
        $Headers,
        $RemoveAccess,
        $TenantFilter,
        $UserID,
        $FolderName,
        $UserToGetPermissions,
        $LoggingName,
        $Permissions,
        [bool]$CanViewPrivateItems,
        [bool]$SendNotificationToUser = $false
    )

    try {
        # If a pretty logging name is not provided, use the ID instead
        if ([string]::IsNullOrWhiteSpace($LoggingName) -and $RemoveAccess) {
            $LoggingName = $RemoveAccess
        } elseif ([string]::IsNullOrWhiteSpace($LoggingName) -and $UserToGetPermissions) {
            $LoggingName = $UserToGetPermissions
        }

        $CalParam = [PSCustomObject]@{
            Identity               = "$($UserID):\$FolderName"
            AccessRights           = @($Permissions)
            User                   = $UserToGetPermissions
            SendNotificationToUser = $SendNotificationToUser
        }

        if ($CanViewPrivateItems) {
            $CalParam | Add-Member -NotePropertyName 'SharingPermissionFlags' -NotePropertyValue 'Delegate,CanViewPrivateItems'
        }

        if ($RemoveAccess) {
            if ($PSCmdlet.ShouldProcess("$UserID\$FolderName", "Remove permissions for $LoggingName")) {
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-MailboxFolderPermission' -cmdParams @{Identity = "$($UserID):\$FolderName"; User = $RemoveAccess }
                $Result = "Successfully removed access for $LoggingName from calendar $($CalParam.Identity)"
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            }
        } else {
            if ($PSCmdlet.ShouldProcess("$UserID\$FolderName", "Set permissions for $LoggingName to $Permissions")) {
                try {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxFolderPermission' -cmdParams $CalParam -Anchor $UserID
                } catch {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Add-MailboxFolderPermission' -cmdParams $CalParam -Anchor $UserID
                }
                $Result = "Successfully set permissions on folder $($CalParam.Identity). The user $LoggingName now has $Permissions permissions on this folder."
                if ($CanViewPrivateItems) {
                    $Result += ' The user can also view private items.'
                }
                if ($SendNotificationToUser) {
                    $Result += ' A notification has been sent to the user.'
                }
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Warning "Error changing calendar permissions $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        $Result = "Failed to set calendar permissions for $LoggingName on $UserID : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error -LogData $ErrorMessage
        throw $Result
    }

    return $Result
}
#EndRegion './Public/Set-CIPPCalendarPermission.ps1' 70
#Region './Public/Set-CIPPCAPolicyServiceException.ps1' -1

function Set-CIPPCAPolicyServiceException {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter,
        $PolicyId
    )

    $CSPtenantId = $env:TenantID

    # Get the current policy
    $policy = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($PolicyId)" -tenantid $TenantFilter -AsApp $true

    # If the policy is set to affect either all or all guests/external users
    if ($policy.conditions.users.includeUsers -eq "All" -OR $policy.conditions.users.includeGuestsOrExternalUsers.externalTenants.membershipKind -eq "all") {

        # Check if the policy already has the correct service provider exception
        if ($policy.conditions.users.excludeGuestsOrExternalUsers) {
            $excludeConfig = $policy.conditions.users.excludeGuestsOrExternalUsers

            # Check if serviceProvider is already in guestOrExternalUserTypes
            $hasServiceProvider = $excludeConfig.guestOrExternalUserTypes -match "serviceProvider"

            # Check if externalTenants is properly configured
            if ($excludeConfig.externalTenants) {
                $externalTenants = $excludeConfig.externalTenants
                $hasCorrectExternalTenants = ($externalTenants.membershipKind -eq "enumerated" -and
                                           $externalTenants.members -contains $CSPtenantId)

                # If already configured, exit without making changes
                if ($hasServiceProvider -and $hasCorrectExternalTenants) {
                    return "Policy $PolicyId already has the correct service provider configuration. No changes needed."
                }
            }
        }

        # If excludeGuestsOrExternalUsers is empty, add the entire exclusion
        if (!($policy.conditions.users.excludeGuestsOrExternalUsers)) {

            # Define data
            $excludeServiceProviderData = [pscustomobject]@{
                guestOrExternalUserTypes = "serviceProvider"
                externalTenants = [pscustomobject]@{
                    '@odata.type' = "#microsoft.graph.conditionalAccessEnumeratedExternalTenants"
                    membershipKind = "enumerated"
                    members = @(
                        $CSPtenantId
                    )
                }
            }

            # Add data to cached policy
            $policy.conditions.users.excludeGuestsOrExternalUsers = $excludeServiceProviderData
        }

        # If excludeGuestsOrExternalUsers already has content correct it to match $excludeServiceProviderData
        if ($policy.conditions.users.excludeGuestsOrExternalUsers) {

            # If guestOrExternalUserTypes doesn't include type serviceProvider add it
            if ($policy.conditions.users.excludeGuestsOrExternalUsers.guestOrExternalUserTypes -notmatch "serviceProvider") {
                $policy.conditions.users.excludeGuestsOrExternalUsers.guestOrExternalUserTypes += ",serviceProvider"
            }

            # If guestOrExternalUserTypes includes type serviceProvider and membershipKind is not all tenants
            if ($policy.conditions.users.excludeGuestsOrExternalUsers.guestOrExternalUserTypes -match "serviceProvider" -AND $policy.conditions.users.excludeGuestsOrExternalUsers.externalTenants.membershipKind -ne "all") {

                # If membershipKind is enumerated and members does not include our tenant add it
                if ($policy.conditions.users.excludeGuestsOrExternalUsers.externalTenants.membershipKind -eq "enumerated" -AND $policy.conditions.users.excludeGuestsOrExternalUsers.externalTenants.members -notmatch $CSPtenantId) {
                    $policy.conditions.users.excludeGuestsOrExternalUsers.externalTenants.members += $($CSPtenantId)
                }
            }
        }

    }

    # Patch policy with updated data.
    # TemplateId,createdDateTime,modifiedDateTime can't be written back so exclude them using -ExcludeProperty
    if ($PSCmdlet.ShouldProcess($PolicyId, "Update policy with service provider exception")) {
        $patch = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/policies/$($policy.id)" -tenantid $TenantFilter -type PATCH -body ($policy | Select-Object * -ExcludeProperty TemplateId,createdDateTime,modifiedDateTime | ConvertTo-Json -Depth 20) -AsApp $true
        return "Successfully added service provider to policy $PolicyId"
    }

}
#EndRegion './Public/Set-CIPPCAPolicyServiceException.ps1' 83
#Region './Public/Set-CIPPCloudManaged.ps1' -1

function Set-CIPPCloudManaged(
    [string]$TenantFilter,
    [string]$Id,
    [string]$DisplayName,
    [ValidateSet('User', 'Group', 'Contact')]
    [string]$Type,
    [bool]$IsCloudManaged,
    [string]$APIName = 'Set Cloud Managed',
    $Headers
) {
    try {
        $statusText = if ($IsCloudManaged -eq $true) { 'cloud-managed' } else { 'on-premises managed' }

        $URI = switch ($Type) {
            'User' { "https://graph.microsoft.com/beta/users/$Id/onPremisesSyncBehavior" }
            'Group' { "https://graph.microsoft.com/beta/groups/$Id/onPremisesSyncBehavior" }
            'Contact' { "https://graph.microsoft.com/beta/contacts/$Id/onPremisesSyncBehavior" }
        }

        $Body = @{
            isCloudManaged = $IsCloudManaged
        } | ConvertTo-Json -Depth 10

        $null = New-GraphPOSTRequest -uri $URI -type PATCH -tenantid $TenantFilter -body $Body -AsApp $true
        $Message = "Successfully set $Type $DisplayName ($Id) source of authority to $statusText"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Info'
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set $Type $DisplayName ($Id) source of authority to ${statusText}: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Error' -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPCloudManaged.ps1' 35
#Region './Public/Set-CIPPContactPermission.ps1' -1

function Set-CIPPContactPermission {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $APIName = 'Set Contact Permissions',
        $Headers,
        $RemoveAccess,
        $TenantFilter,
        $UserID,
        $FolderName,
        $UserToGetPermissions,
        $LoggingName,
        $Permissions,
        [bool]$SendNotificationToUser = $false
    )

    try {
        # If a pretty logging name is not provided, use the ID instead
        if ([string]::IsNullOrWhiteSpace($LoggingName) -and $RemoveAccess) {
            $LoggingName = $RemoveAccess
        } elseif ([string]::IsNullOrWhiteSpace($LoggingName) -and $UserToGetPermissions) {
            $LoggingName = $UserToGetPermissions
        }

        $ContactParam = [PSCustomObject]@{
            Identity               = "$($UserID):\$FolderName"
            AccessRights           = @($Permissions)
            User                   = $UserToGetPermissions
            SendNotificationToUser = $SendNotificationToUser
        }

        if ($RemoveAccess) {
            if ($PSCmdlet.ShouldProcess("$UserID\$FolderName", "Remove permissions for $LoggingName")) {
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Remove-MailboxFolderPermission' -cmdParams @{Identity = "$($UserID):\$FolderName"; User = $RemoveAccess }
                $Result = "Successfully removed access for $LoggingName from contact folder $($ContactParam.Identity)"
                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            }
        } else {
            if ($PSCmdlet.ShouldProcess("$UserID\$FolderName", "Set permissions for $LoggingName to $Permissions")) {
                try {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxFolderPermission' -cmdParams $ContactParam -Anchor $UserID
                } catch {
                    $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Add-MailboxFolderPermission' -cmdParams $ContactParam -Anchor $UserID
                }

                $Result = "Successfully set permissions on contact folder $($ContactParam.Identity). The user $LoggingName now has $Permissions permissions on this folder."

                if ($SendNotificationToUser) {
                    $Result += ' A notification has been sent to the user.'
                }

                Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Info
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Warning "Error changing contact permissions $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
        $Result = "Failed to set contact permissions for $LoggingName on $UserID : $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -sev Error -LogData $ErrorMessage
        throw $Result
    }

    return $Result
}
#EndRegion './Public/Set-CIPPContactPermission.ps1' 65
#Region './Public/Set-CIPPCopyGroupMembers.ps1' -1

function Set-CIPPCopyGroupMembers {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $Headers,
        [string]$UserId,
        [string]$CopyFromId,
        [string]$TenantFilter,
        [string]$APIName = 'Copy User Groups',
        [switch]$ExchangeOnly
    )

    $Requests = @(
        @{
            id     = 'User'
            url    = 'users/{0}' -f $UserId
            method = 'GET'
        }
        @{
            id     = 'UserMembership'
            url    = 'users/{0}/memberOf' -f $UserId
            method = 'GET'
        }
        @{
            id     = 'CopyFromMembership'
            url    = 'users/{0}/memberOf' -f $CopyFromId
            method = 'GET'
        }
    )
    $Results = New-GraphBulkRequest -Requests $Requests -tenantid $TenantFilter
    $User = ($Results | Where-Object { $_.id -eq 'User' }).body
    $CurrentMemberships = ($Results | Where-Object { $_.id -eq 'UserMembership' }).body.value
    $CopyFromMemberships = ($Results | Where-Object { $_.id -eq 'CopyFromMembership' }).body.value

    # Write-Information ($Results | ConvertTo-Json -Depth 10) # For debugging

    $ODataBind = 'https://graph.microsoft.com/v1.0/directoryObjects/{0}' -f $User.id
    $AddMemberBody = @{
        '@odata.id' = $ODataBind
    } | ConvertTo-Json -Compress

    $Success = [System.Collections.Generic.List[object]]::new()
    $Errors = [System.Collections.Generic.List[object]]::new()
    $Memberships = $CopyFromMemberships | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.group' -and
        $_.groupTypes -notcontains 'DynamicMembership' -and
        $_.onPremisesSyncEnabled -ne $true -and
        $_.visibility -ne 'Public' -and
        $CurrentMemberships.id -notcontains $_.id }
    $ScheduleExchangeGroupTask = $false
    foreach ($MailGroup in $Memberships) {
        try {
            if ($PSCmdlet.ShouldProcess($MailGroup.displayName, "Add $UserId to group")) {
                if ($MailGroup.MailEnabled -and $MailGroup.ResourceProvisioningOptions -notcontains 'Team' -and $MailGroup.groupTypes -notcontains 'Unified') {
                    $Params = @{ Identity = $MailGroup.id; Member = $UserId; BypassSecurityGroupManagerCheck = $true }
                    try {
                        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Add-DistributionGroupMember' -cmdParams $params -UseSystemMailbox $true
                    } catch {
                        if ($_.Exception.Message -match 'Ex94914C|Microsoft.Exchange.Configuration.Tasks.ManagementObjectNotFoundException') {
                            if (($User.assignedLicenses | Measure-Object).Count -gt 0 -and !$ExchangeOnly.IsPresent) {
                                $ScheduleExchangeGroupTask = $true
                            } else {
                                throw $_
                            }
                        } else {
                            throw $_
                        }
                    }
                } elseif (!$ExchangeOnly.IsPresent) {
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/groups/$($MailGroup.id)/members/`$ref" -tenantid $TenantFilter -body $AddMemberBody -Verbose
                }
            }

            if ($ScheduleExchangeGroupTask) {
                $TaskBody = [PSCustomObject]@{
                    TenantFilter  = $TenantFilter
                    Name          = "Copy Exchange Group Membership: $UserId from $CopyFromId"
                    Command       = @{
                        value = 'Set-CIPPCopyGroupMembers'
                    }
                    Parameters    = [PSCustomObject]@{
                        UserId       = $UserId
                        CopyFromId   = $CopyFromId
                        TenantFilter = $TenantFilter
                        ExchangeOnly = $true
                    }
                    ScheduledTime = [int64](([datetime]::UtcNow).AddMinutes(5) - (Get-Date '1/1/1970')).TotalSeconds
                    PostExecution = @{
                        Webhook = $false
                        Email   = $false
                        PSA     = $false
                    }
                }
                Add-CIPPScheduledTask -Task $TaskBody -hidden $false
                $Errors.Add("We've scheduled a task to add $UserId to the Exchange group $($MailGroup.displayName)") | Out-Null
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "Added $UserId to group $($MailGroup.displayName)" -Sev 'Info' -tenant $TenantFilter
                $Success.Add("Added user to group: $($MailGroup.displayName)") | Out-Null
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $Errors.Add("We've failed to add the group $($MailGroup.displayName): $($ErrorMessage.NormalizedError)") | Out-Null
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Group adding failed for group $($_.displayName):  $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        }
    }

    $Results = [PSCustomObject]@{
        'Success' = $Success
        'Error'   = $Errors
    }

    return @($Results)
}
#EndRegion './Public/Set-CIPPCopyGroupMembers.ps1' 112
#Region './Public/Set-CIPPCPVConsent.ps1' -1

function Set-CIPPCPVConsent {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter,
        $APIName = 'CPV Consent',
        $Headers,
        [bool]$ResetSP = $false
    )
    $Results = [System.Collections.Generic.List[string]]::new()
    $Tenant = Get-Tenants -IncludeAll | Where-Object -Property customerId -EQ $TenantFilter | Select-Object -First 1
    $TenantName = $Tenant.displayName
    $User = $Request.Headers

    if ($TenantFilter -eq $env:TenantID) {
        return @('Cannot modify CPV consent on partner tenant')
    }
    if ($Tenant.customerId -ne $TenantFilter) {
        return @('Not a valid tenant')
    }
    if ($Tenant.delegatedPrivilegeStatus -eq 'directTenant') {
        return @('Application is already consented to this tenant')
    }

    if ($ResetSP) {
        try {
            if ($PSCmdlet.ShouldProcess($env:ApplicationID, "Delete Service Principal from $TenantName")) {
                $null = New-GraphPostRequest -Type DELETE -noauthcheck $true -uri "https://api.partnercenter.microsoft.com/v1/customers/$($TenantFilter)/applicationconsents/$($env:ApplicationID)" -scope 'https://api.partnercenter.microsoft.com/.default' -tenantid $env:TenantID
            }
            $Results.add("Deleted Service Principal from $TenantName")
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $Results.add("Error deleting SP - $($ErrorMessage)")
        }
    }

    try {
        $AppBody = @{
            ApplicationId     = $($env:ApplicationID)
            ApplicationGrants = @(
                @{
                    EnterpriseApplicationId = '00000003-0000-0000-c000-000000000000'
                    Scope                   = @(
                        'DelegatedPermissionGrant.ReadWrite.All',
                        'Directory.ReadWrite.All',
                        'AppRoleAssignment.ReadWrite.All'
                    ) -join ','
                }
            )
        } | ConvertTo-Json

        if ($PSCmdlet.ShouldProcess($env:ApplicationID, "Add Service Principal to $TenantName")) {
            $null = New-GraphpostRequest -body $AppBody -Type POST -noauthcheck $true -uri "https://api.partnercenter.microsoft.com/v1/customers/$($TenantFilter)/applicationconsents" -scope 'https://api.partnercenter.microsoft.com/.default' -tenantid $env:TenantID
            $Table = Get-CIPPTable -TableName cpvtenants
            $unixtime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
            $GraphRequest = @{
                LastApply     = "$unixtime"
                applicationId = "$($env:ApplicationID)"
                Tenant        = "$($tenantfilter)"
                PartitionKey  = 'Tenant'
                RowKey        = "$($tenantfilter)"
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force
        }
        $Results.add("Successfully added CPV Application to tenant $($TenantName)") | Out-Null
        Write-LogMessage -Headers $User -API $APINAME -message "Added our Service Principal to $($TenantName)" -Sev 'Info' -tenant $Tenant.defaultDomainName -tenantId $TenantFilter
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        if ($ErrorMessage.NormalizedError -like '*Permission entry already exists*') {
            $Table = Get-CIPPTable -TableName cpvtenants
            $unixtime = [int64](([datetime]::UtcNow) - (Get-Date '1/1/1970')).TotalSeconds
            $GraphRequest = @{
                LastApply     = "$unixtime"
                applicationId = "$($env:ApplicationID)"
                Tenant        = "$($tenantfilter)"
                PartitionKey  = 'Tenant'
                RowKey        = "$($tenantfilter)"
            }
            Add-CIPPAzDataTableEntity @Table -Entity $GraphRequest -Force
            return @("We've already added our Service Principal to $($TenantName)")
        }
        Write-LogMessage -Headers $User -API $APINAME -message "Could not add our Service Principal to the client tenant $($TenantName): $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $Tenant.defaultDomainName -tenantId $TenantFilter -LogData $ErrorMessage
        return @("Could not add our Service Principal to the client tenant $($TenantName). Error: $($ErrorMessage.NormalizedError)")
    }
    return $Results
}
#EndRegion './Public/Set-CIPPCPVConsent.ps1' 86
#Region './Public/Set-CIPPDefaultAPDeploymentProfile.ps1' -1

function Set-CIPPDefaultAPDeploymentProfile {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter,
        $DisplayName,
        $Description,
        $DeviceNameTemplate,
        $AllowWhiteGlove,
        $CollectHash,
        $UserType,
        $DeploymentMode,
        $HideChangeAccount = $true,
        $AssignTo,
        $HidePrivacy,
        $HideTerms,
        $AutoKeyboard,
        $Headers,
        $Language = 'os-default',
        $APIName = 'Add Default Enrollment Status Page'
    )

    $User = $Request.Headers

    try {
        $ObjBody = [pscustomobject]@{
            '@odata.type'                   = '#microsoft.graph.azureADWindowsAutopilotDeploymentProfile'
            'displayName'                   = "$($DisplayName)"
            'description'                   = "$($Description)"
            'deviceNameTemplate'            = "$($DeviceNameTemplate)"
            'locale'                        = "$($Language ?? 'os-default')"
            'preprovisioningAllowed'        = $([bool]($AllowWhiteGlove))
            'deviceType'                    = 'windowsPc'
            'hardwareHashExtractionEnabled' = $([bool]($CollectHash))
            'roleScopeTagIds'               = @()
            'outOfBoxExperienceSetting'     = @{
                'deviceUsageType'              = "$DeploymentMode"
                'escapeLinkHidden'             = $([bool]($true))
                'privacySettingsHidden'        = $([bool]($HidePrivacy))
                'eulaHidden'                   = $([bool]($HideTerms))
                'userType'                     = "$UserType"
                'keyboardSelectionPageSkipped' = $([bool]($AutoKeyboard))
            }
        }
        $Body = ConvertTo-Json -InputObject $ObjBody -Depth 10

        Write-Information $Body

        $Profiles = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles' -tenantid $TenantFilter | Where-Object -Property displayName -EQ $DisplayName
        if ($Profiles.count -gt 1) {
            $Profiles | ForEach-Object {
                if ($_.id -ne $Profiles[0].id) {
                    if ($PSCmdlet.ShouldProcess($_.displayName, 'Delete duplicate Autopilot profile')) {
                        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$($_.id)" -tenantid $TenantFilter -type DELETE
                        Write-LogMessage -Headers $User -API $APIName -tenant $($TenantFilter) -message "Deleted duplicate Autopilot profile $($DisplayName)" -Sev 'Info'
                    }
                }
            }
            $Profiles = $Profiles[0]
        }
        if (!$Profiles) {
            if ($PSCmdlet.ShouldProcess($DisplayName, 'Add Autopilot profile')) {
                $Type = 'Add'
                $GraphRequest = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles' -body $Body -tenantid $TenantFilter
                Write-LogMessage -Headers $User -API $APIName -tenant $($TenantFilter) -message "Added Autopilot profile $($DisplayName)" -Sev 'Info'
            }
        } else {
            $Type = 'Edit'
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$($Profiles.id)" -tenantid $TenantFilter -body $Body -type PATCH
            $GraphRequest = $Profiles | Select-Object -Last 1
        }

        if ($AssignTo -eq $true) {
            $AssignBody = '{"target":{"@odata.type":"#microsoft.graph.allDevicesAssignmentTarget"}}'
            if ($PSCmdlet.ShouldProcess($AssignTo, "Assign Autopilot profile $DisplayName")) {
                #Get assignments
                $Assignments = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$($GraphRequest.id)/assignments" -tenantid $TenantFilter
                if (!$Assignments) {
                    $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles/$($GraphRequest.id)/assignments" -tenantid $TenantFilter -type POST -body $AssignBody
                }
                Write-LogMessage -Headers $User -API $APIName -tenant $TenantFilter -message "Assigned autopilot profile $($DisplayName) to $AssignTo" -Sev 'Info'
            }
        }
        "Successfully $($Type)ed profile for $TenantFilter"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed $($Type)ing Autopilot Profile $($DisplayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $User -API $APIName -tenant $TenantFilter -message $Result -Sev 'Error' -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CIPPDefaultAPDeploymentProfile.ps1' 91
#Region './Public/Set-CIPPDefaultAPEnrollment.ps1' -1

function Set-CIPPDefaultAPEnrollment {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $TenantFilter,
        $ShowProgress,
        $BlockDevice,
        $AllowReset,
        $EnableLog,
        $ErrorMessage,
        $TimeOutInMinutes,
        $InstallWindowsUpdates,
        $AllowFail,
        $OBEEOnly,
        $Headers,
        $APIName = 'Add Default Enrollment Status Page'
    )

    try {
        $ObjBody = [pscustomobject]@{
            '@odata.type'                             = '#microsoft.graph.windows10EnrollmentCompletionPageConfiguration'
            'id'                                      = 'DefaultWindows10EnrollmentCompletionPageConfiguration'
            'displayName'                             = 'All users and all devices'
            'description'                             = 'This is the default enrollment status screen configuration applied with the lowest priority to all users and all devices regardless of group membership.'
            'showInstallationProgress'                = [bool]$ShowProgress
            'blockDeviceSetupRetryByUser'             = ![bool]$BlockDevice
            'allowDeviceResetOnInstallFailure'        = [bool]$AllowReset
            'allowLogCollectionOnInstallFailure'      = [bool]$EnableLog
            'customErrorMessage'                      = "$ErrorMessage"
            'installProgressTimeoutInMinutes'         = $TimeOutInMinutes
            'installQualityUpdates'                   = [bool]$InstallWindowsUpdates
            'allowDeviceUseOnInstallFailure'          = [bool]$AllowFail
            'selectedMobileAppIds'                    = @()
            'trackInstallProgressForAutopilotOnly'    = [bool]$OBEEOnly
            'disableUserStatusTrackingAfterFirstUser' = $true
            'roleScopeTagIds'                         = @()
        }
        $Body = ConvertTo-Json -InputObject $ObjBody
        $ExistingStatusPage = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations' -tenantid $TenantFilter) | Where-Object { $_.id -like '*DefaultWindows10EnrollmentCompletionPageConfiguration' }

        if ($PSCmdlet.ShouldProcess($ExistingStatusPage.ID, 'Set Default Enrollment Status Page')) {
            $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations/$($ExistingStatusPage.ID)" -body $Body -Type PATCH -tenantid $TenantFilter
            "Successfully changed default enrollment status page for $TenantFilter"
            Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Added Autopilot Enrollment Status Page $($ExistingStatusPage.displayName)" -Sev 'Info'
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Failed adding Autopilot Enrollment Status Page $($ExistingStatusPage.displayName). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        throw "Failed to change default enrollment status page for $($TenantFilter): $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPDefaultAPEnrollment.ps1' 51
#Region './Public/Set-CIPPDeviceState.ps1' -1

function Set-CIPPDeviceState {
    <#
    .SYNOPSIS
    Sets or modifies the state of a device in Microsoft Graph.

    .DESCRIPTION
    This function allows you to enable, disable, or delete a device by making
    corresponding requests to the Microsoft Graph API. It logs the result
    and returns a success or error message based on the outcome.

    .PARAMETER Action
    Specifies the action to perform on the device. Valid actions are:
        - Enable: Enable the device
        - Disable: Disable the device
        - Delete: Remove the device from the tenant

    .PARAMETER DeviceID
    Specifies the unique identifier (Object ID) of the device to be managed.

    .PARAMETER TenantFilter
    Specifies the tenant ID or domain against which to perform the operation.

    .PARAMETER Headers
    Specifies the user who initiated the request for logging purposes.

    .PARAMETER APIName
    Specifies the name of the API call for logging purposes. Defaults to 'Set Device State'.

    .EXAMPLE
    Set-CIPPDeviceState -Action Enable -DeviceID "1234abcd-5678-efgh-ijkl-9012mnopqrst" -TenantFilter "contoso.onmicrosoft.com" -Headers "admin@contoso.onmicrosoft.com"

    This command enables the specified device within the given tenant.

    .EXAMPLE
    Set-CIPPDeviceState -Action Delete -DeviceID "1234abcd-5678-efgh-ijkl-9012mnopqrst" -TenantFilter "contoso.onmicrosoft.com"

    This command removes the specified device from the tenant.
#>
    param (
        [Parameter(Mandatory = $true)][ValidateSet('Enable', 'Disable', 'Delete')]$Action,

        [ValidateScript({
                if ([Guid]::TryParse($_, [ref] [Guid]::Empty)) {
                    $true
                } else {
                    throw 'DeviceID must be a valid GUID.'
                }
            })]
        [Parameter(Mandatory = $true)]$DeviceID,

        [Parameter(Mandatory = $true)]$TenantFilter,
        $Headers,
        $APIName = 'Set Device State'
    )
    $Url = "https://graph.microsoft.com/beta/devices/$($DeviceID)"

    try {
        switch ($Action) {
            'Delete' {
                $ActionResult = New-GraphPOSTRequest -uri $Url -type DELETE -tenantid $TenantFilter
            }
            'Disable' {
                $ActionResult = New-GraphPOSTRequest -uri $Url -type PATCH -tenantid $TenantFilter -body '{"accountEnabled": false }'
            }
            'Enable' {
                $ActionResult = New-GraphPOSTRequest -uri $Url -type PATCH -tenantid $TenantFilter -body '{"accountEnabled": true }'
            }
        }
        Write-Host $ActionResult
        Write-LogMessage -headers $Headers -API $APIName -message "Executed action $($Action) on $($DeviceID)" -Sev Info
        return "Executed action $($Action) on $($DeviceID)"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to queue action $($Action) on $($DeviceID). Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        throw "Failed to queue action $($Action) on $($DeviceID). Error: $($ErrorMessage.NormalizedError)"
    }


}
#EndRegion './Public/Set-CIPPDeviceState.ps1' 80
#Region './Public/Set-CIPPDriftDeviation.ps1' -1

function Set-CIPPDriftDeviation {
    <#
    .SYNOPSIS
        Sets the status of a drift deviation in the tenant drift table
    .DESCRIPTION
        This function stores drift deviation status changes in the tenantDrift table.
        It tracks when deviations are accepted, denied, or marked as customer specific.
    .PARAMETER TenantFilter
        The tenant filter (used as PartitionKey)
    .PARAMETER StandardName
        The standard name (used as RowKey, with '.' replaced by '_')
    .PARAMETER Status
        The status to set. Valid values: Accepted, New, Denied, CustomerSpecific, DeniedRemediate, DeniedDelete
    .PARAMETER Reason
        Optional reason for the status change
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Set-CIPPDriftDeviation -TenantFilter "contoso.onmicrosoft.com" -StandardName "IntuneTemplates.12345" -Status "Accepted" -Reason "Business requirement"
    .EXAMPLE
        Set-CIPPDriftDeviation -TenantFilter "contoso.onmicrosoft.com" -StandardName "standards.passwordComplexity" -Status "CustomerSpecific" -Reason "Custom security policy"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [string]$StandardName,
        [Parameter(Mandatory = $true)]
        [ValidateSet('Accepted', 'New', 'Denied', 'CustomerSpecific', 'DeniedRemediate', 'DeniedDelete')]
        [string]$Status,
        [Parameter(Mandatory = $false)]
        [string]$Reason,
        [string]$user
    )

    try {
        $Table = Get-CippTable -tablename 'tenantDrift'
        $RowKey = $StandardName -replace '\.', '_'
        $Entity = @{
            PartitionKey = $TenantFilter
            RowKey       = $RowKey
            StandardName = $StandardName
            Status       = $Status
            User         = $user
            LastModified = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
        }

        # Add reason if provided
        if ($Reason) {
            $Entity.Reason = $Reason
        }

        $Result = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force

        Write-Verbose "Successfully set drift deviation status for $StandardName to $Status"
        return "Successfully set drift deviation status for $StandardName to $Status"

    } catch {
        Write-Error "Error setting drift deviation status: $($_.Exception.Message)"
        throw
    }
}
#EndRegion './Public/Set-CIPPDriftDeviation.ps1' 64
#Region './Public/Set-CIPPForwarding.ps1' -1

function Set-CIPPForwarding {
    <#
    .SYNOPSIS
    Set forwarding for a user mailbox.

    .DESCRIPTION
    Set forwarding for a user mailbox.

    .PARAMETER userid
    User ID to set forwarding for.

    .PARAMETER forwardingSMTPAddress
    SMTP address to forward to.

    .PARAMETER tenantFilter
    Tenant to manage for forwarding.

    .PARAMETER username
    Username to manage for forwarding.

    .PARAMETER Headers
    CIPP HTTP Request headers.

    .PARAMETER APIName
    Name of the API executing the command.

    .PARAMETER Forward
    Forwarding address.

    .PARAMETER KeepCopy
    Keep a copy of the email.

    .PARAMETER Disable
    Disable forwarding.

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [string]$UserID,
        [string]$ForwardingSMTPAddress,
        [string]$TenantFilter,
        [string]$Username,
        $Headers,
        [string]$APIName = 'Forwarding',
        [string]$Forward,
        $KeepCopy,
        [bool]$Disable
    )


    try {
        if (!$Username) { $Username = $UserID }
        if ($PSCmdlet.ShouldProcess($Username, 'Set forwarding')) {
            if ($Disable -eq $true) {
                Write-Output "Disabling forwarding for $Username"
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $UserID; ForwardingSMTPAddress = $null; ForwardingAddress = $null ; DeliverToMailboxAndForward = $false } -Anchor $Username
                $Message = "Successfully disabled forwarding for $Username"
            } elseif ($Forward) {
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $UserID; ForwardingSMTPAddress = $null; ForwardingAddress = $Forward ; DeliverToMailboxAndForward = $KeepCopy } -Anchor $Username
                $Message = "Successfully set forwarding for $Username to Internal Address $Forward with keeping a copy set to $KeepCopy"
            } elseif ($forwardingSMTPAddress) {
                $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $UserID; ForwardingSMTPAddress = $ForwardingSMTPAddress; ForwardingAddress = $null ; DeliverToMailboxAndForward = $KeepCopy } -Anchor $Username
                $Message = "Successfully set forwarding for $Username to External Address $ForwardingSMTPAddress with keeping a copy set to $KeepCopy"
            }
        }
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Info' -tenant $TenantFilter
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set forwarding for $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPForwarding.ps1' 75
#Region './Public/Set-CIPPGDAPAutoExtend.ps1' -1

function Set-CIPPGDAPAutoExtend {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        $RelationShipid,
        [switch]$All,
        $APIName = 'Set GDAP Auto Exension',
        $Headers
    )

    $ReturnedData = if ($All -eq $true) {
        $Relationships = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships' -tenantid $env:TenantID -NoAuthCheck $true | Where-Object -Property autoExtendDuration -EQ 'PT0S'
        foreach ($Relation in $Relationships) {
            try {
                $AddedHeader = @{'If-Match' = $Relation.'@odata.etag' }
                if ($PSCmdlet.ShouldProcess($Relation.id, "Set auto renew for $($Relation.customer.displayName)")) {
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($Relation.id)" -tenantid $env:TenantID -type PATCH -body '{"autoExtendDuration":"P180D"}' -Verbose -NoAuthCheck $true -AddedHeaders $AddedHeader
                    Write-LogMessage -headers $Headers -API $APIName -message "Successfully set auto renew for tenant $($Relation.customer.displayName) with ID $($RelationShipid)" -Sev 'Info'
                    @("Successfully set auto renew for tenant $($Relation.customer.displayName) with ID $($Relation.id)" )
                }
            } catch {
                $ErrorMessage = $_.Exception.Message
                $CleanError = Get-NormalizedError -message $ErrorMessage
                "Could not set auto renewal for $($Relation.id): $CleanError"
            }
        }
    } else {
        try {
            $Relationship = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships' -tenantid $env:TenantID -NoAuthCheck $true | Where-Object -Property id -EQ $RelationShipid
            $AddedHeader = @{'If-Match' = $Relationship.'@odata.etag' }
            if ($PSCmdlet.ShouldProcess($RelationShipid, "Set auto renew for $($Relationship.customer.displayName)")) {
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($RelationShipid)" -tenantid $env:TenantID -type PATCH -body '{"autoExtendDuration":"P180D"}' -Verbose -NoAuthCheck $true -AddedHeaders $AddedHeader
                write-LogMessage -headers $Headers -API $APIName -message "Successfully set auto renew for tenant $($Relationship.customer.displayName) with ID $($RelationShipid)" -Sev 'Info'
                @("Successfully set auto renew for tenant $($Relationship.customer.displayName) with ID $($RelationShipid)" )
            }
        } catch {
            $ErrorMessage = $_.Exception.Message
            $CleanError = Get-NormalizedError -message $ErrorMessage
            "Could not set auto renewal for $($RelationShipid): $CleanError"
        }
    }
    return $ReturnedData
}
#EndRegion './Public/Set-CIPPGDAPAutoExtend.ps1' 43
#Region './Public/Set-CIPPGDAPInviteGroups.ps1' -1

function Set-CIPPGDAPInviteGroups {
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param($Relationship)
    $Table = Get-CIPPTable -TableName 'GDAPInvites'

    if ($Relationship) {
        $Invite = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Relationship.id)'"
        $APINAME = 'GDAPInvites'
        $RoleMappings = $Invite.RoleMappings | ConvertFrom-Json
        $AccessAssignments = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($Relationship.id)/accessAssignments"
        foreach ($Role in $RoleMappings) {
            # Skip mapping if group is present in relationship
            if ($AccessAssignments.id -and $AccessAssignments.accessContainer.accessContainerid -contains $Role.GroupId ) { continue }
            try {
                $Mappingbody = ConvertTo-Json -Depth 10 -InputObject @{
                    'accessContainer' = @{
                        'accessContainerId'   = "$($Role.GroupId)"
                        'accessContainerType' = 'securityGroup'
                    }
                    'accessDetails'   = @{
                        'unifiedRoles' = @(@{
                                'roleDefinitionId' = "$($Role.roleDefinitionId)"
                            })
                    }
                }
                if ($PSCmdlet.ShouldProcess($Relationship.id, "Map group $($Role.GroupName) to customer $($Relationship.customer.displayName)")) {
                    $null = New-GraphPostRequest -NoAuthCheck $True -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships/$($Relationship.id)/accessAssignments" -tenantid $env:TenantID -type POST -body $MappingBody -verbose
                    Start-Sleep -Milliseconds 100
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API $APINAME -message "GDAP Group mapping failed for $($Relationship.customer.displayName) - Group: $($role.GroupId) - Exception: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
                return $false
            }
        }

        if ($PSCmdlet.ShouldProcess($Relationship.id, "Remove invite entry for $($Relationship.customer.displayName)")) {
            Write-LogMessage -API $APINAME -message "Groups mapped for GDAP Relationship: $($Relationship.customer.displayName) - $($Relationship.customer.displayName)" -Sev Info
            Remove-AzDataTableEntity -Force @Table -Entity $Invite
        }
        return $true
    } else {
        $InviteList = Get-CIPPAzDataTableEntity @Table
        if (($InviteList | Measure-Object).Count -gt 0) {
            $Activations = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships?`$filter=status eq 'active'"

            $Batch = foreach ($Activation in $Activations) {
                if ($InviteList.RowKey -contains $Activation.id) {
                    Write-Information "Mapping groups for GDAP relationship: $($Activation.customer.displayName) - $($Activation.id)"
                    $Activation | Add-Member -NotePropertyName FunctionName -NotePropertyValue 'ExecGDAPInviteQueue'
                    $Activation
                }
            }
            if (($Batch | Measure-Object).Count -gt 0) {
                $InputObject = [PSCustomObject]@{
                    OrchestratorName = 'GDAPInviteOrchestrator'
                    Batch            = @($Batch)
                    SkipLog          = $true
                }
                #Write-Information ($InputObject | ConvertTo-Json)
                $InstanceId = Start-NewOrchestration -FunctionName 'CIPPOrchestrator' -InputObject (ConvertTo-Json -InputObject $InputObject -Depth 5 -Compress)
                Write-Information "Started GDAP Invite orchestration with ID = '$InstanceId'"
                return $InstanceId
            }
        }
    }
}
#EndRegion './Public/Set-CIPPGDAPInviteGroups.ps1' 68
#Region './Public/Set-CIPPGraphSubscription.ps1' -1

function Set-CIPPGraphSubscription {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $RenewSubscriptions,
        $Resource,
        $EventType,
        $APIName = 'Set Graph Webhook',
        $Headers
    )

    if ($RenewSubscriptions) {
        $RenewalDate = (Get-Date).AddDays(1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
        $body = @{
            'expirationDateTime' = "$RenewalDate"
        } | ConvertTo-Json
        $null = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscriptions' -tenantid $TenantFilter) | ForEach-Object {
            try {
                $GraphRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/subscriptions/$($_.id)" -tenantid $TenantFilter -type PATCH -body $body -Verbose
                $WebhookTable = Get-CIPPTable -TableName webhookTable
                #get the row from the table, grab it by the webhook notification url, and update the expiration date.
                $WebhookRow = Get-CIPPAzDataTableEntity @WebhookTable | Where-Object { $_.WebhookNotificationUrl -eq $GraphRequest.notificationUrl }
                $WebhookRow.Expiration = $RenewalDate
                $null = Add-CIPPAzDataTableEntity @WebhookTable -Entity $WebhookRow -Force
                return "Renewed $($GraphRequest.notificationUrl)"

            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -headers $Headers -API $APIName -message "Failed to renew Webhook Subscription: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
                return   "Failed to renew Webhook Subscription $($WebhookRow.RowKey): $($ErrorMessage.NormalizedError)"
            }
        }
    }
}
#EndRegion './Public/Set-CIPPGraphSubscription.ps1' 35
#Region './Public/Set-CIPPGroupAuthentication.ps1' -1

function Set-CIPPGroupAuthentication(
    [string]$Headers,
    [string]$GroupType,
    [string]$Id,
    [bool]$OnlyAllowInternal,
    [string]$TenantFilter,
    [string]$APIName = 'Group Sender Authentication'
) {
    try {
        $messageSuffix = if ($OnlyAllowInternal -eq $true) { 'inside the organisation.' } else { 'inside and outside the organisation.' }

        if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-DistributionGroup' -cmdParams @{Identity = $Id; RequireSenderAuthenticationEnabled = $OnlyAllowInternal }
        } elseif ($GroupType -eq 'Microsoft 365') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-UnifiedGroup' -cmdParams @{Identity = $Id; RequireSenderAuthenticationEnabled = $OnlyAllowInternal }
        } elseif ($GroupType -eq 'Security') {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message 'This setting cannot be set on a security group.' -Sev 'Error'
            throw "$GroupType's group cannot have this setting changed"
        }

        $Message = "Successfully set $GroupType group $Id to allow messages from people $messageSuffix"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Info'
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set Delivery Management: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Error' -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPGroupAuthentication.ps1' 31
#Region './Public/Set-CIPPGroupGAL.ps1' -1

function Set-CIPPGroupGAL(
    [string]$Headers,
    [string]$GroupType,
    [string]$Id,
    [string]$HiddenString,
    [string]$TenantFilter,
    [string]$APIName = 'Group GAL Status'
) {
    $Hidden = if ($HiddenString -eq 'true') { 'true' } else { 'false' }
    $messageSuffix = if ($Hidden -eq 'true') { 'hidden' } else { 'unhidden' }

    try {
        if ($GroupType -eq 'Distribution List' -or $GroupType -eq 'Mail-Enabled Security') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-DistributionGroup' -cmdParams @{Identity = $Id; HiddenFromAddressListsEnabled = $Hidden }
        } elseif ($GroupType -eq 'Microsoft 365') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-UnifiedGroup' -cmdParams @{Identity = $Id; HiddenFromAddressListsEnabled = $Hidden }
        } elseif ($GroupType -eq 'Security') {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message 'This setting cannot be set on a security group.' -Sev 'Error'
            return "$GroupType's group cannot have this setting changed"
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "$Id $messageSuffix from GAL failed: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        return "Failed. $($ErrorMessage.NormalizedError)"
    }

    Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "$Id $messageSuffix from GAL" -Sev 'Info'
    return "Successfully $messageSuffix $GroupType group $Id from GAL."
}
#EndRegion './Public/Set-CIPPGroupGAL.ps1' 30
#Region './Public/Set-CIPPHideFromGAL.ps1' -1

function Set-CIPPHideFromGAL {
    [CmdletBinding()]
    param (
        $UserId,
        $TenantFilter,
        $APIName = 'Hide From Address List',
        [bool]$HideFromGAL,
        $Headers
    )
    $Text = if ($HideFromGAL) { 'hidden' } else { 'unhidden' }
    try {
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $UserId ; HiddenFromAddressListsEnabled = $HideFromGAL }
        $Result = "Successfully $Text $($UserId) from GAL."
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev Info
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set $($UserId) to $Text in GAL. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPHideFromGAL.ps1' 23
#Region './Public/Set-CIPPIntunePolicy.ps1' -1

function Set-CIPPIntunePolicy {
    param (
        [Parameter(Mandatory = $true)]
        $TemplateType,
        $Description,
        $DisplayName,
        $RawJSON,
        $AssignTo,
        $ExcludeGroup,
        $Headers,
        $APIName = 'Set-CIPPIntunePolicy',
        $TenantFilter,
        $AssignmentFilterName,
        $AssignmentFilterType = 'include'
    )

    $RawJSON = Get-CIPPTextReplacement -TenantFilter $TenantFilter -Text $RawJSON

    try {
        switch ($TemplateType) {
            'AppProtection' {
                $PlatformType = 'deviceAppManagement'
                $TemplateType = ($RawJSON | ConvertFrom-Json).'@odata.type' -replace '#microsoft.graph.', ''
                $PolicyFile = $RawJSON | ConvertFrom-Json
                $Null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'description' -Value $Description -Force
                $null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'displayName' -Value $DisplayName -Force
                $PolicyFile = $PolicyFile | Select-Object * -ExcludeProperty 'apps'
                $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 20
                $TemplateTypeURL = if ($TemplateType -eq 'windowsInformationProtectionPolicy') { 'windowsInformationProtectionPolicies' } else { "$($TemplateType)s" }
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                }
            }
            'AppConfiguration' {
                $PlatformType = 'deviceAppManagement'
                $TemplateTypeURL = 'mobileAppConfigurations'
                $PolicyFile = $RawJSON | ConvertFrom-Json
                $Null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'description' -Value $Description -Force
                $null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'displayName' -Value $DisplayName -Force
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    $PolicyFile = $PolicyFile | Select-Object * -ExcludeProperty id, createdDateTime, lastModifiedDateTime, version, '@odata.context', targetedMobileApps
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 20 -Compress
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Updated policy $($DisplayName) to template defaults" -Sev 'info'
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $PostType = 'added'
                    $PolicyFile = $PolicyFile | Select-Object * -ExcludeProperty id, createdDateTime, lastModifiedDateTime, version, '@odata.context'
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 20 -Compress
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'deviceCompliancePolicies' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'deviceCompliancePolicies'
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                $JSON = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty id, createdDateTime, lastModifiedDateTime, version, 'scheduledActionsForRule@odata.context', '@odata.context'
                $JSON.scheduledActionsForRule = @($JSON.scheduledActionsForRule | Select-Object * -ExcludeProperty 'scheduledActionConfigurations@odata.context')
                if ($DisplayName -in $CheckExististing.displayName) {
                    $RawJSON = ConvertTo-Json -InputObject ($JSON | Select-Object * -ExcludeProperty 'scheduledActionsForRule') -Depth 20 -Compress
                    $PostType = 'edited'
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Updated policy $($DisplayName) to template defaults" -Sev 'info'
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $RawJSON = ConvertTo-Json -InputObject $JSON -Depth 20 -Compress
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'Admin' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'groupPolicyConfigurations'
                $CreateBody = '{"description":"' + $Description + '","displayName":"' + $DisplayName + '","roleScopeTagIds":["0"]}'
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    $ExistingData = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($ExistingID.id)')/definitionValues" -tenantid $TenantFilter
                    $DeleteJson = $RawJSON | ConvertFrom-Json -Depth 10
                    $DeleteJson | Add-Member -MemberType NoteProperty -Name 'deletedIds' -Value @($ExistingData.id) -Force
                    $DeleteJson | Add-Member -MemberType NoteProperty -Name 'added' -Value @() -Force
                    $DeleteJson = ConvertTo-Json -Depth 10 -InputObject $DeleteJson
                    $DeleteRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($ExistingID.id)')/updateDefinitionValues" -tenantid $TenantFilter -type POST -body $DeleteJson
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($ExistingID.id)')/updateDefinitionValues" -tenantid $TenantFilter -type POST -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Updated policy $($DisplayName) to template defaults" -Sev 'info'
                    $PostType = 'edited'
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $CreateBody
                    $UpdateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL('$($CreateRequest.id)')/updateDefinitionValues" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) to template defaults" -Sev 'info'

                }
            }
            'Device' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'deviceConfigurations'
                $PolicyFile = $RawJSON | ConvertFrom-Json
                $Null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'description' -Value "$Description" -Force
                $null = $PolicyFile | Add-Member -MemberType NoteProperty -Name 'displayName' -Value $DisplayName -Force
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName | Select-Object -Last 1
                $PolicyFile = $policyFile | Select-Object * -ExcludeProperty 'featureUpdatesWillBeRolledBack', 'qualityUpdatesWillBeRolledBack', 'qualityUpdatesPauseStartDate', 'featureUpdatesPauseStartDate'
                $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                if ($ExistingID) {
                    $PostType = 'edited'
                    Write-Host "Raw JSON is $RawJSON"
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $tenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($tenantFilter) -message "Updated policy $($DisplayName) to template defaults" -Sev 'info'
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($tenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'

                }
            }
            'Catalog' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'configurationPolicies'
                $DisplayName = ($RawJSON | ConvertFrom-Json).Name

                $Template = $RawJSON | ConvertFrom-Json
                if ($Template.templateReference.templateId) {
                    Write-Information "Checking configuration policy template $($Template.templateReference.templateId) for $($DisplayName)"
                    # Remove unavailable settings from the template
                    $AvailableSettings = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/deviceManagement/configurationPolicyTemplates('$($Template.templateReference.templateId)')/settingTemplates?`$expand=settingDefinitions&`$top=1000" -tenantid $tenantFilter

                    if ($AvailableSettings) {
                        Write-Information "Available settings for template $($Template.templateReference.templateId): $($AvailableSettings.Count)"
                        $FilteredSettings = [System.Collections.Generic.List[psobject]]::new()
                        foreach ($setting in $Template.settings) {
                            if ($setting.settingInstance.settingInstanceTemplateReference.settingInstanceTemplateId -in $AvailableSettings.settingInstanceTemplate.settingInstanceTemplateId) {
                                $AvailableSetting = $AvailableSettings | Where-Object { $_.settingInstanceTemplate.settingInstanceTemplateId -eq $setting.settingInstance.settingInstanceTemplateReference.settingInstanceTemplateId }

                                if ($AvailableSetting.settingInstanceTemplate.settingInstanceTemplateId -cnotmatch $setting.settingInstance.settingInstanceTemplateReference.settingInstanceTemplateId) {
                                    # update casing
                                    Write-Information "Fixing casing for setting instance template $($AvailableSetting.settingInstanceTemplate.settingInstanceTemplateId)"
                                    $setting.settingInstance.settingInstanceTemplateReference.settingInstanceTemplateId = $AvailableSetting.settingInstanceTemplate.settingInstanceTemplateId
                                }

                                if ($AvailableSetting.settingInstanceTemplate.choiceSettingValueTemplate -cnotmatch $setting.settingInstance.choiceSettingValue.settingValueTemplateReference.settingValueTemplateId) {
                                    # update choice setting value template
                                    Write-Information "Fixing casing for choice setting value template $($AvailableSetting.settingInstanceTemplate.choiceSettingValueTemplate.settingValueTemplateId)"
                                    $setting.settingInstance.choiceSettingValue.settingValueTemplateReference.settingValueTemplateId = $AvailableSetting.settingInstanceTemplate.choiceSettingValueTemplate.settingValueTemplateId
                                }

                                $FilteredSettings.Add($setting)
                            }
                        }
                        $Template.settings = $FilteredSettings
                        $RawJSON = $Template | ConvertTo-Json -Depth 100 -Compress
                    }
                }

                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.name) {
                    $PolicyFile = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty Platform, PolicyType, CreationSource
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                    $ExistingID = $CheckExististing | Where-Object -Property Name -EQ $DisplayName
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PUT -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property Name -EQ $DisplayName
                    $PostType = 'edited'
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'windowsDriverUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsDriverUpdateProfiles'
                $File = ($RawJSON | ConvertFrom-Json)
                $DisplayName = $File.displayName ?? $File.Name
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $PolicyFile = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty inventorySyncStatus, newUpdates, deviceReporting, approvalType
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-Host 'We are editing'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'windowsFeatureUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsFeatureUpdateProfiles'
                $File = ($RawJSON | ConvertFrom-Json)
                $DisplayName = $File.displayName ?? $File.Name
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $tenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $PolicyFile = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty deployableContentDisplayName, endOfSupportDate, installLatestWindows10OnWindows11IneligibleDevice
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-Host 'We are editing'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName

                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'windowsQualityUpdatePolicies' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsQualityUpdatePolicies'
                $File = ($RawJSON | ConvertFrom-Json)
                $DisplayName = $File.displayName ?? $File.Name
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $PolicyFile = $RawJSON | ConvertFrom-Json | Select-Object *
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-Host 'We are editing'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
            'windowsQualityUpdateProfiles' {
                $PlatformType = 'deviceManagement'
                $TemplateTypeURL = 'windowsQualityUpdateProfiles'
                $File = ($RawJSON | ConvertFrom-Json)
                $DisplayName = $File.displayName ?? $File.Name
                $CheckExististing = New-GraphGETRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter
                if ($DisplayName -in $CheckExististing.displayName) {
                    $PostType = 'edited'
                    $PolicyFile = $RawJSON | ConvertFrom-Json | Select-Object * -ExcludeProperty releaseDateDisplayName, deployableContentDisplayName
                    $RawJSON = ConvertTo-Json -InputObject $PolicyFile -Depth 100 -Compress
                    $ExistingID = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                    Write-Host 'We are editing'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL/$($ExistingID.Id)" -tenantid $TenantFilter -type PATCH -body $RawJSON
                    $CreateRequest = $CheckExististing | Where-Object -Property displayName -EQ $DisplayName
                } else {
                    $PostType = 'added'
                    $CreateRequest = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$PlatformType/$TemplateTypeURL" -tenantid $TenantFilter -type POST -body $RawJSON
                    Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Added policy $($DisplayName) via template" -Sev 'info'
                }
            }
        }
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "$($PostType) policy $($DisplayName)" -Sev 'Info'
        if ($AssignTo) {
            Write-Host "Assigning policy to $($AssignTo) with ID $($CreateRequest.id) and type $TemplateTypeURL for tenant $TenantFilter"
            Write-Host "ID is $($CreateRequest.id)"

            $AssignParams = @{
                GroupName    = $AssignTo
                PolicyId     = $CreateRequest.id
                PlatformType = $PlatformType
                Type         = $TemplateTypeURL
                TenantFilter = $tenantFilter
                ExcludeGroup = $ExcludeGroup
            }

            if ($AssignmentFilterName) {
                $AssignParams.AssignmentFilterName = $AssignmentFilterName
                $AssignParams.AssignmentFilterType = $AssignmentFilterType
            }

            Set-CIPPAssignedPolicy @AssignParams
        }
        return "Successfully $($PostType) policy for $($TenantFilter) with display name $($DisplayName)"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message "Failed $($PostType) policy $($DisplayName). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        throw "Failed to add or set policy for $($TenantFilter) with display name $($DisplayName): $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPIntunePolicy.ps1' 294
#Region './Public/Set-CIPPIntuneTemplate.ps1' -1

function Set-CIPPIntuneTemplate {
    param (
        [Parameter(Mandatory = $true)]
        $RawJSON,
        $GUID,
        $DisplayName,
        $Description,
        $templateType,
        $Package,
        $Headers
    )
    Write-Host "Received $DisplayName, $Description, $RawJSON, $templateType"
    if (!$DisplayName) { throw 'You must enter a displayname' }
    if ($null -eq ($RawJSON | ConvertFrom-Json)) { throw 'the JSON is invalid' }

    $object = [PSCustomObject]@{
        Displayname = $DisplayName
        Description = $Description
        RAWJson     = $RawJSON
        Type        = $templateType
        GUID        = $GUID
    } | ConvertTo-Json -Depth 10 -Compress
    $Table = Get-CippTable -tablename 'templates'
    $Table.Force = $true
    Add-CIPPAzDataTableEntity @Table -Entity @{
        JSON         = "$object"
        RowKey       = "$GUID"
        GUID         = "$GUID"
        Package      = "$Package"
        PartitionKey = 'IntuneTemplate'
    }
    Write-LogMessage -Headers $Headers -API $APINAME -message "Created intune policy template named $($Request.body.displayname) with GUID $GUID" -Sev 'Debug'

    return 'Successfully added template'
}
#EndRegion './Public/Set-CIPPIntuneTemplate.ps1' 36
#Region './Public/Set-CIPPMailboxAccess.ps1' -1

function Set-CIPPMailboxAccess {
    [CmdletBinding()]
    param (
        $userid,
        $AccessUser,
        [bool]$Automap,
        $TenantFilter,
        $APIName = 'Manage Shared Mailbox Access',
        $Headers,
        [array]$AccessRights
    )

    try {
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Add-MailboxPermission' -cmdParams @{Identity = $userid; user = $AccessUser; AutoMapping = $Automap; accessRights = $AccessRights; InheritanceType = 'all' } -Anchor $userid

        $Message = "Successfully added $($AccessUser) to $($userid) Shared Mailbox $($Automap ? 'with' : 'without') AutoMapping, with the following permissions: $AccessRights"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Info' -tenant $TenantFilter
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to add mailbox permissions for $($AccessUser) on $($userid). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPMailboxAccess.ps1' 26
#Region './Public/Set-CIPPMailboxArchive.ps1' -1

function Set-CIPPMailboxArchive {
    [CmdletBinding()]
    param (
        $Headers,
        $UserID,
        $Username,
        $APIName = 'Mailbox Archive',
        $TenantFilter,
        [bool]$ArchiveEnabled,
        [switch]$AutoExpandingArchive
    )

    try {
        if ([string]::IsNullOrWhiteSpace($Username)) { $Username = $UserID }
        $OperationType = if ($AutoExpandingArchive.IsPresent -eq $true) { 'auto-expanding archive' } else { 'archive' }
        if ($AutoExpandingArchive.IsPresent -eq $true) {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Enable-Mailbox' -cmdParams @{Identity = $UserID; AutoExpandingArchive = $true }
            $Message = "Successfully enabled $OperationType for $Username"
        } else {
            $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Enable-Mailbox' -cmdParams @{Identity = $UserID; Archive = $ArchiveEnabled }
            $Message = "Successfully set $OperationType for $Username to $ArchiveEnabled"
        }

        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Info'
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set $OperationType for $Username. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message $Message -Sev 'Error' -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPMailboxArchive.ps1' 33
#Region './Public/Set-CIPPMailboxLocale.ps1' -1

function Set-CippMailboxLocale {
    [CmdletBinding()]
    param (
        $Headers,
        $Locale,
        $Username,
        $APIName = 'Mailbox Locale',
        $TenantFilter
    )

    try {
        # Validate the locale. Also if the locale is not valid, it will throw an exception, not wasting a request.
        if ([System.Globalization.CultureInfo]::GetCultureInfo($Locale).IsNeutralCulture) {
            throw "$Locale is not a valid Locale. Neutral cultures are not supported."
        }

        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxRegionalConfiguration' -cmdParams @{
            Identity                  = $Username
            Language                  = $Locale
            LocalizeDefaultFolderName = $true
            DateFormat                = $null
            TimeFormat                = $null
        } -Anchor $username
        $Result = "Set locale for $($Username) to $Locale"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Info -tenant $TenantFilter
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to set locale for $($Username). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CIPPMailboxLocale.ps1' 34
#Region './Public/Set-CIPPMailboxRule.ps1' -1

function Set-CIPPMailboxRule {
    [CmdletBinding()]
    param (
        $UserId,
        $Username,
        $TenantFilter,
        $APIName = 'Set mailbox rules',
        $Headers,
        $RuleId,
        $RuleName,
        [switch]$Enable,
        [switch]$Disable
    )

    if ($Enable.IsPresent -eq $true) {
        $State = 'Enable'
    } elseif ($Disable.IsPresent -eq $true) {
        $State = 'Disable'
    } else {
        Write-LogMessage -headers $Headers -API $APIName -message 'No state provided for mailbox rule' -Sev 'Error' -tenant $TenantFilter
        throw 'No state provided for mailbox rule'
    }

    try {
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet "$State-InboxRule" -Anchor $Username -cmdParams @{Identity = $RuleId }
        Write-LogMessage -headers $Headers -API $APIName -message "Successfully set mailbox rule $($RuleName) for $($Username) to $($State)d" -Sev 'Info' -tenant $TenantFilter
        return "Successfully set mailbox rule $($RuleName) for $($Username) to $($State)d"
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Could not set mailbox rule $($RuleName) for $($Username) to $($State)d. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw "Could not set mailbox rule $($RuleName) for $($Username) to $($State)d. Error: $($ErrorMessage.NormalizedError)"
    }

}
#EndRegion './Public/Set-CIPPMailboxRule.ps1' 35
#Region './Public/Set-CIPPMailboxType.ps1' -1

function Set-CIPPMailboxType {
    [CmdletBinding()]
    param (
        $Headers,
        $UserID,
        $Username,
        $APIName = 'Mailbox Conversion',
        $TenantFilter,
        [Parameter(Mandatory = $true)]
        [ValidateSet('Shared', 'Regular', 'Room', 'Equipment')]$MailboxType
    )

    try {
        if ([string]::IsNullOrWhiteSpace($Username)) { $Username = $UserID }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams @{Identity = $UserID; Type = $MailboxType } -Anchor $Username
        $Message = "Successfully converted $Username to a $MailboxType mailbox"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Info' -tenant $TenantFilter
        return $Message
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to convert $Username to a $MailboxType mailbox. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPMailboxType.ps1' 26
#Region './Public/Set-CIPPManager.ps1' -1

function Set-CIPPManager {
    [CmdletBinding()]
    param (
        $User,
        $Manager,
        $TenantFilter,
        $APIName = 'Set Manager',
        $Headers
    )

    try {
        $ManagerBody = [PSCustomObject]@{'@odata.id' = "https://graph.microsoft.com/beta/users/$($Manager)" }
        $ManagerBodyJSON = ConvertTo-Json -Compress -Depth 10 -InputObject $ManagerBody
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($User)/manager/`$ref" -tenantid $TenantFilter -type PUT -body $ManagerBodyJSON
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Set $User's manager to $Manager" -Sev 'Info'
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to Set Manager. Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $_
        throw "Failed to set manager: $($ErrorMessage.NormalizedError)"
    }
    return "Set $User's manager to $Manager"
}

#EndRegion './Public/Set-CIPPManager.ps1' 24
#Region './Public/Set-CippMaxEmailSize.ps1' -1

function Set-CippMaxEmailSize {
    [CmdletBinding()]
    param (
        $Headers,
        $TenantFilter,
        $APIName = 'Mailbox Max Send/Receive Size',
        $UserPrincipalName,
        $UserID,
        [ValidateRange(1, 150)]
        [Int32]$MaxSendSize,
        [ValidateRange(1, 150)]
        [Int32]$MaxReceiveSize
    )

    try {
        # Id the ID is provided, use it. Otherwise, use the UPN
        $Identity = $UserID ?? $UserPrincipalName
        if ([string]::IsNullOrWhiteSpace($Identity)) {
            $Result = 'No identity provided. Cannot set mailbox email max size.'
            Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter
            throw $Result
        }

        if ($MaxSendSize -eq 0 -and $MaxReceiveSize -eq 0) {
            $Result = 'No max send or receive size provided. Cannot set mailbox email max size.'
            Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter
            throw $Result
        }

        $cmdletParams = @{
            Identity = $Identity
        }
        # Set the max send and receive size if they are provided. Convert to bytes
        if ($MaxSendSize -gt 0) { $cmdletParams['MaxSendSize'] = $MaxSendSize * 1MB }
        if ($MaxReceiveSize -gt 0) { $cmdletParams['MaxReceiveSize'] = $MaxReceiveSize * 1MB }

        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams $cmdletParams

        # Use UPN for logging if provided
        $Identity = $UserPrincipalName ?? $UserID
        $Result = "Set mailbox email max size for $($Identity) to "
        if ($MaxSendSize -gt 0) { $Result += "Send: $($MaxSendSize)MB " }
        if ($MaxReceiveSize -gt 0) { $Result += "Receive: $($MaxReceiveSize)MB" }

        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Info -tenant $TenantFilter
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_

        # Use UPN for logging if provided
        $Identity = $UserPrincipalName ?? $UserID
        $Result = "Failed to set mailbox email max size for $($Identity). Error: $($ErrorMessage)"

        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CippMaxEmailSize.ps1' 58
#Region './Public/Set-CIPPMessageCopy.ps1' -1

function Set-CIPPMessageCopy {
    [CmdletBinding()]
    param (
        $UserId,
        [bool]$MessageCopyForSentAsEnabled,
        [bool]$MessageCopyForSendOnBehalfEnabled,
        $TenantFilter,
        $APIName = 'Set message copy for sent',
        $Headers
    )
    try {
        $cmdParams = @{
            Identity                          = $UserId
            MessageCopyForSentAsEnabled       = $MessageCopyForSentAsEnabled
            MessageCopyForSendOnBehalfEnabled = $MessageCopyForSendOnBehalfEnabled

        }
        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-Mailbox' -cmdParams $cmdParams
        $Result = "Successfully set message copy for 'Send as' as $MessageCopyForSentAsEnabled and 'Sent on behalf' as $MessageCopyForSendOnBehalfEnabled on $($UserId)."
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Info'
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to set message copy for 'Send as' as $MessageCopyForSentAsEnabled and 'Sent on behalf' as $MessageCopyForSendOnBehalfEnabled - $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -tenant $($TenantFilter) -message $Result -Sev 'Error' -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CIPPMessageCopy.ps1' 29
#Region './Public/Set-CIPPMobileDevice.ps1' -1

function Set-CIPPMobileDevice(
    [string]$Headers,
    [string]$Quarantine,
    [string]$UserId,
    [string]$DeviceId,
    [string]$TenantFilter,
    [string]$Delete,
    [string]$Guid,
    [string]$APIName = 'Mobile Device'
) {

    try {
        if ($Quarantine -eq 'false') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-CASMailbox' -cmdParams @{Identity = $UserId; ActiveSyncAllowedDeviceIDs = @{'@odata.type' = '#Exchange.GenericHashTable'; add = $DeviceId } }
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Allow Active Sync Device for $UserId" -Sev 'Info'
            return "Allowed Active Sync Device for $UserId"
        } elseif ($Quarantine -eq 'true') {
            New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-CASMailbox' -cmdParams @{Identity = $UserId; ActiveSyncBlockedDeviceIDs = @{'@odata.type' = '#Exchange.GenericHashTable'; add = $DeviceId } }
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Blocked Active Sync Device for $UserId" -Sev 'Info'
            return "Blocked Active Sync Device for $UserId"
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        if ($Quarantine -eq 'false') {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to Allow Active Sync Device for $($UserId): $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
            return "Failed to Allow Active Sync Device for $($UserId): $($ErrorMessage.NormalizedError)"
        } elseif ($Quarantine -eq 'true') {
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to Block Active Sync Device for $($UserId): $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
            return "Failed to Block Active Sync Device for $($UserId): $($ErrorMessage.NormalizedError)"
        }
    }

    try {
        if ($Delete -eq 'true') {
            New-ExoRequest -tenant $TenantFilter -cmdlet 'Remove-MobileDevice' -cmdParams @{Identity = $Guid; Confirm = $false } -UseSystemMailbox $true
            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Deleted Active Sync Device for $UserId" -Sev 'Info'
            return "Deleted Active Sync Device for $UserId"
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to delete Mobile Device $($Guid): $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
        return "Failed to delete Mobile Device $($Guid): $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPMobileDevice.ps1' 45
#Region './Public/Set-CIPPNamedLocation.ps1' -1

function Set-CIPPNamedLocation {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        $NamedLocationId,
        $TenantFilter,
        #$Change should be one of 'addIp','addLocation','removeIp','removeLocation','rename','setTrusted','setUntrusted','delete'
        [ValidateSet('addIp', 'addLocation', 'removeIp', 'removeLocation', 'rename', 'setTrusted', 'setUntrusted', 'delete')]
        $Change,
        $Content,
        $APIName = 'Set Named Location',
        $Headers
    )

    try {
        $NamedLocations = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations/$NamedLocationId" -Tenantid $TenantFilter

        switch ($Change) {
            'addIp' {
                $NamedLocations.ipRanges = @($NamedLocations.ipRanges + @{ cidrAddress = $Content; '@odata.type' = '#microsoft.graph.iPv4CidrRange' })
                $ActionDescription = "Adding IP $Content to named location"
            }
            'addLocation' {
                $NamedLocations.countriesAndRegions = $NamedLocations.countriesAndRegions + $Content
                $ActionDescription = "Adding location $Content to named location"
            }
            'removeIp' {
                $NamedLocations.ipRanges = @($NamedLocations.ipRanges | Where-Object -Property cidrAddress -NE $Content)
                $ActionDescription = "Removing IP $Content from named location"
            }
            'removeLocation' {
                $NamedLocations.countriesAndRegions = @($NamedLocations.countriesAndRegions | Where-Object { $_ -NE $Content })
                $ActionDescription = "Removing location $Content from named location"
            }
            'rename' {
                $NamedLocations.displayName = $Content
                $ActionDescription = "Renaming named location to: $Content"
            }
            'setTrusted' {
                $NamedLocations.isTrusted = $true
                $ActionDescription = 'Setting named location as trusted'
            }
            'setUntrusted' {
                $NamedLocations.isTrusted = $false
                $ActionDescription = 'Setting named location as untrusted'
            }
            'delete' {
                $ActionDescription = 'Deleting named location'
            }
        }

        if ($PSCmdlet.ShouldProcess($NamedLocations.displayName, $ActionDescription)) {
            if ($Change -eq 'delete') {
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations/$NamedLocationId" -tenantid $TenantFilter -type DELETE
                $Result = "Deleted named location: $($NamedLocations.displayName)"
            } else {
                # PATCH operations - remove unneeded properties
                if ($NamedLocations.'@odata.type' -eq '#microsoft.graph.countryNamedLocation') {
                    $NamedLocations = $NamedLocations | Select-Object '@odata.type', 'displayName', 'countriesAndRegions', 'includeUnknownCountriesAndRegions'
                } elseif ($NamedLocations.'@odata.type' -eq '#microsoft.graph.ipNamedLocation') {
                    $NamedLocations = $NamedLocations | Select-Object '@odata.type', 'displayName', 'ipRanges', 'isTrusted'
                }

                $JsonBody = ConvertTo-Json -InputObject $NamedLocations -Compress -Depth 10
                $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/identity/conditionalAccess/namedLocations/$NamedLocationId" -tenantid $TenantFilter -type PATCH -body $JsonBody
                $Result = "Edited named location: $($NamedLocations.displayName). Change: $Change$(if ($Content) { " with content $Content" })"
            }

            Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message $Result -Sev 'Info'
        }
        return $Result
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to edit named location: $($NamedLocations.displayName). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -tenant $TenantFilter -API $APIName -message $Result -Sev 'Error' -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CIPPNamedLocation.ps1' 78
#Region './Public/Set-CIPPNotificationConfig.ps1' -1

function Set-CIPPNotificationConfig {
    [CmdletBinding()]
    param (
        $email,
        $webhook,
        $onepertenant,
        $logsToInclude,
        $sendtoIntegration,
        $sev,
        $APIName = 'Set Notification Config'
    )

    $results = try {
        $Table = Get-CIPPTable -TableName SchedulerConfig
        $SchedulerConfig = @{
            'tenant'            = 'Any'
            'tenantid'          = 'TenantId'
            'type'              = 'CIPPNotifications'
            'schedule'          = 'Every 15 minutes'
            'Severity'          = [string]$sev
            'email'             = "$($email)"
            'webhook'           = "$($webhook)"
            'onePerTenant'      = [boolean]$onePerTenant
            'sendtoIntegration' = [boolean]$sendtoIntegration
            'includeTenantId'   = $true
            'PartitionKey'      = 'CippNotifications'
            'RowKey'            = 'CippNotifications'
        }
        foreach ($logvalue in [pscustomobject]$logsToInclude) {
            $SchedulerConfig[([pscustomobject]$logvalue.value)] = $true
        }

        Add-CIPPAzDataTableEntity @Table -Entity $SchedulerConfig -Force | Out-Null
        return 'Successfully set the configuration'
    } catch {
        return "Failed to set configuration: $($_.Exception.message)"
    }
}
#EndRegion './Public/Set-CIPPNotificationConfig.ps1' 39
#Region './Public/Set-CIPPOutOfoffice.ps1' -1

function Set-CIPPOutOfOffice {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        $UserID,
        $InternalMessage,
        $ExternalMessage,
        $TenantFilter,
        [ValidateSet('Enabled', 'Disabled', 'Scheduled')]
        [Parameter(Mandatory = $true)]
        [string]$State,
        $APIName = 'Set Out of Office',
        $Headers,
        $StartTime,
        $EndTime
    )

    try {

        $CmdParams = @{
            Identity         = $UserID
            AutoReplyState   = $State
            ExternalAudience = 'None'
        }

        if ($PSBoundParameters.ContainsKey('InternalMessage')) {
            $CmdParams.InternalMessage = $InternalMessage
        }

        if ($PSBoundParameters.ContainsKey('ExternalMessage')) {
            $CmdParams.ExternalMessage = $ExternalMessage
            $CmdParams.ExternalAudience = 'All'
        }

        if ($State -eq 'Scheduled') {
            # If starttime or endtime are not provided, default to enabling OOO for 7 days
            $StartTime = $StartTime ? $StartTime : (Get-Date).ToString()
            $EndTime = $EndTime ? $EndTime : (Get-Date $StartTime).AddDays(7)
            $CmdParams.StartTime = $StartTime
            $CmdParams.EndTime = $EndTime
        }

        $null = New-ExoRequest -tenantid $TenantFilter -cmdlet 'Set-MailboxAutoReplyConfiguration' -cmdParams $CmdParams -Anchor $UserID

        $Results = $State -eq 'Scheduled' ?
        "Scheduled Out-of-office for $($UserID) between $($StartTime.toString()) and $($EndTime.toString())" :
        "Set Out-of-office for $($UserID) to $State."

        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Info' -tenant $TenantFilter
        return $Results
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Results = "Could not add OOO for $($UserID). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Results -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Results
    }
}
#EndRegion './Public/Set-CIPPOutOfoffice.ps1' 58
#Region './Public/Set-CIPPPerUserMFA.ps1' -1

function Set-CIPPPerUserMFA {
    <#
    .SYNOPSIS
    Change Per-User MFA State for a User

    .DESCRIPTION
    Change the Per-User MFA State for a user via the /users/{id}/authentication/requirements endpoint

    .PARAMETER TenantFilter
    Tenant where the user resides

    .PARAMETER userId
    One or more User IDs to set the MFA state for (GUID or UserPrincipalName)

    .PARAMETER State
    State to set the user to (enabled, disabled, enforced)

    .PARAMETER Headers
    User executing the command

    .EXAMPLE
    Set-CIPPPerUserMFA -TenantFilter 'contoso.onmicrosoft.com' -userId user@contoso.onmicrosoft.com -State 'disabled' -Headers 'mspuser@partner.com'
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [string[]]$userId,
        [ValidateSet('enabled', 'disabled', 'enforced')]
        $State = 'enabled',
        $Headers,
        $APIName = 'Set-CIPPPerUserMFA'
    )

    try {
        $int = 0
        $Body = @{
            perUserMFAstate = $State
        }
        $Requests = foreach ($id in $userId) {
            @{
                id        = $int++
                method    = 'PATCH'
                url       = "users/$id/authentication/requirements"
                body      = $Body
                'headers' = @{
                    'Content-Type' = 'application/json'
                }
            }
        }

        $Requests = New-GraphBulkRequest -tenantid $TenantFilter -scope 'https://graph.microsoft.com/.default' -Requests @($Requests) -asapp $true
        "Successfully set Per user MFA State for $userId"

        Write-LogMessage -headers $Headers -API $APIName -message "Successfully set Per user MFA State to $State for $id" -Sev Info -tenant $TenantFilter
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Result = "Failed to set MFA State to $State for $id. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Result -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Result
    }
}
#EndRegion './Public/Set-CIPPPerUserMFA.ps1' 64
#Region './Public/Set-CIPPProfilePhoto.ps1' -1

function Set-CIPPProfilePhoto {
    [CmdletBinding()]
    param(
        $TenantFilter,
        $id,
        [ValidateSet('users', 'groups', 'teams')]
        $type = 'users',
        $ContentType = 'image/png',
        $PhotoBase64,
        $Headers
    )
    try {
        $PhotoBytes = [Convert]::FromBase64String($PhotoBase64)
        New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/$type/$id/photo/`$value" -tenantid $tenantfilter -type PUT -body $PhotoBytes -ContentType $ContentType
        "Successfully set profile photo for $id"
        Write-LogMessage -headers $Headers -API 'Set-CIPPUserProfilePhoto' -message "Successfully set profile photo for $id" -Sev 'Info' -tenant $TenantFilter
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        "Failed to set profile photo for $id. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API 'Set-CIPPUserProfilePhoto' -message "Failed to set profile photo for $id. Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
    }
}
#EndRegion './Public/Set-CIPPProfilePhoto.ps1' 23
#Region './Public/Set-CIPPQuarantinePolicy.ps1' -1

function Set-CIPPQuarantinePolicy {
    <#
    .SYNOPSIS
    Set/Add Quarantine policy, supports both custom and global Quarantine Policy

    .DESCRIPTION
    Set/Add Quarantine policy, supports both custom and global Quarantine Policy

    .PARAMETER identity
    Identity of the Quarantine policy to set, Name or GUID.

    .PARAMETER action
    Which action to perform Create or Update. Valid values are Add, New, Create, Edit, Set, Update.

    .PARAMETER tenantFilter
    Tenant to manage quarantine policy for.

    .PARAMETER EndUserQuarantinePermissions
    End user quarantine permissions to set. This is a hashtable with the following keys:
    PermissionToBlockSender
    PermissionToDelete
    PermissionToPreview
    PermissionToRelease
    PermissionToRequestRelease
    PermissionToAllowSender
    PermissionToViewHeader
    PermissionToDownload

    .PARAMETER APIName
    Name of the API executing the command.

    .PARAMETER ESNEnabled
    Whether the quarantine notification is enabled or not.

    .PARAMETER IncludeMessagesFromBlockedSenderAddress
    Whether to include messages from blocked sender address or not.

    #>
    [CmdletBinding(DefaultParameterSetName = 'QuarantinePolicy')]
    param(
        [Parameter(Mandatory, ParameterSetName = 'QuarantinePolicy')]
        [Parameter(Mandatory, ParameterSetName = 'GlobalQuarantinePolicy')]
        [ValidateNotNullOrEmpty()]
        [string]$identity,

        [Parameter(Mandatory, ParameterSetName = 'QuarantinePolicy')]
        [ValidateSet("Add", "New", "Create", "Edit", "Set", "Update")]
        [string]$action,

        [Parameter(Mandatory, ParameterSetName = 'QuarantinePolicy')]
        [Hashtable]$EndUserQuarantinePermissions,

        [Parameter(Mandatory, ParameterSetName = 'QuarantinePolicy')]
        [bool]$ESNEnabled,

        [Parameter(ParameterSetName = 'QuarantinePolicy')]
        [bool]$IncludeMessagesFromBlockedSenderAddress = $false,

        [Parameter(Mandatory, ParameterSetName = 'GlobalQuarantinePolicy')]
        [TimeSpan]$EndUserSpamNotificationFrequency,

        [Parameter(ParameterSetName = 'GlobalQuarantinePolicy')]
        [string]$EndUserSpamNotificationCustomFromAddress = "",

        [Parameter(ParameterSetName = 'GlobalQuarantinePolicy')]
        [bool]$OrganizationBrandingEnabled = $false,

        [Parameter(Mandatory)]
        [string]$tenantFilter,
        [string]$APIName = 'QuarantinePolicy'
    )

    try {

        switch ($PSCmdlet.ParameterSetName) {
            "GlobalQuarantinePolicy" {
                $cmdParams = @{
                    Identity = $identity
                    EndUserSpamNotificationFrequency = $EndUserSpamNotificationFrequency.ToString()
                    EndUserSpamNotificationCustomFromAddress = $EndUserSpamNotificationCustomFromAddress
                    OrganizationBrandingEnabled = $OrganizationBrandingEnabled
                    # QuarantinePolicyType = 'GlobalQuarantinePolicy'
                }
                $cmdLet = 'Set-QuarantinePolicy'
             }
            "QuarantinePolicy" {
                $cmdParams = @{
                    EndUserQuarantinePermissionsValue = Convert-QuarantinePermissionsValue @EndUserQuarantinePermissions -ErrorAction Stop
                    ESNEnabled = $ESNEnabled
                    IncludeMessagesFromBlockedSenderAddress = $IncludeMessagesFromBlockedSenderAddress
                }

                switch ($action) {
                    {$_ -in @("Add", "New", "Create")} { $cmdParams.Add("Name", $identity) ; $cmdLet = 'New-QuarantinePolicy' }
                    {$_ -in @("Edit", "Set", "Update")} { $cmdParams.Add("Identity", $identity) ; $cmdLet = 'Set-QuarantinePolicy' }
                    Default {
                        throw "Invalid action specified. Valid actions are: Add, New, Edit, Set, Update."
                    }
                }
            }
        }

        $null = New-ExoRequest -tenantid $tenantFilter -cmdlet $cmdLet -cmdParams $cmdParams -useSystemMailbox $true

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        throw ($ErrorMessage.NormalizedError -replace '\|Microsoft.Exchange.Management.Tasks.ValidationException\|', '')
    }
}
#EndRegion './Public/Set-CIPPQuarantinePolicy.ps1' 110
#Region './Public/Set-CIPPResetPassword.ps1' -1

function Set-CIPPResetPassword {
    [CmdletBinding()]
    param(
        $UserID,
        $DisplayName,
        $TenantFilter,
        $APIName = 'Reset Password',
        $Headers,
        [bool]$forceChangePasswordNextSignIn = $true
    )

    try {
        $password = New-passwordString
        $passwordProfile = @{
            'passwordProfile' = @{
                'forceChangePasswordNextSignIn' = $forceChangePasswordNextSignIn
                'password'                      = $password
            }
        } | ConvertTo-Json -Compress

        $UserDetails = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)?`$select=onPremisesSyncEnabled" -noPagination $true -tenantid $TenantFilter -verbose
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)" -tenantid $TenantFilter -type PATCH -body $passwordProfile -verbose

        #PWPush
        $PasswordLink = $null
        try {
            $PasswordLink = New-PwPushLink -Payload $password
            if ($PasswordLink -and $PasswordLink -ne $false) {
                $password = $PasswordLink
            }
        }
        catch {
            Write-LogMessage -headers $Headers -API $APIName -message "Failed to create PwPush link, using plain password. Error: $($_.Exception.Message)" -Sev 'Warning' -tenant $TenantFilter
        }
        Write-LogMessage -headers $Headers -API $APIName -message "Successfully reset the password for $DisplayName, $($UserID). User must change password is set to $forceChangePasswordNextSignIn" -Sev 'Info' -tenant $TenantFilter

        if ($UserDetails.onPremisesSyncEnabled -eq $true) {
            return [pscustomobject]@{
                resultText = "Successfully reset the password for $DisplayName, $($UserID). User must change password is set to $forceChangePasswordNextSignIn. The new password is $password. WARNING: This user is AD synced. Please confirm passthrough or writeback is enabled."
                copyField  = $password
                state      = 'warning'
            }
        } else {
            return [pscustomobject]@{
                resultText = "Successfully reset the password for $DisplayName, $($UserID). User must change password is set to $forceChangePasswordNextSignIn. The new password is $password"
                copyField  = $password
                state      = 'success'
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to reset password for $DisplayName, $($UserID). Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPResetPassword.ps1' 57
#Region './Public/Set-CIPPSAMAdminRoles.ps1' -1

function Set-CIPPSAMAdminRoles {
    <#
    .SYNOPSIS
        Set SAM roles
    .DESCRIPTION
        Set SAM roles on a tenant
    .PARAMETER TenantFilter
        Tenant to apply the SAM roles to
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter
    )

    $ActionLogs = [System.Collections.Generic.List[object]]::new()

    $SAMRolesTable = Get-CIPPTable -tablename 'SAMRoles'
    $Roles = Get-CIPPAzDataTableEntity @SAMRolesTable

    try {
        $SAMRoles = $Roles.Roles | ConvertFrom-Json -ErrorAction Stop
        $Tenants = $Roles.Tenants | ConvertFrom-Json -ErrorAction Stop
        if ($Tenants.value) {
            $Tenants = $Tenants.value
        }
    } catch {
        $ActionLogs.Add('CIPP-SAM roles not configured')
        return $ActionLogs
    }

    if (($SAMRoles | Measure-Object).count -gt 0 -and $Tenants -contains $TenantFilter -or $Tenants -contains 'AllTenants') {
        $AppMemberOf = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals(appId='$($env:ApplicationID)')/memberOf/#microsoft.graph.directoryRole" -tenantid $TenantFilter -AsApp $true

        $sp = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/servicePrincipals(appId='$($env:ApplicationID)')?`$select=id,displayName" -tenantid $TenantFilter -AsApp $true)
        $id = $sp.id

        $Requests = $SAMRoles | Where-Object { $AppMemberOf.roleTemplateId -notcontains $_.value } | ForEach-Object {
            # Batch add service principal to directoryRole
            [PSCustomObject]@{
                'id'      = $_.label
                'headers' = @{
                    'Content-Type' = 'application/json'
                }
                'url'     = "directoryRoles(roleTemplateId='$($_.value)')/members/`$ref"
                'method'  = 'POST'
                'body'    = @{
                    '@odata.id' = "https://graph.microsoft.com/v1.0/directoryObjects/$($id)"
                }
            }
        }
        if (($Requests | Measure-Object).count -gt 0) {
            $HasFailures = $false
            try {
                $null = New-ExoRequest -cmdlet 'New-ServicePrincipal' -cmdParams @{AppId = $env:ApplicationID; ObjectId = $id; DisplayName = 'CIPP-SAM' } -Compliance -tenantid $TenantFilter -useSystemMailbox $true -AsApp
                $ActionLogs.Add('Added Service Principal to Compliance Center')
            } catch {
                $ActionLogs.Add('Service Principal already added to Compliance Center')
            }
            try {
                $null = New-ExoRequest -cmdlet 'New-ServicePrincipal' -cmdParams @{AppId = $env:ApplicationID; ObjectId = $id; DisplayName = 'CIPP-SAM' } -tenantid $TenantFilter -useSystemMailbox $true -AsApp
                $ActionLogs.Add('Added Service Principal to Exchange Online')
            } catch {
                $ActionLogs.Add('Service Principal already added to Exchange Online')
            }

            Write-Verbose ($Requests | ConvertTo-Json -Depth 5)
            $Results = New-GraphBulkRequest -tenantid $TenantFilter -Requests @($Requests)
            $Results | ForEach-Object {
                if ($_.status -eq 204) {
                    $ActionLogs.Add("Added service principal to directory role $($_.id)")
                } else {
                    $ActionLogs.Add("Failed to add service principal to directoryRole $($_.id)")
                    Write-Verbose ($_ | ConvertTo-Json -Depth 5)
                    $HasFailures = $true
                }
            }
            $LogMessage = @{
                'API'      = 'Set-CIPPSAMAdminRoles'
                'tenant'   = $TenantFilter
                'tenantid' = (Get-Tenants -TenantFilter $TenantFilter -IncludeErrors).custom
                'message'  = ''
                'LogData'  = $ActionLogs
            }
            if ($HasFailures) {
                $LogMessage.message = 'Errors occurred while setting Admin Roles for CIPP-SAM'
                $LogMessage.sev = 'Error'
            } else {
                $LogMessage.message = 'Successfully set Admin Roles for CIPP-SAM'
                $LogMessage.sev = 'Info'
            }
            Write-LogMessage @LogMessage
        } else {
            $ActionLogs.Add('Service principal already exists in all requested Admin Roles')
        }
    } else {
        $ActionLogs.Add('No SAM roles found or tenant not added to CIPP-SAM roles')
    }
    $ActionLogs
}
#EndRegion './Public/Set-CIPPSAMAdminRoles.ps1' 103
#Region './Public/Set-CIPPSharePointPerms.ps1' -1

function Set-CIPPSharePointPerms {
    [CmdletBinding()]
    param (
        $UserId, # The UPN or ID of the users OneDrive we are changing permissions on
        $OnedriveAccessUser, # The UPN of the user we are adding or removing permissions for
        $TenantFilter,
        $APIName = 'Manage SharePoint Owner',
        $RemovePermission,
        $Headers,
        $URL
    )
    if ($RemovePermission -eq $true) {
        $SiteAdmin = 'false'
    } else {
        $SiteAdmin = 'true'
    }

    try {
        if (!$URL) {
            Write-Information 'No URL provided, getting URL from Graph'
            $URL = (New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserId)/Drives" -asapp $true -tenantid $TenantFilter).WebUrl
        }

        $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
        $XML = @"
<Request xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009" AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName=".NET Library">
  <Actions>
    <ObjectPath Id="249" ObjectPathId="248"/>
  </Actions>
  <ObjectPaths>
    <Method Id="248" ParentId="242" Name="SetSiteAdmin">
      <Parameters>
        <Parameter Type="String">$URL</Parameter>
        <Parameter Type="String">$OnedriveAccessUser</Parameter>
        <Parameter Type="Boolean">$SiteAdmin</Parameter>
      </Parameters>
    </Method>
    <Constructor Id="242" TypeId="{268004ae-ef6b-4e9b-8425-127220d84719}"/>
  </ObjectPaths>
</Request>
"@
        $request = New-GraphPostRequest -scope "$($SharePointInfo.AdminUrl)/.default" -tenantid $TenantFilter -Uri "$($SharePointInfo.AdminUrl)/_vti_bin/client.svc/ProcessQuery" -Type POST -Body $XML -ContentType 'text/xml'
        # Write-Host $($request)
        if (!$request.ErrorInfo.ErrorMessage) {
            $Message = "Successfully $($RemovePermission ? 'removed' : 'added') $($OnedriveAccessUser) as an owner of $URL"
            Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev Info -tenant $TenantFilter
            return $Message
        } else {
            $Message = "Failed to change access: $($request.ErrorInfo.ErrorMessage)"
            Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev Error -tenant $TenantFilter
            throw $Message
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set SharePoint permissions for $($OnedriveAccessUser) on $URL. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev Error -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPSharePointPerms.ps1' 60
#Region './Public/Set-CIPPSherwebLicense.ps1' -1

function Set-CIPPSherwebLicense {
    param (
        [Parameter(Mandatory = $true)]
        [string]$tenantFilter,

        [Parameter(Mandatory = $true)]
        [string]$SKUid,

        [int]$Quantity,
        [int]$Add,
        [int]$Remove
    )

    Set-SherwebSubscription -SKU $SKUid -Quantity $Quantity -Add $Add -Remove $Remove -TenantFilter $tenantFilter
}
#EndRegion './Public/Set-CIPPSherwebLicense.ps1' 16
#Region './Public/Set-CIPPSignature.ps1' -1

function Set-CIPPSignature {
    [CmdletBinding()]
    param (
        $userid,
        $InternalMessage,
        $ExternalMessage,
        $TenantFilter,
        $State,
        $APIName = 'Set Outlook Roaming Signature',
        $Headers,
        $StartTime,
        $EndTime
    )

    try {
        $SignatureProfile = @'
[{"name":"Roaming_New_Signature","itemClass":"","id":"","scope":"AdeleV@M365x42953883.OnMicrosoft.com","parentSetting":"","secondaryKey":"","type":"String","timestamp":638296273181532792,"metadata":"","value":"Kelvin","isFirstSync":"true","source":"UserOverride"}]
'@
        $null = New-GraphPostRequest -uri 'https://substrate.office.com/ows/beta/outlookcloudsettings/settings/global' -tenantid $TenantFilter -type PATCH -contentType 'application/json' -verbose -scope 'https://outlook.office.com/.default'
        Write-LogMessage -headers $Headers -API $APIName -message "Set Out-of-office for $($userid) to $state" -Sev 'Info' -tenant $TenantFilter
        return "Set Out-of-office for $($userid) to $state."

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -message "Could not add OOO for $($userid). Error: $($ErrorMessage.NormalizedError)" -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        return "Could not add out of office message for $($userid). Error: $($ErrorMessage.NormalizedError)"
    }
}
#EndRegion './Public/Set-CIPPSignature.ps1' 29
#Region './Public/Set-CIPPSignInState.ps1' -1

function Set-CIPPSignInState {
    [CmdletBinding()]
    param (
        $UserID,
        [bool]$AccountEnabled,
        $TenantFilter,
        $APIName = 'Disable User Sign-in',
        $Headers
    )

    try {
        $body = @{
            accountEnabled = [bool]$AccountEnabled
        }
        $body = ConvertTo-Json -InputObject $body -Compress -Depth 5
        $UserDetails = New-GraphGetRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)?`$select=onPremisesSyncEnabled" -noPagination $true -tenantid $TenantFilter -verbose
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/v1.0/users/$($UserID)" -tenantid $TenantFilter -type PATCH -body $body -verbose
        Write-LogMessage -headers $Headers -API $APIName -message "Successfully set account enabled state to $AccountEnabled for $UserID" -Sev 'Info' -tenant $TenantFilter

        if ($UserDetails.onPremisesSyncEnabled -eq $true) {
            throw "WARNING: User $UserID is AD Sync enabled. Please enable/disable in the local AD."
        } else {
            return "Successfully set account enabled state to $AccountEnabled for $UserID"
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        $Message = "Failed to set sign-in state for $UserID. Error: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $APIName -message $Message -Sev 'Error' -tenant $TenantFilter -LogData $ErrorMessage
        throw $Message
    }
}
#EndRegion './Public/Set-CIPPSignInState.ps1' 33
#Region './Public/Set-CIPPSponsor.ps1' -1

function Set-CIPPSponsor {
    [CmdletBinding()]
    param (
        $User,
        $Sponsor,
        $TenantFilter,
        $APIName = 'Set Sponsor',
        $Headers
    )

    try {
        $SponsorBody = [PSCustomObject]@{'@odata.id' = "https://graph.microsoft.com/beta/users/$($Sponsor)" }
        $SponsorBodyJSON = ConvertTo-Json -Compress -Depth 10 -InputObject $SponsorBody
        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$($User)/sponsors/`$ref" -tenantid $TenantFilter -type PUT -body $SponsorBodyJSON
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Set $User's sponsor to $Sponsor" -Sev 'Info'
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to Set Sponsor. Error:$($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $_
        throw "Failed to set sponsor: $($_.Exception.Message)"
    }
    return "Set $user's sponsor to $Sponsor"
}
#EndRegion './Public/Set-CIPPSponsor.ps1' 23
#Region './Public/Set-CIPPSPOTenant.ps1' -1

function Set-CIPPSPOTenant {
    <#
    .SYNOPSIS
    Set SharePoint Tenant properties

    .DESCRIPTION
    Set SharePoint Tenant properties via SPO API

    .PARAMETER TenantFilter
    Tenant to apply settings to

    .PARAMETER Identity
    Tenant Identity (Get from Get-CIPPSPOTenant)

    .PARAMETER Properties
    Hashtable of tenant properties to change

    .PARAMETER SharepointPrefix
    Prefix for the sharepoint tenant

    .EXAMPLE
    $Properties = @{
        'EnableAIPIntegration' = $true
    }
    Get-CippSPOTenant -TenantFilter 'contoso.onmicrosoft.com' | Set-CIPPSPOTenant -Properties $Properties

    .FUNCTIONALITY
    Internal

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [Alias('_ObjectIdentity_')]
        [string]$Identity,
        [Parameter(Mandatory = $true)]
        [hashtable]$Properties,
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [string]$SharepointPrefix
    )

    process {
        if (!$SharepointPrefix) {
            # get sharepoint admin site
            $SharePointInfo = Get-SharePointAdminLink -Public $false -tenantFilter $TenantFilter
            $AdminUrl = $SharePointInfo.AdminUrl
        } else {
            $tenantName = $SharepointPrefix
            $AdminUrl = "https://$($tenantName)-admin.sharepoint.com"
        }
        $Identity = $Identity -replace "`n", '&#xA;'
        $AllowedTypes = @('Boolean', 'String', 'Int32')
        $SetProperty = [System.Collections.Generic.List[string]]::new()
        $x = 114
        foreach ($Property in $Properties.Keys) {
            # Get property type
            $PropertyType = $Properties[$Property].GetType().Name
            if ($PropertyType -in $AllowedTypes) {
                if ($PropertyType -eq 'Boolean') {
                    $PropertyToSet = $Properties[$Property].ToString().ToLower()
                } else {
                    $PropertyToSet = $Properties[$Property]
                }
                $xml = @"
    <SetProperty Id="$x" ObjectPathId="110" Name="$Property">
        <Parameter Type="$PropertyType">$($PropertyToSet)</Parameter>
    </SetProperty>
"@
                $SetProperty.Add($xml)
                $x++
            }
        }

        if (($SetProperty | Measure-Object).Count -eq 0) {
            Write-Error 'No valid properties found'
            return
        }

        # Query tenant settings
        $XML = @"
    <Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="SharePoint Online PowerShell (16.0.24908.0)" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions>$($SetProperty -join '')</Actions><ObjectPaths><Identity Id="110" Name="$Identity" /></ObjectPaths></Request>
"@
        $AdditionalHeaders = @{
            'Accept' = 'application/json;odata=verbose'
        }

        if ($PSCmdlet.ShouldProcess(($Properties.Keys -join ', '), 'Set Tenant Properties')) {
            New-GraphPostRequest -scope "$AdminURL/.default" -tenantid $TenantFilter -Uri "$AdminURL/_vti_bin/client.svc/ProcessQuery" -Type POST -Body $XML -ContentType 'text/xml' -AddedHeaders $AdditionalHeaders
        }
    }
}
#EndRegion './Public/Set-CIPPSPOTenant.ps1' 94
#Region './Public/Set-CIPPStandardsCompareField.ps1' -1

function Set-CIPPStandardsCompareField {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        $FieldName,
        $FieldValue,
        $TenantFilter
    )
    $Table = Get-CippTable -tablename 'CippStandardsReports'
    $TenantName = Get-Tenants -TenantFilter $TenantFilter

    if ($FieldValue -is [System.Boolean]) {
        $FieldValue = [bool]$FieldValue
    } elseif ($FieldValue -is [string]) {
        $FieldValue = [string]$FieldValue
    } else {
        $FieldValue = ConvertTo-Json -Compress -InputObject @($FieldValue) -Depth 10 | Out-String
        $FieldValue = [string]$FieldValue
    }

    $Existing = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq '$($TenantName.defaultDomainName)' and RowKey eq '$($FieldName)'"

    if ($PSCmdlet.ShouldProcess('CIPP Standards Compare', "Set field '$FieldName' to '$FieldValue' for tenant '$($TenantName.defaultDomainName)'")) {
        try {
            if ($Existing) {
                $Existing.Value = $FieldValue
                $Existing | Add-Member -NotePropertyName TemplateId -NotePropertyValue ([string]$script:CippStandardInfoStorage.Value.StandardTemplateId) -Force
                Add-CIPPAzDataTableEntity @Table -Entity $Existing -Force
            } else {
                $Result = [PSCustomObject]@{
                    PartitionKey = [string]$TenantName.defaultDomainName
                    RowKey       = [string]$FieldName
                    Value        = $FieldValue
                    TemplateId   = [string]$script:CippStandardInfoStorage.Value.StandardTemplateId
                }
                Add-CIPPAzDataTableEntity @Table -Entity $Result -Force
            }
            Write-Information "Adding $FieldName to StandardCompare for $Tenant. content is $FieldValue"
        } catch {
            Write-Warning "Failed to add $FieldName to StandardCompare for $Tenant. content is $FieldValue - $($_.Exception.Message)"
        }
    }
}
#EndRegion './Public/Set-CIPPStandardsCompareField.ps1' 43
#Region './Public/Set-CIPPUserJITAdmin.ps1' -1

function Set-CIPPUserJITAdmin {
    <#
    .SYNOPSIS
    Just-in-time admin management

    .DESCRIPTION
    Just-in-time admin management for CIPP. This function can create users, add roles, remove roles, delete, or disable a user.

    .PARAMETER TenantFilter
    Tenant to manage for JIT admin

    .PARAMETER User
    User object to manage JIT admin roles, required property UserPrincipalName - If user is being created we also require FirstName and LastName

    .PARAMETER Roles
    List of Role GUIDs to add or remove

    .PARAMETER Action
    Action to perform: Create, AddRoles, RemoveRoles, DeleteUser, DisableUser

    .PARAMETER Expiration
    DateTime for expiration

    .PARAMETER Reason
    Reason for JIT admin assignment. Defaults to 'No reason provided' as due to backwards compatibility this is not a mandatory field.

    .EXAMPLE
    Set-CIPPUserJITAdmin -TenantFilter 'contoso.onmicrosoft.com' -Headers@{UserPrincipalName = 'jit@contoso.onmicrosoft.com'} -Roles @('62e90394-69f5-4237-9190-012177145e10') -Action 'AddRoles' -Expiration (Get-Date).AddDays(1) -Reason 'Emergency access'

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,

        [Parameter(Mandatory = $true)]
        [hashtable]$User,

        [string[]]$Roles,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Create', 'AddRoles', 'RemoveRoles', 'DeleteUser', 'DisableUser')]
        [string]$Action,

        [datetime]$Expiration,

        [string]$Reason = 'No reason provided'
    )

    if ($PSCmdlet.ShouldProcess("User: $($User.UserPrincipalName)", "Action: $Action")) {
        if ($Action -ne 'Create') {
            $UserObj = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/users/$($User.UserPrincipalName)" -tenantid $TenantFilter
        }

        switch ($Action) {
            'Create' {
                $Password = New-passwordString
                $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1

                $Body = @{
                    givenName         = $User.FirstName
                    surname           = $User.LastName
                    accountEnabled    = $true
                    displayName       = $User.FirstName + ' ' + $User.LastName
                    userPrincipalName = $User.UserPrincipalName
                    mailNickname      = $User.UserPrincipalName.Split('@')[0]
                    passwordProfile   = @{
                        forceChangePasswordNextSignIn        = $true
                        forceChangePasswordNextSignInWithMfa = $false
                        password                             = $Password
                    }
                    $Schema.id        = @{
                        jitAdminEnabled    = $false
                        jitAdminExpiration = $Expiration.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                        jitAdminReason     = $Reason
                    }
                }
                $Json = ConvertTo-Json -Depth 5 -InputObject $Body
                try {
                    $NewUser = New-GraphPOSTRequest -type POST -Uri 'https://graph.microsoft.com/beta/users' -Body $Json -tenantid $TenantFilter
                    #PWPush
                    $PasswordLink = New-PwPushLink -Payload $Password
                    if ($PasswordLink) {
                        $Password = $PasswordLink
                    }
                    [PSCustomObject]@{
                        id                = $NewUser.id
                        userPrincipalName = $NewUser.userPrincipalName
                        password          = $Password
                    }
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-Information "Error creating user: $ErrorMessage"
                    throw $ErrorMessage
                }
            }
            'AddRoles' {
                $Roles = $Roles | ForEach-Object {
                    try {
                        $Body = @{
                            '@odata.id' = "https://graph.microsoft.com/v1.0/directoryObjects/$($UserObj.id)"
                        }
                        $Json = ConvertTo-Json -Depth 5 -InputObject $Body
                        $null = New-GraphPOSTRequest -uri "https://graph.microsoft.com/beta/directoryRoles(roleTemplateId='$($_)')/members/`$ref" -tenantid $TenantFilter -body $Json -ErrorAction SilentlyContinue
                    } catch {}
                }
                $UserEnabled = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)?`$select=accountEnabled" -tenantid $TenantFilter).accountEnabled
                if (-not $UserEnabled) {
                    $Body = @{
                        accountEnabled = $true
                    }
                    $Json = ConvertTo-Json -Depth 5 -InputObject $Body
                    try {
                        New-GraphPOSTRequest -type PATCH -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $TenantFilter -body $Json | Out-Null
                    } catch {}
                }

                Set-CIPPUserJITAdminProperties -TenantFilter $TenantFilter -UserId $UserObj.id -Enabled -Expiration $Expiration -Reason $Reason | Out-Null
                return "Added admin roles to user $($UserObj.displayName) ($($UserObj.userPrincipalName))"
            }
            'RemoveRoles' {
                $Roles = $Roles | ForEach-Object {
                    try {
                        $null = New-GraphPOSTRequest -type DELETE -uri "https://graph.microsoft.com/beta/directoryRoles(roleTemplateId='$($_)')/members/$($UserObj.id)/`$ref" -tenantid $TenantFilter
                    } catch {}
                }
                Set-CIPPUserJITAdminProperties -TenantFilter $TenantFilter -UserId $UserObj.id -Clear | Out-Null
                return "Removed admin roles from user $($UserObj.displayName)"
            }
            'DeleteUser' {
                try {
                    $null = New-GraphPOSTRequest -type DELETE -uri "https://graph.microsoft.com/beta/users/$($UserObj.id)" -tenantid $TenantFilter
                    return "Deleted user $($UserObj.displayName) ($($UserObj.userPrincipalName)) with id $($UserObj.id)"
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    return "Error deleting user $($UserObj.displayName) ($($UserObj.userPrincipalName)): $ErrorMessage"
                }
            }
            'DisableUser' {
                $Body = @{
                    accountEnabled = $false
                }
                $Json = ConvertTo-Json -Depth 5 -InputObject $Body -Compress
                try {
                    Write-Information "Disabling user $($UserObj.displayName) ($($User.UserPrincipalName))"
                    Write-Information $Json
                    Write-Information "https://graph.microsoft.com/beta/users/$($User.UserPrincipalName)"
                    $null = New-GraphPOSTRequest -type PATCH -uri "https://graph.microsoft.com/beta/users/$($User.UserPrincipalName)" -tenantid $TenantFilter -body $Json
                    Set-CIPPUserJITAdminProperties -TenantFilter $TenantFilter -UserId $User.UserPrincipalName -Clear | Out-Null
                    return "Disabled user $($UserObj.displayName) ($($UserObj.userPrincipalName))"
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    return "Error disabling user $($UserObj.displayName) ($($UserObj.userPrincipalName)): $ErrorMessage"

                }
            }
        }
    }
}
#EndRegion './Public/Set-CIPPUserJITAdmin.ps1' 160
#Region './Public/Set-CIPPUserJITAdminProperties.ps1' -1

function Set-CIPPUserJITAdminProperties {
    [CmdletBinding()]
    param(
        [string]$TenantFilter,
        [string]$UserId,
        [switch]$Enabled,
        $Expiration,
        [switch]$Clear,
        [string]$Reason
    )
    try {
        $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1
        if ($Clear.IsPresent) {
            $Body = [PSCustomObject]@{
                "$($Schema.id)" = @{
                    jitAdminEnabled    = $null
                    jitAdminExpiration = $null
                    jitAdminReason     = $null
                }
            }
        } else {
            $Body = [PSCustomObject]@{
                "$($Schema.id)" = @{
                    jitAdminEnabled    = $Enabled.IsPresent
                    jitAdminExpiration = $Expiration.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
                    jitAdminReason     = $Reason
                }
            }
        }

        $Json = ConvertTo-Json -Depth 5 -InputObject $Body
        Write-Information $Json
        New-GraphPOSTRequest -type PATCH -Uri "https://graph.microsoft.com/beta/users/$UserId" -Body $Json -tenantid $TenantFilter | Out-Null
    } catch {
        Write-Information "Error setting JIT Admin properties: $($_.Exception.Message) - $($_.InvocationInfo.PositionMessage)"
    }
}
#EndRegion './Public/Set-CIPPUserJITAdminProperties.ps1' 38
#Region './Public/Set-CIPPUserLicense.ps1' -1

function Set-CIPPUserLicense {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string]$UserId,
        [Parameter(Mandatory)][string]$TenantFilter,
        [Parameter()][array]$AddLicenses = @(),
        [Parameter()][array]$RemoveLicenses = @(),
        $Headers,
        $APIName = 'Set User License'
    )

    # Build the addLicenses array
    $AddLicensesArray = foreach ($license in $AddLicenses) {
        @{
            'disabledPlans' = @()
            'skuId'         = $license
        }
    }

    # Build the LicenseBody hashtable
    $LicenseBody = @{
        'addLicenses'    = @($AddLicensesArray)
        'removeLicenses' = @($RemoveLicenses) ? @($RemoveLicenses) : @()
    }

    # Convert the LicenseBody to JSON
    $LicenseBodyJson = ConvertTo-Json -InputObject $LicenseBody -Depth 10 -Compress

    Write-Host "License body JSON: $LicenseBodyJson"

    try {
        try {
            $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$UserId/assignLicense" -tenantid $TenantFilter -type POST -body $LicenseBodyJson -Verbose
        } catch {
            # Handle if the error is due to missing usage location
            if ($_.Exception.Message -like '*invalid usage location*') {
                $Table = Get-CippTable -tablename 'UserSettings'
                $UserSettings = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'UserSettings' and RowKey eq 'allUsers'"
                if ($UserSettings) { $DefaultUsageLocation = (ConvertFrom-Json $UserSettings.JSON -Depth 5 -ErrorAction SilentlyContinue).usageLocation.value }
                $DefaultUsageLocation ??= 'US' # Fallback to US if not set

                $UsageLocationJson = ConvertTo-Json -InputObject @{'usageLocation' = $DefaultUsageLocation } -Depth 5 -Compress
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$UserId" -tenantid $TenantFilter -type PATCH -body $UsageLocationJson -Verbose
                Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Set usage location for user $UserId to $DefaultUsageLocation" -Sev 'Info'
                # Retry assigning the license
                $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/users/$UserId/assignLicense" -tenantid $TenantFilter -type POST -body $LicenseBodyJson -Verbose
            } else {
                throw $_
            }
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Failed to assign the license. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        throw "Failed to assign the license. $($ErrorMessage.NormalizedError)"
    }

    Write-LogMessage -Headers $Headers -API $APIName -tenant $TenantFilter -message "Assigned licenses to user $UserId. Added: $AddLicenses; Removed: $RemoveLicenses" -Sev 'Info'
    return 'Set licenses successfully'
}
#EndRegion './Public/Set-CIPPUserLicense.ps1' 60
#Region './Public/Set-CIPPUserSchemaProperties.ps1' -1

function Set-CIPPUserSchemaProperties {
    <#
    .SYNOPSIS
    Set Schema Properties for a user

    .DESCRIPTION
    Uses scheam extensions to set properties for a user

    .PARAMETER TenantFilter
    Tenant for user

    .PARAMETER UserId
    One or more user ids to set properties for

    .PARAMETER Properties
    Hashtable of properties to set

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [object]$Users
    )

    $Schema = Get-CIPPSchemaExtensions | Where-Object { $_.id -match '_cippUser' } | Select-Object -First 1
    $int = 0
    $Requests = foreach ($User in $Users) {
        @{
            id        = $int++
            method    = 'PATCH'
            url       = "users/$($User.userId)"
            body      = @{
                "$($Schema.id)" = $User.Properties
            }
            'headers' = @{
                'Content-Type' = 'application/json'
            }
        }
    }

    if ($PSCmdlet.ShouldProcess("User: $($Users.userId -join ', ')", 'Set Schema Properties')) {
        $Requests = New-GraphBulkRequest -tenantid $tenantfilter -Requests @($Requests)
    }
}
#EndRegion './Public/Set-CIPPUserSchemaProperties.ps1' 47
#Region './Public/Standards/Convert-SingleStandardObject.ps1' -1

function Convert-SingleStandardObject {
    param(
        [Parameter(Mandatory = $true)]
        $Obj
    )

    # Ensure we have a PSCustomObject we can modify
    $Obj = [pscustomobject]$Obj

    # Extract action arrays
    $AllActionValues = @()
    if ($Obj.PSObject.Properties.Name -contains 'combinedActions') {
        $AllActionValues = $Obj.combinedActions
        $Obj.PSObject.Properties.Remove('combinedActions') | Out-Null
    } elseif ($Obj.PSObject.Properties.Name -contains 'action') {
        if ($Obj.action -and $Obj.action.value) {
            $AllActionValues = $Obj.action.value
        }
        $Obj.PSObject.Properties.Remove('action') | Out-Null
    }

    # Convert to booleans
    $Obj | Add-Member -NotePropertyName 'remediate' -NotePropertyValue ($AllActionValues -contains 'Remediate') -Force
    $Obj | Add-Member -NotePropertyName 'alert' -NotePropertyValue ($AllActionValues -contains 'warn') -Force
    $Obj | Add-Member -NotePropertyName 'report' -NotePropertyValue ($AllActionValues -contains 'Report') -Force

    # Flatten "standards" if present
    if ($Obj.PSObject.Properties.Name -contains 'standards' -and $Obj.standards) {
        foreach ($standardKey in $Obj.standards.PSObject.Properties.Name) {
            $NestedStandard = $Obj.standards.$standardKey
            if ($NestedStandard) {
                foreach ($nsProp in $NestedStandard.PSObject.Properties) {
                    $Obj | Add-Member -NotePropertyName $nsProp.Name -NotePropertyValue $nsProp.Value -Force
                }
            }
        }
        $Obj.PSObject.Properties.Remove('standards') | Out-Null
    }

    return $Obj
}
#EndRegion './Public/Standards/Convert-SingleStandardObject.ps1' 42
#Region './Public/Standards/ConvertTo-CippStandardObject.ps1' -1

function ConvertTo-CippStandardObject {

    param(
        [Parameter(Mandatory = $true)]
        $StandardObject
    )
    # If it's an array of items, process each item
    if ($StandardObject -is [System.Collections.IEnumerable] -and -not ($StandardObject -is [string])) {
        $ProcessedItems = New-Object System.Collections.ArrayList
        foreach ($Item in $StandardObject) {
            $ProcessedItems.Add((Convert-SingleStandardObject $Item)) | Out-Null
        }
        return $ProcessedItems
    } else {
        # Single object
        return Convert-SingleStandardObject $StandardObject
    }
}
#EndRegion './Public/Standards/ConvertTo-CippStandardObject.ps1' 19
#Region './Public/Standards/Get-CIPPStandards.ps1' -1

function Get-CIPPStandards {
    param(
        [Parameter(Mandatory = $false)]
        [string]$TenantFilter = 'allTenants',

        [Parameter(Mandatory = $false)]
        [switch]$ListAllTenants,

        [Parameter(Mandatory = $false)]
        $TemplateId = '*',

        [Parameter(Mandatory = $false)]
        $runManually = $false
    )

    # Get tenant groups
    $TenantGroups = Get-TenantGroups

    # 1. Get all JSON-based templates from the "templates" table
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'StandardsTemplateV2'"
    $Templates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter | Sort-Object TimeStamp).JSON |
        ForEach-Object {
            try {
                # Fix old "Action" => "action"
                $JSON = $_ -replace '"Action":', '"action":' -replace '"permissionlevel":', '"permissionLevel":'
                ConvertFrom-Json -InputObject $JSON -ErrorAction SilentlyContinue
            } catch {}
        } |
        Where-Object {
            $_.GUID -like $TemplateId -and $_.runManually -eq $runManually
        }

    # 1.5. Expand templates that contain TemplateList-Tags into multiple standards
    $ExpandedTemplates = foreach ($Template in $Templates) {
        Write-Information "Template $($Template.templateName) ($($Template.GUID)) processing..."
        $NewTemplate = $Template.PSObject.Copy()
        $ExpandedStandards = [ordered]@{}
        $HasExpansions = $false

        foreach ($StandardName in $Template.standards.PSObject.Properties.Name) {
            $StandardValue = $Template.standards.$StandardName
            $IsArray = $StandardValue -is [System.Collections.IEnumerable] -and -not ($StandardValue -is [string])

            if ($IsArray) {
                $NewArray = foreach ($Item in $StandardValue) {
                    if ($Item.'TemplateList-Tags'.value) {
                        $HasExpansions = $true
                        $Table = Get-CippTable -tablename 'templates'
                        $Filter = "PartitionKey eq 'IntuneTemplate'"
                        $TemplatesList = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object -Property package -EQ $Item.'TemplateList-Tags'.value

                        foreach ($TemplateItem in $TemplatesList) {
                            $NewItem = $Item.PSObject.Copy()
                            $NewItem.PSObject.Properties.Remove('TemplateList-Tags')
                            $NewItem | Add-Member -NotePropertyName TemplateList -NotePropertyValue ([pscustomobject]@{
                                    label = "$($TemplateItem.RowKey)"
                                    value = "$($TemplateItem.RowKey)"
                                }) -Force
                            $NewItem | Add-Member -NotePropertyName TemplateId -NotePropertyValue $Template.GUID -Force
                            $NewItem
                        }
                    } else {
                        $Item | Add-Member -NotePropertyName TemplateId -NotePropertyValue $Template.GUID -Force
                        $Item
                    }
                }
                $ExpandedStandards[$StandardName] = $NewArray
            } else {
                if ($StandardValue.'TemplateList-Tags'.value) {
                    $HasExpansions = $true
                    $Table = Get-CippTable -tablename 'templates'
                    $Filter = "PartitionKey eq 'IntuneTemplate'"
                    $TemplatesList = Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object -Property package -EQ $StandardValue.'TemplateList-Tags'.value

                    $NewArray = foreach ($TemplateItem in $TemplatesList) {
                        $NewItem = $StandardValue.PSObject.Copy()
                        $NewItem.PSObject.Properties.Remove('TemplateList-Tags')
                        $NewItem | Add-Member -NotePropertyName TemplateList -NotePropertyValue ([pscustomobject]@{
                                label = "$($TemplateItem.RowKey)"
                                value = "$($TemplateItem.RowKey)"
                            }) -Force
                        $NewItem | Add-Member -NotePropertyName TemplateId -NotePropertyValue $Template.GUID -Force
                        $NewItem
                    }
                    $ExpandedStandards[$StandardName] = $NewArray
                } else {
                    $StandardValue | Add-Member -NotePropertyName TemplateId -NotePropertyValue $Template.GUID -Force
                    $ExpandedStandards[$StandardName] = $StandardValue
                }
            }
        }

        if ($HasExpansions) {
            $NewTemplate.standards = [pscustomobject]$ExpandedStandards
        }

        $NewTemplate
    }

    $Templates = $ExpandedTemplates

    # 2. Get tenant list, filter if needed
    $AllTenantsList = Get-Tenants
    if ($TenantFilter -ne 'allTenants') {
        $AllTenantsList = $AllTenantsList | Where-Object {
            $_.defaultDomainName -eq $TenantFilter -or $_.customerId -eq $TenantFilter
        }
    }

    # 3. If -ListAllTenants, build standards for "AllTenants" only
    if ($ListAllTenants.IsPresent) {
        $AllTenantsTemplates = $Templates | Where-Object {
            $_.tenantFilter.value -contains 'AllTenants'
        }

        foreach ($Template in $AllTenantsTemplates) {
            $Standards = $Template.standards

            foreach ($StandardName in $Standards.PSObject.Properties.Name) {
                $Value = $Standards.$StandardName
                $IsArray = $Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])

                if ($IsArray) {
                    # Emit one object per array element
                    foreach ($Item in $Value) {
                        $CurrentStandard = $Item.PSObject.Copy()

                        # Add Remediate if autoRemediate is true
                        if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Remediate'
                                value = 'Remediate'
                            }
                        }

                        # Add Report if Remediate present but Report missing
                        if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Report'
                                value = 'Report'
                            }
                        }

                        $Actions = $CurrentStandard.action.value
                        if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                            $Normalized = ConvertTo-CippStandardObject $CurrentStandard

                            [pscustomobject]@{
                                Tenant     = 'AllTenants'
                                Standard   = $StandardName
                                Settings   = $Normalized
                                TemplateId = $Template.GUID
                            }
                        }
                    }
                } else {
                    # Single object
                    $CurrentStandard = $Value.PSObject.Copy()

                    # Add Remediate if autoRemediate is true
                    if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                        $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                            label = 'Remediate'
                            value = 'Remediate'
                        }
                    }

                    # Add Report if Remediate present but Report missing
                    if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                        $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                            label = 'Report'
                            value = 'Report'
                        }
                    }

                    $Actions = $CurrentStandard.action.value
                    if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                        $Normalized = ConvertTo-CippStandardObject $CurrentStandard

                        [pscustomobject]@{
                            Tenant     = 'AllTenants'
                            Standard   = $StandardName
                            Settings   = $Normalized
                            TemplateId = $Template.GUID
                        }
                    }
                }
            }
        }
    } else {
        # 4. For each tenant, figure out which templates apply, merge them, and output.
        foreach ($Tenant in $AllTenantsList) {
            $TenantName = $Tenant.defaultDomainName
            # Determine which templates apply to this tenant
            $ApplicableTemplates = $Templates | ForEach-Object {
                $template = $_
                $tenantFilterValues = $template.tenantFilter | ForEach-Object {
                    $FilterValue = $_.value
                    # Group lookup
                    if ($_.type -eq 'Group') {
                        ($TenantGroups | Where-Object {
                            $_.Id -eq $FilterValue
                        }).Members.defaultDomainName
                    } else {
                        $FilterValue
                    }
                }

                $excludedTenantValues = @()

                if ($template.excludedTenants) {
                    if ($template.excludedTenants -is [System.Collections.IEnumerable] -and -not ($template.excludedTenants -is [string])) {
                        $excludedTenantValues = $template.excludedTenants | ForEach-Object {
                            $FilterValue = $_.value
                            if ($_.type -eq 'Group') {
                                ($TenantGroups | Where-Object {
                                    $_.Id -eq $FilterValue
                                }).Members.defaultDomainName
                            } else {
                                $FilterValue
                            } }
                    } else {
                        $excludedTenantValues = @($template.excludedTenants)
                    }
                }

                $AllTenantsApplicable = $false
                $TenantSpecificApplicable = $false

                if ($tenantFilterValues -contains 'AllTenants' -and -not ($excludedTenantValues -contains $TenantName)) {
                    $AllTenantsApplicable = $true
                }
                if ($tenantFilterValues -contains $TenantName -and -not ($excludedTenantValues -contains $TenantName)) {
                    $TenantSpecificApplicable = $true
                }

                if ($AllTenantsApplicable -or $TenantSpecificApplicable) {
                    $template
                }
            }

            # Separate AllTenants vs TenantSpecific templates
            $AllTenantTemplatesSet = $ApplicableTemplates | Where-Object {
                $_.tenantFilter.value -contains 'AllTenants'
            }
            $TenantSpecificTemplatesSet = $ApplicableTemplates | Where-Object {
                $_.tenantFilter.value -notcontains 'AllTenants'
            }

            # Build merged standards keyed by (StandardName, TemplateList.value)
            $ComputedStandards = @{}

            # Process AllTenants templates first
            foreach ($Template in $AllTenantTemplatesSet) {
                $Standards = $Template.standards

                foreach ($StandardName in $Standards.PSObject.Properties.Name) {
                    $Value = $Standards.$StandardName
                    $IsArray = $Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])

                    if ($IsArray) {
                        foreach ($Item in $Value) {
                            $CurrentStandard = $Item.PSObject.Copy()
                            $CurrentStandard | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $Template.GUID -Force

                            # Add Remediate if autoRemediate is true
                            if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                                $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                    label = 'Remediate'
                                    value = 'Remediate'
                                }
                            }

                            # Add Report if Remediate present but Report missing
                            if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                                $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                    label = 'Report'
                                    value = 'Report'
                                }
                            }

                            $Actions = $CurrentStandard.action.value
                            if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                                # Key by StandardName + TemplateList.value (if present)
                                $TemplateKey = if ($CurrentStandard.TemplateList.value) { $CurrentStandard.TemplateList.value } else { '' }
                                $Key = "$StandardName|$TemplateKey"

                                $ComputedStandards[$Key] = $CurrentStandard
                            }
                        }
                    } else {
                        $CurrentStandard = $Value.PSObject.Copy()
                        $CurrentStandard | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $Template.GUID -Force

                        # Add Remediate if autoRemediate is true
                        if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Remediate'
                                value = 'Remediate'
                            }
                        }

                        # Add Report if Remediate present but Report missing
                        if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Report'
                                value = 'Report'
                            }
                        }

                        $Actions = $CurrentStandard.action.value
                        if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                            $TemplateKey = if ($CurrentStandard.TemplateList.value) { $CurrentStandard.TemplateList.value } else { '' }
                            $Key = "$StandardName|$TemplateKey"

                            $ComputedStandards[$Key] = $CurrentStandard
                        }
                    }
                }
            }

            # Process TenantSpecific templates, merging with AllTenants base
            foreach ($Template in $TenantSpecificTemplatesSet) {
                $Standards = $Template.standards

                foreach ($StandardName in $Standards.PSObject.Properties.Name) {
                    $Value = $Standards.$StandardName
                    $IsArray = $Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])

                    if ($IsArray) {
                        foreach ($Item in $Value) {
                            $CurrentStandard = $Item.PSObject.Copy()
                            $CurrentStandard | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $Template.GUID -Force

                            # Add Remediate if autoRemediate is true
                            if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                                $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                    label = 'Remediate'
                                    value = 'Remediate'
                                }
                            }

                            # Add Report if Remediate present but Report missing
                            if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                                $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                    label = 'Report'
                                    value = 'Report'
                                }
                            }

                            $Actions = $CurrentStandard.action.value
                            if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                                $TemplateKey = if ($CurrentStandard.TemplateList.value) { $CurrentStandard.TemplateList.value } else { '' }
                                $Key = "$StandardName|$TemplateKey"

                                if ($ComputedStandards.ContainsKey($Key)) {
                                    # Merge tenant-specific over AllTenants base
                                    $MergedStandard = Merge-CippStandards -Existing $ComputedStandards[$Key] -New $CurrentStandard -StandardName $StandardName
                                    $ComputedStandards[$Key] = $MergedStandard
                                } else {
                                    $ComputedStandards[$Key] = $CurrentStandard
                                }
                            }
                        }
                    } else {
                        $CurrentStandard = $Value.PSObject.Copy()
                        $CurrentStandard | Add-Member -NotePropertyName 'TemplateId' -NotePropertyValue $Template.GUID -Force

                        # Add Remediate if autoRemediate is true
                        if ($CurrentStandard.autoRemediate -eq $true -and -not ($CurrentStandard.action.value -contains 'Remediate')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Remediate'
                                value = 'Remediate'
                            }
                        }

                        # Add Report if Remediate present but Report missing
                        if ($CurrentStandard.action.value -contains 'Remediate' -and -not ($CurrentStandard.action.value -contains 'Report')) {
                            $CurrentStandard.action = @($CurrentStandard.action) + [pscustomobject]@{
                                label = 'Report'
                                value = 'Report'
                            }
                        }

                        $Actions = $CurrentStandard.action.value
                        if ($Actions -contains 'Remediate' -or $Actions -contains 'warn' -or $Actions -contains 'Report') {
                            $TemplateKey = if ($CurrentStandard.TemplateList.value) { $CurrentStandard.TemplateList.value } else { '' }
                            $Key = "$StandardName|$TemplateKey"

                            if ($ComputedStandards.ContainsKey($Key)) {
                                $MergedStandard = Merge-CippStandards -Existing $ComputedStandards[$Key] -New $CurrentStandard -StandardName $StandardName
                                $ComputedStandards[$Key] = $MergedStandard
                            } else {
                                $ComputedStandards[$Key] = $CurrentStandard
                            }
                        }
                    }
                }
            }

            # Emit one object per unique (StandardName, TemplateList.value)
            foreach ($Key in $ComputedStandards.Keys) {
                $Standard = $ComputedStandards[$Key]
                $StandardName = $Key -replace '\|.*$', ''

                # Preserve TemplateId before removing
                $PreservedTemplateId = $Standard.TemplateId
                $Standard.PSObject.Properties.Remove('TemplateId') | Out-Null

                $Normalized = ConvertTo-CippStandardObject $Standard

                [pscustomobject]@{
                    Tenant     = $TenantName
                    Standard   = $StandardName
                    Settings   = $Normalized
                    TemplateId = $PreservedTemplateId
                }
            }
        }
    }
}

#EndRegion './Public/Standards/Get-CIPPStandards.ps1' 424
#Region './Public/Standards/Invoke-CIPPStandardActivityBasedTimeout.ps1' -1

function Invoke-CIPPStandardActivityBasedTimeout {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ActivityBasedTimeout
    .SYNOPSIS
        (Label) Enable Activity based Timeout
    .DESCRIPTION
        (Helptext) Enables and sets Idle session timeout for Microsoft 365 to 1 hour. This policy affects most M365 web apps
        (DocsDescription) Enables and sets Idle session timeout for Microsoft 365 to 1 hour. This policy affects most M365 web apps
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (1.3.2)"
            "spo_idle_session_timeout"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Automatically logs out inactive users from Microsoft 365 applications after a specified time period to prevent unauthorized access to company data on unattended devices. This security measure protects against data breaches when employees leave workstations unlocked.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.ActivityBasedTimeout.timeout","options":[{"label":"1 Hour","value":"01:00:00"},{"label":"3 Hours","value":"03:00:00"},{"label":"6 Hours","value":"06:00:00"},{"label":"12 Hours","value":"12:00:00"},{"label":"24 Hours","value":"1.00:00:00"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2022-04-13
        POWERSHELLEQUIVALENT
            Portal or Graph API
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'ActivityBasedTimeout' -Settings $Settings

    # Get timeout value using null-coalescing operator
    $timeout = $Settings.timeout.value ?? $Settings.timeout

    # Input validation
    if ([string]::IsNullOrWhiteSpace($timeout) -or $timeout -eq 'Select a value' ) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'ActivityBasedTimeout: Invalid timeout parameter set' -sev Error
        return
    }

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/activityBasedTimeoutPolicies' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ActivityBasedTimeout state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }
    $StateIsCorrect = if ($CurrentState.definition -like "*$timeout*") { $true } else { $false }

    if ($Settings.remediate -eq $true) {
        try {
            if ($StateIsCorrect -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Activity Based Timeout is already enabled and set to $timeout" -sev Info
            } else {
                $PolicyTemplate = @{
                    displayName           = 'DefaultTimeoutPolicy'
                    isOrganizationDefault = $true
                    definition            = @(
                        "{`"ActivityBasedTimeoutPolicy`":{`"Version`":1,`"ApplicationPolicies`":[{`"ApplicationId`":`"default`",`"WebSessionIdleTimeout`":`"$timeout`"}]}}"
                    )
                }
                $body = ConvertTo-Json -InputObject $PolicyTemplate -Depth 10 -Compress

                # Switch between parameter sets if the policy already exists
                if ($null -eq $CurrentState.id) {
                    $RequestType = 'POST'
                    $URI = 'https://graph.microsoft.com/beta/policies/activityBasedTimeoutPolicies'
                } else {
                    $RequestType = 'PATCH'
                    $URI = "https://graph.microsoft.com/beta/policies/activityBasedTimeoutPolicies/$($CurrentState.id)"
                }
                New-GraphPostRequest -tenantid $Tenant -Uri $URI -Type $RequestType -Body $body
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Enabled Activity Based Timeout with a value of $timeout" -sev Info
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable Activity Based Timeout a value of $timeout." -sev Error -LogData $ErrorMessage
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Activity Based Timeout is enabled and set to $timeout" -sev Info
        } else {
            Write-StandardsAlert -message "Activity Based Timeout is not set to $timeout" -object ($CurrentState.definition | ConvertFrom-Json -ErrorAction SilentlyContinue).activitybasedtimeoutpolicy.ApplicationPolicies -tenant $Tenant -standardName 'ActivityBasedTimeout' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Activity Based Timeout is not set to $timeout" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.ActivityBasedTimeout' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'ActivityBasedTimeout' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardActivityBasedTimeout.ps1' 105
#Region './Public/Standards/Invoke-CIPPStandardAddDKIM.ps1' -1

function Invoke-CIPPStandardAddDKIM {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AddDKIM
    .SYNOPSIS
        (Label) Enables DKIM for all domains that currently support it
    .DESCRIPTION
        (Helptext) Enables DKIM for all domains that currently support it
        (DocsDescription) Enables DKIM for all domains that currently support it
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (2.1.9)"
        EXECUTIVETEXT
            Enables email authentication technology that digitally signs outgoing emails to verify they actually came from your organization. This prevents email spoofing, improves email deliverability, and protects the company's reputation by ensuring recipients can trust emails from your domains.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2023-03-14
        POWERSHELLEQUIVALENT
            New-DkimSigningConfig and Set-DkimSigningConfig
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'AddDKIM' -Settings $Settings
    $TestResult = Test-CIPPStandardLicense -StandardName 'AddDKIM' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $DkimRequest = @(
        @{
            CmdletInput = @{
                CmdletName = 'Get-AcceptedDomain'
                Parameters = @{}
            }
        },
        @{
            CmdletInput = @{
                CmdletName = 'Get-DkimSigningConfig'
                Parameters = @{}
            }
        }
    )

    $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray $DkimRequest -useSystemMailbox $true

    # Check for errors in the batch results. Cannot continue if there are errors.
    $ErrorCounter = 0
    $ErrorMessages = [System.Collections.Generic.List[string]]::new()
    $BatchResults | ForEach-Object {
        if ($_.error) {
            $ErrorCounter++
            $ErrorMessage = Get-NormalizedError -Message $_.error
            $ErrorMessages.Add($ErrorMessage)
        }
    }
    if ($ErrorCounter -gt 0) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to get DKIM config. Error: $($ErrorMessages -join ', ')" -sev Error
        return
    }

    # Same exclusions also found in Push-DomainAnalyserTenant
    $ExclusionDomains = @(
        '*.microsoftonline.com'
        '*.mail.onmicrosoft.com'
        '*.exclaimer.cloud'
        '*.excl.cloud'
        '*.codetwo.online'
        '*.call2teams.com'
        '*.signature365.net'
        '*.myteamsconnect.io'
        '*.teams.dstny.com'
        '*.msteams.8x8.com'
        '*.ucconnect.co.uk'
        '*.teams-sbc.dk'
    )

    $AllDomains = ($BatchResults | Where-Object { $_.DomainName }).DomainName | ForEach-Object {
        $Domain = $_
        foreach ($ExclusionDomain in $ExclusionDomains) {
            if ($Domain -like $ExclusionDomain) {
                $Domain = $null
            }
        }
        if ($null -ne $Domain) { $Domain }
    }
    $DKIM = $BatchResults | Where-Object { $_.Domain } | Select-Object Domain, Enabled, Status | ForEach-Object {
        $Domain = $_
        foreach ($ExclusionDomain in $ExclusionDomains) {
            if ($Domain.Domain -like $ExclusionDomain) {
                $Domain = $null
            }
        }
        if ($null -ne $Domain) { $Domain }
    }

    # List of domains for each way to enable DKIM
    $NewDomains = $AllDomains | Where-Object { $DKIM.Domain -notcontains $_ }
    $SetDomains = $DKIM | Where-Object { $AllDomains -contains $_.Domain -and $_.Enabled -eq $false }

    if ($Settings.remediate -eq $true) {

        if ($null -eq $NewDomains -and $null -eq $SetDomains) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'DKIM is already enabled for all available domains.' -sev Info
        } else {
            $ErrorCounter = 0
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Trying to enable DKIM for:$($NewDomains -join ', ' ) $($SetDomains.Domain -join ', ')" -sev Info

            # New-domains
            $Request = $NewDomains | ForEach-Object {
                @{
                    CmdletInput = @{
                        CmdletName = 'New-DkimSigningConfig'
                        Parameters = @{ KeySize = 2048; DomainName = $_; Enabled = $true }
                    }
                }
            }
            if ($null -ne $Request) { $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($Request) -useSystemMailbox $true }
            $BatchResults | ForEach-Object {
                if ($_.error) {
                    $ErrorCounter ++
                    $ErrorMessage = Get-NormalizedError -Message $_.error
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable DKIM. Error: $ErrorMessage" -sev Error
                }
            }

            # Set-domains
            $Request = $SetDomains | ForEach-Object {
                @{
                    CmdletInput = @{
                        CmdletName = 'Set-DkimSigningConfig'
                        Parameters = @{ Identity = $_.Domain; Enabled = $true }
                    }
                }
            }
            if ($null -ne $Request) { $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($Request) -useSystemMailbox $true }
            $BatchResults | ForEach-Object {
                if ($_.error) {
                    $ErrorCounter ++
                    $ErrorMessage = Get-NormalizedError -Message $_.error
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set DKIM. Error: $ErrorMessage" -sev Error
                }
            }

            if ($ErrorCounter -eq 0) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Enabled DKIM for all domains in tenant' -sev Info
            } elseif ($ErrorCounter -gt 0 -and $ErrorCounter -lt ($NewDomains.Count + $SetDomains.Count)) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to enable DKIM for some domains in tenant' -sev Error
            } else {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to enable DKIM for all domains in tenant' -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($null -eq $NewDomains -and $null -eq $SetDomains) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DKIM is enabled for all available domains' -sev Info
        } else {
            $NoDKIM = ($NewDomains + $SetDomains.Domain) -join ';'
            Write-StandardsAlert -message "DKIM is not enabled for: $NoDKIM" -object @{NewDomains = $NewDomains; SetDomains = $SetDomains } -tenant $tenant -standardName 'AddDKIM' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "DKIM is not enabled for: $NoDKIM" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $DKIMState = if ($null -eq $NewDomains -and $null -eq $SetDomains) { $true } else { $SetDomains, $NewDomains }
        Set-CIPPStandardsCompareField -FieldName 'standards.AddDKIM' -FieldValue $DKIMState -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'DKIM' -FieldValue $DKIMState -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAddDKIM.ps1' 186
#Region './Public/Standards/Invoke-CIPPStandardAddDMARCToMOERA.ps1' -1

function Invoke-CIPPStandardAddDMARCToMOERA {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AddDMARCToMOERA
    .SYNOPSIS
        (Label) Enables DMARC on MOERA (onmicrosoft.com) domains
    .DESCRIPTION
        (Helptext) Note: requires 'Domain Name Administrator' GDAP role. This should be enabled even if the MOERA (onmicrosoft.com) domains is not used for sending. Enabling this prevents email spoofing. The default value is 'v=DMARC1; p=reject;' recommended because the domain is only used within M365 and reporting is not needed. Omitting pct tag default to 100%
        (DocsDescription) Note: requires 'Domain Name Administrator' GDAP role. Adds a DMARC record to MOERA (onmicrosoft.com) domains. This should be enabled even if the MOERA (onmicrosoft.com) domains is not used for sending. Enabling this prevents email spoofing. The default record is 'v=DMARC1; p=reject;' recommended because the domain is only used within M365 and reporting is not needed. Omitting pct tag default to 100%
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (2.1.10)"
            "Security"
            "PhishingProtection"
        EXECUTIVETEXT
            Implements advanced email security for Microsoft's default domain names (onmicrosoft.com) to prevent criminals from impersonating your organization. This blocks fraudulent emails that could damage your company's reputation and protects partners and customers from phishing attacks using your domain names.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":true,"required":false,"placeholder":"v=DMARC1; p=reject; (recommended)","label":"Value","name":"standards.AddDMARCToMOERA.RecordValue","options":[{"label":"v=DMARC1; p=reject; (recommended)","value":"v=DMARC1; p=reject;"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-16
        POWERSHELLEQUIVALENT
            Portal only
        RECOMMENDEDBY
            "CIS"
            "Microsoft"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'AddDMARCToMOERA' -Settings $Settings

    $RecordModel = [PSCustomObject]@{
        HostName = '_dmarc'
        TtlValue = 3600
        Type     = 'TXT'
        Value    = $Settings.RecordValue.Value ?? 'v=DMARC1; p=reject;'
    }

    # Get all fallback domains (onmicrosoft.com domains) and check if the DMARC record is set correctly
    try {
        $Domains = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $Tenant -Uri 'https://admin.microsoft.com/admin/api/Domains/List' | Where-Object -Property Name -Like '*.onmicrosoft.com'

        $CurrentInfo = $Domains | ForEach-Object {
            # Get current DNS records that matches _dmarc hostname and TXT type
            $CurrentRecords = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $Tenant -Uri "https://admin.microsoft.com/admin/api/Domains/Records?domainName=$($_.Name)" | Select-Object -ExpandProperty DnsRecords | Where-Object { $_.HostName -eq $RecordModel.HostName -and $_.Type -eq $RecordModel.Type }

            if ($CurrentRecords.count -eq 0) {
                #record not found, return a model with Match set to false
                [PSCustomObject]@{
                    DomainName    = $_.Name
                    Match         = $false
                    CurrentRecord = $null
                }
            } else {
                foreach ($CurrentRecord in $CurrentRecords) {
                    # Create variable matching the RecordModel used for comparison
                    $CurrentRecordModel = [PSCustomObject]@{
                        HostName = $CurrentRecord.HostName
                        TtlValue = $CurrentRecord.TtlValue
                        Type     = $CurrentRecord.Type
                        Value    = $CurrentRecord.Value
                    }

                    # Compare the current record with the expected record model
                    if (!(Compare-Object -ReferenceObject $RecordModel -DifferenceObject $CurrentRecordModel -Property HostName, TtlValue, Type, Value)) {
                        [PSCustomObject]@{
                            DomainName    = $_.Name
                            Match         = $true
                            CurrentRecord = $CurrentRecord
                        }
                    } else {
                        [PSCustomObject]@{
                            DomainName    = $_.Name
                            Match         = $false
                            CurrentRecord = $CurrentRecord
                        }
                    }
                }
            }
        }
        # Check if match is true and there is only one DMARC record for the domain
        $StateIsCorrect = $false -notin $CurrentInfo.Match -and $CurrentInfo.Count -eq 1
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        if ($_.Exception.Message -like '*403*') {
            $Message = "AddDMARCToMOERA: Insufficient permissions. Please ensure the tenant GDAP relationship includes the 'Domain Name Administrator' role: $($ErrorMessage.NormalizedError)"
        } else {
            $Message = "Failed to get dns records for MOERA domains: $($ErrorMessage.NormalizedError)"
        }
        Write-LogMessage -API 'Standards' -tenant $tenant -message $Message -sev Error -LogData $ErrorMessage
        return $Message
    }

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DMARC record is already set for all MOERA (onmicrosoft.com) domains.' -sev Info
        } else {
            # Loop through each domain and set the DMARC record, existing misconfigured records and duplicates will be deleted
            foreach ($Domain in ($CurrentInfo | Sort-Object -Property DomainName -Unique)) {
                try {
                    foreach ($Record in ($CurrentInfo | Where-Object -Property DomainName -EQ $Domain.DomainName)) {
                        if ($Record.CurrentRecord) {
                            New-GraphPOSTRequest -tenantid $tenant -scope 'https://admin.microsoft.com/.default' -Uri "https://admin.microsoft.com/admin/api/Domains/Record?domainName=$($Domain.DomainName)" -Body ($Record.CurrentRecord | ConvertTo-Json -Compress) -AddedHeaders @{'x-http-method-override' = 'Delete' }
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Deleted incorrect DMARC record for domain $($Domain.DomainName)" -sev Info
                        }
                        New-GraphPOSTRequest -tenantid $tenant -scope 'https://admin.microsoft.com/.default' -type 'PUT' -Uri "https://admin.microsoft.com/admin/api/Domains/Record?domainName=$($Domain.DomainName)" -Body (@{RecordModel = $RecordModel } | ConvertTo-Json -Compress)
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Set DMARC record for domain $($Domain.DomainName)" -sev Info
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set DMARC record for domain $($Domain.DomainName): $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DMARC record is already set for all MOERA (onmicrosoft.com) domains.' -sev Info
        } else {
            $UniqueDomains = ($CurrentInfo | Sort-Object -Property DomainName -Unique)
            $NotSetDomains = @($UniqueDomains | ForEach-Object { if ($_.Match -eq $false -or ($CurrentInfo | Where-Object -Property DomainName -EQ $_.DomainName).Count -eq 1) { $_.DomainName } })
            $Message = "DMARC record is not set for $($NotSetDomains.count) of $($UniqueDomains.count) MOERA (onmicrosoft.com) domains."

            Write-StandardsAlert -message $Message -object @{MissingDMARC = ($NotSetDomains -join ', ') } -tenant $tenant -standardName 'AddDMARCToMOERA' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "$Message. Missing for: $($NotSetDomains -join ', ')" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        set-CIPPStandardsCompareField -FieldName 'standards.AddDMARCToMOERA' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AddDMARCToMOERA' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAddDMARCToMOERA.ps1' 144
#Region './Public/Standards/Invoke-CIPPStandardallowOAuthTokens.ps1' -1

function Invoke-CIPPStandardallowOAuthTokens {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) allowOAuthTokens
    .SYNOPSIS
        (Label) Enable OTP Software OAuth tokens
    .DESCRIPTION
        (Helptext) Allows you to use any software OAuth token generator
        (DocsDescription) Enables OTP Software OAuth tokens for the tenant. This allows users to use OTP codes generated via software, like a password manager to be used as an authentication method.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "EIDSCA.AT01"
            "EIDSCA.AT02"
        EXECUTIVETEXT
            Allows employees to use third-party authentication apps and password managers to generate secure login codes, providing flexibility in authentication methods while maintaining security standards. This accommodates diverse user preferences and existing security tools.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'AddDKIM' -Settings $Settings

    try {
        $CurrentState = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy/authenticationMethodConfigurations/softwareOath' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the allowOTPTokens state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'enabled')

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Software OTP/oAuth tokens is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'softwareOath' -Enabled $true
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Software OTP/oAuth tokens is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Software OTP/oAuth tokens is not enabled' -object $CurrentState -tenant $tenant -standardName 'allowOAuthTokens' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Software OTP/oAuth tokens is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'softwareOath' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.allowOAuthTokens' -FieldValue $StateIsCorrect -TenantFilter $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardallowOAuthTokens.ps1' 71
#Region './Public/Standards/Invoke-CIPPStandardallowOTPTokens.ps1' -1

function Invoke-CIPPStandardallowOTPTokens {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) allowOTPTokens
    .SYNOPSIS
        (Label) Enable OTP via Authenticator
    .DESCRIPTION
        (Helptext) Allows you to use MS authenticator OTP token generator
        (DocsDescription) Allows you to use Microsoft Authenticator OTP token generator. Useful for using the NPS extension as MFA on VPN clients.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "EIDSCA.AM02"
        EXECUTIVETEXT
            Enables one-time password generation through Microsoft Authenticator app, providing an additional secure authentication method for employees. This is particularly useful for secure VPN access and other systems requiring multi-factor authentication.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2023-12-06
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'allowOTPTokens' -Settings $Settings

    try {
        $CurrentInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy/authenticationMethodConfigurations/microsoftAuthenticator' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the allowOTPTokens state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($CurrentInfo.isSoftwareOathEnabled) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MS authenticator OTP/oAuth tokens is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'MicrosoftAuthenticator' -Enabled $true -MicrosoftAuthenticatorSoftwareOathEnabled $true
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.isSoftwareOathEnabled) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MS authenticator OTP/oAuth tokens is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'MS authenticator OTP/oAuth tokens is not enabled' -object $CurrentInfo -tenant $tenant -standardName 'allowOTPTokens' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MS authenticator OTP/oAuth tokens is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.allowOTPTokens' -FieldValue $CurrentInfo.isSoftwareOathEnabled -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'MSAuthenticator' -FieldValue $CurrentInfo.isSoftwareOathEnabled -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardallowOTPTokens.ps1' 70
#Region './Public/Standards/Invoke-CIPPStandardAnonReportDisable.ps1' -1

function Invoke-CIPPStandardAnonReportDisable {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AnonReportDisable
    .SYNOPSIS
        (Label) Enable Usernames instead of pseudo anonymised names in reports
    .DESCRIPTION
        (Helptext) Shows usernames instead of pseudo anonymised names in reports. This standard is required for reporting to work correctly.
        (DocsDescription) Microsoft announced some APIs and reports no longer return names, to comply with compliance and legal requirements in specific countries. This proves an issue for a lot of MSPs because those reports are often helpful for engineers. This standard applies a setting that shows usernames in those API calls / reports.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Configures Microsoft 365 reports to display actual usernames instead of anonymized identifiers, enabling IT administrators to effectively troubleshoot issues and generate meaningful usage reports. This improves operational efficiency and system management capabilities.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminReportSetting -BodyParameter @{displayConcealedNames = \$true}
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'allowOTPTokens' -Settings $Settings

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/reportSettings' -tenantid $Tenant -AsApp $true
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the AnonReportDisable state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {

        if ($CurrentInfo.displayConcealedNames -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Anonymous Reports is already disabled.' -sev Info
        } else {
            try {
                New-GraphPOSTRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/reportSettings' -Type patch -Body '{"displayConcealedNames": false}' -AsApp $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Anonymous Reports Disabled.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable anonymous reports. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }
    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.displayConcealedNames -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Anonymous Reports is disabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Anonymous Reports is not disabled' -object $CurrentInfo -tenant $tenant -standardName 'AnonReportDisable' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Anonymous Reports is not disabled' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $StateIsCorrect = $CurrentInfo.displayConcealedNames ? $false : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.AnonReportDisable' -FieldValue $StateIsCorrect -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'AnonReport' -FieldValue $CurrentInfo.displayConcealedNames -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAnonReportDisable.ps1' 73
#Region './Public/Standards/Invoke-CIPPStandardAntiPhishPolicy.ps1' -1

function Invoke-CIPPStandardAntiPhishPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AntiPhishPolicy
    .SYNOPSIS
        (Label) Default Anti-Phishing Policy
    .DESCRIPTION
        (Helptext) This creates a Anti-Phishing policy that automatically enables Mailbox Intelligence and spoofing, optional switches for Mail tips.
        (DocsDescription) This creates a Anti-Phishing policy that automatically enables Mailbox Intelligence and spoofing, optional switches for Mail tips.
    .NOTES
        CAT
            Defender Standards
        TAG
            "mdo_safeattachments"
            "mdo_highconfidencespamaction"
            "mdo_highconfidencephishaction"
            "mdo_phisspamacation"
            "mdo_spam_notifications_only_for_admins"
            "mdo_antiphishingpolicies"
            "mdo_phishthresholdlevel"
            "CIS M365 5.0 (2.1.7)"
            "NIST CSF 2.0 (DE.CM-09)"
        ADDEDCOMPONENT
            {"type":"number","label":"Phishing email threshold. (Default 1)","name":"standards.AntiPhishPolicy.PhishThresholdLevel","defaultValue":1}
            {"type":"switch","label":"Show first contact safety tip","name":"standards.AntiPhishPolicy.EnableFirstContactSafetyTips","defaultValue":true}
            {"type":"switch","label":"Show user impersonation safety tip","name":"standards.AntiPhishPolicy.EnableSimilarUsersSafetyTips","defaultValue":true}
            {"type":"switch","label":"Show domain impersonation safety tip","name":"standards.AntiPhishPolicy.EnableSimilarDomainsSafetyTips","defaultValue":true}
            {"type":"switch","label":"Show user impersonation unusual characters safety tip","name":"standards.AntiPhishPolicy.EnableUnusualCharactersSafetyTips","defaultValue":true}
            {"type":"select","multiple":false,"label":"If the message is detected as spoof by spoof intelligence","name":"standards.AntiPhishPolicy.AuthenticationFailAction","options":[{"label":"Quarantine the message","value":"Quarantine"},{"label":"Move to Junk Folder","value":"MoveToJmf"}]}
            {"type":"select","multiple":false,"creatable":true,"label":"Quarantine policy for Spoof","name":"standards.AntiPhishPolicy.SpoofQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"select","multiple":false,"label":"If a message is detected as user impersonation","name":"standards.AntiPhishPolicy.TargetedUserProtectionAction","options":[{"label":"Move to Junk Folder","value":"MoveToJmf"},{"label":"Delete the message before its delivered","value":"Delete"},{"label":"Quarantine the message","value":"Quarantine"}]}
            {"type":"select","multiple":false,"creatable":true,"label":"Quarantine policy for user impersonation","name":"standards.AntiPhishPolicy.TargetedUserQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"select","multiple":false,"label":"If a message is detected as domain impersonation","name":"standards.AntiPhishPolicy.TargetedDomainProtectionAction","options":[{"label":"Move to Junk Folder","value":"MoveToJmf"},{"label":"Delete the message before its delivered","value":"Delete"},{"label":"Quarantine the message","value":"Quarantine"}]}
            {"type":"select","multiple":false,"creatable":true,"label":"Quarantine policy for domain impersonation","name":"standards.AntiPhishPolicy.TargetedDomainQuarantineTag","options":[{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"},{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"}]}
            {"type":"select","multiple":false,"label":"If Mailbox Intelligence detects an impersonated user","name":"standards.AntiPhishPolicy.MailboxIntelligenceProtectionAction","options":[{"label":"Move to Junk Folder","value":"MoveToJmf"},{"label":"Delete the message before its delivered","value":"Delete"},{"label":"Quarantine the message","value":"Quarantine"}]}
            {"type":"select","multiple":false,"creatable":true,"label":"Apply quarantine policy","name":"standards.AntiPhishPolicy.MailboxIntelligenceQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-25
        POWERSHELLEQUIVALENT
            Set-AntiPhishPolicy or New-AntiPhishPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AntiPhishPolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AntiPhishPolicy'

    $ServicePlans = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus?$select=servicePlans' -tenantid $Tenant
    $ServicePlans = $ServicePlans.servicePlans.servicePlanName
    $MDOLicensed = $ServicePlans -contains "ATP_ENTERPRISE"
    Write-Information "MDOLicensed: $MDOLicensed"

    # Use custom name if provided, otherwise use default for backward compatibility
    $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Anti-Phishing Policy' }
    $PolicyList = @($PolicyName, 'CIPP Default Anti-Phishing Policy','Default Anti-Phishing Policy')
    $ExistingPolicy = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AntiPhishPolicy' | Where-Object -Property Name -In $PolicyList | Select-Object -First 1
    if ($null -eq $ExistingPolicy.Name) {
        # No existing policy - use the configured/default name
        $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Anti-Phishing Policy' }
    } else {
        # Use existing policy name if found
        $PolicyName = $ExistingPolicy.Name
    }
    # Derive rule name from policy name, but check for old names for backward compatibility
    $DesiredRuleName = "$PolicyName Rule"
    $RuleList = @($DesiredRuleName, 'CIPP Default Anti-Phishing Rule','CIPP Default Anti-Phishing Policy')
    $ExistingRule = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AntiPhishRule' | Where-Object -Property Name -In $RuleList | Select-Object -First 1
    if ($null -eq $ExistingRule.Name) {
        # No existing rule - use the derived name
        $RuleName = $DesiredRuleName
    } else {
        # Use existing rule name if found
        $RuleName = $ExistingRule.Name
    }

    $CurrentState = $ExistingPolicy |
        Select-Object Name, Enabled, PhishThresholdLevel, EnableMailboxIntelligence, EnableMailboxIntelligenceProtection, EnableSpoofIntelligence, EnableFirstContactSafetyTips, EnableSimilarUsersSafetyTips, EnableSimilarDomainsSafetyTips, EnableUnusualCharactersSafetyTips, EnableUnauthenticatedSender, EnableViaTag, AuthenticationFailAction, SpoofQuarantineTag, MailboxIntelligenceProtectionAction, MailboxIntelligenceQuarantineTag, TargetedUserProtectionAction, TargetedUserQuarantineTag, TargetedDomainProtectionAction, TargetedDomainQuarantineTag, EnableOrganizationDomainsProtection, EnableTargetedDomainsProtection, EnableTargetedUserProtection

    if ($MDOLicensed) {
        $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
                          ($CurrentState.Enabled -eq $true) -and
                          ($CurrentState.PhishThresholdLevel -eq $Settings.PhishThresholdLevel) -and
                          ($CurrentState.EnableMailboxIntelligence -eq $true) -and
                          ($CurrentState.EnableMailboxIntelligenceProtection -eq $true) -and
                          ($CurrentState.EnableSpoofIntelligence -eq $true) -and
                          ($CurrentState.EnableFirstContactSafetyTips -eq $Settings.EnableFirstContactSafetyTips) -and
                          ($CurrentState.EnableSimilarUsersSafetyTips -eq $Settings.EnableSimilarUsersSafetyTips) -and
                          ($CurrentState.EnableSimilarDomainsSafetyTips -eq $Settings.EnableSimilarDomainsSafetyTips) -and
                          ($CurrentState.EnableUnusualCharactersSafetyTips -eq $Settings.EnableUnusualCharactersSafetyTips) -and
                          ($CurrentState.EnableUnauthenticatedSender -eq $true) -and
                          ($CurrentState.EnableViaTag -eq $true) -and
                          ($CurrentState.AuthenticationFailAction -eq $Settings.AuthenticationFailAction) -and
                          ($CurrentState.SpoofQuarantineTag -eq $Settings.SpoofQuarantineTag) -and
                          ($CurrentState.MailboxIntelligenceProtectionAction -eq $Settings.MailboxIntelligenceProtectionAction) -and
                          ($CurrentState.MailboxIntelligenceQuarantineTag -eq $Settings.MailboxIntelligenceQuarantineTag) -and
                          ($CurrentState.TargetedUserProtectionAction -eq $Settings.TargetedUserProtectionAction) -and
                          ($CurrentState.TargetedUserQuarantineTag -eq $Settings.TargetedUserQuarantineTag) -and
                          ($CurrentState.TargetedDomainProtectionAction -eq $Settings.TargetedDomainProtectionAction) -and
                          ($CurrentState.TargetedDomainQuarantineTag -eq $Settings.TargetedDomainQuarantineTag) -and
                          ($CurrentState.EnableTargetedDomainsProtection -eq $true) -and
                          ($CurrentState.EnableTargetedUserProtection -eq $true) -and
                          ($CurrentState.EnableOrganizationDomainsProtection -eq $true)
    } else {
        $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
                          ($CurrentState.Enabled -eq $true) -and
                          ($CurrentState.EnableSpoofIntelligence -eq $true) -and
                          ($CurrentState.EnableFirstContactSafetyTips -eq $Settings.EnableFirstContactSafetyTips) -and
                          ($CurrentState.EnableUnauthenticatedSender -eq $true) -and
                          ($CurrentState.EnableViaTag -eq $true) -and
                          ($CurrentState.AuthenticationFailAction -eq $Settings.AuthenticationFailAction) -and
                          ($CurrentState.SpoofQuarantineTag -eq $Settings.SpoofQuarantineTag)
    }

    $AcceptedDomains = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AcceptedDomain'

    $RuleState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AntiPhishRule' |
        Where-Object -Property Name -EQ $RuleName |
        Select-Object Name, AntiPhishPolicy, Priority, RecipientDomainIs

    $RuleStateIsCorrect = ($RuleState.Name -eq $RuleName) -and
                          ($RuleState.AntiPhishPolicy -eq $PolicyName) -and
                          ($RuleState.Priority -eq 0) -and
                          (!(Compare-Object -ReferenceObject $RuleState.RecipientDomainIs -DifferenceObject $AcceptedDomains.Name))

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Anti-phishing policy already correctly configured' -sev Info
        } else {
            if ($MDOLicensed) {
                $cmdParams = @{
                    Enabled                             = $true
                    PhishThresholdLevel                 = $Settings.PhishThresholdLevel
                    EnableMailboxIntelligence           = $true
                    EnableMailboxIntelligenceProtection = $true
                    EnableSpoofIntelligence             = $true
                    EnableFirstContactSafetyTips        = $Settings.EnableFirstContactSafetyTips
                    EnableSimilarUsersSafetyTips        = $Settings.EnableSimilarUsersSafetyTips
                    EnableSimilarDomainsSafetyTips      = $Settings.EnableSimilarDomainsSafetyTips
                    EnableUnusualCharactersSafetyTips   = $Settings.EnableUnusualCharactersSafetyTips
                    EnableUnauthenticatedSender         = $true
                    EnableViaTag                        = $true
                    AuthenticationFailAction            = $Settings.AuthenticationFailAction
                    SpoofQuarantineTag                  = $Settings.SpoofQuarantineTag
                    MailboxIntelligenceProtectionAction = $Settings.MailboxIntelligenceProtectionAction
                    MailboxIntelligenceQuarantineTag    = $Settings.MailboxIntelligenceQuarantineTag
                    TargetedUserProtectionAction        = $Settings.TargetedUserProtectionAction
                    TargetedUserQuarantineTag           = $Settings.TargetedUserQuarantineTag
                    TargetedDomainProtectionAction      = $Settings.TargetedDomainProtectionAction
                    TargetedDomainQuarantineTag         = $Settings.TargetedDomainQuarantineTag
                    EnableTargetedDomainsProtection     = $true
                    EnableTargetedUserProtection        = $true
                    EnableOrganizationDomainsProtection = $true
                }
            } else {
                $cmdParams = @{
                    Enabled                             = $true
                    EnableSpoofIntelligence             = $true
                    EnableFirstContactSafetyTips        = $Settings.EnableFirstContactSafetyTips
                    EnableUnauthenticatedSender         = $true
                    EnableViaTag                        = $true
                    AuthenticationFailAction            = $Settings.AuthenticationFailAction
                    SpoofQuarantineTag                  = $Settings.SpoofQuarantineTag
                }
            }

            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams.Add('Identity', $PolicyName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-AntiPhishPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Anti-phishing policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Anti-phishing policy $PolicyName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', $PolicyName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'New-AntiPhishPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Anti-phishing policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Anti-phishing policy $PolicyName." -sev Error -LogData $_
                }
            }
        }

        if ($RuleStateIsCorrect -eq $false) {
            $cmdParams = @{
                Priority          = 0
                RecipientDomainIs = $AcceptedDomains.Name
            }

            if ($RuleState.AntiPhishPolicy -ne $PolicyName) {
                $cmdParams.Add('AntiPhishPolicy', $PolicyName)
            }

            if ($RuleState.Name -eq $RuleName) {
                try {
                    $cmdParams.Add('Identity', $RuleName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-AntiPhishRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Anti-phishing rule $RuleName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Anti-phishing rule $RuleName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', $RuleName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'New-AntiPhishRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Anti-phishing rule $RuleName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Anti-phishing rule $RuleName." -sev Error -LogData $_
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Anti-phishing policy is enabled' -sev Info
        } else {
            Write-StandardsAlert -message "Anti-phishing policy is not enabled" -object $CurrentState -tenant $Tenant -standardName 'AntiPhishPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Anti-phishing policy is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.AntiPhishPolicy' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AntiPhishPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardAntiPhishPolicy.ps1' 246
#Region './Public/Standards/Invoke-CIPPStandardAntiSpamSafeList.ps1' -1

function Invoke-CIPPStandardAntiSpamSafeList {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AntiSpamSafeList
    .SYNOPSIS
        (Label) Set Anti-Spam Connection Filter Safe List
    .DESCRIPTION
        (Helptext) Sets the anti-spam connection filter policy option 'safe list' in Defender.
        (DocsDescription) Sets [Microsoft's built-in 'safe list'](https://learn.microsoft.com/en-us/powershell/module/exchange/set-hostedconnectionfilterpolicy?view=exchange-ps#-enablesafelist) in the anti-spam connection filter policy, rather than setting a custom safe/block list of IPs.
    .NOTES
        CAT
            Defender Standards
        TAG
            "CIS M365 5.0 (2.1.13)"
        EXECUTIVETEXT
            Enables Microsoft's pre-approved list of trusted email servers to improve email delivery from legitimate sources while maintaining spam protection. This reduces false positives where legitimate emails might be blocked while still protecting against spam and malicious emails.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.AntiSpamSafeList.EnableSafeList","label":"Enable Safe List"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-02-15
        POWERSHELLEQUIVALENT
            Set-HostedConnectionFilterPolicy "Default" -EnableSafeList \$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AntiSpamSafeList' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AntiSpamSafeList'

    try {
        $State = [System.Convert]::ToBoolean($Settings.EnableSafeList)
    } catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'AntiSpamSafeList: Failed to convert the EnableSafeList parameter to a boolean' -sev Error
        return
    }

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-HostedConnectionFilterPolicy' -cmdParams @{Identity = 'Default' }).EnableSafeList
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to get the Anti-Spam Connection Filter Safe List. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return
    }
    $WantedState = $State -eq $true ? $true : $false
    $StateIsCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.AntiSpamSafeList' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AntiSpamSafeList' -FieldValue $CurrentState -StoreAs bool -Tenant $Tenant
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $false) {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-HostedConnectionFilterPolicy' -cmdParams @{
                    Identity       = 'Default'
                    EnableSafeList = $WantedState
                }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set the Anti-Spam Connection Filter Safe List to $WantedState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set the Anti-Spam Connection Filter Safe List to $WantedState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The Anti-Spam Connection Filter Safe List is already set correctly to $WantedState" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The Anti-Spam Connection Filter Safe List is set correctly to $WantedState" -sev Info
        } else {
            Write-StandardsAlert -message "The Anti-Spam Connection Filter Safe List is not set correctly to $WantedState" -object @{CurrentState = $CurrentState; WantedState = $WantedState } -tenant $Tenant -standardName 'AntiSpamSafeList' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The Anti-Spam Connection Filter Safe List is not set correctly to $WantedState" -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAntiSpamSafeList.ps1' 92
#Region './Public/Standards/Invoke-CIPPStandardAppDeploy.ps1' -1

function Invoke-CIPPStandardAppDeploy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AppDeploy
    .SYNOPSIS
        (Label) Deploy Application
    .DESCRIPTION
        (Helptext) Deploys selected applications to the tenant. Use a comma separated list of application IDs to deploy multiple applications. Permissions will be copied from the source application.
        (DocsDescription) Uses the CIPP functionality that deploys applications across an entire tenant base as a standard.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Automatically deploys approved business applications across all company locations and users, ensuring consistent access to essential tools and maintaining standardized software configurations. This streamlines application management and reduces IT deployment overhead.
        ADDEDCOMPONENT
            {"type":"select","multiple":false,"creatable":false,"label":"App Approval Mode","name":"standards.AppDeploy.mode","options":[{"label":"Template","value":"template"},{"label":"Copy Permissions","value":"copy"}]}
            {"type":"autoComplete","multiple":true,"creatable":false,"label":"Select Applications","name":"standards.AppDeploy.templateIds","api":{"url":"/api/ListAppApprovalTemplates","labelField":"TemplateName","valueField":"TemplateId","queryKey":"StdAppApprovalTemplateList","addedField":{"AppId":"AppId"}},"condition":{"field":"standards.AppDeploy.mode","compareType":"is","compareValue":"template"}}
            {"type":"textField","name":"standards.AppDeploy.appids","label":"Application IDs, comma separated","condition":{"field":"standards.AppDeploy.mode","compareType":"isNot","compareValue":"template"}}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-07
        POWERSHELLEQUIVALENT
            Portal or Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    Write-Information "Running AppDeploy standard for tenant $($Tenant)."

    $AppsToAdd = $Settings.appids -split ','
    $AppExists = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/servicePrincipals?$top=999' -tenantid $Tenant
    $Mode = $Settings.mode ?? 'copy'

    if ($Mode -eq 'template') {
        # For template mode, we need to check each template individually
        # since Gallery Templates and Enterprise Apps have different deployment methods
        $AppsToAdd = @()
        $Table = Get-CIPPTable -TableName 'templates'

        $AppsToAdd = foreach ($TemplateId in $Settings.templateIds.value) {
            $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$TemplateId'"
            if ($Template) {
                $TemplateData = $Template.JSON | ConvertFrom-Json
                # Default to EnterpriseApp for backward compatibility with older templates
                $AppType = $TemplateData.AppType
                if (-not $AppType) {
                    $AppType = 'EnterpriseApp'
                }

                # Return different identifiers based on app type for checking
                if ($AppType -eq 'ApplicationManifest') {
                    # For Application Manifests, use display name for checking
                    $TemplateData.AppName
                } elseif ($AppType -eq 'GalleryTemplate') {
                    # For Gallery Templates, use gallery template ID
                    $TemplateData.GalleryTemplateId
                } else {
                    # For Enterprise Apps, use app ID
                    $TemplateData.AppId
                }
            }
        }
    }

    # Check for missing apps based on template type
    $MissingApps = [System.Collections.Generic.List[string]]::new()
    if ($Mode -eq 'template') {
        $Table = Get-CIPPTable -TableName 'templates'
        foreach ($TemplateId in $Settings.templateIds.value) {
            $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$TemplateId'"
            if ($Template) {
                $TemplateData = $Template.JSON | ConvertFrom-Json
                $AppType = $TemplateData.AppType ?? 'EnterpriseApp'

                $IsAppMissing = $false
                if ($AppType -eq 'ApplicationManifest') {
                    # For Application Manifests, check by display name
                    $IsAppMissing = $TemplateData.AppName -notin $AppExists.displayName
                } elseif ($AppType -eq 'GalleryTemplate') {
                    # For Gallery Templates, check by application template ID
                    $IsAppMissing = $TemplateData.GalleryTemplateId -notin $AppExists.applicationTemplateId
                } else {
                    # For Enterprise Apps, check by app ID
                    $IsAppMissing = $TemplateData.AppId -notin $AppExists.appId
                }

                if ($IsAppMissing) {
                    $MissingApps.Add($TemplateData.AppName ?? $TemplateData.AppId ?? $TemplateData.GalleryTemplateId)
                }
            }
        }
    } else {
        # For copy mode, check by app ID as before
        $MissingApps = foreach ($App in $AppsToAdd) {
            if ($App -notin $AppExists.appId -and $App -notin $AppExists.applicationTemplateId) {
                $App
            }
        }
    }
    if ($Settings.remediate -eq $true) {
        if ($Mode -eq 'copy') {
            foreach ($App in $AppsToAdd) {
                $App = $App.Trim()
                if (!$App) {
                    continue
                }
                $Application = $AppExists | Where-Object -Property appId -EQ $App
                try {
                    New-CIPPApplicationCopy -App $App -Tenant $Tenant
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Added application $($Application.displayName) ($App) to $Tenant and updated it's permissions" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to add app $($Application.displayName) ($App). Error: $ErrorMessage" -sev Error
                }
            }
        } elseif ($Mode -eq 'template') {
            $TemplateIds = $Settings.templateIds.value

            # Get template data to determine deployment type for each template
            $Table = Get-CIPPTable -TableName 'templates'

            foreach ($TemplateId in $TemplateIds) {
                try {
                    # Get the template data to determine if it's a Gallery Template or Enterprise App
                    $Template = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AppApprovalTemplate' and RowKey eq '$TemplateId'"

                    if (!$Template) {
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Template $TemplateId not found" -sev Error
                        continue
                    }

                    $TemplateData = $Template.JSON | ConvertFrom-Json
                    # Default to EnterpriseApp for backward compatibility with older templates
                    $AppType = $TemplateData.AppType
                    if (-not $AppType) {
                        $AppType = 'EnterpriseApp'
                    }

                    if ($AppType -eq 'GalleryTemplate') {
                        # Handle Gallery Template deployment
                        Write-Information "Deploying Gallery Template $($TemplateData.AppName) to tenant $Tenant."

                        $GalleryTemplateId = $TemplateData.GalleryTemplateId
                        if (!$GalleryTemplateId) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Gallery Template ID not found in template data for $($TemplateData.TemplateName)" -sev Error
                            continue
                        }

                        # Check if the app already exists in the tenant
                        if ($TemplateData.GalleryTemplateId -in $AppExists.applicationTemplateId) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Gallery Template app $($TemplateData.AppName) already exists in tenant $Tenant" -sev Info
                            continue
                        }

                        # Instantiate the gallery template
                        $InstantiateBody = @{
                            displayName = $TemplateData.AppName
                        } | ConvertTo-Json -Depth 10

                        $InstantiateResult = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/applicationTemplates/$GalleryTemplateId/instantiate" -type POST -tenantid $Tenant -body $InstantiateBody

                        if ($InstantiateResult.application.appId) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully deployed Gallery Template $($TemplateData.AppName) to tenant $Tenant. Application ID: $($InstantiateResult.application.appId)" -sev Info
                            New-CIPPApplicationCopy -App $InstantiateResult.application.appId -Tenant $Tenant
                        } else {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Gallery Template deployment completed but application ID not returned for $($TemplateData.AppName) in tenant $Tenant" -sev Warning
                        }

                    } elseif ($AppType -eq 'ApplicationManifest') {
                        # Handle Application Manifest deployment
                        Write-Information "Deploying Application Manifest $($TemplateData.AppName) to tenant $Tenant."

                        $ApplicationManifest = $TemplateData.ApplicationManifest
                        if (!$ApplicationManifest) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Application Manifest not found in template data for $($TemplateData.TemplateName)" -sev Error
                            continue
                        }

                        # Check if an application with the same display name already exists
                        $ExistingApp = $AppExists | Where-Object { $_.displayName -eq $TemplateData.AppName }
                        if ($ExistingApp) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Application with name '$($TemplateData.AppName)' already exists in tenant $Tenant" -sev Info

                            # get existing application
                            $App = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/applications(appId='$($ExistingApp.appId)')" -tenantid $Tenant

                            # compare permissions
                            $ExistingPermissions = $App.requiredResourceAccess | ConvertTo-Json -Depth 10
                            $NewPermissions = $ApplicationManifest.requiredResourceAccess | ConvertTo-Json -Depth 10
                            if ($ExistingPermissions -ne $NewPermissions) {
                                Write-LogMessage -API 'Standards' -tenant $tenant -message "Updating permissions for existing application '$($TemplateData.AppName)' in tenant $Tenant" -sev Info

                                # Update permissions for existing application
                                $UpdateBody = @{
                                    requiredResourceAccess = $ApplicationManifest.requiredResourceAccess
                                } | ConvertTo-Json -Depth 10
                                $null = New-GraphPostRequest -type PATCH -uri "https://graph.microsoft.com/beta/applications(appId='$($ExistingApp.appId)')" -tenantid $Tenant -body $UpdateBody

                                # consent new permissions
                                Add-CIPPDelegatedPermission -RequiredResourceAccess $ApplicationManifest.requiredResourceAccess -ApplicationId $ExistingApp.appId -Tenantfilter $Tenant
                                Add-CIPPApplicationPermission -RequiredResourceAccess $ApplicationManifest.requiredResourceAccess -ApplicationId $ExistingApp.appId -Tenantfilter $Tenant
                            }

                            continue
                        }

                        $PropertiesToRemove = @('appId', 'id', 'createdDateTime', 'publisherDomain', 'servicePrincipalLockConfiguration', 'identifierUris', 'applicationIdUris')

                        # Strip tenant-specific data that might cause conflicts
                        $CleanManifest = $ApplicationManifest | ConvertTo-Json -Depth 10 | ConvertFrom-Json
                        foreach ($Property in $PropertiesToRemove) {
                            $CleanManifest.PSObject.Properties.Remove($Property)
                        }
                        # Create the application from manifest
                        try {
                            $CreateBody = $CleanManifest | ConvertTo-Json -Depth 10
                            $CreatedApp = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/applications' -type POST -tenantid $Tenant -body $CreateBody

                            if ($CreatedApp.appId) {
                                # Create service principal for the application
                                $ServicePrincipalBody = @{
                                    appId = $CreatedApp.appId
                                } | ConvertTo-Json

                                $ServicePrincipal = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/servicePrincipals' -type POST -tenantid $Tenant -body $ServicePrincipalBody

                                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully deployed Application Manifest $($TemplateData.AppName) to tenant $Tenant. Application ID: $($CreatedApp.appId)" -sev Info

                                if ($CreatedApp.requiredResourceAccess) {
                                    Add-CIPPDelegatedPermission -RequiredResourceAccess $CreatedApp.requiredResourceAccess -ApplicationId $CreatedApp.appId -Tenantfilter $Tenant
                                    Add-CIPPApplicationPermission -RequiredResourceAccess $CreatedApp.requiredResourceAccess -ApplicationId $CreatedApp.appId -Tenantfilter $Tenant
                                }
                            } else {
                                Write-LogMessage -API 'Standards' -tenant $tenant -message "Application Manifest deployment failed - no application ID returned for $($TemplateData.AppName) in tenant $Tenant" -sev Error
                            }
                        } catch {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Error creating application from manifest in tenant $Tenant - $($_.Exception.Message)" -sev Error
                        }

                    } else {
                        # Handle Enterprise App deployment (existing logic)
                        $AppId = $TemplateData.AppId
                        if ($AppId -notin $AppExists.appId) {
                            Write-Information "Adding $AppId to tenant $Tenant."
                            $PostResults = New-GraphPostRequest 'https://graph.microsoft.com/beta/servicePrincipals' -type POST -tenantid $Tenant -body "{ `"appId`": `"$AppId`" }"
                            Write-LogMessage -message "Added $AppId to tenant $Tenant" -tenant $Tenant -API 'Standards' -sev Info
                        }

                        # Apply permissions for Enterprise Apps
                        Add-CIPPApplicationPermission -TemplateId $TemplateId -TenantFilter $Tenant
                        Add-CIPPDelegatedPermission -TemplateId $TemplateId -TenantFilter $Tenant
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Added application $($TemplateData.AppName) from Enterprise App template and updated its permissions" -sev Info
                    }

                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to deploy template $TemplateId. Error: $ErrorMessage" -sev Error
                }
            }
        }
    }

    if ($Settings.alert) {
        if ($MissingApps.Count -gt 0) {
            Write-StandardsAlert -message "The following applications are not deployed: $($MissingApps -join ', ')" -object (@{ 'Missing Apps' = $MissingApps -join ',' }) -tenant $Tenant -standardName 'AppDeploy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The following applications are not deployed: $($MissingApps -join ', ')" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'All applications are deployed' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $StateIsCorrect = $MissingApps.Count -eq 0 ? $true : @{ 'Missing Apps' = $MissingApps -join ',' }
        Set-CIPPStandardsCompareField -FieldName 'standards.AppDeploy' -FieldValue $StateIsCorrect -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'AppDeploy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardAppDeploy.ps1' 287
#Region './Public/Standards/Invoke-CIPPStandardAssignmentFilterTemplate.ps1' -1

function Invoke-CIPPStandardAssignmentFilterTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AssignmentFilterTemplate
    .SYNOPSIS
        (Label) Assignment Filter Template
    .DESCRIPTION
        (Helptext) Deploy and manage assignment filter templates.
        (DocsDescription) Deploy and manage assignment filter templates.
    .NOTES
        MULTI
            True
        CAT
            Templates
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-10-04
        EXECUTIVETEXT
            Creates standardized assignment filters with predefined settings. These templates ensure consistent assignment filter configurations across the organization, streamlining assignment management.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"assignmentFilterTemplate","label":"Select Assignment Filter Template","api":{"url":"/api/ListAssignmentFilterTemplates","labelField":"Displayname","altLabelField":"displayName","valueField":"GUID","queryKey":"ListAssignmentFilterTemplates"}}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)

    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AssignmentFilterTemplate'
    $existingFilters = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/assignmentFilters' -tenantid $tenant

    $Settings.assignmentFilterTemplate ? ($Settings | Add-Member -NotePropertyName 'TemplateList' -NotePropertyValue $Settings.assignmentFilterTemplate) : $null

    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'AssignmentFilterTemplate' and (RowKey eq '$($Settings.TemplateList.value -join "' or RowKey eq '")')"
    $AssignmentFilterTemplates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json

    if ($Settings.remediate -eq $true) {
        Write-Host "Settings: $($Settings.TemplateList | ConvertTo-Json)"
        foreach ($Template in $AssignmentFilterTemplates) {
            Write-Information "Processing template: $($Template.displayName)"
            try {
                $filterobj = $Template

                # Check if filter already exists
                $CheckExisting = $existingFilters | Where-Object -Property displayName -EQ $filterobj.displayName

                if (!$CheckExisting) {
                    Write-Information 'Creating assignment filter'
                    $ActionType = 'create'

                    # Use the centralized New-CIPPAssignmentFilter function
                    $Result = New-CIPPAssignmentFilter -FilterObject $filterobj -TenantFilter $tenant -APIName 'Standards' -ExecutingUser 'CIPP-Standards'

                    if (!$Result.Success) {
                        Write-Information "Failed to create assignment filter $($filterobj.displayName): $($Result.Message)"
                        continue
                    }
                } else {
                    $ActionType = 'update'

                    # Compare existing filter with template to determine what needs updating
                    $PatchBody = [PSCustomObject]@{}
                    $ChangesNeeded = [System.Collections.Generic.List[string]]::new()

                    # Check description
                    if ($CheckExisting.description -ne $filterobj.description) {
                        $PatchBody | Add-Member -NotePropertyName 'description' -NotePropertyValue $filterobj.description
                        $ChangesNeeded.Add("description: '$($CheckExisting.description)'  '$($filterobj.description)'")
                    }

                    # Check platform
                    if ($CheckExisting.platform -ne $filterobj.platform) {
                        $PatchBody | Add-Member -NotePropertyName 'platform' -NotePropertyValue $filterobj.platform
                        $ChangesNeeded.Add("platform: '$($CheckExisting.platform)'  '$($filterobj.platform)'")
                    }

                    # Check rule
                    if ($CheckExisting.rule -ne $filterobj.rule) {
                        $PatchBody | Add-Member -NotePropertyName 'rule' -NotePropertyValue $filterobj.rule
                        $ChangesNeeded.Add("rule: '$($CheckExisting.rule)'  '$($filterobj.rule)'")
                    }

                    # Check assignmentFilterManagementType
                    if ($CheckExisting.assignmentFilterManagementType -ne $filterobj.assignmentFilterManagementType) {
                        $PatchBody | Add-Member -NotePropertyName 'assignmentFilterManagementType' -NotePropertyValue $filterobj.assignmentFilterManagementType
                        $ChangesNeeded.Add("assignmentFilterManagementType: '$($CheckExisting.assignmentFilterManagementType)'  '$($filterobj.assignmentFilterManagementType)'")
                    }

                    # Only patch if there are actual changes
                    if ($ChangesNeeded.Count -gt 0) {
                        $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/deviceManagement/assignmentFilters/$($CheckExisting.id)" -tenantid $tenant -type PATCH -body (ConvertTo-Json -InputObject $PatchBody -Depth 10)
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Updated Assignment Filter '$($filterobj.displayName)' - Changes: $($ChangesNeeded -join ', ')" -Sev Info
                    } else {
                        Write-Information "Assignment Filter '$($filterobj.displayName)' already matches template - no update needed"
                    }
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to $ActionType assignment filter $($filterobj.displayName). Error: $ErrorMessage" -sev 'Error'
            }
        }
    }
    if ($Settings.report -eq $true) {
        # Check if all filters.displayName are in the existingFilters, if not $fieldvalue should contain all missing filters, else it should be true.
        $MissingFilters = foreach ($Filter in $AssignmentFilterTemplates) {
            $CheckExisting = $existingFilters | Where-Object { $_.displayName -eq $Filter.displayName }
            if (!$CheckExisting) {
                $Filter.displayName
            }
        }

        if ($MissingFilters.Count -eq 0) {
            $fieldValue = $true
        } else {
            $fieldValue = $MissingFilters -join ', '
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.AssignmentFilterTemplate' -FieldValue $fieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAssignmentFilterTemplate.ps1' 127
#Region './Public/Standards/Invoke-CIPPStandardAtpPolicyForO365.ps1' -1

function Invoke-CIPPStandardAtpPolicyForO365 {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AtpPolicyForO365
    .SYNOPSIS
        (Label) Default Atp Policy For O365
    .DESCRIPTION
        (Helptext) This creates a Atp policy that enables Defender for Office 365 for SharePoint, OneDrive and Microsoft Teams.
        (DocsDescription) This creates a Atp policy that enables Defender for Office 365 for SharePoint, OneDrive and Microsoft Teams.
    .NOTES
        CAT
            Defender Standards
        TAG
            "CIS M365 5.0 (2.1.5)"
            "NIST CSF 2.0 (DE.CM-09)"
        ADDEDCOMPONENT
            {"type":"switch","label":"Allow people to click through Protected View even if Safe Documents identified the file as malicious","name":"standards.AtpPolicyForO365.AllowSafeDocsOpen","defaultValue":false,"required":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-25
        POWERSHELLEQUIVALENT
            Set-AtpPolicyForO365
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AtpPolicyForO365' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU', 'ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AtpPolicyForO365'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AtpPolicyForO365' |
            Select-Object EnableATPForSPOTeamsODB, EnableSafeDocs, AllowSafeDocsOpen
    } catch {
        $CurrentState = @{
            License = 'This tenant might not be licensed for this feature'
        }
    }
    $StateIsCorrect = ($CurrentState.EnableATPForSPOTeamsODB -eq $true) -and
    ($CurrentState.EnableSafeDocs -eq $true) -and
    ($CurrentState.AllowSafeDocsOpen -eq $Settings.AllowSafeDocsOpen)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Atp Policy For O365 already set.' -sev Info
        } else {
            $cmdParams = @{
                EnableATPForSPOTeamsODB = $true
                EnableSafeDocs          = $true
                AllowSafeDocsOpen       = $Settings.AllowSafeDocsOpen
            }

            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-AtpPolicyForO365' -cmdParams $cmdParams -UseSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Atp Policy For O365' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Atp Policy For O365. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Atp Policy For O365 is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Atp Policy For O365 is not enabled' -object $CurrentState -tenant $Tenant -standardName 'AtpPolicyForO365' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Atp Policy For O365 is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect -eq $true ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.AtpPolicyForO365' -FieldValue $state -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'AtpPolicyForO365' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardAtpPolicyForO365.ps1' 91
#Region './Public/Standards/Invoke-CIPPStandardAuditLog.ps1' -1

function Invoke-CIPPStandardAuditLog {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AuditLog
    .SYNOPSIS
        (Label) Enable the Unified Audit Log
    .DESCRIPTION
        (Helptext) Enables the Unified Audit Log for tracking and auditing activities. Also runs Enable-OrganizationCustomization if necessary.
        (DocsDescription) Enables the Unified Audit Log for tracking and auditing activities. Also runs Enable-OrganizationCustomization if necessary.
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (3.1.1)"
            "mip_search_auditlog"
            "NIST CSF 2.0 (DE.CM-09)"
        EXECUTIVETEXT
            Activates comprehensive activity logging across Microsoft 365 services to track user actions, system changes, and security events. This provides essential audit trails for compliance requirements, security investigations, and regulatory reporting.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Enable-OrganizationCustomization
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AuditLog' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AuditLog'

    Write-Host ($Settings | ConvertTo-Json)
    $AuditLogEnabled = [bool](New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AdminAuditLogConfig' -Select UnifiedAuditLogIngestionEnabled).UnifiedAuditLogIngestionEnabled

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        $DehydratedTenant = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig' -Select IsDehydrated).IsDehydrated
        if ($DehydratedTenant -eq $true) {
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Enable-OrganizationCustomization'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Organization customization enabled.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable organization customization. Error: $ErrorMessage" -sev Debug
            }
        }

        try {
            if ($AuditLogEnabled -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Unified Audit Log already enabled.' -sev Info
            } else {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-AdminAuditLogConfig' -cmdParams @{UnifiedAuditLogIngestionEnabled = $true }
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Unified Audit Log Enabled.' -sev Info
            }

        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to apply Unified Audit Log. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }
    if ($Settings.alert -eq $true) {

        if ($AuditLogEnabled -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Unified Audit Log is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Unified Audit Log is not enabled' -object @{AuditLogEnabled = $AuditLogEnabled } -tenant $Tenant -standardName 'AuditLog' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Unified Audit Log is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $AuditLogEnabled -eq $true ? $true : $AuditLogEnabled
        Set-CIPPStandardsCompareField -FieldName 'standards.AuditLog' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AuditLog' -FieldValue $AuditLogEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAuditLog.ps1' 92
#Region './Public/Standards/Invoke-CIPPStandardAuthMethodsPolicyMigration.ps1' -1

function Invoke-CIPPStandardAuthMethodsPolicyMigration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AuthMethodsPolicyMigration
    .SYNOPSIS
        (Label) Complete Authentication Methods Policy Migration
    .DESCRIPTION
        (Helptext) Completes the migration of authentication methods policy to the new format
        (DocsDescription) Sets the authentication methods policy migration state to complete. This is required when migrating from legacy authentication policies to the new unified authentication methods policy.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Completes the transition from legacy authentication policies to Microsoft's modern unified authentication methods policy, ensuring the organization benefits from the latest security features and management capabilities. This migration enables enhanced security controls and simplified policy management.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-07-07
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicy
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    try {
        $CurrentInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the AuthMethodsPolicyMigration state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    if ($null -eq $CurrentInfo) {
        throw 'Failed to retrieve current authentication methods policy information'
    }

    if ($Settings.remediate -eq $true) {
        if ($CurrentInfo.policyMigrationState -eq 'migrationComplete' -or $null -eq $CurrentInfo.policyMigrationState) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Authentication methods policy migration is already complete.' -sev Info
        } else {
            try {
                New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy' -tenantid $Tenant -body '{"policyMigrationState": "migrationComplete"}' -type PATCH
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Authentication methods policy migration completed successfully.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to complete authentication methods policy migration: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.policyMigrationState -ne 'migrationComplete' -and $null -ne $CurrentInfo.policyMigrationState) {
            Write-StandardsAlert -message 'Authentication methods policy migration is not complete. Please check if you have legacy SSPR settings or MFA settings set: https://learn.microsoft.com/en-us/entra/identity/authentication/how-to-authentication-methods-manage' -object $CurrentInfo -tenant $tenant -standardName 'AuthMethodsPolicyMigration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Authentication methods policy migration is not complete' -sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        $migrationComplete = $CurrentInfo.policyMigrationState -eq 'migrationComplete' -or $null -eq $CurrentInfo.policyMigrationState
        Set-CIPPStandardsCompareField -FieldName 'standards.AuthMethodsPolicyMigration' -FieldValue $migrationComplete -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'AuthMethodsPolicyMigration' -FieldValue $migrationComplete -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardAuthMethodsPolicyMigration.ps1' 74
#Region './Public/Standards/Invoke-CIPPStandardAuthMethodsSettings.ps1' -1

function Invoke-CIPPStandardAuthMethodsSettings {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AuthMethodsSettings
    .SYNOPSIS
        (Label) Configure Authentication Methods Policy Settings
    .DESCRIPTION
        (Helptext) Configures the report suspicious activity settings and system credential preferences in the authentication methods policy.
        (DocsDescription) Controls the authentication methods policy settings for reporting suspicious activity and system credential preferences. These settings help enhance the security of authentication in your organization.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "EIDSCA.AG01"
            "EIDSCA.AG02"
            "EIDSCA.AG03"
        EXECUTIVETEXT
            Configures security settings that allow users to report suspicious login attempts and manages how the system handles authentication credentials. This enhances overall security by enabling early detection of potential security threats and optimizing authentication processes.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"required":false,"name":"standards.AuthMethodsSettings.ReportSuspiciousActivity","label":"Report Suspicious Activity Settings","options":[{"label":"Microsoft managed","value":"default"},{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
            {"type":"autoComplete","multiple":false,"creatable":false,"required":false,"name":"standards.AuthMethodsSettings.SystemCredential","label":"System Credential Preferences","options":[{"label":"Microsoft managed","value":"default"},{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-02-10
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    Write-Host 'Time to run'
    # Get current authentication methods policy
    try {
        $CurrentPolicy = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy' -tenantid $Tenant -AsApp $true
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'Failed to get authentication methods policy' -sev Error -LogData $ErrorMessage
        return
    }


    # Set wanted states
    $ReportSuspiciousActivityState = $Settings.ReportSuspiciousActivity.value ?? $Settings.ReportSuspiciousActivity
    $SystemCredentialState = $Settings.SystemCredential.value ?? $Settings.SystemCredential

    # Input validation
    $ValidStates = @('default', 'enabled', 'disabled')
    if (($Settings.remediate -eq $true -or $Settings.alert -eq $true) -and
        ($ReportSuspiciousActivityState -notin $ValidStates -or $SystemCredentialState -notin $ValidStates)) {
        Write-Host "ReportSuspiciousActivity: $($ReportSuspiciousActivityState)"
        Write-Host "SystemCredential: $($SystemCredentialState)"
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'AuthMethodsPolicy: Invalid state parameter set' -sev Error
        return
    }



    # Check if states are set correctly
    $ReportSuspiciousActivityCorrect = if ($CurrentPolicy.reportSuspiciousActivitySettings.state -eq $ReportSuspiciousActivityState) { $true } else { $false }
    $SystemCredentialCorrect = if ($CurrentPolicy.systemCredentialPreferences.state -eq $SystemCredentialState) { $true } else { $false }
    $StateSetCorrectly = $ReportSuspiciousActivityCorrect -and $SystemCredentialCorrect

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateSetCorrectly -eq $false) {
            try {
                $body = [PSCustomObject]@{
                    reportSuspiciousActivitySettings = $CurrentPolicy.reportSuspiciousActivitySettings
                    systemCredentialPreferences      = $CurrentPolicy.systemCredentialPreferences
                }
                $body.reportSuspiciousActivitySettings.state = $ReportSuspiciousActivityState
                $body.systemCredentialPreferences.state = $SystemCredentialState

                Write-Host "Body: $($body | ConvertTo-Json -Depth 10 -Compress)"
                # Update settings
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy' -AsApp $true -Type PATCH -Body ($body | ConvertTo-Json -Depth 10 -Compress) -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully configured authentication methods policy settings: Report Suspicious Activity ($ReportSuspiciousActivityState), System Credential Preferences ($SystemCredentialState)" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Failed to configure authentication methods policy settings' -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Authentication methods policy settings are already configured correctly' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateSetCorrectly ? $true :  @{CurrentReportState = $CurrentReportState; CurrentSystemState = $CurrentSystemState; WantedReportState = $ReportSuspiciousActivityState; WantedSystemState = $SystemCredentialState }
        Set-CIPPStandardsCompareField -FieldName 'standards.AuthMethodsSettings' -FieldValue $state -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'ReportSuspiciousActivity' -FieldValue $CurrentPolicy.reportSuspiciousActivitySettings.state -StoreAs string -Tenant $tenant
        Add-CIPPBPAField -FieldName 'SystemCredential' -FieldValue $CurrentPolicy.systemCredentialPreferences.state -StoreAs string -Tenant $tenant
    }

    if ($Settings.alert -eq $true) {
        if ($StateSetCorrectly -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Authentication methods policy settings are correctly configured: Report Suspicious Activity ($ReportSuspiciousActivityState), System Credential Preferences ($SystemCredentialState)" -sev Info
        } else {
            $CurrentReportState = $CurrentPolicy.reportSuspiciousActivitySettings.state
            $CurrentSystemState = $CurrentPolicy.systemCredentialPreferences.state
            Write-StandardsAlert -message 'Authentication methods policy settings are not configured correctly.' -object @{CurrentReportState = $CurrentReportState; CurrentSystemState = $CurrentSystemState; WantedReportState = $ReportSuspiciousActivityState; WantedSystemState = $SystemCredentialState } -tenant $tenant -standardName 'AuthMethodsSettings' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Authentication methods policy settings are not configured correctly. Current values: Report Suspicious Activity ($CurrentReportState), System Credential Preferences ($CurrentSystemState)" -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAuthMethodsSettings.ps1' 113
#Region './Public/Standards/Invoke-CIPPStandardAutoAddProxy.ps1' -1

function Invoke-CIPPStandardAutoAddProxy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AutoAddProxy
    .SYNOPSIS
        (Label) Automatically deploy proxy addresses
    .DESCRIPTION
        (Helptext) Automatically adds all available domains as a proxy address.
        (DocsDescription) Automatically finds all available domain names in the tenant, and tries to add proxy addresses based on the user's UPN to each of these.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Automatically creates email addresses for employees across all company domains, ensuring they can receive emails sent to any of the organization's domain names. This improves email delivery reliability and maintains consistent communication channels across different business units or brands.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-02-07
        POWERSHELLEQUIVALENT
            Set-Mailbox -EmailAddresses @{add=\$EmailAddress}
        RECOMMENDEDBY
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param(
        $Tenant,
        $Settings,
        $QueueItem
    )

    try {
        $Domains = New-ExoRequest -TenantId $Tenant -Cmdlet 'Get-AcceptedDomain' | Select-Object -ExpandProperty DomainName
        $AllMailboxes = New-ExoRequest -TenantId $Tenant -Cmdlet 'Get-Mailbox'
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the AutoAddProxy state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    $MissingProxies = 0
    foreach ($Domain in $Domains) {
        $ProcessMailboxes = $AllMailboxes | Where-Object {
            $addresses = @($_.EmailAddresses) -replace '^[^:]+:'    # remove SPO:, SMTP:, etc.
            $hasDomain = $addresses | Where-Object { $_ -like "*@$Domain" }
            if ($hasDomain) { return $false } else { return $true }
        }
        $MissingProxies += $ProcessMailboxes.Count
    }

    $StateIsCorrect = $MissingProxies -eq 0

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $MissingProxies
        Set-CIPPStandardsCompareField -FieldName 'standards.AutoAddProxy' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AutoAddProxy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All mailboxes have proxy addresses for all domains' -sev Info
        } else {
            Write-StandardsAlert -message "There are $MissingProxies missing proxy addresses across all mailboxes" -object @{MissingProxies = $MissingProxies } -tenant $Tenant -standardName 'AutoAddProxy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "There are $MissingProxies missing proxy addresses across all mailboxes" -sev Info
        }
    }

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All mailboxes already have proxy addresses for all domains' -sev Info
        } else {
            foreach ($Domain in $Domains) {
                $ProcessMailboxes = $AllMailboxes | Where-Object {
                    $addresses = @($_.EmailAddresses) -replace '^[^:]+:'    # remove SPO:, SMTP:, etc.
                    $hasDomain = $addresses | Where-Object { $_ -like "*@$Domain" }
                    if ($hasDomain) { return $false } else { return $true }
                }

                $bulkRequest = foreach ($Mailbox in $ProcessMailboxes) {
                    $LocalPart = $Mailbox.UserPrincipalName -split '@' | Select-Object -First 1
                    $NewAlias = "$LocalPart@$Domain"
                    @{
                        CmdletInput = @{
                            CmdletName = 'Set-Mailbox'
                            Parameters = @{Identity = $Mailbox.Identity ; EmailAddresses = @{
                                    '@odata.type' = '#Exchange.GenericHashTable'
                                    Add           = "smtp:$NewAlias"
                                }
                            }
                        }
                    }
                }
                $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($bulkRequest)
                $BatchResults | ForEach-Object {
                    if ($_.error) {
                        $ErrorMessage = Get-CippException -Exception $_.error
                        Write-Host "Failed to apply new email policy to $($_.target) Error: $($ErrorMessage.NormalizedError)"
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to apply proxy address to $($_.error.target) Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                    }
                }
            }
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Added missing proxy addresses to mailboxes' -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAutoAddProxy.ps1' 113
#Region './Public/Standards/Invoke-CIPPStandardAutoExpandArchive.ps1' -1

function Invoke-CIPPStandardAutoExpandArchive {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AutoExpandArchive
    .SYNOPSIS
        (Label) Enable Auto-expanding archives
    .DESCRIPTION
        (Helptext) Enables auto-expanding archives for the tenant
        (DocsDescription) Enables auto-expanding archives for the tenant. Does not enable archives for users.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Enables automatic expansion of email archive storage when users approach their archive limits, ensuring continuous email retention without manual intervention. This prevents email storage issues and maintains compliance with data retention policies without requiring ongoing administrative management.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -AutoExpandingArchive
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AutoExpandArchive' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'AutoExpandArchive'

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').AutoExpandingArchiveEnabled
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the AutoExpandArchive state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentState) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Auto Expanding Archive is already enabled.' -sev Info
        } else {
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{AutoExpandingArchive = $true }
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Added Auto Expanding Archive.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to apply Auto Expanding Archives. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentState) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Auto Expanding Archives is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Auto Expanding Archives is not enabled' -object @{CurrentState = $CurrentState } -tenant $tenant -standardName 'AutoExpandArchive' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Auto Expanding Archives is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CurrentState -eq $true ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.AutoExpandArchive' -FieldValue $state -TenantFilter $tenant
        Add-CIPPBPAField -FieldName 'AutoExpandingArchive' -FieldValue $CurrentState -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAutoExpandArchive.ps1' 81
#Region './Public/Standards/Invoke-CIPPStandardAutopilotProfile.ps1' -1

function Invoke-CIPPStandardAutopilotProfile {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AutopilotProfile
    .SYNOPSIS
        (Label) Enable Autopilot Profile
    .DESCRIPTION
        (Helptext) Assign the appropriate Autopilot profile to streamline device deployment.
        (DocsDescription) This standard allows the deployment of Autopilot profiles to devices, including settings such as unique name templates, language options, and local admin privileges.
    .NOTES
        CAT
            Device Management Standards
        TAG
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.AutopilotProfile.DisplayName","label":"Profile Display Name"}
            {"type":"textField","name":"standards.AutopilotProfile.Description","label":"Profile Description"}
            {"type":"textField","name":"standards.AutopilotProfile.DeviceNameTemplate","label":"Unique Device Name Template","required":false}
            {"type":"autoComplete","multiple":false,"creatable":false,"required":false,"name":"standards.AutopilotProfile.Languages","label":"Languages","api":{"url":"/languageList.json","labelField":"languageTag","valueField":"tag"}}
            {"type":"switch","name":"standards.AutopilotProfile.CollectHash","label":"Convert all targeted devices to Autopilot","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.AssignToAllDevices","label":"Assign to all devices","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.SelfDeployingMode","label":"Enable Self-deploying Mode","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.HideTerms","label":"Hide Terms and Conditions","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.HidePrivacy","label":"Hide Privacy Settings","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.HideChangeAccount","label":"Hide Change Account Options","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.NotLocalAdmin","label":"Setup user as a standard user (not local admin)","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.AllowWhiteGlove","label":"Allow White Glove OOBE","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotProfile.AutoKeyboard","label":"Automatically configure keyboard","defaultValue":true}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-12-30
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AutopilotProfile' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    # Get the current configuration

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    try {
        $CurrentConfig = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/windowsAutopilotDeploymentProfiles' -tenantid $Tenant |
            Where-Object { $_.displayName -eq $Settings.DisplayName } |
            Select-Object -Property displayName, description, deviceNameTemplate, locale, preprovisioningAllowed, hardwareHashExtractionEnabled, outOfBoxExperienceSetting

        if ($Settings.NotLocalAdmin -eq $true) { $userType = 'Standard' } else { $userType = 'Administrator' }
        if ($Settings.SelfDeployingMode -eq $true) {
            $DeploymentMode = 'shared'
            $Settings.AllowWhiteGlove = $false
        } else {
            $DeploymentMode = 'singleUser'
        }

        $StateIsCorrect = ($CurrentConfig.displayName -eq $Settings.DisplayName) -and
        ($CurrentConfig.description -eq $Settings.Description) -and
        ($CurrentConfig.deviceNameTemplate -eq $Settings.DeviceNameTemplate) -and
        ([string]::IsNullOrWhiteSpace($CurrentConfig.locale) -and [string]::IsNullOrWhiteSpace($Settings.Languages.value) -or $CurrentConfig.locale -eq $Settings.Languages.value) -and
        ($CurrentConfig.preprovisioningAllowed -eq $Settings.AllowWhiteGlove) -and
        ($CurrentConfig.hardwareHashExtractionEnabled -eq $Settings.CollectHash) -and
        ($CurrentConfig.outOfBoxExperienceSetting.deviceUsageType -eq $DeploymentMode) -and
        ($CurrentConfig.outOfBoxExperienceSetting.privacySettingsHidden -eq $Settings.HidePrivacy) -and
        ($CurrentConfig.outOfBoxExperienceSetting.eulaHidden -eq $Settings.HideTerms) -and
        ($CurrentConfig.outOfBoxExperienceSetting.userType -eq $userType) -and
        ($CurrentConfig.outOfBoxExperienceSetting.keyboardSelectionPageSkipped -eq $Settings.AutoKeyboard)
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to check Autopilot profile: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        $StateIsCorrect = $false
    }

    # Remediate if the state is not correct
    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Autopilot profile '$($Settings.DisplayName)' already exists" -sev Info
        } else {
            try {
                $Parameters = @{
                    tenantFilter       = $Tenant
                    displayName        = $Settings.DisplayName
                    description        = $Settings.Description
                    userType           = $userType
                    DeploymentMode     = $DeploymentMode
                    AssignTo           = $Settings.AssignToAllDevices
                    devicenameTemplate = $Settings.DeviceNameTemplate
                    allowWhiteGlove    = $Settings.AllowWhiteGlove
                    CollectHash        = $Settings.CollectHash
                    hideChangeAccount  = $true
                    hidePrivacy        = $Settings.HidePrivacy
                    hideTerms          = $Settings.HideTerms
                    AutoKeyboard       = $Settings.AutoKeyboard
                    Language           = $Settings.Languages.value
                }

                Set-CIPPDefaultAPDeploymentProfile @Parameters
                if ($null -eq $CurrentConfig) {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Autopilot profile '$($Settings.DisplayName)'" -sev Info
                } else {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Autopilot profile '$($Settings.DisplayName)'" -sev Info
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Autopilot profile: $($ErrorMessage.NormalizedError)" -sev 'Error' -LogData $ErrorMessage
                throw $ErrorMessage
            }
        }
    }

    # Report
    if ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect -eq $true ? $true : $CurrentConfig
        Set-CIPPStandardsCompareField -FieldName 'standards.AutopilotProfile' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AutopilotProfile' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }

    # Alert
    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Autopilot profile '$($Settings.DisplayName)' exists" -sev Info
        } else {
            Write-StandardsAlert -message "Autopilot profile '$($Settings.DisplayName)' do not match expected configuration" -object $CurrentConfig -tenant $Tenant -standardName 'AutopilotProfile' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Autopilot profile '$($Settings.DisplayName)' do not match expected configuration" -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAutopilotProfile.ps1' 135
#Region './Public/Standards/Invoke-CIPPStandardAutopilotStatusPage.ps1' -1

function Invoke-CIPPStandardAutopilotStatusPage {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) AutopilotStatusPage
    .SYNOPSIS
        (Label) Enable Autopilot Status Page
    .DESCRIPTION
        (Helptext) Deploy the Autopilot Status Page, which shows progress during device setup through Autopilot.
        (DocsDescription) This standard allows configuration of the Autopilot Status Page, providing users with a visual representation of the progress during device setup. It includes options like timeout, logging, and retry settings.
    .NOTES
        CAT
            Device Management Standards
        TAG
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        EXECUTIVETEXT
            Provides employees with a visual progress indicator during automated device setup, improving the user experience when receiving new computers. This reduces IT support calls and helps ensure successful device deployment by guiding users through the setup process.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.AutopilotStatusPage.TimeOutInMinutes","label":"Timeout in minutes","defaultValue":60}
            {"type":"textField","name":"standards.AutopilotStatusPage.ErrorMessage","label":"Custom Error Message","required":false}
            {"type":"switch","name":"standards.AutopilotStatusPage.ShowProgress","label":"Show progress to users","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.EnableLog","label":"Turn on log collection","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.OBEEOnly","label":"Show status page only with OOBE setup","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.InstallWindowsUpdates","label":"Install Windows Updates during setup","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.BlockDevice","label":"Block device usage during setup","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.AllowReset","label":"Allow reset","defaultValue":true}
            {"type":"switch","name":"standards.AutopilotStatusPage.AllowFail","label":"Allow users to use device if setup fails","defaultValue":true}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-12-30
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'AutopilotStatusPage' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    # Get current Autopilot enrollment status page configuration

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    try {
        $CurrentConfig = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations?`$expand=assignments&orderBy=priority&`$filter=deviceEnrollmentConfigurationType eq 'windows10EnrollmentCompletionPageConfiguration' and priority eq 0" -tenantid $Tenant |
            Select-Object -Property id, displayName, priority, showInstallationProgress, blockDeviceSetupRetryByUser, allowDeviceResetOnInstallFailure, allowLogCollectionOnInstallFailure, customErrorMessage, installProgressTimeoutInMinutes, allowDeviceUseOnInstallFailure, trackInstallProgressForAutopilotOnly, installQualityUpdates

        # Compatibility for standards made in v8.3.0 or before, which did not have the InstallWindowsUpdates setting
        $InstallWindowsUpdates = $Settings.InstallWindowsUpdates ?? $false

        $StateIsCorrect = ($CurrentConfig.installProgressTimeoutInMinutes -eq $Settings.TimeOutInMinutes) -and
        ($CurrentConfig.customErrorMessage -eq $Settings.ErrorMessage) -and
        ($CurrentConfig.showInstallationProgress -eq $Settings.ShowProgress) -and
        ($CurrentConfig.allowLogCollectionOnInstallFailure -eq $Settings.EnableLog) -and
        ($CurrentConfig.trackInstallProgressForAutopilotOnly -eq $Settings.OBEEOnly) -and
        ($CurrentConfig.blockDeviceSetupRetryByUser -eq !$Settings.BlockDevice) -and
        ($CurrentConfig.installQualityUpdates -eq $InstallWindowsUpdates) -and
        ($CurrentConfig.allowDeviceResetOnInstallFailure -eq $Settings.AllowReset) -and
        ($CurrentConfig.allowDeviceUseOnInstallFailure -eq $Settings.AllowFail)
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to check Autopilot Enrollment Status Page: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        $StateIsCorrect = $false
    }

    # Remediate if the state is not correct
    if ($Settings.remediate -eq $true) {
        try {
            $Parameters = @{
                TenantFilter          = $Tenant
                ShowProgress          = $Settings.ShowProgress
                BlockDevice           = $Settings.BlockDevice
                InstallWindowsUpdates = $InstallWindowsUpdates
                AllowReset            = $Settings.AllowReset
                EnableLog             = $Settings.EnableLog
                ErrorMessage          = $Settings.ErrorMessage
                TimeOutInMinutes      = $Settings.TimeOutInMinutes
                AllowFail             = $Settings.AllowFail
                OBEEOnly              = $Settings.OBEEOnly
            }

            Set-CIPPDefaultAPEnrollment @Parameters
        } catch {
        }
    }

    # Report
    if ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect -eq $true ? $true : $CurrentConfig
        Set-CIPPStandardsCompareField -FieldName 'standards.AutopilotStatusPage' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AutopilotStatusPage' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }

    # Alert
    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Autopilot Enrollment Status Page is configured correctly' -sev Info
        } else {
            Write-StandardsAlert -message 'Autopilot Enrollment Status Page settings do not match expected configuration' -object $CurrentConfig -tenant $Tenant -standardName 'AutopilotStatusPage' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Autopilot Enrollment Status Page settings do not match expected configuration' -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAutopilotStatusPage.ps1' 109
#Region './Public/Standards/Invoke-CIPPStandardAzurePortal.ps1' -1

function Invoke-CIPPStandardAzurePortal {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    
    # This standard is deprecated and no longer functional
    return $true
}
#EndRegion './Public/Standards/Invoke-CIPPStandardAzurePortal.ps1' 11
#Region './Public/Standards/Invoke-CIPPStandardBitLockerKeysForOwnedDevice.ps1' -1

function Invoke-CIPPStandardBitLockerKeysForOwnedDevice {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) BitLockerKeysForOwnedDevice
    .SYNOPSIS
        (Label) Restrict users from recovering BitLocker keys for owned devices
    .DESCRIPTION
    (Helptext) Controls whether standard users can recover BitLocker keys for devices they own via Microsoft 365 portals.
    (DocsDescription) Updates the default user role setting that governs access to BitLocker recovery keys for owned devices. This allows administrators to either permit self-service recovery or require helpdesk involvement through Microsoft Entra authorization policies.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Ensures administrators retain control over BitLocker recovery secrets when required, while still allowing flexibility to enable self-service recovery when business needs demand it.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select state","name":"standards.BitLockerKeysForOwnedDevice.state","options":[{"label":"Restrict","value":"restrict"},{"label":"Allow","value":"allow"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-10-12
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthorizationPolicy
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'BitLockerKeysForOwnedDevice'

    $StateValue = $Settings.state.value ?? $Settings.state
    if ([string]::IsNullOrWhiteSpace($StateValue)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'BitLockerKeysForOwnedDevice: Invalid state parameter set.' -sev Error
        return
    }

    switch ($StateValue.ToLowerInvariant()) {
        'restrict' { $DesiredValue = $false; $DesiredLabel = 'restricted'; break }
        'allow' { $DesiredValue = $true; $DesiredLabel = 'allowed'; break }
        default {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "BitLockerKeysForOwnedDevice: Unsupported state value '$StateValue'." -sev Error
            return
        }
    }

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the BitLockerKeysForOwnedDevice state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }
    $CurrentValue = [bool]$CurrentState.defaultUserRolePermissions.allowedToReadBitLockerKeysForOwnedDevice
    $StateIsCorrect = ($CurrentValue -eq $DesiredValue)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Users are already $DesiredLabel from recovering BitLocker keys for their owned devices." -sev Info
        } else {
            try {
                $BodyObject = @{ defaultUserRolePermissions = @{ allowedToReadBitLockerKeysForOwnedDevice = $DesiredValue } }
                $BodyJson = $BodyObject | ConvertTo-Json -Depth 4 -Compress
                $null = New-GraphPOSTRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -Type patch -Body $BodyJson
                $ActionMessage = if ($DesiredValue) { 'Allowed users to recover BitLocker keys for their owned devices.' } else { 'Restricted users from recovering BitLocker keys for their owned devices.' }
                Write-LogMessage -API 'Standards' -tenant $tenant -message $ActionMessage -sev Info


                # Update current state variables to reflect the change immediately if running remediate and report/alert together
                $CurrentState.defaultUserRolePermissions.allowedToReadBitLockerKeysForOwnedDevice = $DesiredValue
                $CurrentValue = $DesiredValue
                $StateIsCorrect = $true
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to $StateValue users to recover BitLocker keys for their owned devices: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Users are $DesiredLabel to recover BitLocker keys for their owned devices as configured." -sev Info
        } else {
            $CurrentLabel = if ($CurrentValue) { 'allowed' } else { 'restricted' }
            $AlertMessage = "Users are $CurrentLabel to recover BitLocker keys for their owned devices but should be $DesiredLabel."
            Write-StandardsAlert -message $AlertMessage -object $CurrentState -tenant $tenant -standardName 'BitLockerKeysForOwnedDevice' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message $AlertMessage -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.BitLockerKeysForOwnedDevice' -FieldValue $StateIsCorrect -Tenant $tenant
        Add-CIPPBPAField -FieldName 'BitLockerKeysForOwnedDevice' -FieldValue $CurrentValue -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardBitLockerKeysForOwnedDevice.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandardBookings.ps1' -1

function Invoke-CIPPStandardBookings {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) Bookings
    .SYNOPSIS
        (Label) Set Bookings state
    .DESCRIPTION
        (Helptext) Sets the state of Bookings on the tenant. Bookings is a scheduling tool that allows users to book appointments with others both internal and external.
        (DocsDescription) Sets the state of Bookings on the tenant. Bookings is a scheduling tool that allows users to book appointments with others both internal and external.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Controls whether employees can use Microsoft Bookings to create online appointment scheduling pages for internal and external clients. This feature can improve customer service and streamline appointment management, but may need to be controlled for security or business process reasons.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.Bookings.state","options":[{"label":"Enabled","value":"true"},{"label":"Disabled","value":"false"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-05-31
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -BookingsEnabled
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'Bookings' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'Bookings'

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').BookingsEnabled
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Bookings state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }
    $WantedState = if ($state -eq 'true') { $true } else { $false }
    $StateIsCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.Bookings' -FieldValue $state -TenantFilter $Tenant
        if ($null -eq $CurrentState ) { $CurrentState = $true }
        Add-CIPPBPAField -FieldName 'BookingsState' -FieldValue $CurrentState -StoreAs bool -Tenant $Tenant
    }

    # Input validation
    if (([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'BookingsEnabled: Invalid state parameter set' -sev Error
        return
    }
    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $false) {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ BookingsEnabled = $WantedState } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set the tenant Bookings state to $state" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set the tenant Bookings state to $state. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Bookings state is already set correctly to $state" -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Bookings is set correctly to $state" -sev Info
        } else {
            Write-StandardsAlert -message "The tenant Bookings is not set correctly to $state" -object @{CurrentState = $CurrentState; WantedState = $WantedState } -tenant $Tenant -standardName 'Bookings' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Bookings is not set correctly to $state" -sev Info
        }
    }



}
#EndRegion './Public/Standards/Invoke-CIPPStandardBookings.ps1' 95
#Region './Public/Standards/Invoke-CIPPStandardBranding.ps1' -1

function Invoke-CIPPStandardBranding {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) Branding
    .SYNOPSIS
        (Label) Set branding for the tenant
    .DESCRIPTION
        (Helptext) Sets the branding for the tenant. This includes the login page, and the Office 365 portal.
        (DocsDescription) Sets the branding for the tenant. This includes the login page, and the Office 365 portal.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Customizes Microsoft 365 login pages and portals with company branding, including logos, colors, and messaging. This creates a consistent corporate identity experience for employees and reinforces brand recognition while maintaining professional appearance across all Microsoft services.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.Branding.signInPageText","label":"Sign-in page text","required":false}
            {"type":"textField","name":"standards.Branding.usernameHintText","label":"Username hint Text","required":false}
            {"type":"switch","name":"standards.Branding.hideAccountResetCredentials","label":"Hide self-service password reset"}
            {"type":"autoComplete","multiple":false,"label":"Visual Template","name":"standards.Branding.layoutTemplateType","options":[{"label":"Full-screen background","value":"default"},{"label":"Partial-screen background","value":"verticalSplit"}]}
            {"type":"switch","name":"standards.Branding.isHeaderShown","label":"Show header"}
            {"type":"switch","name":"standards.Branding.isFooterShown","label":"Show footer"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-05-13
        POWERSHELLEQUIVALENT
            Portal only
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'Branding'

    $TenantId = Get-Tenants | Where-Object -Property defaultDomainName -EQ $Tenant

    $Localizations = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations" -tenantID $Tenant -AsApp $true
    # Get layoutTemplateType value using null-coalescing operator
    $layoutTemplateType = $Settings.layoutTemplateType.value ?? $Settings.layoutTemplateType
    # If default localization (id "0") exists, use that to get the currentState. Otherwise we have to create it first.
    if ($Localizations | Where-Object { $_.id -eq '0' }) {
        try {
            $CurrentState = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations/0" -tenantID $Tenant -AsApp $true
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Branding state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            return
        }
    } else {
        try {
            $GraphRequest = @{
                tenantID    = $Tenant
                uri         = "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations"
                AsApp       = $true
                Type        = 'POST'
                ContentType = 'application/json; charset=utf-8'
                Body        = [pscustomobject]@{
                    signInPageText                  = $Settings.signInPageText
                    usernameHintText                = $Settings.usernameHintText
                    loginPageTextVisibilitySettings = [pscustomobject]@{
                        hideAccountResetCredentials = $Settings.hideAccountResetCredentials
                    }
                    loginPageLayoutConfiguration    = [pscustomobject]@{
                        layoutTemplateType = $layoutTemplateType
                        isHeaderShown      = $Settings.isHeaderShown
                        isFooterShown      = $Settings.isFooterShown
                    }
                } | ConvertTo-Json -Compress
            }
            $CurrentState = New-GraphPostRequest @GraphRequest
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not create the default Branding localization for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            return
        }
    }

    $StateIsCorrect = ($CurrentState.signInPageText -eq $Settings.signInPageText) -and
    ($CurrentState.usernameHintText -eq $Settings.usernameHintText) -and
    ($CurrentState.loginPageTextVisibilitySettings.hideAccountResetCredentials -eq $Settings.hideAccountResetCredentials) -and
    ($CurrentState.loginPageLayoutConfiguration.layoutTemplateType -eq $layoutTemplateType) -and
    ($CurrentState.loginPageLayoutConfiguration.isHeaderShown -eq $Settings.isHeaderShown) -and
    ($CurrentState.loginPageLayoutConfiguration.isFooterShown -eq $Settings.isFooterShown)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Branding is already applied correctly.' -Sev Info
        } else {
            try {
                $GraphRequest = @{
                    tenantID    = $Tenant
                    uri         = "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations/0"
                    AsApp       = $true
                    Type        = 'PATCH'
                    ContentType = 'application/json; charset=utf-8'
                    Body        = [pscustomobject]@{
                        signInPageText                  = $Settings.signInPageText
                        usernameHintText                = $Settings.usernameHintText
                        loginPageTextVisibilitySettings = [pscustomobject]@{
                            hideAccountResetCredentials = $Settings.hideAccountResetCredentials
                        }
                        loginPageLayoutConfiguration    = [pscustomobject]@{
                            layoutTemplateType = $layoutTemplateType
                            isHeaderShown      = $Settings.isHeaderShown
                            isFooterShown      = $Settings.isFooterShown
                        }
                    } | ConvertTo-Json -Compress
                }
                $null = New-GraphPostRequest @GraphRequest
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully updated branding.' -Sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to update branding. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            }
        }

    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Branding is correctly set.' -Sev Info
        } else {
            Write-StandardsAlert -message 'Branding is incorrectly set.' -object ($CurrentState | Select-Object -Property signInPageText, usernameHintText, loginPageTextVisibilitySettings, loginPageLayoutConfiguration) -tenant $Tenant -standardName 'Branding' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Branding is incorrectly set.' -Sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect -eq $true ? $true : ($CurrentState | Select-Object -Property signInPageText, usernameHintText, loginPageTextVisibilitySettings, loginPageLayoutConfiguration)
        Set-CIPPStandardsCompareField -FieldName 'standards.Branding' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'Branding' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardBranding.ps1' 141
#Region './Public/Standards/Invoke-CIPPStandardcalDefault.ps1' -1

function Invoke-CIPPStandardcalDefault {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) calDefault
    .SYNOPSIS
        (Label) Set Sharing Level for Default calendar
    .DESCRIPTION
        (Helptext) Sets the default sharing level for the default calendar, for all users
        (DocsDescription) Sets the default sharing level for the default calendar for all users in the tenant. You can read about the different sharing levels [here.](https://learn.microsoft.com/en-us/powershell/module/exchange/set-mailboxfolderpermission?view=exchange-ps#-accessrights)
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Configures how much calendar information employees share by default with colleagues, balancing collaboration needs with privacy. This setting determines whether others can see meeting details, free/busy times, or just availability, helping optimize scheduling while protecting sensitive meeting information.
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select Sharing Level","name":"standards.calDefault.permissionLevel","options":[{"label":"Owner - The user can create, read, edit, and delete all items in the folder, and create subfolders. The user is both folder owner and folder contact.","value":"Owner"},{"label":"Publishing Editor - The user can create, read, edit, and delete all items in the folder, and create subfolders.","value":"PublishingEditor"},{"label":"Editor - The user can create items in the folder. The contents of the folder do not appear.","value":"Editor"},{"label":"Publishing Author.  The user can read, create all items/subfolders. Can modify and delete only items they create.","value":"PublishingAuthor"},{"label":"Author - The user can create and read items, and modify and delete items that they create.","value":"Author"},{"label":"Non Editing Author - The user has full read access and create items. Can can delete only own items.","value":"NonEditingAuthor"},{"label":"Reviewer - The user can read all items in the folder.","value":"Reviewer"},{"label":"Contributor - The user can create items and folders.","value":"Contributor"},{"label":"Availability Only - Indicates that the user can view only free/busy time within the calendar.","value":"AvailabilityOnly"},{"label":"Limited Details - The user can view free/busy time within the calendar and the subject and location of appointments.","value":"LimitedDetails"},{"label":"None - The user has no permissions on the folder.","value":"none"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-04-27
        POWERSHELLEQUIVALENT
            Set-MailboxFolderPermission
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings, $QueueItem)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'calDefault'
    $TestResult = Test-CIPPStandardLicense -StandardName 'calDefault' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Get permissionLevel value using null-coalescing operator
    $permissionLevel = $Settings.permissionLevel.value ?? $Settings.permissionLevel

    # Input validation
    if ([string]::IsNullOrWhiteSpace($permissionLevel) -or $permissionLevel -eq 'Select a value') {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'calDefault: Invalid permissionLevel parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        $Mailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' | Sort-Object UserPrincipalName
        $TotalMailboxes = $Mailboxes.Count
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Started setting default calendar permissions for $($TotalMailboxes) mailboxes." -sev Info

        # Retrieve the last run status
        $LastRunTable = Get-CIPPTable -Table StandardsLastRun
        $Filter = "RowKey eq 'calDefaults' and PartitionKey eq '{0}'" -f $tenant
        $LastRun = Get-CIPPAzDataTableEntity @LastRunTable -Filter $Filter

        $startIndex = 0
        if ($LastRun -and $LastRun.processedMailboxes -lt $LastRun.totalMailboxes ) {
            $startIndex = $LastRun.processedMailboxes
        }

        $SuccessCounter = if ($startIndex -eq 0) { 0 } else { [int64]$LastRun.currentSuccessCount }
        $processedMailboxes = $startIndex
        $Mailboxes = $Mailboxes[$startIndex..($TotalMailboxes - 1)]
        Write-Host "CalDefaults Starting at index $startIndex"
        Write-Host "CalDefaults success counter starting at $SuccessCounter"
        Write-Host "CalDefaults Processing $($Mailboxes.Count) mailboxes"
        $Mailboxes | ForEach-Object {
            $Mailbox = $_
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailboxFolderStatistics' -cmdParams @{identity = $Mailbox.UserPrincipalName; FolderScope = 'Calendar' } -Anchor $Mailbox.UserPrincipalName | Where-Object { $_.FolderType -eq 'Calendar' } |
                    ForEach-Object {
                        try {
                            New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailboxFolderPermission' -cmdParams @{Identity = "$($Mailbox.UserPrincipalName):$($_.FolderId)"; User = 'Default'; AccessRights = $permissionLevel } -Anchor $Mailbox.UserPrincipalName
                            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set default folder permission for $($Mailbox.UserPrincipalName):\$($_.Name) to $permissionLevel" -sev Debug
                            $SuccessCounter++
                        } catch {
                            $ErrorMessage = Get-CippException -Exception $_
                            Write-Host "Setting cal failed: $ErrorMessage"
                            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set default calendar permissions for $($Mailbox.UserPrincipalName). Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                        }
                    }
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set default calendar permissions for $($Mailbox.UserPrincipalName). Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
                $processedMailboxes++
                if ($processedMailboxes % 25 -eq 0) {
                    $LastRun = @{
                        RowKey              = 'calDefaults'
                        PartitionKey        = $Tenant
                        totalMailboxes      = $TotalMailboxes
                        processedMailboxes  = $processedMailboxes
                        currentSuccessCount = $SuccessCounter
                    }
                    Add-CIPPAzDataTableEntity @LastRunTable -Entity $LastRun -Force
                    Write-Host "Processed $processedMailboxes mailboxes"
                }
            }

            $LastRun = @{
                RowKey              = 'calDefaults'
                PartitionKey        = $Tenant
                totalMailboxes      = $TotalMailboxes
                processedMailboxes  = $processedMailboxes
                currentSuccessCount = $SuccessCounter
            }
            Add-CIPPAzDataTableEntity @LastRunTable -Entity $LastRun -Force

            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set default calendar permissions for $SuccessCounter out of $TotalMailboxes mailboxes." -sev Info
        }
        if ($Settings.report -eq $true) {
            #This script always returns true, as it only disables the Safe Senders list
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeSendersDisable' -FieldValue $true -Tenant $Tenant
        }
    }
#EndRegion './Public/Standards/Invoke-CIPPStandardcalDefault.ps1' 123
#Region './Public/Standards/Invoke-CIPPStandardCloudMessageRecall.ps1' -1

function Invoke-CIPPStandardCloudMessageRecall {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) CloudMessageRecall
    .SYNOPSIS
        (Label) Set Cloud Message Recall state
    .DESCRIPTION
        (Helptext) Sets the Cloud Message Recall state for the tenant. This allows users to recall messages from the cloud.
        (DocsDescription) Sets the default state for Cloud Message Recall for the tenant. By default this is enabled. You can read more about the feature [here.](https://techcommunity.microsoft.com/t5/exchange-team-blog/cloud-based-message-recall-in-exchange-online/ba-p/3744714)
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Enables employees to recall or retract emails they've sent, helping prevent embarrassing mistakes or accidental data sharing. This feature can reduce the impact of human errors in email communication and provides a safety net for sensitive information accidentally sent to wrong recipients.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.CloudMessageRecall.state","options":[{"label":"Enabled","value":"true"},{"label":"Disabled","value":"false"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-05-31
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -MessageRecallEnabled
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'CloudMessageRecall' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'CloudMessageRecall'

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').MessageRecallEnabled
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the CloudMessageRecall state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }
    $WantedState = if ($state -eq 'true') { $true } else { $false }
    $StateIsCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    if ($Settings.report -eq $true) {
        # Default is not set, not set means it's enabled
        if ($null -eq $CurrentState ) { $CurrentState = $true }
        Set-CIPPStandardsCompareField -FieldName 'standards.CloudMessageRecall' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'MessageRecall' -FieldValue $CurrentState -StoreAs bool -Tenant $Tenant
    }

    # Input validation
    if (([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'CloudMessageRecall: Invalid state parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $false) {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ MessageRecallEnabled = $WantedState } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set the tenant Message Recall state to $state" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set the tenant Message Recall state to $state. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Message Recall state is already set correctly to $state" -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Message Recall is set correctly to $state" -sev Info
        } else {
            Write-StandardsAlert -message "The tenant Message Recall is not set correctly to $state" -object @{CurrentState = $CurrentState; WantedState = $WantedState } -tenant $Tenant -standardName 'CloudMessageRecall' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant Message Recall is not set correctly to $state" -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardCloudMessageRecall.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardConditionalAccessTemplate.ps1' -1

function Invoke-CIPPStandardConditionalAccessTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ConditionalAccessTemplate
    .SYNOPSIS
        (Label) Conditional Access Template
    .DESCRIPTION
        (Helptext) Manage conditional access policies for better security.
        (DocsDescription) Manage conditional access policies for better security.
    .NOTES
        CAT
            Templates
        MULTIPLE
            True
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-30
        EXECUTIVETEXT
            Deploys standardized conditional access policies that automatically enforce security requirements based on user location, device compliance, and risk factors. These templates ensure consistent security controls across the organization while enabling secure access to business resources.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"TemplateList","multiple":false,"label":"Select Conditional Access Template","api":{"url":"/api/ListCATemplates","labelField":"displayName","valueField":"GUID","queryKey":"ListCATemplates"}}
            {"name":"state","label":"What state should we deploy this template in?","type":"radio","options":[{"value":"donotchange","label":"Do not change state"},{"value":"Enabled","label":"Set to enabled"},{"value":"Disabled","label":"Set to disabled"},{"value":"enabledForReportingButNotEnforced","label":"Set to report only"}]}
            {"type":"switch","name":"DisableSD","label":"Disable Security Defaults when deploying policy"}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'ConditionalAccess'
    $Table = Get-CippTable -tablename 'templates'
    $TestResult = Test-CIPPStandardLicense -StandardName 'ConditionalAccessTemplate_general' -TenantFilter $Tenant -RequiredCapabilities @('AAD_PREMIUM', 'AAD_PREMIUM_P2')
    $TestP2 = Test-CIPPStandardLicense -StandardName 'ConditionalAccessTemplate_p2' -TenantFilter $Tenant -RequiredCapabilities @('AAD_PREMIUM_P2') -SkipLog
    if ($TestResult -eq $false) {
        #writing to each item that the license is not present.
        $settings.TemplateList | ForEach-Object {
            Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($_.value)" -FieldValue 'This tenant does not have the required license for this standard.' -Tenant $Tenant
        }
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $AllCAPolicies = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies?$top=999' -tenantid $Tenant -asApp $true
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ConditionalAccessTemplate state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        foreach ($Setting in $Settings) {
            try {
                $Filter = "PartitionKey eq 'CATemplate' and RowKey eq '$($Setting.TemplateList.value)'"
                $JSONObj = (Get-CippAzDataTableEntity @Table -Filter $Filter).JSON
                $Policy = $JSONObj | ConvertFrom-Json
                if ($Policy.conditions.userRiskLevels.count -gt 0 -or $Policy.conditions.signInRiskLevels.count -gt 0) {
                    if (!$TestP2) {
                        Write-Information "Skipping policy $($Policy.displayName) as it requires AAD Premium P2 license."
                        Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue "Policy $($Policy.displayName) requires AAD Premium P2 license." -Tenant $Tenant
                        continue
                    }
                }
                $NewCAPolicy = @{
                    replacePattern = 'displayName'
                    TenantFilter   = $Tenant
                    state          = $Setting.state
                    RawJSON        = $JSONObj
                    Overwrite      = $true
                    APIName        = 'Standards'
                    Headers        = $Request.Headers
                    DisableSD      = $Setting.DisableSD
                    CreateGroups   = $Setting.CreateGroups ?? $false
                }

                $null = New-CIPPCAPolicy @NewCAPolicy
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to create or update conditional access rule $($JSONObj.displayName). Error: $ErrorMessage" -sev 'Error'
            }
        }
    }
    if ($Settings.report -eq $true -or $Settings.remediate -eq $true) {
        $Filter = "PartitionKey eq 'CATemplate'"
        $Policies = (Get-CippAzDataTableEntity @Table -Filter $Filter | Where-Object RowKey -In $Settings.TemplateList.value).JSON | ConvertFrom-Json -Depth 10
        $AllCAPolicies = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/identity/conditionalAccess/policies?$top=999' -tenantid $Tenant -asApp $true
        #check if all groups.displayName are in the existingGroups, if not $fieldvalue should contain all missing groups, else it should be true.
        $MissingPolicies = foreach ($Setting in $Settings.TemplateList) {
            $policy = $Policies | Where-Object { $_.displayName -eq $Setting.label }
            $CheckExististing = $AllCAPolicies | Where-Object -Property displayName -EQ $Setting.label
            if (!$CheckExististing) {
                if ($Setting.conditions.userRiskLevels.Count -gt 0 -or $Setting.conditions.signInRiskLevels.Count -gt 0) {
                    if (!$TestP2) {
                        Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue "Policy $($Setting.label) requires AAD Premium P2 license." -Tenant $Tenant
                    } else {
                        Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue "Policy $($Setting.label) is missing from this tenant." -Tenant $Tenant
                    }
                } else {
                    Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue "Policy $($Setting.label) is missing from this tenant." -Tenant $Tenant
                }
            } else {
                $CompareObj = ConvertFrom-Json -ErrorAction SilentlyContinue -InputObject (New-CIPPCATemplate -TenantFilter $tenant -JSON $CheckExististing)
                $Compare = Compare-CIPPIntuneObject -ReferenceObject $policy -DifferenceObject $CompareObj
                if (!$Compare) {
                    Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue $true -Tenant $Tenant
                } else {
                    Set-CIPPStandardsCompareField -FieldName "standards.ConditionalAccessTemplate.$($Setting.value)" -FieldValue $Compare -Tenant $Tenant
                }
            }
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardConditionalAccessTemplate.ps1' 118
#Region './Public/Standards/Invoke-CIPPStandardCustomBannedPasswordList.ps1' -1

function Invoke-CIPPStandardCustomBannedPasswordList {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) CustomBannedPasswordList
    .SYNOPSIS
        (Label) Set Entra ID Custom Banned Password List
    .DESCRIPTION
        (Helptext) **Requires Entra ID P1.** Updates and enables the Entra ID custom banned password list with the supplied words. Enter words separated by commas or semicolons. Each word must be 4-16 characters long. Maximum 1,000 words allowed.
        (DocsDescription) Updates and enables the Entra ID custom banned password list with the supplied words. This supplements the global banned password list maintained by Microsoft. The custom list is limited to 1,000 key base terms of 4-16 characters each. Entra ID will [block variations and common substitutions](https://learn.microsoft.com/en-us/entra/identity/authentication/tutorial-configure-custom-password-protection#configure-custom-banned-passwords) of these words in user passwords. [How are passwords evaluated?](https://learn.microsoft.com/en-us/entra/identity/authentication/concept-password-ban-bad#score-calculation)
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (5.2.3.2)"
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.CustomBannedPasswordList.BannedWords","label":"Banned Words","placeholder":"Banned words separated by commas or semicolons","required":true}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-06-28
        POWERSHELLEQUIVALENT
            Get-MgBetaDirectorySetting, New-MgBetaDirectorySetting, Update-MgBetaDirectorySetting
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    Write-Host "All params received: $Tenant, $tenant, $($Settings | ConvertTo-Json -Depth 10 -Compress)"
    $PasswordRuleTemplateId = '5cf42378-d67d-4f36-ba46-e8b86229381d'
    # Parse and validate banned words from input
    $BannedWordsInput = $Settings.BannedWords
    if ([string]::IsNullOrWhiteSpace($BannedWordsInput)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'CustomBannedPasswordList: No banned words provided' -sev Error
        return
    }

    # Split input by commas, newlines, or semicolons and clean up
    $BannedWordsList = $BannedWordsInput -split '[,;\r\n]+' | ForEach-Object { ($_.Trim()) } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique

    # Validate word count
    if ($BannedWordsList.Count -gt 1000) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message "CustomBannedPasswordList: Too many banned words provided ($($BannedWordsList.Count)). Maximum allowed is 1000." -sev Error
        return
    }

    # Validate word length (4-16 characters), remove duplicates and invalid words
    $ValidBannedWordsList = [System.Collections.Generic.List[string]]::new()
    $InvalidWords = [System.Collections.Generic.List[string]]::new()

    foreach ($Word in $BannedWordsList) {
        if ($Word.Length -ge 4 -and $Word.Length -le 16) {
            $ValidBannedWordsList.Add($Word)
        } else {
            $InvalidWords.Add($Word)
        }
    }
    $BannedWordsList = $ValidBannedWordsList | Select-Object -Unique

    # Alert if invalid words are found
    if ($InvalidWords.Count -gt 0) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message "CustomBannedPasswordList: Invalid words found in input (must be 4-16 characters). Please remove the following words: $($InvalidWords -join ', ')" -sev Warning
    }

    # Get existing directory settings for password rules
    try {
        $ExistingSettings = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/settings' -tenantid $Tenant | Where-Object { $_.templateId -eq $PasswordRuleTemplateId }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to get existing Custom Banned Password List: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate Custom Banned Password List'

        if ($null -eq $ExistingSettings) {
            Write-Host 'No existing Custom Banned Password List found, creating new one'
            # Create new directory setting with default values if it doesn't exist
            try {
                $Body = @{
                    templateId = $PasswordRuleTemplateId
                    values     = @(
                        @{
                            name  = 'EnableBannedPasswordCheck'
                            value = 'True'
                        }
                        @{
                            name  = 'BannedPasswordList'
                            value = $BannedWordsList -join ([char]9)
                        }
                        @{
                            name  = 'LockoutDurationInSeconds'
                            value = '60'
                        }
                        @{
                            name  = 'LockoutThreshold'
                            value = '10'
                        }
                        @{
                            name  = 'EnableBannedPasswordCheckOnPremises'
                            value = 'False'
                        }
                        @{
                            name  = 'BannedPasswordCheckOnPremisesMode'
                            value = 'Audit'
                        }
                    )
                }
                $JsonBody = ConvertTo-Json -Depth 10 -InputObject $Body -Compress

                $ExistingSettings = New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/settings' -Type POST -Body $JsonBody
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Custom Banned Password List created with $($BannedWordsList.Count) words." -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Custom Banned Password List: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-Host 'Existing Custom Banned Password List found, updating it'
            # Update existing directory setting
            try {
                # Get the current passwords and check if all the new words are already in the list
                $CurrentBannedWords = $ExistingSettings.values | Where-Object { $_.name -eq 'BannedPasswordList' }
                $CurrentBannedWords = $CurrentBannedWords.value -split ([char]9)

                # Check if the new words are already in the list
                $NewBannedWords = $BannedWordsList | Where-Object { $CurrentBannedWords -notcontains $_ }
                if ($NewBannedWords.Count -eq 0 -and ($ExistingSettings.values | Where-Object { $_.name -eq 'EnableBannedPasswordCheck' }).value -eq 'True') {
                    Write-Host 'No new words to add'
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Custom Banned Password List is already configured with $($CurrentBannedWords.Count) words." -sev Info
                } else {
                    Write-Host "$($NewBannedWords.Count) new words to add"
                    $AllBannedWords = [System.Collections.Generic.List[string]]::new()
                    $NewBannedWords | ForEach-Object { $AllBannedWords.Add($_) }
                    $CurrentBannedWords | ForEach-Object { $AllBannedWords.Add($_) }
                    $AllBannedWords = $AllBannedWords | Select-Object -Unique -First 1000 | Where-Object { $_ -ne $null }

                    $Body = @{
                        values = @(
                            @{
                                name  = 'EnableBannedPasswordCheck'
                                value = 'True'
                            }
                            @{
                                name  = 'BannedPasswordList'
                                value = $AllBannedWords -join ([char]9)
                            }
                            @{
                                name  = 'LockoutDurationInSeconds'
                                value = ($ExistingSettings.values | Where-Object { $_.name -eq 'LockoutDurationInSeconds' }).value
                            }
                            @{
                                name  = 'LockoutThreshold'
                                value = ($ExistingSettings.values | Where-Object { $_.name -eq 'LockoutThreshold' }).value
                            }
                            @{
                                name  = 'EnableBannedPasswordCheckOnPremises'
                                value = ($ExistingSettings.values | Where-Object { $_.name -eq 'EnableBannedPasswordCheckOnPremises' }).value
                            }
                            @{
                                name  = 'BannedPasswordCheckOnPremisesMode'
                                value = ($ExistingSettings.values | Where-Object { $_.name -eq 'BannedPasswordCheckOnPremisesMode' }).value
                            }
                        )
                    }

                    $JsonBody = ConvertTo-Json -Depth 10 -InputObject $Body -Compress
                    $null = New-GraphPostRequest -tenantid $Tenant -Uri "https://graph.microsoft.com/beta/settings/$($ExistingSettings.id)" -Type PATCH -Body $JsonBody
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Custom Banned Password List updated with $($NewBannedWords.Count) new words." -sev Info
                }

            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Custom Banned Password List: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($null -eq $ExistingSettings) {
            Write-StandardsAlert -message 'Custom Banned Password List is not configured' -object @{Status = 'Not Configured'; WordCount = 0 } -tenant $tenant -standardName 'CustomBannedPasswordList' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Custom Banned Password List is not configured' -sev Info
        } else {
            $BannedPasswordCheckEnabled = $ExistingSettings.values | Where-Object { $_.name -eq 'EnableBannedPasswordCheck' }
            $CurrentBannedWords = $ExistingSettings.values | Where-Object { $_.name -eq 'BannedPasswordList' }
            $CurrentBannedWords = if ($CurrentBannedWords.value) { ($CurrentBannedWords.value -split ([char]9)) } else { @() }

            # Find missing words from input
            $MissingInputWords = $BannedWordsList | Where-Object { $CurrentBannedWords -notcontains $_ }

            if ($MissingInputWords.Count -gt 0) {
                Write-StandardsAlert -message "Custom Banned Password List is missing $($MissingInputWords.Count) input words: $($MissingInputWords -join ', ')" -object @{Status = 'Configured but Missing Input Words'; MissingWords = $MissingInputWords; Enabled = $BannedPasswordCheckEnabled.value } -tenant $tenant -standardName 'CustomBannedPasswordList' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Custom Banned Password List is missing $($MissingInputWords.Count) input words: $($MissingInputWords -join ', ')" -sev Info
            } else {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Custom Banned Password List contains all input words ($($BannedWordsList.Count))." -sev Info
            }
        }
    }

    if ($Settings.report -eq $true) {
        if ($null -eq $ExistingSettings) {
            $BannedPasswordState = @{
                Status            = 'Not Configured'
                Enabled           = $false
                WordCount         = 0
                Compliant         = $false
                MissingInputWords = $BannedWordsList
            }
        } else {
            $BannedPasswordCheckEnabled = $ExistingSettings.values | Where-Object { $_.name -eq 'EnableBannedPasswordCheck' }
            $CurrentBannedWords = $ExistingSettings.values | Where-Object { $_.name -eq 'BannedPasswordList' }
            $CurrentBannedWords = if ($CurrentBannedWords.value) { ($CurrentBannedWords.value -split ([char]9)) } else { @() }
            $CurrentWordCount = $CurrentBannedWords.Count

            # Find missing words from input
            $MissingInputWords = $BannedWordsList | Where-Object { $CurrentBannedWords -notcontains $_ }

            $BannedPasswordState = @{
                Status            = 'Configured'
                Enabled           = $BannedPasswordCheckEnabled.value -eq 'True'
                WordCount         = $CurrentWordCount
                Compliant         = ($BannedPasswordCheckEnabled.value -eq 'True' -and $MissingInputWords.Count -eq 0)
                MissingInputWords = $MissingInputWords
            }
        }

        Add-CIPPBPAField -FieldName 'CustomBannedPasswordList' -FieldValue $BannedPasswordState -StoreAs json -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.CustomBannedPasswordList' -FieldValue $BannedPasswordState.Compliant -Tenant $tenant
    }


}
#EndRegion './Public/Standards/Invoke-CIPPStandardCustomBannedPasswordList.ps1' 238
#Region './Public/Standards/Invoke-CIPPStandardDefaultPlatformRestrictions.ps1' -1

function Invoke-CIPPStandardDefaultPlatformRestrictions {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DefaultPlatformRestrictions
    .SYNOPSIS
        (Label) Device enrollment restrictions
    .DESCRIPTION
        (Helptext) Sets the default platform restrictions for enrolling devices into Intune. Note: Do not block personally owned if platform is blocked.
        (DocsDescription) Sets the default platform restrictions for enrolling devices into Intune. Note: Do not block personally owned if platform is blocked.
    .NOTES
        CAT
            Intune Standards
        TAG
            "CISA (MS.AAD.19.1v1)"
        EXECUTIVETEXT
            Controls which types of devices (iOS, Android, Windows, macOS) and ownership models (corporate vs. personal) can be enrolled in the company's device management system. This helps maintain security standards while supporting necessary business device types and usage scenarios.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.platformAndroidForWorkBlocked","label":"Block platform Android Enterprise (work profile)","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.personalAndroidForWorkBlocked","label":"Block personally owned Android Enterprise (work profile)","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.platformAndroidBlocked","label":"Block platform Android","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.personalAndroidBlocked","label":"Block personally owned Android","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.platformiOSBlocked","label":"Block platform iOS","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.personaliOSBlocked","label":"Block personally owned iOS","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.platformMacOSBlocked","label":"Block platform macOS","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.personalMacOSBlocked","label":"Block personally owned macOS","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.platformWindowsBlocked","label":"Block platform Windows","default":false}
            {"type":"switch","name":"standards.DefaultPlatformRestrictions.personalWindowsBlocked","label":"Block personally owned Windows","default":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-04-01
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DefaultPlatformRestrictions' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations?`$expand=assignments&orderBy=priority&`$filter=deviceEnrollmentConfigurationType eq 'SinglePlatformRestriction'" -tenantID $Tenant -AsApp $true |
        Select-Object -Property id, androidForWorkRestriction, androidRestriction, iosRestriction, macOSRestriction, windowsRestriction
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DefaultPlatformRestrictions state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.androidForWorkRestriction.platformBlocked -eq $Settings.platformAndroidForWorkBlocked) -and
        ($CurrentState.androidForWorkRestriction.personalDeviceEnrollmentBlocked -eq $Settings.personalAndroidForWorkBlocked) -and
        ($CurrentState.androidRestriction.platformBlocked -eq $Settings.platformAndroidBlocked) -and
        ($CurrentState.androidRestriction.personalDeviceEnrollmentBlocked -eq $Settings.personalAndroidBlocked) -and
        ($CurrentState.iosRestriction.platformBlocked -eq $Settings.platformiOSBlocked) -and
        ($CurrentState.iosRestriction.personalDeviceEnrollmentBlocked -eq $Settings.personaliOSBlocked) -and
        ($CurrentState.macOSRestriction.platformBlocked -eq $Settings.platformMacOSBlocked) -and
        ($CurrentState.macOSRestriction.personalDeviceEnrollmentBlocked -eq $Settings.personalMacOSBlocked) -and
        ($CurrentState.windowsRestriction.platformBlocked -eq $Settings.platformWindowsBlocked) -and
        ($CurrentState.windowsRestriction.personalDeviceEnrollmentBlocked -eq $Settings.personalWindowsBlocked)

    $CompareField = [PSCustomObject]@{
        platformAndroidForWorkBlocked   = $CurrentState.androidForWorkRestriction.platformBlocked
        personalAndroidForWorkBlocked   = $CurrentState.androidForWorkRestriction.personalDeviceEnrollmentBlocked
        platformAndroidBlocked          = $CurrentState.androidRestriction.platformBlocked
        personalAndroidBlocked          = $CurrentState.androidRestriction.personalDeviceEnrollmentBlocked
        platformiOSBlocked              = $CurrentState.iosRestriction.platformBlocked
        personaliOSBlocked              = $CurrentState.iosRestriction.personalDeviceEnrollmentBlocked
        platformMacOSBlocked            = $CurrentState.macOSRestriction.platformBlocked
        personalMacOSBlocked            = $CurrentState.macOSRestriction.personalDeviceEnrollmentBlocked
        platformWindowsBlocked          = $CurrentState.windowsRestriction.platformBlocked
        personalWindowsBlocked          = $CurrentState.windowsRestriction.personalDeviceEnrollmentBlocked
    }

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'DefaultPlatformRestrictions is already applied correctly.' -Sev Info
        } else {
            $cmdParam = @{
                tenantid  = $Tenant
                uri      = "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations/$($CurrentState.id)"
                AsApp    = $false
                Type     = 'PATCH'
                ContentType = 'application/json; charset=utf-8'
                Body     = [PSCustomObject]@{
                    "@odata.type" = "#microsoft.graph.deviceEnrollmentPlatformRestrictionsConfiguration"
                    androidForWorkRestriction = [PSCustomObject]@{
                        "@odata.type"                   = "microsoft.graph.deviceEnrollmentPlatformRestriction"
                        platformBlocked                 = $Settings.platformAndroidForWorkBlocked
                        personalDeviceEnrollmentBlocked = $Settings.personalAndroidForWorkBlocked
                    }
                    androidRestriction = [PSCustomObject]@{
                        "@odata.type"                   = "microsoft.graph.deviceEnrollmentPlatformRestriction"
                        platformBlocked                 = $Settings.platformAndroidBlocked
                        personalDeviceEnrollmentBlocked = $Settings.personalAndroidBlocked
                    }
                    iosRestriction = [PSCustomObject]@{
                        "@odata.type"                   = "microsoft.graph.deviceEnrollmentPlatformRestriction"
                        platformBlocked                 = $Settings.platformiOSBlocked
                        personalDeviceEnrollmentBlocked = $Settings.personaliOSBlocked
                    }
                    macOSRestriction = [PSCustomObject]@{
                        "@odata.type"                   = "microsoft.graph.deviceEnrollmentPlatformRestriction"
                        platformBlocked                 = $Settings.platformMacOSBlocked
                        personalDeviceEnrollmentBlocked = $Settings.personalMacOSBlocked
                    }
                    windowsRestriction = [PSCustomObject]@{
                        "@odata.type"                   = "microsoft.graph.deviceEnrollmentPlatformRestriction"
                        platformBlocked                 = $Settings.platformWindowsBlocked
                        personalDeviceEnrollmentBlocked = $Settings.personalWindowsBlocked
                    }
                } | ConvertTo-Json -Compress -Depth 10
            }
            try {
                $null = New-GraphPostRequest @cmdParam
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully updated DefaultPlatformRestrictions.' -Sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to update DefaultPlatformRestrictions. Error: $($ErrorMessage.NormalizedError)" -Sev Error
            }
        }

    }

    If ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'DefaultPlatformRestrictions is correctly set.' -Sev Info
        } else {
            Write-StandardsAlert -message 'DefaultPlatformRestrictions is incorrectly set.' -object $CompareField -tenant $Tenant -standardName 'DefaultPlatformRestrictions' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'DefaultPlatformRestrictions is incorrectly set.' -Sev Info
        }
    }

    If ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Set-CIPPStandardsCompareField -FieldName 'standards.DefaultPlatformRestrictions' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DefaultPlatformRestrictions' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDefaultPlatformRestrictions.ps1' 150
#Region './Public/Standards/Invoke-CIPPStandardDefaultSharingLink.ps1' -1

function Invoke-CIPPStandardDefaultSharingLink {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DefaultSharingLink
    .SYNOPSIS
        (Label) Set Default Sharing Link Settings
    .DESCRIPTION
        (Helptext) Configure the SharePoint default sharing link type and permission. This setting controls both the type of sharing link created by default and the permission level assigned to those links.
        (DocsDescription) Sets the default sharing link type (Direct or Internal) and permission (View) in SharePoint and OneDrive. Direct sharing means links only work for specific people, while Internal sharing means links work for anyone in the organization. Setting the view permission as the default ensures that users must deliberately select the edit permission when sharing a link, reducing the risk of unintentionally granting edit privileges.
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.7)"
            "CIS M365 5.0 (7.2.11)"
            "CISA (MS.SPO.1.4v1)"
        EXECUTIVETEXT
            Configures SharePoint default sharing links to implement the principle of least privilege for document sharing. This security measure reduces the risk of accidental data modification while maintaining collaboration functionality, requiring users to explicitly select Edit permissions when necessary. The sharing type setting controls whether links are restricted to specific recipients or available to the entire organization. This reduces the risk of accidental data exposure through link sharing.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"required":true,"label":"Default Sharing Link Type","name":"standards.DefaultSharingLink.SharingLinkType","options":[{"label":"Direct - Only the people the user specifies","value":"Direct"},{"label":"Internal - Only people in your organization","value":"Internal"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-13
        POWERSHELLEQUIVALENT
            Set-SPOTenant -DefaultSharingLinkType [Direct\|Internal] -DefaultLinkPermission View
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DefaultSharingLink' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    # Determine the desired sharing link type (default to Internal if not specified)

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $DesiredSharingLinkType = $Settings.SharingLinkType.value ?? 'Internal'

    # Map the string values to numeric values for SharePoint
    $SharingLinkTypeMap = @{
        'Direct'   = 1
        'Internal' = 2
        'Anyone'   = 3
    }
    $DesiredSharingLinkTypeValue = $SharingLinkTypeMap[$DesiredSharingLinkType]

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, DefaultSharingLinkType, DefaultLinkPermission
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DefaultSharingLink state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Check if the current state matches the desired configuration
    $StateIsCorrect = ($CurrentState.DefaultSharingLinkType -eq $DesiredSharingLinkTypeValue) -and ($CurrentState.DefaultLinkPermission -eq 1)
    Write-Host "currentstate: $($CurrentState.DefaultSharingLinkType), $($CurrentState.DefaultLinkPermission). Desired: $DesiredSharingLinkTypeValue, 1"
    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Default sharing link settings are already configured correctly (Type: $DesiredSharingLinkType, Permission: View)" -Sev Info
        } else {
            $Properties = @{
                DefaultSharingLinkType = $DesiredSharingLinkTypeValue
                DefaultLinkPermission  = 1  # View
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Successfully set default sharing link settings (Type: $DesiredSharingLinkType, Permission: View)" -Sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set default sharing link settings. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Default sharing link settings are configured correctly (Type: $DesiredSharingLinkType, Permission: View)" -Sev Info
        } else {
            # Determine current values for alert message
            $CurrentSharingType = switch ($CurrentState.DefaultSharingLinkType) {
                1 { 'Direct' }
                2 { 'Internal' }
                3 { 'Anyone' }
                default { 'Unknown' }
            }
            $CurrentPermission = switch ($CurrentState.DefaultLinkPermission) {
                0 { 'Edit' }
                1 { 'View' }
                2 { 'Edit' }
                default { 'Unknown' }
            }

            $Message = "Default sharing link settings are not configured correctly. Current: Type=$CurrentSharingType, Permission=$CurrentPermission. Expected: Type=$DesiredSharingLinkType, Permission=View"
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'DefaultSharingLink' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'DefaultSharingLink' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.DefaultSharingLink' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDefaultSharingLink.ps1' 123
#Region './Public/Standards/Invoke-CIPPStandardDelegateSentItems.ps1' -1

function Invoke-CIPPStandardDelegateSentItems {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DelegateSentItems
    .SYNOPSIS
        (Label) Set mailbox Sent Items delegation (Sent items for shared mailboxes)
    .DESCRIPTION
        (Helptext) Sets emails sent as and on behalf of shared mailboxes to also be stored in the shared mailbox sent items folder
        (DocsDescription) This makes sure that e-mails sent from shared mailboxes or delegate mailboxes, end up in the mailbox of the shared/delegate mailbox instead of the sender, allowing you to keep replies in the same mailbox as the original e-mail.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Ensures emails sent from shared mailboxes (like info@company.com) are stored in the shared mailbox rather than the individual sender's mailbox. This maintains complete email threads in one location, improving collaboration and ensuring all team members can see the full conversation history.
        ADDEDCOMPONENT
            {"type":"switch","label":"Include user mailboxes","name":"standards.DelegateSentItems.IncludeUserMailboxes"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-Mailbox
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DelegateSentItems' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    #$Rerun -Type Standard -Tenant $Tenant -API 'DelegateSentItems' -Settings $Settings


    # Backwards compatibility for Pre 7.0.5
    if ([string]::IsNullOrWhiteSpace($Settings.IncludeUserMailboxes)) {
        $Settings.IncludeUserMailboxes = $true
    }

    if ($Settings.IncludeUserMailboxes -eq $true) {
        $Mailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{ RecipientTypeDetails = @('UserMailbox', 'SharedMailbox') } -Select 'Identity,UserPrincipalName,MessageCopyForSendOnBehalfEnabled,MessageCopyForSentAsEnabled' |
        Where-Object { $_.MessageCopyForSendOnBehalfEnabled -eq $false -or $_.MessageCopyForSentAsEnabled -eq $false }
    } else {
        $Mailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{ RecipientTypeDetails = @('SharedMailbox') } -Select 'Identity,UserPrincipalName,MessageCopyForSendOnBehalfEnabled,MessageCopyForSentAsEnabled' |
        Where-Object { $_.MessageCopyForSendOnBehalfEnabled -eq $false -or $_.MessageCopyForSentAsEnabled -eq $false }
    }


    Write-Host "Mailboxes: $($Mailboxes.Count)"
    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($Mailboxes) {
            try {
                $Request = $Mailboxes | ForEach-Object {
                    @{
                        CmdletInput = @{
                            CmdletName = 'Set-Mailbox'
                            Parameters = @{Identity = $_.UserPrincipalName ; MessageCopyForSendOnBehalfEnabled = $true; MessageCopyForSentAsEnabled = $true }
                        }
                    }
                }
                $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($Request)
                $BatchResults | ForEach-Object {
                    if ($_.error) {
                        $ErrorMessage = Get-CippException -Exception $_.error
                        Write-Host "Failed to apply Delegate Sent Items Style to $($_.target) Error: $($ErrorMessage.NormalizedError)"
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to apply Delegate Sent Items Style to $($_.error.target) Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                    }
                }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Delegate Sent Items Style applied for $($Mailboxes.Count - $BatchResults.Error.Count) mailboxes" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to apply Delegate Sent Items Style. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Delegate Sent Items Style already enabled.' -sev Info

        }
    }
    if ($Settings.alert -eq $true) {
        if ($null -eq $Mailboxes) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Delegate Sent Items Style is enabled for all mailboxes' -sev Info
        } else {
            Write-StandardsAlert -message "Delegate Sent Items Style is not enabled for $($Mailboxes.Count) mailboxes" -object $Mailboxes -tenant $Tenant -standardName 'DelegateSentItems' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Delegate Sent Items Style is not enabled for $($Mailboxes.Count) mailboxes" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $Filtered = $Mailboxes | Select-Object -Property UserPrincipalName, MessageCopyForSendOnBehalfEnabled, MessageCopyForSentAsEnabled
        $CurrentState = if ($null -eq $Mailboxes) { $true } else { $Filtered }
        Set-CIPPStandardsCompareField -FieldName 'standards.DelegateSentItems' -FieldValue $CurrentState -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DelegateSentItems' -FieldValue $Filtered -StoreAs json -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDelegateSentItems.ps1' 105
#Region './Public/Standards/Invoke-CIPPStandardDeletedUserRentention.ps1' -1

function Invoke-CIPPStandardDeletedUserRentention {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DeletedUserRentention
    .SYNOPSIS
        (Label) Set deleted user retention time in OneDrive
    .DESCRIPTION
        (Helptext) Sets the retention period for deleted users OneDrive to the specified period of time. The default is 30 days.
        (DocsDescription) When a OneDrive user gets deleted, the personal SharePoint site is saved for selected amount of time that data can be retrieved from it.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Preserves departed employees' OneDrive files for a specified period, allowing time to recover important business documents before permanent deletion. This helps prevent data loss while managing storage costs and maintaining compliance with data retention policies.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"name":"standards.DeletedUserRentention.Days","label":"Retention time (Default 30 days)","options":[{"label":"30 days","value":"30"},{"label":"90 days","value":"90"},{"label":"1 year","value":"365"},{"label":"2 years","value":"730"},{"label":"3 years","value":"1095"},{"label":"4 years","value":"1460"},{"label":"5 years","value":"1825"},{"label":"6 years","value":"2190"},{"label":"7 years","value":"2555"},{"label":"8 years","value":"2920"},{"label":"9 years","value":"3285"},{"label":"10 years","value":"3650"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DeletedUserRentention' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DeletedUserRetention'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DeletedUserRetention state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $Days = $Settings.Days.value ?? $Settings.Days

    if ($Settings.report -eq $true) {
        $CurrentState = $CurrentInfo.deletedUserPersonalSiteRetentionPeriodInDays -eq $Days ? $true : ($CurrentInfo | Select-Object deletedUserPersonalSiteRetentionPeriodInDays)
        Set-CIPPStandardsCompareField -FieldName 'standards.DeletedUserRentention' -FieldValue $CurrentState -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DeletedUserRentention' -FieldValue $CurrentInfo.deletedUserPersonalSiteRetentionPeriodInDays -StoreAs string -Tenant $Tenant
    }

    # Get days value using null-coalescing operator

    # Input validation
    if (($Days -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'DeletedUserRentention: Invalid Days parameter set' -sev Error
        Return
    }

    # Backwards compatibility for v5.9.4 and back
    if ([string]::IsNullOrWhiteSpace($Days)) {
        $WantedState = 365
    } else {
        $WantedState = [int]$Days
    }

    $StateSetCorrectly = if ($CurrentInfo.deletedUserPersonalSiteRetentionPeriodInDays -eq $WantedState) { $true } else { $false }

    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($StateSetCorrectly -eq $false) {
            try {
                $body = [PSCustomObject]@{
                    deletedUserPersonalSiteRetentionPeriodInDays = $Days
                }
                $body = ConvertTo-Json -InputObject $body -Depth 5 -Compress
                $null = New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type PATCH -Body $body -ContentType 'application/json'

                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set deleted user retention of OneDrive to $WantedState day(s)" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set deleted user retention of OneDrive to $WantedState day(s). Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Deleted user retention of OneDrive is already set to $WantedState day(s)" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateSetCorrectly -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Deleted user retention of OneDrive is set to $WantedState day(s)" -sev Info
        } else {
            Write-StandardsAlert -message "Deleted user retention of OneDrive is not set to $WantedState day(s)." -object $CurrentInfo -tenant $Tenant -standardName 'DeletedUserRentention' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Deleted user retention of OneDrive is not set to $WantedState day(s). Current value is: $($CurrentInfo.deletedUserPersonalSiteRetentionPeriodInDays) day(s)." -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDeletedUserRentention.ps1' 105
#Region './Public/Standards/Invoke-CIPPStandardDeployCheckChromeExtension.ps1' -1

function Invoke-CIPPStandardDeployCheckChromeExtension {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DeployCheckChromeExtension
    .SYNOPSIS
        (Label) Deploy Check Chrome Extension
    .DESCRIPTION
        (Helptext) Deploys the Check Chrome extension via Intune OMA-URI custom policies for both Chrome and Edge browsers with configurable settings. Chrome ID: benimdeioplgkhanklclahllklceahbe, Edge ID: knepjpocdagponkonnbggpcnhnaikajg
        (DocsDescription) Creates Intune OMA-URI custom policies that automatically install and configure the Check Chrome extension on managed devices for both Google Chrome and Microsoft Edge browsers. This ensures the extension is deployed consistently across all corporate devices with customizable settings.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Automatically deploys the Check browser extension across all company devices with configurable security and branding settings, ensuring consistent security monitoring and compliance capabilities. This extension provides enhanced security features and monitoring tools that help protect against threats while maintaining user productivity.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.DeployCheckChromeExtension.enableValidPageBadge","label":"Enable valid page badge","defaultValue":true}
            {"type":"switch","name":"standards.DeployCheckChromeExtension.enablePageBlocking","label":"Enable page blocking","defaultValue":true}
            {"type":"switch","name":"standards.DeployCheckChromeExtension.enableCippReporting","label":"Enable CIPP reporting","defaultValue":true}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.cippServerUrl","label":"CIPP Server URL","placeholder":"https://YOUR-CIPP-SERVER-URL","required":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.customRulesUrl","label":"Custom Rules URL","placeholder":"https://YOUR-CIPP-SERVER-URL/rules.json","required":false}
            {"type":"number","name":"standards.DeployCheckChromeExtension.updateInterval","label":"Update interval (hours)","defaultValue":12}
            {"type":"switch","name":"standards.DeployCheckChromeExtension.enableDebugLogging","label":"Enable debug logging","defaultValue":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.companyName","label":"Company Name","placeholder":"YOUR-COMPANY","required":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.productName","label":"Product Name","placeholder":"YOUR-PRODUCT-NAME","required":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.supportEmail","label":"Support Email","placeholder":"support@yourcompany.com","required":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.primaryColor","label":"Primary Color","placeholder":"#0044CC","required":false}
            {"type":"textField","name":"standards.DeployCheckChromeExtension.logoUrl","label":"Logo URL","placeholder":"https://yourcompany.com/logo.png","required":false}
            {"name":"AssignTo","label":"Who should this policy be assigned to?","type":"radio","options":[{"label":"Do not assign","value":"On"},{"label":"Assign to all users","value":"allLicensedUsers"},{"label":"Assign to all devices","value":"AllDevices"},{"label":"Assign to all users and devices","value":"AllDevicesAndUsers"},{"label":"Assign to Custom Group","value":"customGroup"}]}
            {"type":"textField","required":false,"name":"customGroup","label":"Enter the custom group name if you selected 'Assign to Custom Group'. Wildcards are allowed."}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-09-18
        POWERSHELLEQUIVALENT
            New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    # Check for required Intune license
    $TestResult = Test-CIPPStandardLicense -StandardName 'DeployCheckChromeExtension' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    if ($TestResult -eq $false) {
        Set-CIPPStandardsCompareField -FieldName 'standards.DeployCheckChromeExtension' -FieldValue 'This tenant does not have the required license for this standard.' -Tenant $Tenant
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'This tenant does not have the required license for this standard.' -sev Error
        return $true
    }

    Write-Information "Running Deploy Check Chrome Extension standard for tenant $($Tenant)."

    # Chrome and Edge extension IDs for the Check extension
    $ChromeExtensionId = 'benimdeioplgkhanklclahllklceahbe'
    $EdgeExtensionId = 'knepjpocdagponkonnbggpcnhnaikajg'

    # Policy names
    $ChromePolicyName = 'Deploy Check Chrome Extension (Chrome)'
    $EdgePolicyName = 'Deploy Check Chrome Extension (Edge)'

    # Get configuration values with defaults
    $ShowNotifications = $Settings.showNotifications ?? $true
    $EnableValidPageBadge = $Settings.enableValidPageBadge ?? $true
    $EnablePageBlocking = $Settings.enablePageBlocking ?? $true
    $EnableCippReporting = $Settings.enableCippReporting ?? $true
    $CippServerUrl = $Settings.cippServerUrl
    $CippTenantId = $Settings.cippTenantId
    $CustomRulesUrl = $Settings.customRulesUrl
    $UpdateInterval = $Settings.updateInterval ?? 24
    $EnableDebugLogging = $Settings.enableDebugLogging ?? $false
    $CompanyName = $Settings.companyName
    $ProductName = $Settings.productName
    $SupportEmail = $Settings.supportEmail
    $PrimaryColor = $Settings.primaryColor ?? '#F77F00'
    $LogoUrl = $Settings.logoUrl

    # Create extension settings JSON
    $ChromeExtensionSettings = @{
        $ChromeExtensionId = @{
            installation_mode = 'force_installed'
            update_url        = 'https://clients2.google.com/service/update2/crx'
            settings          = @{
                showNotifications    = $ShowNotifications
                enableValidPageBadge = $EnableValidPageBadge
                enablePageBlocking   = $EnablePageBlocking
                enableCippReporting  = $EnableCippReporting
                cippServerUrl        = $CippServerUrl
                cippTenantId         = $CippTenantId
                customRulesUrl       = $CustomRulesUrl
                updateInterval       = $UpdateInterval
                enableDebugLogging   = $EnableDebugLogging
                customBranding       = @{
                    companyName  = $CompanyName
                    productName  = $ProductName
                    supportEmail = $SupportEmail
                    primaryColor = $PrimaryColor
                    logoUrl      = $LogoUrl
                }
            }
        }
    } | ConvertTo-Json -Depth 10

    $EdgeExtensionSettings = @{
        $EdgeExtensionId = @{
            installation_mode = 'force_installed'
            update_url        = 'https://edge.microsoft.com/extensionwebstorebase/v1/crx'
            settings          = @{
                showNotifications    = $ShowNotifications
                enableValidPageBadge = $EnableValidPageBadge
                enablePageBlocking   = $EnablePageBlocking
                enableCippReporting  = $EnableCippReporting
                cippServerUrl        = $CippServerUrl
                cippTenantId         = $CippTenantId
                customRulesUrl       = $CustomRulesUrl
                updateInterval       = $UpdateInterval
                enableDebugLogging   = $EnableDebugLogging
                customBranding       = @{
                    companyName  = $CompanyName
                    productName  = $ProductName
                    supportEmail = $SupportEmail
                    primaryColor = $PrimaryColor
                    logoUrl      = $LogoUrl
                }
            }
        }
    } | ConvertTo-Json -Depth 10

    # Create Chrome OMA-URI policy JSON
    $ChromePolicyJSON = @{
        '@odata.type' = '#microsoft.graph.windows10CustomConfiguration'
        displayName   = $ChromePolicyName
        description   = 'Deploys and configures the Check Chrome extension for Google Chrome browsers'
        omaSettings   = @(
            @{
                '@odata.type' = '#microsoft.graph.omaSettingString'
                displayName   = 'Chrome Extension Settings'
                description   = 'Configure Check Chrome extension settings'
                omaUri        = './Device/Vendor/MSFT/Policy/Config/Chrome~Policy~googlechrome/ExtensionSettings'
                value         = $ChromeExtensionSettings
            }
        )
    } | ConvertTo-Json -Depth 20

    # Create Edge OMA-URI policy JSON
    $EdgePolicyJSON = @{
        '@odata.type' = '#microsoft.graph.windows10CustomConfiguration'
        displayName   = $EdgePolicyName
        description   = 'Deploys and configures the Check Chrome extension for Microsoft Edge browsers'
        omaSettings   = @(
            @{
                '@odata.type' = '#microsoft.graph.omaSettingString'
                displayName   = 'Edge Extension Settings'
                description   = 'Configure Check Chrome extension settings'
                omaUri        = './Device/Vendor/MSFT/Policy/Config/Edge/ExtensionSettings'
                value         = $EdgeExtensionSettings
            }
        )
    } | ConvertTo-Json -Depth 20

    try {
        # Check if the policies already exist
        $ExistingPolicies = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations' -tenantid $Tenant
        $ChromePolicyExists = $ExistingPolicies.value | Where-Object { $_.displayName -eq $ChromePolicyName }
        $EdgePolicyExists = $ExistingPolicies.value | Where-Object { $_.displayName -eq $EdgePolicyName }

        if ($Settings.remediate -eq $true) {
            # Handle assignment configuration
            $AssignTo = $Settings.AssignTo ?? 'AllDevices'
            $ExcludeGroup = $Settings.ExcludeGroup

            # Handle custom group assignment
            if ($Settings.customGroup) {
                $AssignTo = $Settings.customGroup
            }

            # Deploy Chrome policy
            if (-not $ChromePolicyExists) {
                $Result = Set-CIPPIntunePolicy -TemplateType 'Device' -Description 'Deploys and configures the Check Chrome extension for Google Chrome browsers' -DisplayName $ChromePolicyName -RawJSON $ChromePolicyJSON -AssignTo $AssignTo -ExcludeGroup $ExcludeGroup -tenantFilter $Tenant
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully created Check Chrome Extension policy for Chrome: $ChromePolicyName" -sev Info
            } else {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Check Chrome Extension policy for Chrome already exists, skipping creation' -sev Info
            }

            # Deploy Edge policy
            if (-not $EdgePolicyExists) {
                $Result = Set-CIPPIntunePolicy -TemplateType 'Device' -Description 'Deploys and configures the Check Chrome extension for Microsoft Edge browsers' -DisplayName $EdgePolicyName -RawJSON $EdgePolicyJSON -AssignTo $AssignTo -ExcludeGroup $ExcludeGroup -tenantFilter $Tenant
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully created Check Chrome Extension policy for Edge: $EdgePolicyName" -sev Info
            } else {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Check Chrome Extension policy for Edge already exists, skipping creation' -sev Info
            }
        }

        if ($Settings.alert -eq $true) {
            $BothPoliciesExist = $ChromePolicyExists -and $EdgePolicyExists
            if ($BothPoliciesExist) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Check Chrome Extension policies are deployed for both Chrome and Edge' -sev Info
            } else {
                $MissingPolicies = @()
                if (-not $ChromePolicyExists) { $MissingPolicies += 'Chrome' }
                if (-not $EdgePolicyExists) { $MissingPolicies += 'Edge' }
                Write-StandardsAlert -message "Check Chrome Extension policies are missing for: $($MissingPolicies -join ', ')" -object @{ 'Missing Policies' = $MissingPolicies -join ',' } -tenant $Tenant -standardName 'DeployCheckChromeExtension' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Check Chrome Extension policies are missing for: $($MissingPolicies -join ', ')" -sev Alert
            }
        }

        if ($Settings.report -eq $true) {
            $StateIsCorrect = $ChromePolicyExists -and $EdgePolicyExists
            Set-CIPPStandardsCompareField -FieldName 'standards.DeployCheckChromeExtension' -FieldValue $StateIsCorrect -TenantFilter $Tenant
            Add-CIPPBPAField -FieldName 'DeployCheckChromeExtension' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        }

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to deploy Check Chrome Extension policies. Error: $ErrorMessage" -sev Error

        if ($Settings.alert -eq $true) {
            Write-StandardsAlert -message "Failed to deploy Check Chrome Extension policies: $ErrorMessage" -object @{ 'Error' = $ErrorMessage } -tenant $Tenant -standardName 'DeployCheckChromeExtension' -standardId $Settings.standardId
        }

        if ($Settings.report -eq $true) {
            Set-CIPPStandardsCompareField -FieldName 'standards.DeployCheckChromeExtension' -FieldValue @{ 'Error' = $ErrorMessage } -TenantFilter $Tenant
            Add-CIPPBPAField -FieldName 'DeployCheckChromeExtension' -FieldValue $false -StoreAs bool -Tenant $Tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDeployCheckChromeExtension.ps1' 233
#Region './Public/Standards/Invoke-CIPPStandardDeployContactTemplates.ps1' -1

function Invoke-CIPPStandardDeployContactTemplates {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DeployContactTemplates
    .SYNOPSIS
        (Label) Deploy Mail Contact Template
    .DESCRIPTION
        (Helptext) Creates new mail contacts in Exchange Online across all selected tenants based on the selected templates. The contact will be visible in the Global Address List unless hidden.
        (DocsDescription) This standard creates new mail contacts in Exchange Online based on the selected templates. Mail contacts are useful for adding external email addresses to your organization's address book. They can be used for distribution lists, shared mailboxes, and other collaboration scenarios.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Deploys standardized external contact templates across all company locations, ensuring consistent communication channels with key external partners, vendors, and stakeholders. This streamlines contact management and maintains uniform business relationships.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":true,"creatable":false,"label":"Select Mail Contact Templates","name":"standards.DeployContactTemplates.templateIds","api":{"url":"/api/ListContactTemplates","labelField":"name","valueField":"GUID","queryKey":"Contact Templates"}}
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-05-31
        POWERSHELLEQUIVALENT
            New-MailContact
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DeployContactTemplates' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $APIName = 'Standards'



    # Helper function to get template by GUID
    function Get-ContactTemplate($TemplateGUID) {
        try {
            $Table = Get-CippTable -tablename 'templates'
            $Filter = "PartitionKey eq 'ContactTemplate' and RowKey eq '$TemplateGUID'"
            $StoredTemplate = Get-CIPPAzDataTableEntity @Table -Filter $Filter

            if (-not $StoredTemplate) {
                Write-LogMessage -API $APIName -tenant $Tenant -message "Contact template with GUID $TemplateGUID not found" -sev Error
                return $null
            }

            return $StoredTemplate.JSON | ConvertFrom-Json
        }
        catch {
            Write-LogMessage -API $APIName -tenant $Tenant -message "Failed to retrieve template $TemplateGUID. Error: $($_.Exception.Message)" -sev Error
            return $null
        }
    }



    try {
        # Extract control flags from Settings
        $RemediateEnabled = [bool]$Settings.remediate
        $AlertEnabled = [bool]$Settings.alert
        $ReportEnabled = [bool]$Settings.report

        # Get templateIds array
        if (-not $Settings.templateIds -or $Settings.templateIds.Count -eq 0) {
            Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: No template IDs found in settings" -sev Error
            return "No template IDs found in settings"
        }

        Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: Processing $($Settings.templateIds.Count) template(s)" -sev Info

        # Get the current contacts
        $CurrentContacts = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailContact' -ErrorAction Stop

        # Process each template in the templateIds array
        $CompareList = foreach ($TemplateItem in $Settings.templateIds) {
            try {
                # Get the template GUID directly from the value property
                $TemplateGUID = $TemplateItem.value

                if ([string]::IsNullOrWhiteSpace($TemplateGUID)) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: TemplateGUID cannot be empty." -sev Error
                    continue
                }

                # Fetch the template from storage
                $Template = Get-ContactTemplate -TemplateGUID $TemplateGUID
                if (-not $Template) {
                    continue
                }

                # Input validation for required fields
                if ([string]::IsNullOrWhiteSpace($Template.displayName)) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: DisplayName cannot be empty for template $TemplateGUID." -sev Error
                    continue
                }

                if ([string]::IsNullOrWhiteSpace($Template.email)) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: ExternalEmailAddress cannot be empty for template $TemplateGUID." -sev Error
                    continue
                }

                # Validate email address format
                try {
                    $null = [System.Net.Mail.MailAddress]::new($Template.email)
                }
                catch {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: Invalid email address format: $($Template.email)" -sev Error
                    continue
                }

                # Check if the contact already exists (using DisplayName as key)
                $ExistingContact = $CurrentContacts | Where-Object { $_.DisplayName -eq $Template.displayName }

                # If the contact exists, we'll overwrite it; if not, we'll create it
                if ($ExistingContact) {
                    $StateIsCorrect = $false  # Always update existing contacts to match template
                    $Action = "Update"
                    $Missing = $false
                }
                else {
                    # Contact doesn't exist, needs to be created
                    $StateIsCorrect = $false
                    $Action = "Create"
                    $Missing = $true
                }

                [PSCustomObject]@{
                    missing         = $Missing
                    StateIsCorrect  = $StateIsCorrect
                    Action          = $Action
                    Template        = $Template
                    TemplateGUID    = $TemplateGUID
                }
            }
            catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                $Message = "Failed to process template $TemplateGUID, Error: $ErrorMessage"
                Write-LogMessage -API $APIName -tenant $tenant -message $Message -sev 'Error'
                Return $Message
            }
        }

        # Remediate each contact which needs to be created or updated
        If ($RemediateEnabled) {
            $ContactsToProcess = $CompareList | Where-Object { $_.StateIsCorrect -eq $false }

            if ($ContactsToProcess.Count -gt 0) {
                $ContactsToCreate = $ContactsToProcess | Where-Object { $_.Action -eq "Create" }
                $ContactsToUpdate = $ContactsToProcess | Where-Object { $_.Action -eq "Update" }

                Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: Processing $($ContactsToCreate.Count) new contacts, $($ContactsToUpdate.Count) existing contacts" -sev Info

                # First pass: Create new mail contacts and update existing ones
                $ProcessedContacts = [System.Collections.Generic.List[PSCustomObject]]::new()
                $ProcessingFailures = 0

                # Handle new contacts
                foreach ($Contact in $ContactsToCreate) {
                    try {
                        $Template = $Contact.Template

                        # Parameters for creating new contact
                        $NewContactParams = @{
                            displayName          = $Template.displayName
                            name                 = $Template.displayName
                            ExternalEmailAddress = $Template.email
                        }

                        # Add optional name fields if provided
                        if (![string]::IsNullOrWhiteSpace($Template.firstName)) {
                            $NewContactParams.FirstName = $Template.firstName
                        }
                        if (![string]::IsNullOrWhiteSpace($Template.lastName)) {
                            $NewContactParams.LastName = $Template.lastName
                        }

                        # Create the mail contact
                        $NewContact = New-ExoRequest -tenantid $Tenant -cmdlet 'New-MailContact' -cmdParams $NewContactParams -UseSystemMailbox $true

                        # Store contact info for second pass
                        $ProcessedContacts.Add([PSCustomObject]@{
                            Contact = $Contact
                            ContactObject = $NewContact
                            Template = $Template
                            IsNew = $true
                        })
                    }
                    catch {
                        $ProcessingFailures++
                        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                        Write-LogMessage -API $APIName -tenant $tenant -message "Failed to create contact $($Template.displayName): $ErrorMessage" -sev 'Error'
                    }
                }

                # Handle existing contacts - update their basic properties
                foreach ($Contact in $ContactsToUpdate) {
                    try {
                        $Template = $Contact.Template
                        $ExistingContact = $CurrentContacts | Where-Object { $_.DisplayName -eq $Template.displayName }

                        # Update MailContact properties (email address)
                        $UpdateMailContactParams = @{
                            Identity = $ExistingContact.Identity
                            ExternalEmailAddress = $Template.email
                        }

                        # Update the existing mail contact
                        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailContact' -cmdParams $UpdateMailContactParams -UseSystemMailbox $true

                        # Update Contact properties (names) if provided
                        $UpdateContactParams = @{
                            Identity = $ExistingContact.Identity
                        }
                        $ContactNeedsUpdate = $false

                        if (![string]::IsNullOrWhiteSpace($Template.firstName)) {
                            $UpdateContactParams.FirstName = $Template.firstName
                            $ContactNeedsUpdate = $true
                        }
                        if (![string]::IsNullOrWhiteSpace($Template.lastName)) {
                            $UpdateContactParams.LastName = $Template.lastName
                            $ContactNeedsUpdate = $true
                        }

                        # Only update Contact if we have name changes
                        if ($ContactNeedsUpdate) {
                            $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Contact' -cmdParams $UpdateContactParams -UseSystemMailbox $true
                        }

                        # Store contact info for second pass
                        $ProcessedContacts.Add([PSCustomObject]@{
                            Contact = $Contact
                            ContactObject = $ExistingContact
                            Template = $Template
                            IsNew = $false
                        })
                    }
                    catch {
                        $ProcessingFailures++
                        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                        Write-LogMessage -API $APIName -tenant $tenant -message "Failed to update contact $($Template.displayName): $ErrorMessage" -sev 'Error'
                    }
                }

                # Log processing summary
                $ProcessedCount = $ProcessedContacts.Count
                if ($ProcessedCount -gt 0) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: Successfully processed $ProcessedCount contacts" -sev Info

                    # Wait for contacts to propagate before updating additional fields
                    Start-Sleep -Seconds 1

                    # Second pass: Update contacts with additional fields (only if needed)
                    $UpdateFailures = 0
                    $ContactsRequiringUpdates = 0

                    foreach ($ProcessedContactInfo in $ProcessedContacts) {
                        try {
                            $Template = $ProcessedContactInfo.Template
                            $ContactObject = $ProcessedContactInfo.ContactObject
                            $HasUpdates = $false

                            # Check if Set-Contact is needed
                            $ContactIdentity = if ($ProcessedContactInfo.IsNew) { $ContactObject.id } else { $ContactObject.Identity }
                            $SetContactParams = @{ Identity = $ContactIdentity }
                            $PropertyMap = @{
                                'Company'         = $Template.companyName
                                'StateOrProvince' = $Template.state
                                'Office'          = $Template.streetAddress
                                'Phone'           = $Template.businessPhone
                                'WebPage'         = $Template.website
                                'Title'           = $Template.jobTitle
                                'City'            = $Template.city
                                'PostalCode'      = $Template.postalCode
                                'CountryOrRegion' = $Template.country
                                'MobilePhone'     = $Template.mobilePhone
                            }

                            foreach ($Property in $PropertyMap.GetEnumerator()) {
                                if (![string]::IsNullOrWhiteSpace($Property.Value)) {
                                    $SetContactParams[$Property.Key] = $Property.Value
                                    $HasUpdates = $true
                                }
                            }

                            # Check if Set-MailContact is needed for additional properties
                            $MailContactParams = @{ Identity = $ContactIdentity }
                            $NeedsMailContactUpdate = $false

                            if ([bool]$Template.hidefromGAL) {
                                $MailContactParams.HiddenFromAddressListsEnabled = $true
                                $NeedsMailContactUpdate = $true
                                $HasUpdates = $true
                            }

                            if (![string]::IsNullOrWhiteSpace($Template.mailTip)) {
                                $MailContactParams.MailTip = $Template.mailTip
                                $NeedsMailContactUpdate = $true
                                $HasUpdates = $true
                            }

                            # Only increment and update if there are actual changes
                            if ($HasUpdates) {
                                $ContactsRequiringUpdates++

                                # Apply Set-Contact updates if needed
                                if ($SetContactParams.Count -gt 1) {
                                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-Contact' -cmdParams $SetContactParams -UseSystemMailbox $true
                                }

                                # Apply Set-MailContact updates if needed
                                if ($NeedsMailContactUpdate) {
                                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailContact' -cmdParams $MailContactParams -UseSystemMailbox $true
                                }
                            }
                        }
                        catch {
                            $UpdateFailures++
                            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                            Write-LogMessage -API $APIName -tenant $tenant -message "Failed to update additional fields for contact $($Template.displayName): $ErrorMessage" -sev 'Error'
                        }
                    }

                    # Log update summary only if updates were needed
                    if ($ContactsRequiringUpdates -gt 0) {
                        $SuccessfulUpdates = $ContactsRequiringUpdates - $UpdateFailures
                        Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: Updated additional fields for $SuccessfulUpdates of $ContactsRequiringUpdates contacts" -sev Info
                    }
                }

                # Final summary
                if ($ProcessingFailures -gt 0) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: $ProcessingFailures contacts failed to process" -sev Error
                }
            }
        }

        if ($AlertEnabled) {
            $MissingContacts = ($CompareList | Where-Object { $_.missing }).Count
            $ExistingContacts = ($CompareList | Where-Object { -not $_.missing }).Count

            if ($MissingContacts -gt 0 -or $ExistingContacts -gt 0) {
                foreach ($Contact in $CompareList) {
                    if ($Contact.missing) {
                        $CurrentInfo = $Contact.Template | Select-Object -Property displayName, email, missing
                        Write-StandardsAlert -message "Mail contact $($Contact.Template.displayName) from template $($Contact.TemplateGUID) is missing." -object $CurrentInfo -tenant $Tenant -standardName 'DeployContactTemplate'
                    }
                    else {
                        $CurrentInfo = $CurrentContacts | Where-Object -Property DisplayName -eq $Contact.Template.displayName | Select-Object -Property DisplayName, ExternalEmailAddress, FirstName, LastName
                        Write-StandardsAlert -message "Mail contact $($Contact.Template.displayName) from template $($Contact.TemplateGUID) will be updated to match template." -object $CurrentInfo -tenant $Tenant -standardName 'DeployContactTemplate'
                    }
                }
                Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: $MissingContacts missing, $ExistingContacts to update" -sev Info
            } else {
                Write-LogMessage -API $APIName -tenant $Tenant -message "DeployContactTemplate: No contacts need processing" -sev Info
            }
        }

        if ($ReportEnabled) {
            foreach ($Contact in $CompareList) {
                Set-CIPPStandardsCompareField -FieldName "standards.DeployContactTemplate" -FieldValue $Contact.StateIsCorrect -TenantFilter $Tenant
            }
        }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API $APIName -tenant $tenant -message "Failed to create or update mail contact(s) from templates, Error: $ErrorMessage" -sev 'Error'
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDeployContactTemplates.ps1' 383
#Region './Public/Standards/Invoke-CIPPStandardDeployMailContact.ps1' -1

function Invoke-CIPPStandardDeployMailContact {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DeployMailContact
    .SYNOPSIS
        (Label) Deploy Mail Contact
    .DESCRIPTION
        (Helptext) Creates a new mail contact in Exchange Online across all selected tenants. The contact will be visible in the Global Address List.
        (DocsDescription) This standard creates a new mail contact in Exchange Online. Mail contacts are useful for adding external email addresses to your organization's address book. They can be used for distribution lists, shared mailboxes, and other collaboration scenarios.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Automatically creates external email contacts in the organization's address book, enabling seamless communication with external partners and vendors. This standardizes contact management across all company locations and improves collaboration efficiency.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.DeployMailContact.ExternalEmailAddress","label":"External Email Address","required":true}
            {"type":"textField","name":"standards.DeployMailContact.DisplayName","label":"Display Name","required":true}
            {"type":"textField","name":"standards.DeployMailContact.FirstName","label":"First Name","required":false}
            {"type":"textField","name":"standards.DeployMailContact.LastName","label":"Last Name","required":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-19
        POWERSHELLEQUIVALENT
            New-MailContact
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DeployMailContact' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Input validation
    if ([string]::IsNullOrWhiteSpace($Settings.DisplayName)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'DeployMailContact: DisplayName cannot be empty or just whitespace.' -sev Error
        return
    }

    try {
        $null = [System.Net.Mail.MailAddress]::new($Settings.ExternalEmailAddress)
    }
    catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "DeployMailContact: Invalid email address format: $($Settings.ExternalEmailAddress)" -sev Error
        return
    }

    # Prepare contact data for reuse
    $ContactData = @{
        DisplayName          = $Settings.DisplayName
        ExternalEmailAddress = $Settings.ExternalEmailAddress
        FirstName            = $Settings.FirstName
        LastName             = $Settings.LastName
    }

    # Check if contact already exists
    try {
        $ExistingContact = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailContact' -cmdParams @{
            Identity    = $Settings.ExternalEmailAddress
            ErrorAction = 'Stop'
        }
    }
    catch {
        if ($_.Exception.Message -like "*couldn't be found*") {
            $ExistingContact = $null
        }
        else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Error checking for existing mail contact: $(Get-CippException -Exception $_).NormalizedError" -sev Error
            return
        }
    }

    # Remediation
    if ($Settings.remediate -eq $true -and -not $ExistingContact) {
        try {
            $NewContactParams = $ContactData.Clone()
            $NewContactParams.Name = $Settings.DisplayName
            $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-MailContact' -cmdParams $NewContactParams
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully created mail contact $($Settings.DisplayName) with email $($Settings.ExternalEmailAddress)" -sev Info
        }
        catch {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not create mail contact. $(Get-CippException -Exception $_).NormalizedError" -sev Error
        }
    }

    # Alert
    if ($Settings.alert -eq $true) {
        if ($ExistingContact) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Mail contact $($Settings.DisplayName) already exists" -sev Info
        }
        else {
            Write-StandardsAlert -message "Mail contact $($Settings.DisplayName) needs to be created" -object $ContactData -tenant $Tenant -standardName 'DeployMailContact' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Mail contact $($Settings.DisplayName) needs to be created" -sev Info
        }
    }

    # Report
    if ($Settings.report -eq $true) {
        $ReportData = $ContactData.Clone()
        $ReportData.Exists = [bool]$ExistingContact
        Add-CIPPBPAField -FieldName 'DeployMailContact' -FieldValue $ReportData -StoreAs json -Tenant $Tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.DeployMailContact' -FieldValue $($ExistingContact ? $true : $ReportData) -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDeployMailContact.ps1' 116
#Region './Public/Standards/Invoke-CIPPStandardDisableAdditionalStorageProviders.ps1' -1

function Invoke-CIPPStandardDisableAdditionalStorageProviders {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableAdditionalStorageProviders
    .SYNOPSIS
        (Label) Disable additional storage providers in OWA
    .DESCRIPTION
        (Helptext) Disables the ability for users to open files in Outlook on the Web, from other providers such as Box, Dropbox, Facebook, Google Drive, OneDrive Personal, etc.
        (DocsDescription) Disables additional storage providers in OWA. This is to prevent users from using personal storage providers like Dropbox, Google Drive, etc. Usually this has little user impact.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.5.3)"
            "exo_storageproviderrestricted"
        EXECUTIVETEXT
            Prevents employees from accessing personal cloud storage services like Dropbox or Google Drive through Outlook on the web, reducing data security risks and ensuring company information stays within approved corporate systems. This helps maintain data governance and prevents accidental data leaks.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-17
        POWERSHELLEQUIVALENT
            Get-OwaMailboxPolicy \| Set-OwaMailboxPolicy -AdditionalStorageProvidersEnabled \$False
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableAdditionalStorageProviders' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableAdditionalStorageProviders'

    try {
        $AdditionalStorageProvidersState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OwaMailboxPolicy' -cmdParams @{Identity = 'OwaMailboxPolicy-Default' } -Select 'Identity, AdditionalStorageProvidersAvailable'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableAddShortcutsToOneDrive state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        try {
            if ($AdditionalStorageProvidersState.AdditionalStorageProvidersAvailable) {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OwaMailboxPolicy' -cmdParams @{ Identity = $AdditionalStorageProvidersState.Identity; AdditionalStorageProvidersAvailable = $false } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'OWA additional storage providers has been disabled.' -sev Info
                $AdditionalStorageProvidersState.AdditionalStorageProvidersAvailable = $false
            } else {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'OWA additional storage providers are already disabled.' -sev Info
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable OWA additional storage providers. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }

    }

    if ($Settings.alert -eq $true) {
        if ($AdditionalStorageProvidersState.AdditionalStorageProvidersAvailable) {
            $Object = $AdditionalStorageProvidersState | Select-Object -Property AdditionalStorageProvidersAvailable
            Write-StandardsAlert -message 'OWA additional storage providers are enabled' -object $Object -tenant $Tenant -standardName 'DisableAdditionalStorageProviders' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'OWA additional storage providers are enabled' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'OWA additional storage providers are disabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $State = $AdditionalStorageProvidersState.AdditionalStorageProvidersEnabled ? $false : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableAdditionalStorageProviders' -FieldValue $State -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AdditionalStorageProvidersEnabled' -FieldValue $State -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableAdditionalStorageProviders.ps1' 86
#Region './Public/Standards/Invoke-CIPPStandardDisableAddShortcutsToOneDrive.ps1' -1

function Invoke-CIPPStandardDisableAddShortcutsToOneDrive {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableAddShortcutsToOneDrive
    .SYNOPSIS
        (Label) Set Add Shortcuts To OneDrive button state
    .DESCRIPTION
        (Helptext) If disabled, the button Add shortcut to OneDrive will be removed and users in the tenant will no longer be able to add new shortcuts to their OneDrive. Existing shortcuts will remain functional
        (DocsDescription) If disabled, the button Add shortcut to OneDrive will be removed and users in the tenant will no longer be able to add new shortcuts to their OneDrive. Existing shortcuts will remain functional
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Controls whether employees can create shortcuts to SharePoint libraries in their OneDrive, managing how users organize and access shared content. This setting helps maintain organized file structures and can prevent confusion from excessive shortcuts while preserving existing workflows.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Add Shortcuts To OneDrive button state","name":"standards.DisableAddShortcutsToOneDrive.state","options":[{"label":"Disabled","value":"true"},{"label":"Enabled","value":"false"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-07-25
        POWERSHELLEQUIVALENT
            Set-SPOTenant -DisableAddShortcutsToOneDrive \$true or \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableAddShortcutsToOneDrive' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableAddShortcutsToOneDrive'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object _ObjectIdentity_, TenantFilter, DisableAddToOneDrive
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableAddShortcutsToOneDrive state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Input validation
    $StateValue = $Settings.state.value ?? $Settings.state
    if (([string]::IsNullOrWhiteSpace($StateValue) -or $StateValue -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'DisableAddShortcutsToOneDrive: Invalid state parameter set' -sev Error
        Return
    }

    $WantedState = [System.Convert]::ToBoolean($StateValue)
    $StateIsCorrect = if ($CurrentState.DisableAddToOneDrive -eq $WantedState) { $true } else { $false }
    $HumanReadableState = if ($WantedState -eq $true) { 'disabled' } else { 'enabled' }

    if ($Settings.report -eq $true) {
        if ($StateIsCorrect -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object -Property DisableAddToOneDrive
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableAddShortcutsToOneDrive' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'OneDriveAddShortcutButtonDisabled' -FieldValue $CurrentState.DisableAddToOneDrive -StoreAs bool -Tenant $Tenant
    }

    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($StateIsCorrect -eq $false) {
            try {
                $CurrentState | Set-CIPPSPOTenant -Properties @{DisableAddToOneDrive = $WantedState }
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set the Add Shortcuts To OneDrive Button to $HumanReadableState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set the Add Shortcuts To OneDrive Button to $HumanReadableState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The Add Shortcuts To OneDrive Button is already set to the wanted of $HumanReadableState" -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The Add Shortcuts To OneDrive Button is already set to the wanted state of $HumanReadableState" -sev Info
        } else {
            Write-StandardsAlert -message "The Add Shortcuts To OneDrive Button is not set to the wanted state of $HumanReadableState" -object $CurrentState -tenant $tenant -standardName 'DisableAddShortcutsToOneDrive' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The Add Shortcuts To OneDrive Button Button is not set to the wanted state of $HumanReadableState" -sev Info
        }
    }


}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableAddShortcutsToOneDrive.ps1' 101
#Region './Public/Standards/Invoke-CIPPStandardDisableAppCreation.ps1' -1

function Invoke-CIPPStandardDisableAppCreation {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableAppCreation
    .SYNOPSIS
        (Label) Disable App creation by users
    .DESCRIPTION
        (Helptext) Disables the ability for users to create App registrations in the tenant.
        (DocsDescription) Disables the ability for users to create applications in Entra. Done to prevent breached accounts from creating an app to maintain access to the tenant, even after the breached account has been secured.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.2.2)"
            "CISA (MS.AAD.4.1v1)"
            "EIDSCA.AP10"
            "Essential 8 (1175)"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Prevents regular employees from creating application registrations that could be used to maintain unauthorized access to company systems. This security measure ensures that only authorized IT personnel can create applications, reducing the risk of persistent security breaches through malicious applications.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-20
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthorizationPolicy
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableAppCreation'


    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy?$select=defaultUserRolePermissions' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableAppCreation state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        if ($CurrentInfo.defaultUserRolePermissions.allowedToCreateApps -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are already not allowed to create App registrations.' -sev Info
        } else {
            try {
                $body = '{"defaultUserRolePermissions":{"allowedToCreateApps":false}}'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled users from creating App registrations.' -sev Info
                $CurrentInfo.defaultUserRolePermissions.allowedToCreateApps = $false
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable users from creating App registrations: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.defaultUserRolePermissions.allowedToCreateApps -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are not allowed to create App registrations.' -sev Info
        } else {
            Write-StandardsAlert -message 'Users are allowed to create App registrations.' -object $CurrentInfo -tenant $tenant -standardName 'DisableAppCreation' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are allowed to create App registrations.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $State = -not $CurrentInfo.defaultUserRolePermissions.allowedToCreateApps
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableAppCreation' -FieldValue $State -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'UserAppCreationDisabled' -FieldValue $State -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableAppCreation.ps1' 84
#Region './Public/Standards/Invoke-CIPPStandardDisableBasicAuth.ps1' -1

function Invoke-CIPPStandardDisableBasicAuth {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    Write-LogMessage -API 'Standards' -tenant $tenant -message "Basic Authentication is disabled by default. SMTP authentication is still allowed. Please use the standard 'Disable SMTP Basic Authentication' to disable" -sev Info
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableBasicAuth.ps1' 9
#Region './Public/Standards/Invoke-CIPPStandardDisableBasicAuthSMTP.ps1' -1

function Invoke-CIPPStandardDisableBasicAuthSMTP {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableBasicAuthSMTP
    .SYNOPSIS
        (Label) Disable SMTP Basic Authentication
    .DESCRIPTION
        (Helptext) Disables SMTP AUTH organization-wide, impacting POP and IMAP clients that rely on SMTP for sending emails. Default for new tenants. For more information, see the [Microsoft documentation](https://learn.microsoft.com/en-us/exchange/clients-and-mobile-in-exchange-online/authenticated-client-smtp-submission)
        (DocsDescription) Disables tenant-wide SMTP basic authentication, including for all explicitly enabled users, impacting POP and IMAP clients that rely on SMTP for sending emails. For more information, see the [Microsoft documentation](https://learn.microsoft.com/en-us/exchange/clients-and-mobile-in-exchange-online/authenticated-client-smtp-submission).
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (6.5.4)"
            "NIST CSF 2.0 (PR.IR-01)"
        EXECUTIVETEXT
            Disables outdated email authentication methods that are vulnerable to security attacks, forcing applications and devices to use modern, more secure authentication protocols. This reduces the risk of email-based security breaches and credential theft.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-TransportConfig -SmtpClientAuthenticationDisabled \$true
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableBasicAuthSMTP' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableBasicAuthSMTP'

    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-TransportConfig'

        $SMTPusers = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-CASMailbox' -cmdParams @{ ResultSize = 'Unlimited' } |
        Where-Object { ($_.SmtpClientAuthenticationDisabled -eq $false) }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableBasicAuthSMTP state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentInfo.SmtpClientAuthenticationDisabled -and $SMTPusers.Count -eq 0) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SMTP Basic Authentication for tenant and all users is already disabled' -sev Info
        } else {
            # Disable SMTP Basic Authentication for the tenant
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-TransportConfig' -cmdParams @{ SmtpClientAuthenticationDisabled = $true }
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled SMTP Basic Authentication' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable SMTP Basic Authentication. Error: $ErrorMessage" -sev Error
            }

            # Disable SMTP Basic Authentication for all users
            $SMTPusers | ForEach-Object {
                try {
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-CASMailbox' -cmdParams @{ Identity = $_.Guid; SmtpClientAuthenticationDisabled = $null } -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Disabled SMTP Basic Authentication for $($_.DisplayName), $($_.PrimarySmtpAddress)" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable SMTP Basic Authentication for $($_.DisplayName), $($_.PrimarySmtpAddress). Error: $ErrorMessage" -sev Error
                }
            }
        }
    }

    $LogMessage = [System.Collections.Generic.List[string]]::new()
    if ($Settings.alert -eq $true -or $Settings.report -eq $true) {

        # Build the log message for use in the alert and report
        if ($CurrentInfo.SmtpClientAuthenticationDisabled) {
            $LogMessage.add('SMTP Basic Authentication for tenant is disabled. ')
        } else {
            $LogMessage.add('SMTP Basic Authentication for tenant is not disabled. ')
        }
        if ($SMTPusers.Count -eq 0) {
            $LogMessage.add('SMTP Basic Authentication for all users is disabled')
        } else {
            $LogMessage.add("SMTP Basic Authentication for the following $($SMTPusers.Count) users is not disabled: $($SMTPusers.PrimarySmtpAddress -join ', ')")
        }

        if ($Settings.alert -eq $true) {

            if ($CurrentInfo.SmtpClientAuthenticationDisabled -and $SMTPusers.Count -eq 0) {
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'SMTP Basic Authentication for tenant and all users is disabled' -sev Info
            } else {
                Write-StandardsAlert -message ($LogMessage -join '') -object @{TenantSMTPAuthDisabled = $CurrentInfo.SmtpClientAuthenticationDisabled; UsersWithSMTPAuthEnabled = $SMTPusers.Count } -tenant $tenant -standardName 'DisableBasicAuthSMTP' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $tenant -message ($LogMessage -join '') -sev Info
            }
        }

        if ($Settings.report -eq $true) {
            if ($CurrentInfo.SmtpClientAuthenticationDisabled -and $SMTPusers.Count -eq 0) {
                Set-CIPPStandardsCompareField -FieldName 'standards.DisableBasicAuthSMTP' -FieldValue $true -TenantFilter $Tenant
                Add-CIPPBPAField -FieldName 'DisableBasicAuthSMTP' -FieldValue $CurrentInfo.SmtpClientAuthenticationDisabled -StoreAs bool -Tenant $tenant
            } else {
                $Logs = $LogMessage | Select-Object @{n = 'Message'; e = { $_ } }
                Set-CIPPStandardsCompareField -FieldName 'standards.DisableBasicAuthSMTP' -FieldValue $logs -TenantFilter $Tenant
                Add-CIPPBPAField -FieldName 'DisableBasicAuthSMTP' -FieldValue $Logs -StoreAs json -Tenant $tenant
            }
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableBasicAuthSMTP.ps1' 122
#Region './Public/Standards/Invoke-CIPPStandardDisableEmail.ps1' -1

function Invoke-CIPPStandardDisableEmail {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableEmail
    .SYNOPSIS
        (Label) Disables Email as an MFA method
    .DESCRIPTION
        (Helptext) This blocks users from using email as an MFA method. This disables the email OTP option for guest users, and instead prompts them to create a Microsoft account.
        (DocsDescription) This blocks users from using email as an MFA method. This disables the email OTP option for guest users, and instead prompts them to create a Microsoft account.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (2.3.5)"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Disables email-based authentication codes due to security concerns with email interception and account compromise. This forces users to adopt more secure authentication methods, particularly affecting guest users who must use stronger verification methods.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableEmail'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/Email' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableEmail state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'disabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Email authentication method is already disabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'Email' -Enabled $false
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Email authentication method is not enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Email authentication method is enabled' -object $CurrentState -tenant $tenant -standardName 'DisableEmail' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Email authentication method is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect -eq $true ? $true :  $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableEmail' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableEmail' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableEmail.ps1' 73
#Region './Public/Standards/Invoke-CIPPStandardDisableEntraPortal.ps1' -1

function Invoke-CIPPStandardDisableEntraPortal {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableEntraPortal
    .SYNOPSIS
        (Label) Disables the Entra Portal for standard users
        https://docs.cipp.app/user-documentation/tenant/standards/edit-standards
    #>

    param($Tenant, $Settings)
    #$Rerun -Type Standard -Tenant $Tenant -API 'allowOTPTokens' -Settings $Settings
    #This standard is still unlisted due to MS fixing some permissions. This will be added to the list once it is fixed.
    try {
        $CurrentInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/admin/entra/uxSetting' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableEntraPortal state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        if ($CurrentInfo.restrictNonAdminAccess) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disable user access to Entra Portal is already enabled.' -sev Info
        } else {
            New-GraphPOSTRequest -uri 'https://graph.microsoft.com/beta/admin/entra/uxSetting' -tenantid $Tenant -body '{"restrictNonAdminAccess":true}' -type PATCH
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.isSoftwareOathEnabled) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disable user access to Entra Portal is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Disable user access to Entra Portal is not enabled' -object $CurrentInfo -tenant $tenant -standardName 'DisableEntraPortal' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disable user access to Entra Portal is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        set-CIPPStandardsCompareField -FieldName 'standards.DisableEntraPortal' -FieldValue $CurrentInfo.isSoftwareOathEnabled -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableEntraPortal' -FieldValue $CurrentInfo.isSoftwareOathEnabled -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableEntraPortal.ps1' 47
#Region './Public/Standards/Invoke-CIPPStandardDisableExchangeOnlinePowerShell.ps1' -1

function Invoke-CIPPStandardDisableExchangeOnlinePowerShell {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableExchangeOnlinePowerShell
    .SYNOPSIS
        (Label) Disable Exchange Online PowerShell for non-admin users
    .DESCRIPTION
        (Helptext) Disables Exchange Online PowerShell access for non-admin users by setting the RemotePowerShellEnabled property to false for each user. This helps prevent attackers from using PowerShell to run malicious commands, access file systems, registry, and distribute ransomware throughout networks. Users with admin roles are automatically excluded.
        (DocsDescription) Disables Exchange Online PowerShell access for non-admin users by setting the RemotePowerShellEnabled property to false for each user. This security measure follows a least privileged access approach, preventing potential attackers from using PowerShell to execute malicious commands, access sensitive systems, or distribute malware. Users with management roles containing 'Admin' are automatically excluded to ensure administrators retain PowerShell access to perform necessary management tasks.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.1.1)"
            "Security"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Restricts PowerShell access to Exchange Online for regular employees while maintaining access for administrators, significantly reducing security risks from compromised accounts. This prevents attackers from using PowerShell to execute malicious commands or distribute ransomware while preserving necessary administrative capabilities.
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-06-19
        POWERSHELLEQUIVALENT
            Set-User -Identity \$user -RemotePowerShellEnabled \$false
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableExchangeOnlinePowerShell' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableExchangeOnlinePowerShell'

    try {

        $AdminUsers = (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/roleManagement/directory/roleAssignments?$expand=principal' -tenantid $Tenant).principal.userPrincipalName
        $UsersWithPowerShell = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-User' -Select 'userPrincipalName, identity, guid, remotePowerShellEnabled' | Where-Object { $_.RemotePowerShellEnabled -eq $true -and $_.userPrincipalName -notin $AdminUsers }
        $PowerShellEnabledCount = ($UsersWithPowerShell | Measure-Object).Count
        $StateIsCorrect = $PowerShellEnabledCount -eq 0
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not check Exchange Online PowerShell status. $($ErrorMessage.NormalizedError)" -sev Error
        $StateIsCorrect = $null
    }

    if ($Settings.remediate -eq $true) {
        if ($PowerShellEnabledCount -gt 0) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Started disabling Exchange Online PowerShell for $PowerShellEnabledCount users." -sev Info

            $Request = $UsersWithPowerShell | ForEach-Object {
                @{
                    CmdletInput = @{
                        CmdletName = 'Set-User'
                        Parameters = @{Identity = $_.Guid; RemotePowerShellEnabled = $false }
                    }
                }
            }

            $BatchResults = New-ExoBulkRequest -tenantid $tenant -cmdletArray @($Request)
            $SuccessCount = 0
            $BatchResults | ForEach-Object {
                if ($_.error) {
                    $ErrorMessage = Get-NormalizedError -Message $_.error
                    Write-Host "Failed to disable Exchange Online PowerShell for $($_.target). Error: $ErrorMessage"
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable Exchange Online PowerShell for $($_.target). Error: $ErrorMessage" -sev Error
                } else {
                    $SuccessCount++
                }
            }

            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully disabled Exchange Online PowerShell for $SuccessCount out of $PowerShellEnabledCount users." -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Exchange Online PowerShell is already disabled for all non-admin users' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Exchange Online PowerShell is disabled for all non-admin users.' -sev Info
        } else {
            Write-StandardsAlert -message "Exchange Online PowerShell is enabled for $PowerShellEnabledCount users" -object @{UsersWithPowerShellEnabled = $PowerShellEnabledCount } -tenant $tenant -standardName 'DisableExchangeOnlinePowerShell' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Exchange Online PowerShell is enabled for $PowerShellEnabledCount users." -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ?? @{UsersWithPowerShellEnabled = $PowerShellEnabledCount }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableExchangeOnlinePowerShell' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'ExchangeOnlinePowerShellDisabled' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableExchangeOnlinePowerShell.ps1' 103
#Region './Public/Standards/Invoke-CIPPStandardDisableExternalCalendarSharing.ps1' -1

function Invoke-CIPPStandardDisableExternalCalendarSharing {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableExternalCalendarSharing
    .SYNOPSIS
        (Label) Disable external calendar sharing
    .DESCRIPTION
        (Helptext) Disables the ability for users to share their calendar with external users. Only for the default policy, so exclusions can be made if needed.
        (DocsDescription) Disables external calendar sharing for the entire tenant. This is not a widely used feature, and it's therefore unlikely that this will impact users. Only for the default policy, so exclusions can be made if needed by making a new policy and assigning it to users.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (1.3.3)"
            "exo_individualsharing"
        EXECUTIVETEXT
            Prevents employees from sharing their calendars with external parties, protecting sensitive meeting information and internal schedules from unauthorized access. This security measure helps maintain confidentiality of business activities while still allowing internal collaboration.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-08
        POWERSHELLEQUIVALENT
            Get-SharingPolicy \| Set-SharingPolicy -Enabled \$False
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableExternalCalendarSharing' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableExternalCalendarSharing'

    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SharingPolicy' |
        Where-Object { $_.Default -eq $true }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableExternalCalendarSharing state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($CurrentInfo.Enabled) {
            $CurrentInfo | ForEach-Object {
                try {
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SharingPolicy' -cmdParams @{ Identity = $_.Id ; Enabled = $false } -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully disabled external calendar sharing for the policy $($_.Name)" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable external calendar sharing for the policy $($_.Name). Error: $ErrorMessage" -sev Error
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'External calendar sharing is already disabled' -sev Info

        }

    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.Enabled) {
            Write-StandardsAlert -message 'External calendar sharing is enabled' -object ($CurrentInfo | Select-Object enabled) -tenant $tenant -standardName 'DisableExternalCalendarSharing' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'External calendar sharing is enabled' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'External calendar sharing is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $CurrentInfo.Enabled = -not $CurrentInfo.Enabled
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableExternalCalendarSharing' -FieldValue $CurrentInfo.Enabled -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'ExternalCalendarSharingDisabled' -FieldValue $CurrentInfo.Enabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableExternalCalendarSharing.ps1' 87
#Region './Public/Standards/Invoke-CIPPStandardDisableGuestDirectory.ps1' -1

function Invoke-CIPPStandardDisableGuestDirectory {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableGuestDirectory
    .SYNOPSIS
        (Label) Restrict guest user access to directory objects
    .DESCRIPTION
        (Helptext) Disables Guest access to enumerate directory objects. This prevents guest users from seeing other users or guests in the directory.
        (DocsDescription) Sets it so guests can view only their own user profile. Permission to view other users isn't allowed. Also restricts guest users from seeing the membership of groups they're in. See exactly what get locked down in the [Microsoft documentation.](https://learn.microsoft.com/en-us/entra/fundamentals/users-default-permissions)
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (5.1.6.2)"
            "CISA (MS.AAD.5.1v1)"
            "EIDSCA.AP14"
            "EIDSCA.ST08"
            "EIDSCA.ST09"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Restricts external guest users from viewing the company's employee directory and organizational structure, protecting sensitive information about staff and internal groups. This security measure prevents unauthorized access to corporate contact information while still allowing necessary collaboration.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-05-04
        POWERSHELLEQUIVALENT
            Set-AzureADMSAuthorizationPolicy -GuestUserRoleId '2af84b1e-32c8-42b7-82bc-daa82404023b'
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableGuestDirectory'

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableGuestDirectory state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($CurrentInfo.guestUserRoleId -eq '2af84b1e-32c8-42b7-82bc-daa82404023b') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guest access to directory information is already disabled.' -sev Info
        } else {
            try {
                $body = '{guestUserRoleId: "2af84b1e-32c8-42b7-82bc-daa82404023b"}'
                New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled Guest access to directory information.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable Guest access to directory information.: $ErrorMessage" -sev 'Error'
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.guestUserRoleId -eq '2af84b1e-32c8-42b7-82bc-daa82404023b') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guest access to directory information is disabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Guest access to directory information is not disabled.' -object $CurrentInfo -tenant $tenant -standardName 'DisableGuestDirectory' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guest access to directory information is not disabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($CurrentInfo.guestUserRoleId -eq '2af84b1e-32c8-42b7-82bc-daa82404023b') { $CurrentInfo.guestUserRoleId = $true } else { $CurrentInfo.guestUserRoleId = $false }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableGuestDirectory' -FieldValue $CurrentInfo.guestUserRoleId -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableGuestDirectory' -FieldValue $CurrentInfo.guestUserRoleId -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableGuestDirectory.ps1' 83
#Region './Public/Standards/Invoke-CIPPStandardDisableGuests.ps1' -1

function Invoke-CIPPStandardDisableGuests {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableGuests
    .SYNOPSIS
        (Label) Disable Guest accounts that have not logged on for a number of days
    .DESCRIPTION
        (Helptext) Blocks login for guest users that have not logged in for a number of days
        (DocsDescription) Blocks login for guest users that have not logged in for a number of days
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Automatically disables external guest accounts that haven't been used for a number of days, reducing security risks from dormant accounts while maintaining access for active external collaborators. This helps maintain a clean user directory and reduces potential attack vectors.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.DisableGuests.days","required":true,"defaultValue":90,"label":"Days of inactivity"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2022-10-20
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableGuests' -TenantFilter $Tenant -RequiredCapabilities @('AAD_PREMIUM', 'AAD_PREMIUM_P2')

    if ($TestResult -eq $false) {
        #writing to each item that the license is not present.
        $settings.TemplateList | ForEach-Object {
            Set-CIPPStandardsCompareField -FieldName 'standards.DisableGuests' -FieldValue 'This tenant does not have the required license for this standard.' -Tenant $Tenant
        }
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $checkDays = if ($Settings.days) { $Settings.days } else { 90 } # Default to 90 days if not set. Pre v8.5.0 compatibility
    $Days = (Get-Date).AddDays(-$checkDays).ToUniversalTime()
    $Lookup = $Days.ToString('o')
    $AuditLookup = (Get-Date).AddDays(-7).ToUniversalTime().ToString('o')

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$filter=createdDateTime le $Lookup and userType eq 'Guest' and accountEnabled eq true &`$select=id,UserPrincipalName,signInActivity,mail,userType,accountEnabled,createdDateTime,externalUserState" -scope 'https://graph.microsoft.com/.default' -tenantid $Tenant |
            Where-Object { $_.signInActivity.lastSuccessfulSignInDateTime -le $Days }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableGuests state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $RecentlyReactivatedUsers = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/auditLogs/directoryAudits?`$filter=activityDisplayName eq 'Enable account' and activityDateTime ge $AuditLookup" -scope 'https://graph.microsoft.com/.default' -tenantid $Tenant |
            ForEach-Object { $_.targetResources[0].id } | Select-Object -Unique)

    $GraphRequest = $GraphRequest | Where-Object { -not ($RecentlyReactivatedUsers -contains $_.id) }

    if ($Settings.remediate -eq $true) {
        if ($GraphRequest.Count -gt 0) {
            foreach ($guest in $GraphRequest) {
                try {
                    $null = New-GraphPostRequest -type Patch -tenantid $tenant -uri "https://graph.microsoft.com/beta/users/$($guest.id)" -body '{"accountEnabled":"false"}'
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Disabling guest $($guest.UserPrincipalName) ($($guest.id)). Last sign-in: $($guest.signInActivity.lastSuccessfulSignInDateTime)" -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable guest $($guest.UserPrincipalName) ($($guest.id)): $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "No guests accounts with a login longer than $checkDays days ago." -sev Info
        }

    }
    if ($Settings.alert -eq $true) {

        if ($GraphRequest.Count -gt 0) {
            $Filtered = $GraphRequest | Select-Object -Property UserPrincipalName, id, signInActivity, mail, userType, accountEnabled, externalUserState
            Write-StandardsAlert -message "Guests accounts with a login longer than 90 days ago: $($GraphRequest.count)" -object $Filtered -tenant $tenant -standardName 'DisableGuests' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Guests accounts with a login longer than $checkDays days ago: $($GraphRequest.count)" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "No guests accounts with a login longer than $checkDays days ago." -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $Filtered = $GraphRequest | Select-Object -Property UserPrincipalName, id, signInActivity, mail, userType, accountEnabled
        $State = $Filtered ? $Filtered : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableGuests' -FieldValue $State -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableGuests' -FieldValue $Filtered -StoreAs json -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableGuests.ps1' 99
#Region './Public/Standards/Invoke-CIPPStandardDisableM365GroupUsers.ps1' -1

function Invoke-CIPPStandardDisableM365GroupUsers {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableM365GroupUsers
    .SYNOPSIS
        (Label) Disable M365 Group creation by users
    .DESCRIPTION
        (Helptext) Restricts M365 group creation to certain admin roles. This disables the ability to create Teams, SharePoint sites, Planner, etc
        (DocsDescription) Users by default are allowed to create M365 groups. This restricts M365 group creation to certain admin roles. This disables the ability to create Teams, SharePoint sites, Planner, etc
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CISA (MS.AAD.21.1v1)"
        EXECUTIVETEXT
            Restricts the creation of Microsoft 365 groups, Teams, and SharePoint sites to authorized administrators, preventing uncontrolled proliferation of collaboration spaces. This ensures proper governance, naming conventions, and resource management while maintaining oversight of all collaborative environments.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-07-17
        POWERSHELLEQUIVALENT
            Update-MgBetaDirectorySetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableM365GroupUsers' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableM365GroupUsers'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/settings' -tenantid $tenant) |
        Where-Object -Property displayname -EQ 'Group.unified'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableM365GroupUsers state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        if (($CurrentState.values | Where-Object { $_.name -eq 'EnableGroupCreation' }).value -eq 'false') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are already disabled from creating M365 Groups.' -sev Info
        } else {
            try {
                if (!$CurrentState) {
                    # If no current configuration is found, we set it to the default template supplied by MS.
                    $CurrentState = '{"id":"","displayName":"Group.Unified","templateId":"62375ab9-6b52-47ed-826b-58e47e0e304b","values":[{"name":"NewUnifiedGroupWritebackDefault","value":"true"},{"name":"EnableMIPLabels","value":"false"},{"name":"CustomBlockedWordsList","value":""},{"name":"EnableMSStandardBlockedWords","value":"false"},{"name":"ClassificationDescriptions","value":""},{"name":"DefaultClassification","value":""},{"name":"PrefixSuffixNamingRequirement","value":""},{"name":"AllowGuestsToBeGroupOwner","value":"false"},{"name":"AllowGuestsToAccessGroups","value":"true"},{"name":"GuestUsageGuidelinesUrl","value":""},{"name":"GroupCreationAllowedGroupId","value":""},{"name":"AllowToAddGuests","value":"true"},{"name":"UsageGuidelinesUrl","value":""},{"name":"ClassificationList","value":""},{"name":"EnableGroupCreation","value":"true"}]}'
                    New-GraphPostRequest -tenantid $tenant -Uri "https://graph.microsoft.com/beta/settings/$($CurrentState.id)" -AsApp $true -Type POST -Body $CurrentState -ContentType 'application/json'
                    $CurrentState = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/settings' -tenantid $tenant) | Where-Object -Property displayname -EQ 'Group.unified'
                }
                ($CurrentState.values | Where-Object { $_.name -eq 'EnableGroupCreation' }).value = 'false'
                $body = "{values : $($CurrentState.values | ConvertTo-Json -Compress)}"
                $null = New-GraphPostRequest -tenantid $tenant -asApp $true -Uri "https://graph.microsoft.com/beta/settings/$($CurrentState.id)" -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled users from creating M365 Groups.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable users from creating M365 Groups: $ErrorMessage" -sev 'Error'
            }
        }
    }
    if ($Settings.alert -eq $true) {

        if ($CurrentState) {
            if (($CurrentState.values | Where-Object { $_.name -eq 'EnableGroupCreation' }).value -eq 'false') {
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are disabled from creating M365 Groups.' -sev Info
            } else {
                Write-StandardsAlert -message 'Users are not disabled from creating M365 Groups.' -object $CurrentState -tenant $tenant -standardName 'DisableM365GroupUsers' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are not disabled from creating M365 Groups.' -sev Info
            }
        } else {
            Write-StandardsAlert -message 'Users are not disabled from creating M365 Groups.' -object @{CurrentState = $null } -tenant $tenant -standardName 'DisableM365GroupUsers' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are not disabled from creating M365 Groups.' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        if ($CurrentState) {
            if (($CurrentState.values | Where-Object { $_.name -eq 'EnableGroupCreation' }).value -eq 'false') {
                $CurrentState = $true
            } else {
                $CurrentState = $false
            }
        } else {
            $CurrentState = $false
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableM365GroupUsers' -FieldValue $CurrentState -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableM365GroupUsers' -FieldValue $CurrentState -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableM365GroupUsers.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandarddisableMacSync.ps1' -1

function Invoke-CIPPStandarddisableMacSync {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) disableMacSync
    .SYNOPSIS
        (Label) Do not allow Mac devices to sync using OneDrive
    .DESCRIPTION
        (Helptext) Disables the ability for Mac devices to sync with OneDrive.
        (DocsDescription) Disables the ability for Mac devices to sync with OneDrive.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Prevents Mac computers from synchronizing files with OneDrive, typically implemented for security or compliance reasons in Windows-centric environments. This restriction helps maintain standardized device management while potentially limiting collaboration for Mac users.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'disableMacSync' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'disableMacSync'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableMacSync state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($CurrentInfo.isMacSyncAppEnabled -eq $true) {
            try {
                $body = '{"isMacSyncAppEnabled": false}'
                New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled Mac OneDrive Sync' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable Mac OneDrive Sync: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Mac OneDrive Sync is already disabled' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.isMacSyncAppEnabled -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Mac OneDrive Sync is disabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Mac OneDrive Sync is not disabled' -object $CurrentInfo -tenant $tenant -standardName 'disableMacSync' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Mac OneDrive Sync is not disabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $CurrentInfo.isMacSyncAppEnabled = -not $CurrentInfo.isMacSyncAppEnabled
        Set-CIPPStandardsCompareField -FieldName 'standards.disableMacSync' -FieldValue $CurrentInfo.isMacSyncAppEnabled -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'MacSync' -FieldValue $CurrentInfo.isMacSyncAppEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandarddisableMacSync.ps1' 82
#Region './Public/Standards/Invoke-CIPPStandardDisableOutlookAddins.ps1' -1

function Invoke-CIPPStandardDisableOutlookAddins {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableOutlookAddins
    .SYNOPSIS
        (Label) Disable users from installing add-ins in Outlook
    .DESCRIPTION
        (Helptext) Disables the ability for users to install add-ins in Outlook. This is to prevent users from installing malicious add-ins.
        (DocsDescription) Disables users from being able to install add-ins in Outlook. Only admins are able to approve add-ins for the users. This is done to reduce the threat surface for data exfiltration.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.3.1)"
            "exo_outlookaddins"
            "NIST CSF 2.0 (PR.AA-05)"
            "NIST CSF 2.0 (PR.PS-05)"
        EXECUTIVETEXT
            Prevents employees from installing third-party add-ins in Outlook without administrative approval, reducing security risks from potentially malicious extensions. This ensures only vetted and approved tools can access company email data while maintaining centralized control over email functionality.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-02-05
        POWERSHELLEQUIVALENT
            Get-ManagementRoleAssignment \| Remove-ManagementRoleAssignment
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableOutlookAddins' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableOutlookAddins'

    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-RoleAssignmentPolicy' |
        Where-Object { $_.IsDefault -eq $true }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableOutlookAddins state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $Roles = @('My Custom Apps', 'My Marketplace Apps', 'My ReadWriteMailbox Apps')
    $RolesToRemove = foreach ($Role in $Roles) {
        if ($CurrentInfo.AssignedRoles -contains $Role) {
            $Role
        }
    }

    if ($Settings.remediate -eq $true) {
        if ($RolesToRemove) {
            $Errors = [System.Collections.Generic.List[string]]::new()

            foreach ($Role in $RolesToRemove) {
                try {
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Get-ManagementRoleAssignment' -cmdParams @{ RoleAssignee = $CurrentInfo.Identity; Role = $Role } | ForEach-Object {
                        New-ExoRequest -tenantid $Tenant -cmdlet 'Remove-ManagementRoleAssignment' -cmdParams @{ Identity = $_.Guid; Confirm = $false } -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Disabled Outlook add-in role: $Role" -sev Debug
                    }
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable Outlook add-in role: $Role Error: $ErrorMessage" -sev Error
                    $Errors.Add($Role)
                }
            }

            if ($Errors.Count -gt 0) {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable users from installing Outlook add-ins. Roles: $($Errors -join ', ')" -sev Error
            } else {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Disabled users from installing Outlook add-ins. Roles removed: $($RolesToRemove -join ', ')" -sev Info
                $RolesToRemove = $null
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users installing Outlook add-ins already disabled' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($RolesToRemove) {
            Write-StandardsAlert -message 'Users are not disabled from installing Outlook add-ins.' -object @{ AllowedApps = $RolesToRemove -join ',' } -tenant $tenant -standardName 'DisableOutlookAddins' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are not disabled from installing Outlook add-ins.' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are disabled from installing Outlook add-ins.' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $State = if ($RolesToRemove) { $false } else { $true }
        $StateForCompare = if ($RolesToRemove) { @{ AllowedApps = $RolesToRemove } } else { $true }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableOutlookAddins' -FieldValue $StateForCompare -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisabledOutlookAddins' -FieldValue $State -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableOutlookAddins.ps1' 105
#Region './Public/Standards/Invoke-CIPPStandardDisableQRCodePin.ps1' -1

function Invoke-CIPPStandardDisableQRCodePin {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableQRCodePin
    .SYNOPSIS
        (Label) Disables QR Code Pin as an MFA method
    .DESCRIPTION
        (Helptext) This blocks users from using QR Code Pin as an MFA method. If a user only has QR Code Pin as a MFA method, they will be unable to log in.
        (DocsDescription) Disables QR Code Pin as an MFA method for the tenant. If a user only has QR Code Pin as a MFA method, they will be unable to sign in.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Disables QR Code Pin authentication method due to security concerns, forcing users to adopt more secure authentication alternatives. This helps standardize authentication methods and reduces potential security vulnerabilities while ensuring employees use more robust multi-factor authentication options.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2024-02-10
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/QRCodePin' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableQRCodePin state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'disabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'QR Code Pin authentication method is already disabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'QRCodePin' -Enabled $false
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'QR Code Pin authentication method is not enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'QR Code Pin authentication method is enabled' -object $CurrentState -tenant $tenant -standardName 'DisableQRCodePin' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'QR Code Pin authentication method is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect -eq $true ? $true :  $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableQRCodePin' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableQRCodePin' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableQRCodePin.ps1' 70
#Region './Public/Standards/Invoke-CIPPStandardDisableReshare.ps1' -1

function Invoke-CIPPStandardDisableReshare {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableReshare
    .SYNOPSIS
        (Label) Disable Re-sharing by External Users
    .DESCRIPTION
        (Helptext) Disables the ability for external users to share files they don't own. Sharing links can only be made for People with existing access
        (DocsDescription) Disables the ability for external users to share files they don't own. Sharing links can only be made for People with existing access. This is a tenant wide setting and overrules any settings set on the site level
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.5)"
            "CISA (MS.AAD.14.2v1)"
            "CISA (MS.SPO.1.2v1)"
        EXECUTIVETEXT
            Prevents external users from sharing company documents with additional people, maintaining control over document distribution and preventing unauthorized access expansion. This security measure ensures that external sharing remains within intended boundaries set by internal employees.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminSharePointSetting
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableReshare' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableReshare'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableReshare state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($CurrentInfo.isResharingByExternalUsersEnabled) {
            try {
                $body = '{"isResharingByExternalUsersEnabled": "False"}'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled guests from resharing files' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable guests from resharing files: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guests are already disabled from resharing files' -sev Info
        }
    }
    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.isResharingByExternalUsersEnabled) {
            Write-StandardsAlert -message 'Guests are allowed to reshare files' -object $CurrentInfo -tenant $tenant -standardName 'DisableReshare' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guests are allowed to reshare files' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guests are not allowed to reshare files' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CurrentInfo.isResharingByExternalUsersEnabled ? ($CurrentInfo | Select-Object isResharingByExternalUsersEnabled) : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableReshare' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableReshare' -FieldValue $CurrentInfo.isResharingByExternalUsersEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableReshare.ps1' 86
#Region './Public/Standards/Invoke-CIPPStandardDisableResourceMailbox.ps1' -1

function Invoke-CIPPStandardDisableResourceMailbox {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableResourceMailbox
    .SYNOPSIS
        (Label) Disable Unlicensed Resource Mailbox Entra accounts
    .DESCRIPTION
        (Helptext) Blocks login for all accounts that are marked as a resource mailbox and does not have a license assigned. Accounts that are synced from on-premises AD are excluded, as account state is managed in the on-premises AD.
        (DocsDescription) Resource mailboxes can be directly logged into if the password is reset, this presents a security risk as do all shared login credentials. Microsoft's recommendation is to disable the user account for resource mailboxes. Accounts that are synced from on-premises AD are excluded, as account state is managed in the on-premises AD.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "NIST CSF 2.0 (PR.AA-01)"
        EXECUTIVETEXT
            Prevents direct login to resource mailbox accounts (like conference rooms or equipment), ensuring they can only be managed through proper administrative channels. This security measure eliminates potential unauthorized access to resource scheduling systems while maintaining proper booking functionality.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-06-01
        POWERSHELLEQUIVALENT
            Get-Mailbox & Update-MgUser
        RECOMMENDEDBY
            "Microsoft"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableResourceMailbox' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableResourceMailbox'

    # Get all users that are able to be
    try {
        $UserList = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/users?$top=999&$filter=accountEnabled eq true and onPremisesSyncEnabled ne true and assignedLicenses/$count eq 0&$count=true' -Tenantid $Tenant -ComplexFilter |
        Where-Object { $_.userType -eq 'Member' }
        $ResourceMailboxList = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{ Filter = "RecipientTypeDetails -eq 'RoomMailbox' -or RecipientTypeDetails -eq 'EquipmentMailbox'" } -Select 'UserPrincipalName,DisplayName,RecipientTypeDetails,ExternalDirectoryObjectId' |
        Where-Object { $_.ExternalDirectoryObjectId -in $UserList.id }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableResourceMailbox state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'


        if ($ResourceMailboxList) {
            Write-Host "Resource Mailboxes to disable: $($ResourceMailboxList.Count)"
            $ResourceMailboxList | ForEach-Object {
                try {
                    New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/users/$($_.ExternalDirectoryObjectId)" -type PATCH -body '{"accountEnabled":"false"}' -tenantid $Tenant
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Entra account for $($_.RecipientTypeDetails), $($_.DisplayName), $($_.UserPrincipalName) disabled." -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable Entra account for $($_.RecipientTypeDetails), $($_.DisplayName), $($_.UserPrincipalName). Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All Entra accounts for resource mailboxes are already disabled.' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($ResourceMailboxList) {
            Write-StandardsAlert -message "Resource mailboxes with enabled accounts: $($ResourceMailboxList.Count)" -object $ResourceMailboxList -tenant $Tenant -standardName 'DisableResourceMailbox' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Resource mailboxes with enabled accounts: $($ResourceMailboxList.Count)" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All Entra accounts for resource mailboxes are disabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        # If there are no resource mailboxes, we set the state to true, so that the standard reports as compliant.
        $State = $ResourceMailboxList ? $ResourceMailboxList : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableResourceMailbox' -FieldValue $State -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'DisableResourceMailbox' -FieldValue $ResourceMailboxList -StoreAs json -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableResourceMailbox.ps1' 94
#Region './Public/Standards/Invoke-CIPPStandardDisableSecurityGroupUsers.ps1' -1

function Invoke-CIPPStandardDisableSecurityGroupUsers {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableSecurityGroupUsers
    .SYNOPSIS
        (Label) Disable Security Group creation by users
    .DESCRIPTION
        (Helptext) Completely disables the creation of security groups by users. This also breaks the ability to manage groups themselves, or create Teams
        (DocsDescription) Completely disables the creation of security groups by users. This also breaks the ability to manage groups themselves, or create Teams
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CISA (MS.AAD.20.1v1)"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Restricts the creation of security groups to IT administrators only, preventing employees from creating unauthorized access groups that could bypass security controls. This ensures proper governance of access permissions and maintains centralized control over who can access what resources.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2022-07-17
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthorizationPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableSecurityGroupUsers'

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableSecurityGroupUsers state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        if ($CurrentInfo.defaultUserRolePermissions.allowedToCreateSecurityGroups -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are already not allowed to create Security Groups.' -sev Info
        } else {
            try {
                $body = '{"defaultUserRolePermissions":{"allowedToCreateSecurityGroups":false}}'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled users from creating Security Groups.' -sev Info
                $CurrentInfo.defaultUserRolePermissions.allowedToCreateSecurityGroups = $false
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable users from creating Security Groups: $ErrorMessage" -sev 'Error'
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.defaultUserRolePermissions.allowedToCreateSecurityGroups -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are not allowed to create Security Groups.' -sev Info
        } else {
            Write-StandardsAlert -message 'Users are allowed to create Security Groups' -object $CurrentInfo -tenant $tenant -standardName 'DisableSecurityGroupUsers' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Users are allowed to create Security Groups.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CurrentInfo.defaultUserRolePermissions.allowedToCreateSecurityGroups -eq $false ? $true : ($currentInfo.defaultUserRolePermissions | Select-Object allowedToCreateSecurityGroups)
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableSecurityGroupUsers' -FieldValue $state -Tenant $tenant
        Add-CIPPBPAField -FieldName 'DisableSecurityGroupUsers' -FieldValue $CurrentInfo.defaultUserRolePermissions.allowedToCreateSecurityGroups -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableSecurityGroupUsers.ps1' 78
#Region './Public/Standards/Invoke-CIPPStandardDisableSelfServiceLicenses.ps1' -1

function Invoke-CIPPStandardDisableSelfServiceLicenses {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableSelfServiceLicenses
    .SYNOPSIS
        (Label) Disable Self Service Licensing
    .DESCRIPTION
        (Helptext) Note: requires 'Billing Administrator' GDAP role. This standard disables all self service licenses and enables all exclusions
        (DocsDescription) Note: requires 'Billing Administrator' GDAP role. This standard disables all self service licenses and enables all exclusions
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Prevents employees from purchasing Microsoft 365 licenses independently, ensuring all software acquisitions go through proper procurement channels. This maintains budget control, prevents unauthorized spending, and ensures compliance with corporate licensing agreements.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.DisableSelfServiceLicenses.Exclusions","label":"License Ids to exclude from this standard","required":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-MsolCompanySettings -AllowAdHocSubscriptions \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableSelfServiceLicenses'

    try {
        $selfServiceItems = (New-GraphGETRequest -scope 'aeb86249-8ea3-49e2-900b-54cc8e308f85/.default' -uri 'https://licensing.m365.microsoft.com/v1.0/policies/AllowSelfServicePurchase/products' -tenantid $Tenant).items
    } catch {
        if ($_.Exception.Message -like '*403*') {
            $Message = "Failed to retrieve self service products: Insufficient permissions. Please ensure the tenant GDAP relationship includes the 'Billing Administrator' role: $($_.Exception.Message)"
        }
        else {
            $Message = "Failed to retrieve self service products: $($_.Exception.Message)"
        }
        Write-LogMessage -API 'Standards' -tenant $tenant -message $Message -sev Error
        throw $Message
    }

    if ($settings.remediate) {
        if ($settings.exclusions -like '*;*') {
            $exclusions = $settings.Exclusions -split (';')
        } else {
            $exclusions = $settings.Exclusions -split (',')
        }

        $selfServiceItems | ForEach-Object {
            $body = $null

            if ($_.policyValue -eq 'Enabled' -AND ($_.productId -in $exclusions)) {
                # Self service is enabled on product and productId is in exclusions, skip
            }
            if ($_.policyValue -eq 'Disabled' -AND ($_.productId -in $exclusions)) {
                # Self service is disabled on product and productId is in exclusions, enable
                $body = '{ "policyValue": "Enabled" }'
            }
            if ($_.policyValue -eq 'Enabled' -AND ($_.productId -notin $exclusions)) {
                # Self service is enabled on product and productId is NOT in exclusions, disable
                $body = '{ "policyValue": "Disabled" }'
            }
            if ($_.policyValue -eq 'Disabled' -AND ($_.productId -notin $exclusions)) {
                # Self service is disabled on product and productId is NOT in exclusions, skip
            }

            try {
                if ($body) {
                    $product = $_
                    New-GraphPOSTRequest -scope 'aeb86249-8ea3-49e2-900b-54cc8e308f85/.default' -uri "https://licensing.m365.microsoft.com/v1.0/policies/AllowSelfServicePurchase/products/$($product.productId)" -tenantid $Tenant -body $body -type PUT
                }
            } catch {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set product status for $($product.productId) with body $($body) for reason: $($_.Exception.Message)" -sev Error
                #Write-Error "Failed to disable product $($product.productName):$($_.Exception.Message)"
            }
        }

        if (!$exclusions) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'No exclusions set for self-service licenses, disabled all not excluded licenses for self-service.' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Exclusions present for self-service licenses, disabled all not excluded licenses for self-service.' -sev Info
        }
    }

    if ($Settings.alert) {
        $selfServiceItemsToAlert = $selfServiceItems | Where-Object { $_.policyValue -eq 'Enabled' }
        if (!$selfServiceItemsToAlert) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'All self-service licenses are disabled' -sev Info
        } else {
            Write-StandardsAlert -message "One or more self-service licenses are enabled" -object $selfServiceItemsToAlert -tenant $tenant -standardName 'DisableSelfServiceLicenses' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'One or more self-service licenses are enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        #Add-CIPPBPAField -FieldName '????' -FieldValue "????" -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableSelfServiceLicenses.ps1' 106
#Region './Public/Standards/Invoke-CIPPStandardDisableSharedMailbox.ps1' -1

function Invoke-CIPPStandardDisableSharedMailbox {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableSharedMailbox
    .SYNOPSIS
        (Label) Disable Shared Mailbox Entra accounts
    .DESCRIPTION
        (Helptext) Blocks login for all accounts that are marked as a shared mailbox. This is Microsoft best practice to prevent direct logons to shared mailboxes.
        (DocsDescription) Shared mailboxes can be directly logged into if the password is reset, this presents a security risk as do all shared login credentials. Microsoft's recommendation is to disable the user account for shared mailboxes. It would be a good idea to review the sign-in reports to establish potential impact.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (1.2.2)"
            "CISA (MS.AAD.10.1v1)"
            "NIST CSF 2.0 (PR.AA-01)"
        EXECUTIVETEXT
            Prevents direct login to shared mailbox accounts (like info@company.com), ensuring they can only be accessed through authorized users' accounts. This security measure eliminates the risk of shared passwords and unauthorized access while maintaining proper access control and audit trails.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Get-Mailbox & Update-MgUser
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableSharedMailbox'

    try {
        $UserList = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/users?$top=999&$filter=accountEnabled eq true and onPremisesSyncEnabled ne true&$count=true' -Tenantid $Tenant -ComplexFilter
        $SharedMailboxList = (New-GraphGetRequest -uri "https://outlook.office365.com/adminapi/beta/$($Tenant)/Mailbox" -Tenantid $Tenant -scope ExchangeOnline | Where-Object { $_.RecipientTypeDetails -EQ 'SharedMailbox' -or $_.RecipientTypeDetails -eq 'SchedulingMailbox' -and $_.UserPrincipalName -in $UserList.UserPrincipalName })
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableSharedMailbox state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($SharedMailboxList) {
            $SharedMailboxList | ForEach-Object {
                try {
                    New-GraphPOSTRequest -uri "https://graph.microsoft.com/v1.0/users/$($_.ObjectKey)" -type PATCH -body '{"accountEnabled":"false"}' -tenantid $Tenant
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Entra account for shared mailbox $($_.DisplayName) disabled." -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable Entra account for shared mailbox. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All Entra accounts for shared mailboxes are already disabled.' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($SharedMailboxList) {
            Write-StandardsAlert -message "Shared mailboxes with enabled accounts: $($SharedMailboxList.Count)" -object $SharedMailboxList -tenant $Tenant -standardName 'DisableSharedMailbox' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Shared mailboxes with enabled accounts: $($SharedMailboxList.Count)" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All Entra accounts for shared mailboxes are disabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $State = $SharedMailboxList ? $SharedMailboxList : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableSharedMailbox' -FieldValue $State -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'DisableSharedMailbox' -FieldValue $SharedMailboxList -StoreAs json -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableSharedMailbox.ps1' 83
#Region './Public/Standards/Invoke-CIPPStandardDisableSharePointLegacyAuth.ps1' -1

function Invoke-CIPPStandardDisableSharePointLegacyAuth {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableSharePointLegacyAuth
    .SYNOPSIS
        (Label) Disable legacy basic authentication for SharePoint
    .DESCRIPTION
        (Helptext) Disables the ability to authenticate with SharePoint using legacy authentication methods. Any applications that use legacy authentication will need to be updated to use modern authentication.
        (DocsDescription) Disables the ability for users and applications to access SharePoint via legacy basic authentication. This will likely not have any user impact, but will block systems/applications depending on basic auth or the SharePointOnlineCredentials class.
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (6.5.1)"
            "CIS M365 5.0 (7.2.1)"
            "spo_legacy_auth"
            "CISA (MS.AAD.3.1v1)"
            "NIST CSF 2.0 (PR.IR-01)"
        EXECUTIVETEXT
            Disables outdated authentication methods for SharePoint access, forcing applications and users to use modern, more secure authentication protocols. This significantly improves security by eliminating vulnerable authentication pathways while requiring updates to older applications.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-02-05
        POWERSHELLEQUIVALENT
            Set-SPOTenant -LegacyAuthProtocolsEnabled \$false
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableSharePointLegacyAuth' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableSharePointLegacyAuth'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings?$select=isLegacyAuthProtocolsEnabled' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableSharePointLegacyAuth state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($CurrentInfo.isLegacyAuthProtocolsEnabled) {
            try {
                $body = '{"isLegacyAuthProtocolsEnabled": "false"}'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled SharePoint basic authentication' -sev Info
                $CurrentInfo.isLegacyAuthProtocolsEnabled = $false
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable SharePoint basic authentication. Error: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SharePoint basic authentication is already disabled' -sev Info
        }
    }
    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.isLegacyAuthProtocolsEnabled) {
            Write-StandardsAlert -message 'SharePoint basic authentication is enabled' -object $CurrentInfo -tenant $tenant -standardName 'DisableSharePointLegacyAuth' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SharePoint basic authentication is enabled' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SharePoint basic authentication is disabled' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $state = $CurrentInfo.isLegacyAuthProtocolsEnabled ? ($CurrentInfo | Select-Object isLegacyAuthProtocolsEnabled) : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableSharePointLegacyAuth' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'SharePointLegacyAuthEnabled' -FieldValue $CurrentInfo.isLegacyAuthProtocolsEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableSharePointLegacyAuth.ps1' 88
#Region './Public/Standards/Invoke-CIPPStandardDisableSMS.ps1' -1

function Invoke-CIPPStandardDisableSMS {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableSMS
    .SYNOPSIS
        (Label) Disables SMS as an MFA method
    .DESCRIPTION
        (Helptext) This blocks users from using SMS as an MFA method. If a user only has SMS as a MFA method, they will be unable to log in.
        (DocsDescription) Disables SMS as an MFA method for the tenant. If a user only has SMS as a MFA method, they will be unable to sign in.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (2.3.5)"
            "EIDSCA.AS04"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Disables SMS text messages as a multi-factor authentication method due to security vulnerabilities like SIM swapping attacks. This forces users to adopt more secure authentication methods like authenticator apps or hardware tokens, significantly improving account security.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableSMS'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/SMS' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableSMS state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'disabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SMS authentication method is already disabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'SMS' -Enabled $false
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SMS authentication method is not enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'SMS authentication method is enabled' -object $CurrentState -tenant $tenant -standardName 'DisableSMS' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'SMS authentication method is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableSMS' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableSMS' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableSMS.ps1' 74
#Region './Public/Standards/Invoke-CIPPStandardDisableTenantCreation.ps1' -1

function Invoke-CIPPStandardDisableTenantCreation {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableTenantCreation
    .SYNOPSIS
        (Label) Disable M365 Tenant creation by users
    .DESCRIPTION
        (Helptext) Restricts creation of M365 tenants to the Global Administrator or Tenant Creator roles.
        (DocsDescription) Users by default are allowed to create M365 tenants. This disables that so only admins can create new M365 tenants.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.2.3)"
            "CISA (MS.AAD.6.1v1)"
        EXECUTIVETEXT
            Prevents regular employees from creating new Microsoft 365 organizations, ensuring all new tenants are properly managed and controlled by IT administrators. This prevents unauthorized shadow IT environments and maintains centralized governance over Microsoft 365 resources.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-11-29
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthorizationPolicy
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableTenantCreation'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableTenantCreation state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.defaultUserRolePermissions.allowedToCreateTenants -eq $false)

    If ($Settings.remediate -eq $true) {
        Write-Host "Time to remediate DisableTenantCreation standard for tenant $Tenant"
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Users are already disabled from creating tenants.' -sev Info
        } else {
            try {
                $GraphRequest = @{
                    tenantid = $Tenant
                    uri      = 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy'
                    Type     = 'PATCH'
                    Body     = '{"defaultUserRolePermissions":{"allowedToCreateTenants":false}}'
                }
                New-GraphPOSTRequest @GraphRequest
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Successfully disabled users from creating tenants.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable users from creating tenants. Error: $($ErrorMessage.NormalizedError)" -sev 'Error' -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Users are not allowed to create tenants.' -sev Info
        } else {
            Write-StandardsAlert -message 'Users are allowed to create tenants' -object $CurrentState -tenant $Tenant -standardName 'DisableTenantCreation' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Users are allowed to create tenants.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableTenantCreation' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableTenantCreation' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableTenantCreation.ps1' 84
#Region './Public/Standards/Invoke-CIPPStandardDisableTNEF.ps1' -1

function Invoke-CIPPStandardDisableTNEF {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableTNEF
    .SYNOPSIS
        (Label) Disable TNEF/winmail.dat
    .DESCRIPTION
        (Helptext) Disables Transport Neutral Encapsulation Format (TNEF)/winmail.dat for the tenant. TNEF can cause issues if the recipient is not using a client supporting TNEF.
        (DocsDescription) Disables Transport Neutral Encapsulation Format (TNEF)/winmail.dat for the tenant. TNEF can cause issues if the recipient is not using a client supporting TNEF. Cannot be overridden by the user. For more information, see [Microsoft's documentation.](https://learn.microsoft.com/en-us/exchange/mail-flow/content-conversion/tnef-conversion?view=exchserver-2019)
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Prevents the creation of winmail.dat attachments that can cause compatibility issues when sending emails to external recipients using non-Outlook email clients. This improves email compatibility and reduces support issues with external partners and customers.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-04-26
        POWERSHELLEQUIVALENT
            Set-RemoteDomain -Identity 'Default' -TNEFEnabled \$false
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableTNEF'
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableTNEF' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-RemoteDomain' -cmdParams @{Identity = 'Default' }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableTNEF state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentState.TNEFEnabled -ne $false) {
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-RemoteDomain' -cmdParams @{Identity = 'Default'; TNEFEnabled = $false } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled TNEF for Default Remote Domain' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable TNEF for Default Remote Domain. Error: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'TNEF is already disabled for Default Remote Domain' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentState.TNEFEnabled -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'TNEF is disabled for Default Remote Domain' -sev Info
        } else {
            $Object = $CurrentState | Select-Object -Property TNEFEnabled
            Write-StandardsAlert -message 'TNEF is not disabled for Default Remote Domain' -object $Object -tenant $tenant -standardName 'DisableTNEF' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'TNEF is not disabled for Default Remote Domain' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $State = if ($CurrentState.TNEFEnabled -ne $false) { $false } else { $true }
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableTNEF' -FieldValue $State -Tenant $tenant
        Add-CIPPBPAField -FieldName 'TNEFDisabled' -FieldValue $State -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableTNEF.ps1' 84
#Region './Public/Standards/Invoke-CIPPStandardDisableUserSiteCreate.ps1' -1

function Invoke-CIPPStandardDisableUserSiteCreate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableUserSiteCreate
    .SYNOPSIS
        (Label) Disable site creation by standard users
    .DESCRIPTION
        (Helptext) Disables users from creating new SharePoint sites
        (DocsDescription) Disables standard users from creating SharePoint sites, also disables the ability to fully create teams
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Restricts the creation of new SharePoint sites to authorized administrators, preventing uncontrolled proliferation of collaboration spaces and ensuring proper governance. This maintains organized information architecture while requiring approval for new collaborative environments.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DisableUserSiteCreate' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableUserSiteCreate'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableUserSiteCreate state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {

        if ($CurrentInfo.isSiteCreationEnabled -or $CurrentInfo.isSiteCreationUIEnabled) {
            try {
                $body = '{"isSiteCreationEnabled": false, "isSiteCreationUIEnabled": false}'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled standard users from creating sites and adjusted UI setting' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable standard users from creating sites: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Standard users are already disabled from creating sites and UI setting is adjusted' -sev Info
        }

    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.isSiteCreationEnabled -eq $false -and $CurrentInfo.isSiteCreationUIEnabled -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Standard users are not allowed to create sites and UI setting is disabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Standard users are allowed to create sites or UI setting is enabled' -object $CurrentInfo -tenant $tenant -standardName 'DisableUserSiteCreate' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Standard users are allowed to create sites or UI setting is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CurrentInfo.isSiteCreationEnabled -and $CurrentInfo.isSiteCreationUIEnabled ? ($CurrentInfo | Select-Object isSiteCreationEnabled, isSiteCreationUIEnabled) : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableUserSiteCreate' -FieldValue $State -Tenant $tenant
        Add-CIPPBPAField -FieldName 'DisableUserSiteCreate' -FieldValue $CurrentInfo.isSiteCreationEnabled -StoreAs bool -Tenant $tenant
        Add-CIPPBPAField -FieldName 'DisableUserSiteCreateUI' -FieldValue $CurrentInfo.isSiteCreationUIEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableUserSiteCreate.ps1' 84
#Region './Public/Standards/Invoke-CIPPStandardDisableViva.ps1' -1

function Invoke-CIPPStandardDisableViva {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableViva
    .SYNOPSIS
        (Label) Disable daily Insight/Viva reports
    .DESCRIPTION
        (Helptext) Disables the daily viva reports for all users. This standard requires the CIPP-SAM application to have the Company Administrator (Global Admin) role in the tenant. Enable this using CIPP > Advanced > Super Admin > SAM App Roles. Activate the roles with a CPV refresh.
        (DocsDescription) Disables the daily viva reports for all users. This standard requires the CIPP-SAM application to have the Company Administrator (Global Admin) role in the tenant. Enable this using CIPP \> Advanced \> Super Admin \> SAM App Roles. Activate the roles with a CPV refresh.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Disables daily Microsoft Viva Insights reports that are automatically sent to employees, reducing email volume and allowing organizations to control when and how productivity insights are shared. This can help prevent information overload while maintaining the ability to access insights when needed.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-05-25
        POWERSHELLEQUIVALENT
            Set-UserBriefingConfig
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableViva'

    try {
        # TODO This does not work without Global Admin permissions for some reason. Throws an "EXCEPTION: Tenant admin role is required" error. -Bobby
        $CurrentSetting = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/organization/$Tenant/settings/peopleInsights" -tenantid $Tenant -AsApp $true
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to get Viva insights settings. Error: $ErrorMessage" -sev Error
        Return
    }

    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentSetting.isEnabledInOrganization -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Viva is already disabled.' -sev Info
        } else {
            try {
                # TODO This does not work without Global Admin permissions for some reason. Throws an "EXCEPTION: Tenant admin role is required" error. -Bobby
                New-GraphPOSTRequest -Uri "https://graph.microsoft.com/beta/organization/$Tenant/settings/peopleInsights" -tenantid $Tenant -Type PATCH -Body '{"isEnabledInOrganization": false}' -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Disabled Viva insights' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable Viva for all users. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentSetting.isEnabledInOrganization -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Viva is disabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Viva is not disabled' -object $CurrentSetting -tenant $Tenant -standardName 'DisableViva' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Viva is not disabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CurrentSetting.isEnabledInOrganization ? $true : ($CurrentSetting | Select-Object isEnabledInOrganization)
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableViva' -FieldValue $State -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'DisableViva' -FieldValue $CurrentSetting.isEnabledInOrganization -StoreAs bool -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableViva.ps1' 77
#Region './Public/Standards/Invoke-CIPPStandardDisableVoice.ps1' -1

function Invoke-CIPPStandardDisableVoice {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) DisableVoice
    .SYNOPSIS
        (Label) Disables Voice call as an MFA method
    .DESCRIPTION
        (Helptext) This blocks users from using Voice call as an MFA method. If a user only has Voice as a MFA method, they will be unable to log in.
        (DocsDescription) Disables Voice call as an MFA method for the tenant. If a user only has Voice call as a MFA method, they will be unable to sign in.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (2.3.5)"
            "EIDSCA.AV01"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Disables voice call authentication due to security vulnerabilities and social engineering risks. This forces users to adopt more secure authentication methods like authenticator apps, improving overall account security by eliminating phone-based attack vectors.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'DisableVoice'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/Voice' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DisableVoice state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'disabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Voice authentication method is already disabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'Voice' -Enabled $false
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Voice authentication method is not enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Voice authentication method is enabled' -object $CurrentState -tenant $tenant -standardName 'DisableVoice' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Voice authentication method is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.DisableVoice' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'DisableVoice' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisableVoice.ps1' 74
#Region './Public/Standards/Invoke-CIPPStandardDisablex509Certificate.ps1' -1

function Invoke-CIPPStandardDisablex509Certificate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) Disablex509Certificate
    .SYNOPSIS
        (Label) Disables Certificates as an MFA method
    .DESCRIPTION
        (Helptext) This blocks users from using Certificates as an MFA method.
        (DocsDescription) This blocks users from using Certificates as an MFA method.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Disables certificate-based authentication as a multi-factor authentication method, typically used when organizations want to standardize on other authentication methods or when certificate management becomes too complex for the security benefit provided.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'Disablex509Certificate'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/x509Certificate' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Disablex509Certificate state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'disabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'x509Certificate authentication method is already disabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'x509Certificate' -Enabled $false
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'x509Certificate authentication method is not enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'x509Certificate authentication method is enabled' -object $CurrentState -tenant $tenant -standardName 'Disablex509Certificate' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'x509Certificate authentication method is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.Disablex509Certificate' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'Disablex509Certificate' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardDisablex509Certificate.ps1' 72
#Region './Public/Standards/Invoke-CIPPStandardEnableAppConsentRequests.ps1' -1

function Invoke-CIPPStandardEnableAppConsentRequests {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableAppConsentRequests
    .SYNOPSIS
        (Label) Enable App consent admin requests
    .DESCRIPTION
        (Helptext) Enables App consent admin requests for the tenant via the GA role. Does not overwrite existing reviewer settings
        (DocsDescription) Enables the ability for users to request admin consent for applications. Should be used in conjunction with the "Require admin consent for applications" standards
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.5.2)"
            "CISA (MS.AAD.9.1v1)"
            "EIDSCA.CP04"
            "EIDSCA.CR01"
            "EIDSCA.CR02"
            "EIDSCA.CR03"
            "EIDSCA.CR04"
            "Essential 8 (1507)"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Establishes a formal approval process where employees can request access to business applications that require administrative review. This balances security with productivity by allowing controlled access to necessary tools while preventing unauthorized application installations.
        ADDEDCOMPONENT
            {"type":"AdminRolesMultiSelect","label":"App Consent Reviewer Roles","name":"standards.EnableAppConsentRequests.ReviewerRoles"}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-11-27
        POWERSHELLEQUIVALENT
            Update-MgPolicyAdminConsentRequestPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableAppConsentRequests'

    try {
        $CurrentInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/adminConsentRequestPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableAppConsentRequests state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        try {
            # Get current state

            # Change state to enabled with default settings
            $CurrentInfo.isEnabled = 'true'
            $CurrentInfo.notifyReviewers = 'true'
            $CurrentInfo.remindersEnabled = 'true'
            $CurrentInfo.requestDurationInDays = 30

            # Roles from standards table
            $RolesToAdd = $Settings.ReviewerRoles.value
            $RoleNames = $Settings.ReviewerRoles.label -join ', '

            # Set default if no roles are selected
            if (!$RolesToAdd) {
                $RolesToAdd = @('62e90394-69f5-4237-9190-012177145e10')
                $RoleNames = '(Default) Global Administrator'
            }

            $NewReviewers = foreach ($Role in $RolesToAdd) {
                @{
                    query     = "/beta/roleManagement/directory/roleAssignments?`$filter=roleDefinitionId eq '$Role'"
                    queryType = 'MicrosoftGraph'
                    queryRoot = 'null'
                }
            }

            # Add existing reviewers
            $Reviewers = [System.Collections.Generic.List[object]]::new()
            foreach ($Reviewer in $CurrentInfo.reviewers) {
                $RoleFound = $false
                foreach ($Role in $RolesToAdd) {
                    if ($Reviewer.query -match $Role -or $Reviewers.query -contains $Reviewer.query) {
                        $RoleFound = $true
                    }
                }
                if (!$RoleFound) {
                    $Reviewers.add($Reviewer)
                }
            }

            # Add new reviewer roles
            foreach ($NewReviewer in $NewReviewers) {
                $Reviewers.add($NewReviewer)
            }

            # Update reviewer list
            $CurrentInfo.reviewers = @($Reviewers)
            $body = (ConvertTo-Json -Compress -Depth 10 -InputObject $CurrentInfo)

            New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/adminConsentRequestPolicy' -Type put -Body $body -ContentType 'application/json'
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Enabled App consent admin requests for the following roles: $RoleNames" -sev Info

        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable App consent admin requests. Error: $ErrorMessage" -sev Error
        }
    }
    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.isEnabled -eq 'true') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'App consent admin requests are enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'App consent admin requests are disabled' -object $CurrentInfo -tenant $tenant -standardName 'EnableAppConsentRequests' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'App consent admin requests are disabled' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $state = $CurrentInfo.isEnabled ? $true : $CurrentInfo
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableAppConsentRequests' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'EnableAppConsentAdminRequests' -FieldValue $CurrentInfo.isEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableAppConsentRequests.ps1' 129
#Region './Public/Standards/Invoke-CIPPStandardEnableCustomerLockbox.ps1' -1

function Invoke-CIPPStandardEnableCustomerLockbox {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableCustomerLockbox
    .SYNOPSIS
        (Label) Enable Customer Lockbox
    .DESCRIPTION
        (Helptext) Enables Customer Lockbox that offers an approval process for Microsoft support to access organization data
        (DocsDescription) Customer Lockbox ensures that Microsoft can't access your content to do service operations without your explicit approval. Customer Lockbox ensures only authorized requests allow access to your organizations data.
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (1.3.6)"
            "CustomerLockBoxEnabled"
        EXECUTIVETEXT
            Requires explicit organizational approval before Microsoft support staff can access company data for service operations. This provides an additional layer of data protection and ensures the organization maintains control over who can access sensitive business information, even during technical support scenarios.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-08
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -CustomerLockBoxEnabled \$true
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableCustomerLockbox'
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnableCustomerLockbox' -TenantFilter $Tenant -RequiredCapabilities @('CustomerLockbox')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CustomerLockboxStatus = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').CustomerLockboxEnabled
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableCustomerLockbox state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        try {

            if ($CustomerLockboxStatus) {
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Customer Lockbox already enabled' -sev Info
            } else {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ CustomerLockboxEnabled = $true } -UseSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Successfully enabled Customer Lockbox' -sev Info
            }
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            if ($ErrorMessage -match 'Ex5E8EA4') {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable Customer Lockbox. E5 license required. Error: $ErrorMessage" -sev Error
            } else {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable Customer Lockbox. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CustomerLockboxStatus) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Customer Lockbox is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Customer Lockbox is not enabled' -object $CustomerLockboxStatus -tenant $tenant -standardName 'EnableCustomerLockbox' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Customer Lockbox is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $CustomerLockboxStatus ? $true : $false
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableCustomerLockbox' -FieldValue $state -Tenant $tenant
        Add-CIPPBPAField -FieldName 'CustomerLockboxEnabled' -FieldValue $CustomerLockboxStatus -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableCustomerLockbox.ps1' 88
#Region './Public/Standards/Invoke-CIPPStandardEnableFIDO2.ps1' -1

function Invoke-CIPPStandardEnableFIDO2 {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableFIDO2
    .SYNOPSIS
        (Label) Enable FIDO2 capabilities
    .DESCRIPTION
        (Helptext) Enables the FIDO2 authenticationMethod for the tenant
        (DocsDescription) Enables FIDO2 capabilities for the tenant. This allows users to use FIDO2 keys like a Yubikey for authentication.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "EIDSCA.AF01"
            "EIDSCA.AF02"
            "EIDSCA.AF03"
            "EIDSCA.AF04"
            "EIDSCA.AF05"
            "EIDSCA.AF06"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Enables support for hardware security keys (like YubiKey) that provide the highest level of authentication security. These physical devices prevent phishing attacks and credential theft, offering superior protection for high-value accounts and sensitive business operations.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2022-12-08
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableFIDO2'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/Fido2' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableFIDO2 state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'enabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'FIDO2 Support is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'Fido2' -Enabled $true
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'FIDO2 Support is enabled' -sev Info
        } else {
            Write-StandardsAlert -message "FIDO2 Support is not enabled" -object $CurrentState -tenant $tenant -standardName 'EnableFIDO2' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'FIDO2 Support is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableFIDO2' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'EnableFIDO2' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableFIDO2.ps1' 79
#Region './Public/Standards/Invoke-CIPPStandardEnableHardwareOAuth.ps1' -1

function Invoke-CIPPStandardEnableHardwareOAuth {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableHardwareOAuth
    .SYNOPSIS
        (Label) Enable Hardware OAuth tokens
    .DESCRIPTION
        (Helptext) Enables the HardwareOath authenticationMethod for the tenant. This allows you to use hardware tokens for generating 6 digit MFA codes.
        (DocsDescription) Enables Hardware OAuth tokens for the tenant. This allows users to use hardware tokens like a Yubikey for authentication.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Enables physical hardware tokens that generate secure authentication codes, providing an alternative to smartphone-based authentication. This is particularly valuable for employees who cannot use mobile devices or require the highest security standards for accessing sensitive systems.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2023-12-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableHardwareOAuth'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/HardwareOath' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableHardwareOAuth state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = ($CurrentState.state -eq 'enabled')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'HardwareOAuth Support is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'HardwareOath' -Enabled $true
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'HardwareOAuth Support is enabled' -sev Info
        } else {
            Write-StandardsAlert -message "HardwareOAuth Support is not enabled" -object $CurrentState -tenant $tenant -standardName 'EnableHardwareOAuth' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'HardwareOAuth Support is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableHardwareOAuth' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'EnableHardwareOAuth' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableHardwareOAuth.ps1' 71
#Region './Public/Standards/Invoke-CIPPStandardEnableLitigationHold.ps1' -1

function Invoke-CIPPStandardEnableLitigationHold {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableLitigationHold
    .SYNOPSIS
        (Label) Enable Litigation Hold for all users
    .DESCRIPTION
        (Helptext) Enables litigation hold for all UserMailboxes with a valid license.
        (DocsDescription) Enables litigation hold for all UserMailboxes with a valid license.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Preserves all email content for legal and compliance purposes by preventing permanent deletion of emails, even when users attempt to delete them. This is essential for organizations subject to legal discovery requirements or regulatory compliance mandates.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.EnableLitigationHold.days","required":false,"label":"Days to apply for litigation hold"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-06-25
        POWERSHELLEQUIVALENT
            Set-Mailbox -LitigationHoldEnabled \$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnableLitigationHold' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableLitigationHold'

    try {
        $MailboxesNoLitHold = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{ Filter = 'LitigationHoldEnabled -eq "False"' } -Select 'UserPrincipalName,PersistedCapabilities,LitigationHoldEnabled' |
            Where-Object { $_.PersistedCapabilities -contains 'EXCHANGE_S_ARCHIVE_ADDON' -or $_.PersistedCapabilities -contains 'EXCHANGE_S_ENTERPRISE' -or $_.PersistedCapabilities -contains 'BPOS_S_DlpAddOn' -or $_.PersistedCapabilities -contains 'BPOS_S_Enterprise' }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableLitigationHold state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($null -eq $MailboxesNoLitHold) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Litigation Hold already enabled for all accounts' -sev Info
        } else {
            try {
                $Request = $MailboxesNoLitHold | ForEach-Object {
                    $params = @{
                        CmdletInput = @{
                            CmdletName = 'Set-Mailbox'
                            Parameters = @{ Identity = $_.UserPrincipalName; LitigationHoldEnabled = $true }
                        }
                    }
                    if ($null -ne $Settings.days) {
                        $params.CmdletInput.Parameters['LitigationHoldDuration'] = $Settings.days
                    }
                    $params
                }


                $BatchResults = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($Request)
                $BatchResults | ForEach-Object {
                    if ($_.error) {
                        $ErrorMessage = Get-NormalizedError -Message $_.error
                        Write-Host "Failed to Enable Litigation Hold for $($_.Target). Error: $ErrorMessage"
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to Enable Litigation Hold for $($_.Target). Error: $ErrorMessage" -sev Error
                    }
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to Enable Litigation Hold for all accounts. Error: $ErrorMessage" -sev Error
            }
        }

    }

    if ($Settings.alert -eq $true) {
        if (($MailboxesNoLitHold | Measure-Object).Count -gt 0) {
            Write-StandardsAlert -message "Mailboxes without Litigation Hold: $($MailboxesNoLitHold.Count)" -object $MailboxesNoLitHold -tenant $Tenant -standardName 'EnableLitigationHold' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Mailboxes without Litigation Hold: $($MailboxesNoLitHold.Count)" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All mailboxes have Litigation Hold enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $filtered = $MailboxesNoLitHold | Select-Object -Property UserPrincipalName
        $state = $filtered ? $MailboxesNoLitHold : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableLitigationHold' -FieldValue $state -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'EnableLitHold' -FieldValue $filtered -StoreAs json -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableLitigationHold.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandardEnableMailboxAuditing.ps1' -1

function Invoke-CIPPStandardEnableMailboxAuditing {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableMailboxAuditing
    .SYNOPSIS
        (Label) Enable Mailbox auditing
    .DESCRIPTION
        (Helptext) Enables Mailbox auditing for all mailboxes and on tenant level. Disables audit bypass on all mailboxes. Unified Audit Log needs to be enabled for this standard to function.
        (DocsDescription) Enables mailbox auditing on tenant level and for all mailboxes. Disables audit bypass on all mailboxes. By default Microsoft does not enable mailbox auditing for Resource Mailboxes, Public Folder Mailboxes and DiscoverySearch Mailboxes. Unified Audit Log needs to be enabled for this standard to function.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.1.1)"
            "CIS M365 5.0 (6.1.2)"
            "CIS M365 5.0 (6.1.3)"
            "exo_mailboxaudit"
            "Essential 8 (1509)"
            "Essential 8 (1683)"
            "NIST CSF 2.0 (DE.CM-09)"
        EXECUTIVETEXT
            Enables comprehensive logging of all email access and modifications across all employee mailboxes, providing detailed audit trails for security investigations and compliance requirements. This helps detect unauthorized access, data breaches, and supports regulatory compliance efforts.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-08
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -AuditDisabled \$false
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnableMailboxAuditing' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableMailboxAuditing'

    try {
        $AuditState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').AuditDisabled
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableMailboxAuditing state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($AuditState) {
            # Enable tenant level mailbox audit
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{AuditDisabled = $false } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Tenant level mailbox audit enabled' -sev Info
                $LogMessage = 'Tenant level mailbox audit enabled. '
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable tenant level mailbox audit. Error: $ErrorMessage" -sev Error
            }
        } else {
            $LogMessage = 'Tenant level mailbox audit already enabled. '
        }

        # Check for mailbox audit on all mailboxes. Enable for all that it's not enabled for
        $Mailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{filter = "auditenabled -eq 'False'" } -useSystemMailbox $true -Select 'AuditEnabled,UserPrincipalName'
        $Request = $mailboxes | ForEach-Object {
            @{
                CmdletInput = @{
                    CmdletName = 'Set-Mailbox'
                    Parameters = @{Identity = $_.UserPrincipalName; AuditEnabled = $true }
                }
            }
        }

        $BatchResults = New-ExoBulkRequest -tenantid $tenant -cmdletArray @($Request)
        $BatchResults | ForEach-Object {
            if ($_.error) {
                $ErrorMessage = Get-NormalizedError -Message $_.error
                Write-Host "Failed to enable user level mailbox audit for $($_.target). Error: $ErrorMessage"
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable user level mailbox audit for $($_.target). Error: $ErrorMessage" -sev Error
            }
        }

        # Disable audit bypass for all mailboxes that have it enabled

        $BypassMailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailboxAuditBypassAssociation' -select 'GUID, AuditBypassEnabled, Name' -useSystemMailbox $true | Where-Object { $_.AuditBypassEnabled -eq $true }
        $Request = $BypassMailboxes | ForEach-Object {
            @{
                CmdletInput = @{
                    CmdletName = 'Set-MailboxAuditBypassAssociation'
                    Parameters = @{Identity = $_.Guid; AuditBypassEnabled = $false }
                }
            }
        }

        $BatchResults = New-ExoBulkRequest -tenantid $tenant -cmdletArray @($Request)
        $BatchResults | ForEach-Object {
            if ($_.error) {
                $ErrorMessage = Get-NormalizedError -Message $_.error
                Write-Host "Failed to disable mailbox audit bypass for $($_.target). Error: $ErrorMessage"
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable mailbox audit bypass for $($_.target). Error: $ErrorMessage" -sev Error
            }
        }

        $LogMessage = if ($Mailboxes.Count -eq 0 -and $BypassMailboxes.Count -eq 0) {
            # Make log message smaller if both are already in the desired state
            'User level mailbox audit already enabled and mailbox audit bypass already disabled for all mailboxes'
        } else {
            if ($Mailboxes.Count -eq 0) {
                'User level mailbox audit already enabled for all mailboxes. '
            }
            if ($BypassMailboxes.Count -eq 0) {
                'Mailbox audit bypass already disabled for all mailboxes'
            }
        }

        Write-LogMessage -API 'Standards' -tenant $Tenant -message $LogMessage -sev Info
    }

    if ($Settings.alert -eq $true) {
        if ($AuditState) {
            Write-StandardsAlert -message 'Tenant level mailbox audit is not enabled' -object $AuditState -tenant $Tenant -standardName 'EnableMailboxAuditing' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Tenant level mailbox audit is not enabled' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Tenant level mailbox audit is enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $AuditState = -not $AuditState
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableMailboxAuditing' -FieldValue $AuditState -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'MailboxAuditingEnabled' -FieldValue $AuditState -StoreAs bool -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableMailboxAuditing.ps1' 146
#Region './Public/Standards/Invoke-CIPPStandardEnableMailTips.ps1' -1

function Invoke-CIPPStandardEnableMailTips {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableMailTips
    .SYNOPSIS
        (Label) Enable all MailTips
    .DESCRIPTION
        (Helptext) Enables all MailTips in Outlook. MailTips are the notifications Outlook and Outlook on the web shows when an email you create, meets some requirements
        (DocsDescription) Enables all MailTips in Outlook. MailTips are the notifications Outlook and Outlook on the web shows when an email you create, meets some requirements
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.5.2)"
            "exo_mailtipsenabled"
        EXECUTIVETEXT
            Enables helpful notifications in Outlook that warn users about potential email issues, such as sending to large groups, external recipients, or invalid addresses. This reduces email mistakes and improves communication efficiency by providing real-time guidance to employees.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.EnableMailTips.MailTipsLargeAudienceThreshold","label":"Number of recipients to trigger the large audience MailTip (Default is 25)","placeholder":"Enter a profile name","defaultValue":25}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-14
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnableMailTips' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableMailTips'

    try {
        $MailTipsState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig' | Select-Object MailTipsAllTipsEnabled, MailTipsExternalRecipientsTipsEnabled, MailTipsGroupMetricsEnabled, MailTipsLargeAudienceThreshold
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnableMailTips state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = if ($MailTipsState.MailTipsAllTipsEnabled -and $MailTipsState.MailTipsExternalRecipientsTipsEnabled -and $MailTipsState.MailTipsGroupMetricsEnabled -and $MailTipsState.MailTipsLargeAudienceThreshold -eq $Settings.MailTipsLargeAudienceThreshold) { $true } else { $false }

    if ($Settings.remediate -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All MailTips are already enabled.' -sev Info
        } else {
            try {
                New-ExoRequest -useSystemMailbox $true -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ MailTipsAllTipsEnabled = $true; MailTipsExternalRecipientsTipsEnabled = $true; MailTipsGroupMetricsEnabled = $true; MailTipsLargeAudienceThreshold = $Settings.MailTipsLargeAudienceThreshold }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Enabled all MailTips' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable all MailTips. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All MailTips are enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Not all MailTips are enabled' -object $MailTipsState -tenant $Tenant -standardName 'EnableMailTips' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Not all MailTips are enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $MailTipsState
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableMailTips' -FieldValue $State -Tenant $tenant
        Add-CIPPBPAField -FieldName 'MailTipsEnabled' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableMailTips.ps1' 88
#Region './Public/Standards/Invoke-CIPPStandardEnableNamePronunciation.ps1' -1

function Invoke-CIPPStandardEnableNamePronunciation {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableNamePronunciation
    .SYNOPSIS
        (Label) Enable Name Pronunciation
    .DESCRIPTION
        (Helptext) Enables the Name Pronunciation feature for the tenant. This allows users to set their name pronunciation in their profile.
        (DocsDescription) Enables the Name Pronunciation feature for the tenant. This allows users to set their name pronunciation in their profile.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Enables employees to add pronunciation guides for their names in Microsoft 365 profiles, improving communication and respect in diverse workplaces. This feature helps colleagues pronounce names correctly, enhancing professional relationships and inclusive culture.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-06
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)

    $Uri = 'https://graph.microsoft.com/beta/admin/people/namePronunciation'
    try {
        $CurrentState = New-GraphGetRequest -Uri $Uri -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not get CurrentState for Name Pronunciation. Error: $($ErrorMessage.NormalizedError)" -sev Error
        Return
    }
    Write-Host $CurrentState

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentState.isEnabledInOrganization -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Name Pronunciation is already enabled.' -sev Info
        } else {
            $CurrentState.isEnabledInOrganization = $true
            try {
                $Body = ConvertTo-Json -InputObject $CurrentState -Depth 10 -Compress
                $null = New-GraphPostRequest -Uri $Uri -tenantid $Tenant -Body $Body -type PATCH -AsApp $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Enabled name pronunciation.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable name pronunciation. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentState.isEnabledInOrganization -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Name Pronunciation is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Name Pronunciation is not enabled' -object $CurrentState -tenant $tenant -standardName 'EnableNamePronunciation' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Name Pronunciation is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableNamePronunciation' -FieldValue $CurrentState.isEnabledInOrganization -Tenant $tenant
        Add-CIPPBPAField -FieldName 'NamePronunciationEnabled' -FieldValue $CurrentState.isEnabledInOrganization -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableNamePronunciation.ps1' 76
#Region './Public/Standards/Invoke-CIPPStandardEnableOnlineArchiving.ps1' -1

function Invoke-CIPPStandardEnableOnlineArchiving {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnableOnlineArchiving
    .SYNOPSIS
        (Label) Enable Online Archive for all users
    .DESCRIPTION
        (Helptext) Enables the In-Place Online Archive for all UserMailboxes with a valid license.
        (DocsDescription) Enables the In-Place Online Archive for all UserMailboxes with a valid license.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "Essential 8 (1511)"
            "NIST CSF 2.0 (PR.DS-11)"
        EXECUTIVETEXT
            Automatically enables online email archiving for all licensed employees, providing additional storage for older emails while maintaining easy access. This helps manage mailbox sizes, improves email performance, and supports compliance with data retention requirements.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-20
        POWERSHELLEQUIVALENT
            Enable-Mailbox -Archive \$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnableOnlineArchiving' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnableOnlineArchiving'

    $MailboxPlans = @( 'ExchangeOnline', 'ExchangeOnlineEnterprise' )
    $MailboxesNoArchive = $MailboxPlans | ForEach-Object {
        New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -cmdParams @{ MailboxPlan = $_; Filter = 'ArchiveGuid -Eq "00000000-0000-0000-0000-000000000000" -AND RecipientTypeDetails -Eq "UserMailbox"' }
        Write-Host "Getting mailboxes without Online Archiving for plan $_"
    }

    If ($Settings.remediate -eq $true) {

        if ($null -eq $MailboxesNoArchive) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Online Archiving already enabled for all accounts' -sev Info
        } else {
            try {
                $Request = $MailboxesNoArchive | ForEach-Object {
                    @{
                        CmdletInput = @{
                            CmdletName = 'Enable-Mailbox'
                            Parameters = @{ Identity = $_.UserPrincipalName; Archive = $true }
                        }
                    }
                }

                $BatchResults = New-ExoBulkRequest -tenantid $tenant -cmdletArray @($Request)
                $BatchResults | ForEach-Object {
                    if ($_.error) {
                        $ErrorMessage = Get-NormalizedError -Message $_.error
                        Write-Host "Failed to Enable Online Archiving for $($_.Target). Error: $ErrorMessage"
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to Enable Online Archiving for $($_.Target). Error: $ErrorMessage" -sev Error
                    }
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to Enable Online Archiving for all accounts. Error: $ErrorMessage" -sev Error
            }
        }

    }

    if ($Settings.alert -eq $true) {

        if ($MailboxesNoArchive) {
            $Object = $MailboxesNoArchive | Select-Object -Property UserPrincipalName, ArchiveGuid
            Write-StandardsAlert -message "Mailboxes without Online Archiving: $($MailboxesNoArchive.Count)" -object $Object -tenant $Tenant -standardName 'EnableOnlineArchiving' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Mailboxes without Online Archiving: $($MailboxesNoArchive.Count)" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All mailboxes have Online Archiving enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $filtered = $MailboxesNoArchive | Select-Object -Property UserPrincipalName, ArchiveGuid
        $stateReport = $filtered ? $filtered : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.EnableOnlineArchiving' -FieldValue $stateReport -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'EnableOnlineArchiving' -FieldValue $filtered -StoreAs json -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnableOnlineArchiving.ps1' 98
#Region './Public/Standards/Invoke-CIPPStandardEnablePronouns.ps1' -1

function Invoke-CIPPStandardEnablePronouns {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnablePronouns
    .SYNOPSIS
        (Label) Enable Pronouns
    .DESCRIPTION
        (Helptext) Enables the Pronouns feature for the tenant. This allows users to set their pronouns in their profile.
        (DocsDescription) Enables the Pronouns feature for the tenant. This allows users to set their pronouns in their profile.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Allows employees to display their preferred pronouns in their Microsoft 365 profiles, supporting inclusive workplace practices and helping colleagues communicate respectfully. This feature enhances diversity and inclusion initiatives while fostering a more welcoming work environment.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-06-05
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminPeoplePronoun -IsEnabledInOrganization:\$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EnablePronouns'

    $Uri = 'https://graph.microsoft.com/v1.0/admin/people/pronouns'
    try {
        $CurrentState = New-GraphGetRequest -Uri $Uri -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not get CurrentState for Pronouns. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        Return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentState.isEnabledInOrganization -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Pronouns are already enabled.' -sev Info
        } else {
            $CurrentState.isEnabledInOrganization = $true
            try {
                $Body = ConvertTo-Json -InputObject $CurrentState -Depth 10 -Compress
                $null = New-GraphPostRequest -Uri $Uri -tenantid $Tenant -Body $Body -type PATCH -AsApp $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Enabled pronouns.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable pronouns. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentState.isEnabledInOrganization -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Pronouns are enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Pronouns are not enabled' -object $CurrentState -tenant $tenant -standardName 'EnablePronouns' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Pronouns are not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.EnablePronouns' -FieldValue $CurrentState.isEnabledInOrganization -Tenant $tenant
        Add-CIPPBPAField -FieldName 'PronounsEnabled' -FieldValue $CurrentState.isEnabledInOrganization -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnablePronouns.ps1' 77
#Region './Public/Standards/Invoke-CIPPStandardEnrollmentWindowsHelloForBusinessConfiguration.ps1' -1

function Invoke-CIPPStandardEnrollmentWindowsHelloForBusinessConfiguration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EnrollmentWindowsHelloForBusinessConfiguration
    .SYNOPSIS
        (Label) Windows Hello for Business enrollment configuration
    .DESCRIPTION
        (Helptext) Sets the Windows Hello for Business configuration during device enrollment.
        (DocsDescription) Sets the Windows Hello for Business configuration during device enrollment.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Enables or disables Windows Hello for Business during device enrollment, enhancing security through biometric or PIN-based authentication methods. This ensures that devices meet corporate security standards while providing a user-friendly sign-in experience.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.state","label":"Configure Windows Hello for Business","multiple":false,"options":[{"label":"Not configured","value":"notConfigured"},{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
            {"type":"switch","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.securityDeviceRequired","label":"Use a Trusted Platform Module (TPM)","default":true}
            {"type":"number","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinMinimumLength","label":"Minimum PIN length (4-127)","default":4}
            {"type":"number","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinMaximumLength","label":"Maximum PIN length (4-127)","default":127}
            {"type":"autoComplete","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinLowercaseCharactersUsage","label":"Lowercase letters in PIN","multiple":false,"options":[{"label":"Not allowed","value":"disallowed"},{"label":"Allowed","value":"allowed"},{"label":"Required","value":"required"}]}
            {"type":"autoComplete","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinUppercaseCharactersUsage","label":"Uppercase letters in PIN","multiple":false,"options":[{"label":"Not allowed","value":"disallowed"},{"label":"Allowed","value":"allowed"},{"label":"Required","value":"required"}]}
            {"type":"autoComplete","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinSpecialCharactersUsage","label":"Special characters in PIN","multiple":false,"options":[{"label":"Not allowed","value":"disallowed"},{"label":"Allowed","value":"allowed"},{"label":"Required","value":"required"}]}
            {"type":"number","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinExpirationInDays","label":"PIN expiration (days) - 0 to disable","default":0}
            {"type":"number","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.pinPreviousBlockCount","label":"PIN history - 0 to disable","default":0}
            {"type":"switch","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.unlockWithBiometricsEnabled","label":"Allow biometric authentication","default":true}
            {"type":"autoComplete","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.enhancedBiometricsState","label":"Use enhanced anti-spoofing when available","multiple":false,"options":[{"label":"Not configured","value":"notConfigured"},{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
            {"type":"switch","name":"standards.EnrollmentWindowsHelloForBusinessConfiguration.remotePassportEnabled","label":"Allow phone sign-in","default":true}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-09-25
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EnrollmentWindowsHelloForBusinessConfiguration' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations?`$expand=assignments&orderBy=priority&`$filter=deviceEnrollmentConfigurationType eq 'WindowsHelloForBusiness'" -tenantID $Tenant -AsApp $true |
        Select-Object -Property id, pinMinimumLength, pinMaximumLength, pinUppercaseCharactersUsage, pinLowercaseCharactersUsage, pinSpecialCharactersUsage, state, securityDeviceRequired, unlockWithBiometricsEnabled, remotePassportEnabled, pinPreviousBlockCount, pinExpirationInDays, enhancedBiometricsState
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EnrollmentWindowsHelloForBusinessConfiguration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.pinMinimumLength -eq $Settings.pinMinimumLength) -and
    ($CurrentState.pinMaximumLength -eq $Settings.pinMaximumLength) -and
    ($CurrentState.pinUppercaseCharactersUsage -eq $Settings.pinUppercaseCharactersUsage.value) -and
    ($CurrentState.pinLowercaseCharactersUsage -eq $Settings.pinLowercaseCharactersUsage.value) -and
    ($CurrentState.pinSpecialCharactersUsage -eq $Settings.pinSpecialCharactersUsage.value) -and
    ($CurrentState.state -eq $Settings.state.value) -and
    ($CurrentState.securityDeviceRequired -eq $Settings.securityDeviceRequired) -and
    ($CurrentState.unlockWithBiometricsEnabled -eq $Settings.unlockWithBiometricsEnabled) -and
    ($CurrentState.remotePassportEnabled -eq $Settings.remotePassportEnabled) -and
    ($CurrentState.pinPreviousBlockCount -eq $Settings.pinPreviousBlockCount) -and
    ($CurrentState.pinExpirationInDays -eq $Settings.pinExpirationInDays) -and
    ($CurrentState.enhancedBiometricsState -eq $Settings.enhancedBiometricsState.value)

    $CompareField = [PSCustomObject]@{
        pinMinimumLength            = $CurrentState.pinMinimumLength
        pinMaximumLength            = $CurrentState.pinMaximumLength
        pinUppercaseCharactersUsage = $CurrentState.pinUppercaseCharactersUsage
        pinLowercaseCharactersUsage = $CurrentState.pinLowercaseCharactersUsage
        pinSpecialCharactersUsage   = $CurrentState.pinSpecialCharactersUsage
        state                       = $CurrentState.state
        securityDeviceRequired      = $CurrentState.securityDeviceRequired
        unlockWithBiometricsEnabled = $CurrentState.unlockWithBiometricsEnabled
        remotePassportEnabled       = $CurrentState.remotePassportEnabled
        pinPreviousBlockCount       = $CurrentState.pinPreviousBlockCount
        pinExpirationInDays         = $CurrentState.pinExpirationInDays
        enhancedBiometricsState     = $CurrentState.enhancedBiometricsState
    }

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'EnrollmentWindowsHelloForBusinessConfiguration is already applied correctly.' -Sev Info
        }
        else {
            $cmdParam = @{
                tenantid    = $Tenant
                uri         = "https://graph.microsoft.com/beta/deviceManagement/deviceEnrollmentConfigurations/$($CurrentState.id)"
                AsApp       = $false
                Type        = 'PATCH'
                ContentType = 'application/json; charset=utf-8'
                Body        = [PSCustomObject]@{
                    "@odata.type"             = "#microsoft.graph.deviceEnrollmentWindowsHelloForBusinessConfiguration"
                    pinMinimumLength          = $Settings.pinMinimumLength
                    pinMaximumLength          = $Settings.pinMaximumLength
                    pinUppercaseCharactersUsage = $Settings.pinUppercaseCharactersUsage.value
                    pinLowercaseCharactersUsage = $Settings.pinLowercaseCharactersUsage.value
                    pinSpecialCharactersUsage   = $Settings.pinSpecialCharactersUsage.value
                    state                       = $Settings.state.value
                    securityDeviceRequired      = $Settings.securityDeviceRequired
                    unlockWithBiometricsEnabled = $Settings.unlockWithBiometricsEnabled
                    remotePassportEnabled       = $Settings.remotePassportEnabled
                    pinPreviousBlockCount       = $Settings.pinPreviousBlockCount
                    pinExpirationInDays         = $Settings.pinExpirationInDays
                    enhancedBiometricsState     = $Settings.enhancedBiometricsState.value
                } | ConvertTo-Json -Compress -Depth 10
            }
            try {
                $null = New-GraphPostRequest @cmdParam
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully updated EnrollmentWindowsHelloForBusinessConfiguration.' -Sev Info
            }
            catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to update EnrollmentWindowsHelloForBusinessConfiguration. Error: $($ErrorMessage.NormalizedError)" -Sev Error
            }
        }

    }

    If ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'EnrollmentWindowsHelloForBusinessConfiguration is correctly set.' -Sev Info
        }
        else {
            Write-StandardsAlert -message 'EnrollmentWindowsHelloForBusinessConfiguration is incorrectly set.' -object $CompareField -tenant $Tenant -standardName 'EnrollmentWindowsHelloForBusinessConfiguration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'EnrollmentWindowsHelloForBusinessConfiguration is incorrectly set.' -Sev Info
        }
    }

    If ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Set-CIPPStandardsCompareField -FieldName 'standards.EnrollmentWindowsHelloForBusinessConfiguration' -FieldValue $FieldValue -TenantFilter $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEnrollmentWindowsHelloForBusinessConfiguration.ps1' 144
#Region './Public/Standards/Invoke-CIPPStandardExchangeConnectorTemplate.ps1' -1

function Invoke-CIPPStandardExchangeConnectorTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ExchangeConnectorTemplate
    .SYNOPSIS
        (Label) Exchange Connector Template
    .DESCRIPTION
        (Helptext) Deploy and manage Exchange connectors.
        (DocsDescription) Deploy and manage Exchange connectors.
    .NOTES
        CAT
            Templates
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-12-30
        EXECUTIVETEXT
            Configures standardized Exchange connectors that control how email flows between your organization and external systems. These templates ensure secure and reliable email delivery while maintaining proper routing and security policies for business communications.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"exConnectorTemplate","label":"Select Exchange Connector Template","api":{"url":"/api/ListExConnectorTemplates","labelField":"name","valueField":"GUID","queryKey":"ListExConnectorTemplates"}}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'ExConnector' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'ExConnector'

    if ($Settings.remediate -eq $true) {

        foreach ($Template in $Settings.TemplateList) {
            try {
                $Table = Get-CippTable -tablename 'templates'
                $Filter = "PartitionKey eq 'ExConnectorTemplate' and RowKey eq '$($Template.value)'"
                $connectorType = (Get-AzDataTableEntity @Table -Filter $Filter).direction
                $RequestParams = (Get-AzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json
                if ($RequestParams.comment) { $RequestParams.comment = Get-CIPPTextReplacement -Text $RequestParams.comment -TenantFilter $Tenant } else { $RequestParams | Add-Member -NotePropertyValue 'no comment' -NotePropertyName comment -Force }
                $Existing = New-ExoRequest -ErrorAction SilentlyContinue -tenantid $Tenant -cmdlet "Get-$($ConnectorType)connector" | Where-Object -Property Identity -EQ $RequestParams.name
                if ($Existing) {
                    $RequestParams | Add-Member -NotePropertyValue $Existing.Identity -NotePropertyName Identity -Force
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet "Set-$($ConnectorType)connector" -cmdParams $RequestParams -useSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated transport rule for $($Tenant, $Settings)" -sev info
                } else {
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet "New-$($ConnectorType)connector" -cmdParams $RequestParams -useSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created transport rule for $($Tenant, $Settings)" -sev info
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to create or update Exchange Connector Rule: $ErrorMessage" -sev 'Error'
            }

        }

    }


}
#EndRegion './Public/Standards/Invoke-CIPPStandardExchangeConnectorTemplate.ps1' 68
#Region './Public/Standards/Invoke-CIPPStandardExcludedfileExt.ps1' -1

function Invoke-CIPPStandardExcludedfileExt {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ExcludedfileExt
    .SYNOPSIS
        (Label) Exclude File Extensions from Syncing
    .DESCRIPTION
        (Helptext) Sets the file extensions that are excluded from syncing with OneDrive. These files will be blocked from upload. '*.' is automatically added to the extension and can be omitted.
        (DocsDescription) Sets the file extensions that are excluded from syncing with OneDrive. These files will be blocked from upload. '\*.' is automatically added to the extension and can be omitted.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Blocks specific file types from being uploaded or synchronized to OneDrive, helping prevent security risks from potentially dangerous file formats. This security measure protects against malware distribution while allowing legitimate business file types to be shared safely.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.ExcludedfileExt.ext","label":"Extensions, Comma separated"}
        IMPACT
            High Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'ExcludedfileExt' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'ExcludedfileExt'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ExcludedfileExt state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $Exts = ($Settings.ext -replace ' ', '') -split ','
    # Add a wildcard to the extensions since thats what the SP admin center does
    $Exts = $Exts | ForEach-Object { if ($_ -notlike '*.*') { "*.$_" } else { $_ } }


    $MissingExclusions = foreach ($Exclusion in $Exts) {
        if ($Exclusion -notin $CurrentInfo.excludedFileExtensionsForSyncApp) {
            $Exclusion
        }
    }

    Write-Host "MissingExclusions: $($MissingExclusions)"


    If ($Settings.remediate -eq $true) {

        # If the number of extensions in the settings does not match the number of extensions in the current settings, we need to update the settings
        $MissingExclusions = if ($Exts.Count -ne $CurrentInfo.excludedFileExtensionsForSyncApp.Count) { $true } else { $MissingExclusions }
        if ($MissingExclusions) {
            Write-Host "CurrentInfo.excludedFileExtensionsForSyncApp: $($CurrentInfo.excludedFileExtensionsForSyncApp)"
            Write-Host "Exts: $($Exts)"
            try {
                $body = ConvertTo-Json -InputObject @{ excludedFileExtensionsForSyncApp = @($Exts) }
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $body -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Added $($Settings.ext) to excluded synced files" -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to add $($Settings.ext) to excluded synced files: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Excluded synced files already contains $($Settings.ext)" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($MissingExclusions) {
            Write-StandardsAlert -message 'Exclude File Extensions from Syncing missing some extensions.' -object $MissingExclusions -tenant $Tenant -standardName 'ExcludedfileExt' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Excluded synced files does not contain $($MissingExclusions -join ',')" -sev Alert
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Excluded synced files contains $($Settings.ext)" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $MissingExclusions ? (@{ ext = $CurrentInfo.excludedFileExtensionsForSyncApp -join ',' }): $true
        Set-CIPPStandardsCompareField -FieldName 'standards.ExcludedfileExt' -FieldValue $state -Tenant $tenant
        Add-CIPPBPAField -FieldName 'ExcludedfileExt' -FieldValue $CurrentInfo.excludedFileExtensionsForSyncApp -StoreAs json -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardExcludedfileExt.ps1' 100
#Region './Public/Standards/Invoke-CIPPStandardEXODirectSend.ps1' -1

function Invoke-CIPPStandardEXODirectSend {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EXODirectSend
    .SYNOPSIS
        (Label) Set Direct Send state
    .DESCRIPTION
        (Helptext) Sets the state of Direct Send in Exchange Online. Direct Send allows applications to send emails directly to Exchange Online mailboxes as the tenants domains, without requiring authentication.
        (DocsDescription) Controls whether applications can use Direct Send to send emails directly to Exchange Online mailboxes as the tenants domains, without requiring authentication. A detailed explanation from Microsoft can be found [here.](https://learn.microsoft.com/en-us/exchange/mail-flow-best-practices/how-to-set-up-a-multifunction-device-or-application-to-send-email-using-microsoft-365-or-office-365)
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Controls whether business applications and devices (like printers or scanners) can send emails through the company's email system without authentication. While this enables convenient features like scan-to-email, it may pose security risks and should be carefully managed.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.EXODirectSend.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-05-28
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -RejectDirectSend \$true/\$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)


    # Determine desired state. These double negative MS loves are a bit confusing
    $DesiredStateName = $Settings.state.value ?? $Settings.state
    # Input validation
    if ([string]::IsNullOrWhiteSpace($DesiredStateName) -or $DesiredStateName -eq 'Select a value') {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'EXODirectSend: Invalid state parameter set' -sev Error
        Return
    }

    # Get current organization config
    try {
        $CurrentConfig = (New-ExoRequest -TenantID $Tenant -cmdlet 'Get-OrganizationConfig' -Select 'RejectDirectSend').RejectDirectSend
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to retrieve current Direct Send configuration: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return
    }

    $DesiredState = $DesiredStateName -eq 'disabled' ? $true : $false
    $StateIsCorrect = $CurrentConfig -eq $DesiredState

    # Remediate if needed
    if ($Settings.remediate -eq $true) {

        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Direct Send is already set to $DesiredStateName." -sev Info
        } else {
            try {
                $null = New-ExoRequest -TenantID $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ RejectDirectSend = $DesiredState }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Direct Send has been set to $DesiredStateName." -sev Info
                $CurrentState = $DesiredState
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Direct Send state: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    # Alert if needed
    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Direct Send is set to $DesiredStateName as required." -sev Info
        } else {
            $CurrentStateName = $CurrentState ? 'disabled' : 'enabled'
            Write-StandardsAlert -message "Direct Send is $CurrentStateName but should be $DesiredStateName" -object $CurrentConfig -tenant $Tenant -standardName 'EXODirectSend' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Direct Send is $CurrentStateName but should be $DesiredStateName." -sev Info
        }
    }

    # Report if needed
    if ($Settings.report -eq $true) {

        Set-CIPPStandardsCompareField -FieldName 'standards.EXODirectSend' -FieldValue $StateIsCorrect -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'EXODirectSend' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEXODirectSend.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardEXODisableAutoForwarding.ps1' -1

function Invoke-CIPPStandardEXODisableAutoForwarding {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EXODisableAutoForwarding
    .SYNOPSIS
        (Label) Disable automatic forwarding to external recipients
    .DESCRIPTION
        (Helptext) Disables the ability for users to automatically forward e-mails to external recipients.
        (DocsDescription) Disables the ability for users to automatically forward e-mails to external recipients. This is to prevent data exfiltration. Please check if there are any legitimate use cases for this feature before implementing, like forwarding invoices and such.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.2.1)"
            "mdo_autoforwardingmode"
            "mdo_blockmailforward"
            "CISA (MS.EXO.4.1v1)"
            "NIST CSF 2.0 (PR.DS-02)"
        EXECUTIVETEXT
            Prevents employees from automatically forwarding company emails to external addresses, protecting against data leaks and unauthorized information sharing. This security measure helps maintain control over sensitive business communications while preventing both accidental and intentional data exfiltration.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2024-07-26
        POWERSHELLEQUIVALENT
            Set-HostedOutboundSpamFilterPolicy -AutoForwardingMode 'Off'
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EXODisableAutoForwarding' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'EXODisableAutoForwarding'

    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-HostedOutboundSpamFilterPolicy' -cmdParams @{Identity = 'Default' } -useSystemMailbox $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EXODisableAutoForwarding state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = $CurrentInfo.AutoForwardingMode -eq 'Off'

    if ($Settings.remediate -eq $true) {
        try {
            New-ExoRequest -tenantid $tenant -cmdlet 'Set-HostedOutboundSpamFilterPolicy' -cmdParams @{ Identity = 'Default'; AutoForwardingMode = 'Off' } -useSystemMailbox $true
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Disabled auto forwarding' -sev Info
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not disable auto forwarding. $($ErrorMessage.NormalizedError)" -sev Error
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Auto forwarding is disabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Auto forwarding is not disabled' -object ($CurrentInfo | Select-Object AutoForwardingMode) -tenant $tenant -standardName 'EXODisableAutoForwarding' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Auto forwarding is not disabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ?? ($CurrentInfo | Select-Object AutoForwardingMode)
        Set-CIPPStandardsCompareField -FieldName 'standards.EXODisableAutoForwarding' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'AutoForwardingDisabled' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEXODisableAutoForwarding.ps1' 83
#Region './Public/Standards/Invoke-CIPPStandardEXOOutboundSpamLimits.ps1' -1

function Invoke-CIPPStandardEXOOutboundSpamLimits {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) EXOOutboundSpamLimits
    .SYNOPSIS
        (Label) Set Exchange Outbound Spam Limits
    .DESCRIPTION
        (Helptext) Configures the outbound spam recipient limits (external per hour, internal per hour, per day) and the action to take when a limit is reached. The 'Set Outbound Spam Alert e-mail' standard is recommended to configure together with this one. 
        (DocsDescription) Configures the Exchange Online outbound spam recipient limits for external per hour, internal per hour, and per day, along with the action to take (e.g., BlockUser, Alert) when these limits are exceeded. This helps prevent abuse and manage email flow. Microsoft's recommendations can be found [here.](https://learn.microsoft.com/en-us/defender-office-365/recommended-settings-for-eop-and-office365#eop-outbound-spam-policy-settings) The 'Set Outbound Spam Alert e-mail' standard is recommended to configure together with this one.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (2.1.6)"
        EXECUTIVETEXT
            Sets limits on how many emails employees can send per hour and per day to prevent spam and protect the organization's email reputation. When limits are exceeded, the system can alert administrators or temporarily block the user, helping detect compromised accounts or prevent abuse.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.EXOOutboundSpamLimits.RecipientLimitExternalPerHour","label":"External Recipient Limit Per Hour","defaultValue":400}
            {"type":"number","name":"standards.EXOOutboundSpamLimits.RecipientLimitInternalPerHour","label":"Internal Recipient Limit Per Hour","defaultValue":800}
            {"type":"number","name":"standards.EXOOutboundSpamLimits.RecipientLimitPerDay","label":"Daily Recipient Limit","defaultValue":800}
            {"type":"autoComplete","multiple":false,"creatable":false,"name":"standards.EXOOutboundSpamLimits.ActionWhenThresholdReached","label":"Action When Threshold Reached","options":[{"label":"Alert","value":"Alert"},{"label":"Block User","value":"BlockUser"},{"label":"Block user from sending mail for the rest of the day","value":"BlockUserForToday"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-05-13
        POWERSHELLEQUIVALENT
            Set-HostedOutboundSpamFilterPolicy
        RECOMMENDEDBY
            "CIPP"
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'EXOOutboundSpamLimits' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Make sure it handles the frontend being both autocomplete and a text field
    $ActionWhenThresholdReached = $Settings.ActionWhenThresholdReached.value ?? $Settings.ActionWhenThresholdReached

    # Input validation
    if ([Int32]$Settings.RecipientLimitExternalPerHour -lt 0 -or [Int32]$Settings.RecipientLimitExternalPerHour -gt 10000) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'EXOOutboundSpamLimits: Invalid RecipientLimitExternalPerHour parameter set. Must be between 0 and 10000.' -sev Error
        return
    }

    if ([Int32]$Settings.RecipientLimitInternalPerHour -lt 0 -or [Int32]$Settings.RecipientLimitInternalPerHour -gt 10000) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'EXOOutboundSpamLimits: Invalid RecipientLimitInternalPerHour parameter set. Must be between 0 and 10000.' -sev Error
        return
    }

    if ([Int32]$Settings.RecipientLimitPerDay -lt 0 -or [Int32]$Settings.RecipientLimitPerDay -gt 10000) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'EXOOutboundSpamLimits: Invalid RecipientLimitPerDay parameter set. Must be between 0 and 10000.' -sev Error
        return
    }

    $ValidActions = @('Alert', 'BlockUser', 'BlockUserForToday')
    if ($ActionWhenThresholdReached -notin $ValidActions) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'EXOOutboundSpamLimits: Invalid ActionWhenThresholdReached parameter set. Must be one of: Alert, BlockUser, BlockUserForToday.' -sev Error
        return
    }

    # Get current settings
    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-HostedOutboundSpamFilterPolicy' -cmdParams @{Identity = 'Default' } -Select 'RecipientLimitExternalPerHour, RecipientLimitInternalPerHour, RecipientLimitPerDay, ActionWhenThresholdReached' -useSystemMailbox $true |
        Select-Object -ExcludeProperty *data.type*
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the EXOOutboundSpamLimits state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Check if settings are already correct
    $StateIsCorrect = ($CurrentInfo.RecipientLimitExternalPerHour -eq $Settings.RecipientLimitExternalPerHour) -and
                        ($CurrentInfo.RecipientLimitInternalPerHour -eq $Settings.RecipientLimitInternalPerHour) -and
                        ($CurrentInfo.RecipientLimitPerDay -eq $Settings.RecipientLimitPerDay) -and
                        ($CurrentInfo.ActionWhenThresholdReached -eq $ActionWhenThresholdReached)

    # Remediation
    If ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $false) {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-HostedOutboundSpamFilterPolicy' -cmdParams @{
                    Identity                      = 'Default'
                    RecipientLimitExternalPerHour = $Settings.RecipientLimitExternalPerHour
                    RecipientLimitInternalPerHour = $Settings.RecipientLimitInternalPerHour
                    RecipientLimitPerDay          = $Settings.RecipientLimitPerDay
                    ActionWhenThresholdReached    = $ActionWhenThresholdReached
                } -useSystemMailbox $true

                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set outbound spam limits: External=$($Settings.RecipientLimitExternalPerHour), Internal=$($Settings.RecipientLimitInternalPerHour), Daily=$($Settings.RecipientLimitPerDay), Action=$($ActionWhenThresholdReached)" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set outbound spam limits. $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Outbound spam limits are already set correctly' -sev Info
        }
    }

    # Alert
    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Outbound spam limits are correctly configured: External=$($Settings.RecipientLimitExternalPerHour), Internal=$($Settings.RecipientLimitInternalPerHour), Daily=$($Settings.RecipientLimitPerDay), Action=$($ActionWhenThresholdReached)" -sev Info
        } else {
            Write-StandardsAlert -message 'Outbound spam limits are not configured correctly' -object $CurrentInfo -tenant $Tenant -standardName 'EXOOutboundSpamLimits' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Outbound spam limits are not configured correctly' -sev Info
        }
    }

    # Report
    if ($Settings.report -eq $true) {
        $State = $StateIsCorrect ? $true : $CurrentInfo
        Set-CIPPStandardsCompareField -FieldName 'standards.EXOOutboundSpamLimits' -FieldValue $State -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'OutboundSpamLimitsConfigured' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardEXOOutboundSpamLimits.ps1' 129
#Region './Public/Standards/Invoke-CIPPStandardExternalMFATrusted.ps1' -1

function Invoke-CIPPStandardExternalMFATrusted {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ExternalMFATrusted
    .SYNOPSIS
        (Label) Sets the Cross-tenant access setting to trust external MFA
    .DESCRIPTION
        (Helptext) Sets the state of the Cross-tenant access setting to trust external MFA. This allows guest users to use their home tenant MFA to access your tenant.
        (DocsDescription) Sets the state of the Cross-tenant access setting to trust external MFA. This allows guest users to use their home tenant MFA to access your tenant.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Allows external partners and vendors to use their own organization's multi-factor authentication when accessing company resources, streamlining collaboration while maintaining security standards. This reduces friction for external users while ensuring they still meet authentication requirements.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.ExternalMFATrusted.state","options":[{"label":"Enabled","value":"true"},{"label":"Disabled","value":"false"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-26
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyCrossTenantAccessPolicyDefault
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'ExternalMFATrusted'

    try {
        $ExternalMFATrusted = (New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/policies/crossTenantAccessPolicy/default?$select=inboundTrust' -tenantid $Tenant)
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ExternalMFATrusted state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state
    $WantedState = if ($state -eq 'true') { $true } else { $false }
    $StateMessage = if ($WantedState) { 'enabled' } else { 'disabled' }



    # Input validation
    if (([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'ExternalMFATrusted: Invalid state parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        Write-Host 'Remediate External MFA Trusted'
        if ($ExternalMFATrusted.inboundTrust.isMfaAccepted -eq $WantedState ) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "External MFA Trusted is already $StateMessage." -sev Info
        } else {
            try {
                $NewBody = $ExternalMFATrusted
                $NewBody.inboundTrust.isMfaAccepted = $WantedState
                $NewBody = ConvertTo-Json -Depth 10 -InputObject $NewBody -Compress
                $null = New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/v1.0/policies/crossTenantAccessPolicy/default' -Type patch -Body $NewBody -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set External MFA Trusted to $StateMessage." -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set External MFA Trusted to $StateMessage. Error: $ErrorMessage" -sev Error
            }
        }
    }
    if ($Settings.report -eq $true) {
        $state = $ExternalMFATrusted.inboundTrust.isMfaAccepted ? $true : $ExternalMFATrusted.inboundTrust
        $ReportState = $ExternalMFATrusted.inboundTrust.isMfaAccepted -eq $WantedState
        Set-CIPPStandardsCompareField -FieldName 'standards.ExternalMFATrusted' -FieldValue $ReportState -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'ExternalMFATrusted' -FieldValue $ExternalMFATrusted.inboundTrust.isMfaAccepted -StoreAs bool -Tenant $Tenant
    }

    if ($Settings.alert -eq $true) {

        if ($ExternalMFATrusted.inboundTrust.isMfaAccepted -eq $WantedState) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "External MFA Trusted is $StateMessage." -sev Info
        } else {
            Write-StandardsAlert -message "External MFA Trusted is not $StateMessage" -object $ExternalMFATrusted.inboundTrust -tenant $Tenant -standardName 'ExternalMFATrusted' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "External MFA Trusted is not $StateMessage." -sev Info
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardExternalMFATrusted.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardFocusedInbox.ps1' -1

function Invoke-CIPPStandardFocusedInbox {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) FocusedInbox
    .SYNOPSIS
        (Label) Set Focused Inbox state
    .DESCRIPTION
        (Helptext) Sets the default Focused Inbox state for the tenant. This can be overridden by the user.
        (DocsDescription) Sets the default Focused Inbox state for the tenant. This can be overridden by the user in their Outlook settings. For more information, see [Microsoft's documentation.](https://support.microsoft.com/en-us/office/focused-inbox-for-outlook-f445ad7f-02f4-4294-a82e-71d8964e3978)
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Configures the default setting for Outlook's Focused Inbox feature, which automatically sorts important emails into a focused view while placing less important emails in a separate section. This can improve employee productivity by reducing email clutter, though users can adjust this setting individually.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.FocusedInbox.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-04-26
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -FocusedInboxOn \$true or \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'FocusedInbox' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'FocusedInbox'

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state

    # Input validation
    if ([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'ExternalMFATrusted: Invalid state parameter set' -sev Error
        Return
    }

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').FocusedInboxOn
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the FocusedInbox state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $WantedState = if ($state -eq 'enabled') { $true } else { $false }
    $StateIsCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Focused Inbox is already set to $state." -sev Info
        } else {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ FocusedInboxOn = $WantedState }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set Focused Inbox state to $state." -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Focused Inbox state to $state. Error: $($ErrorMessage.NormalizedError)" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Focused Inbox is set to $state." -sev Info
        } else {
            Write-StandardsAlert -message "Focused Inbox is not set to $state" -object $CurrentState -tenant $Tenant -standardName 'FocusedInbox' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Focused Inbox is not set to $state." -sev Info
        }
    }

    if ($Settings.report -eq $true) {

        Set-CIPPStandardsCompareField -FieldName 'standards.FocusedInbox' -FieldValue $StateIsCorrect -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'FocusedInboxCorrectState' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardFocusedInbox.ps1' 95
#Region './Public/Standards/Invoke-CIPPStandardFormsPhishingProtection.ps1' -1

function Invoke-CIPPStandardFormsPhishingProtection {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) FormsPhishingProtection
    .SYNOPSIS
        (Label) Enable internal phishing protection for Forms
    .DESCRIPTION
        (Helptext) Enables internal phishing protection for Microsoft Forms to help prevent malicious forms from being created and shared within the organization. This feature scans forms created by internal users for potential phishing content and suspicious patterns.
        (DocsDescription) Enables internal phishing protection for Microsoft Forms by setting the isInOrgFormsPhishingScanEnabled property to true. This security feature helps protect organizations from internal phishing attacks through Microsoft Forms by automatically scanning forms created by internal users for potential malicious content, suspicious links, and phishing patterns. When enabled, Forms will analyze form content and block or flag potentially dangerous forms before they can be shared within the organization.
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (1.3.5)"
            "Security"
            "PhishingProtection"
        EXECUTIVETEXT
            Automatically scans Microsoft Forms created by employees for malicious content and phishing attempts, preventing the creation and distribution of harmful forms within the organization. This protects against both internal threats and compromised accounts that might be used to distribute malicious content.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-06
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'FormsPhishingProtection'

    $Uri = 'https://graph.microsoft.com/beta/admin/forms/settings'

    try {
        $CurrentState = (New-GraphGetRequest -Uri $Uri -tenantid $Tenant).isInOrgFormsPhishingScanEnabled
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not get current Forms settings. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        Return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate Forms phishing protection'

        # Check if phishing protection is already enabled
        if ($CurrentState -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Forms internal phishing protection is already enabled.' -sev Info
        } else {
            # Enable Forms phishing protection
            try {
                $Body = @{
                    isInOrgFormsPhishingScanEnabled = $true
                } | ConvertTo-Json -Depth 10 -Compress

                $null = New-GraphPostRequest -Uri $Uri -Body $Body -TenantID $Tenant -Type PATCH

                # Refresh the current state after enabling
                $CurrentState = New-GraphGetRequest -Uri $Uri -tenantid $Tenant
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Successfully enabled Forms internal phishing protection.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable Forms internal phishing protection. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentState -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Forms internal phishing protection is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Forms internal phishing protection is not enabled' -object $CurrentState -tenant $Tenant -standardName 'FormsPhishingProtection' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Forms internal phishing protection is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.FormsPhishingProtection' -FieldValue $CurrentState -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'FormsPhishingProtection' -FieldValue $CurrentState -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardFormsPhishingProtection.ps1' 89
#Region './Public/Standards/Invoke-CIPPStandardfwdAdminAlerts.ps1' -1

function Invoke-CIPPStandardfwdAdminAlerts {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    If ($Settings.remediate -eq $true) {

        # TODO This isn't done yet.
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardfwdAdminAlerts.ps1' 12
#Region './Public/Standards/Invoke-CIPPStandardGlobalQuarantineNotifications.ps1' -1

function Invoke-CIPPStandardGlobalQuarantineNotifications {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) GlobalQuarantineNotifications
    .SYNOPSIS
        (Label) Set Global Quarantine Notification Interval
    .DESCRIPTION
        (Helptext) Sets the Global Quarantine Notification Interval to the selected value. Determines how often the quarantine notification is sent to users.
        (DocsDescription) Sets the global quarantine notification interval for the tenant. This is the time between the quarantine notification emails are sent out to users. Default is 24 hours.
    .NOTES
        CAT
            Exchange Standards
        TAG
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.GlobalQuarantineNotifications.NotificationInterval","options":[{"label":"4 hours","value":"04:00:00"},{"label":"1 day/Daily","value":"1.00:00:00"},{"label":"7 days/Weekly","value":"7.00:00:00"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-05-03
        POWERSHELLEQUIVALENT
            Set-QuarantinePolicy -EndUserSpamNotificationFrequency
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'GlobalQuarantineNotifications'
    $TestResult = Test-CIPPStandardLicense -StandardName 'GlobalQuarantineNotifications' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-QuarantinePolicy' -cmdParams @{ QuarantinePolicyType = 'GlobalQuarantinePolicy' } |
        Select-Object -ExcludeProperty '*data.type'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the GlobalQuarantineNotifications state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # This might take the cake on ugly hacky stuff i've done,
    # but i just cant understand why the API returns the values it does and not a timespan like the equivalent powershell command does
    # If you know why, please let me know -Bobby
    $CurrentState.EndUserSpamNotificationFrequency = switch ($CurrentState.EndUserSpamNotificationFrequency) {
        'PT4H' { New-TimeSpan -Hours 4 }
        'P1D' { New-TimeSpan -Days 1 }
        'P7D' { New-TimeSpan -Days 7 }
        default { $null }
    }


    # Get notification interval using null-coalescing operator
    $NotificationInterval = $Settings.NotificationInterval.value ?? $Settings.NotificationInterval

    # Input validation
    try {
        $WantedState = [timespan]$NotificationInterval
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "GlobalQuarantineNotifications: Invalid NotificationInterval parameter set. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentState.EndUserSpamNotificationFrequency -eq $WantedState) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Global Quarantine Notifications are already set to the desired value of $WantedState" -sev Info
        } else {
            try {
                if ($CurrentState.Name -eq 'DefaultGlobalPolicy') {
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-QuarantinePolicy' -cmdParams @{ Name = 'DefaultGlobalTag'; QuarantinePolicyType = 'GlobalQuarantinePolicy'; EndUserSpamNotificationFrequency = [string]$WantedState }
                } else {
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-QuarantinePolicy' -cmdParams @{Identity = $CurrentState.Identity; EndUserSpamNotificationFrequency = [string]$WantedState }
                }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set Global Quarantine Notifications to $WantedState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Global Quarantine Notifications to $WantedState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentState.EndUserSpamNotificationFrequency -eq $WantedState) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Global Quarantine Notifications are set to the desired value of $WantedState" -sev Info
        } else {
            Write-StandardsAlert -message "Global Quarantine Notifications are not set to the desired value of $WantedState" -object $CurrentState -tenant $Tenant -standardName 'GlobalQuarantineNotifications' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Global Quarantine Notifications are not set to the desired value of $WantedState" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $notificationInterval = @{ NotificationInterval = "$(($CurrentState.EndUserSpamNotificationFrequency).TotalHours) hours" }
        $ReportState = $CurrentState.EndUserSpamNotificationFrequency -eq $WantedState ? $true : $notificationInterval
        Set-CIPPStandardsCompareField -FieldName 'standards.GlobalQuarantineNotifications' -FieldValue $ReportState -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'GlobalQuarantineNotificationsSet' -FieldValue [string]$CurrentState.EndUserSpamNotificationFrequency -StoreAs string -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardGlobalQuarantineNotifications.ps1' 110
#Region './Public/Standards/Invoke-CIPPStandardGroupTemplate.ps1' -1

function Invoke-CIPPStandardGroupTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) GroupTemplate
    .SYNOPSIS
        (Label) Group Template
    .DESCRIPTION
        (Helptext) Deploy and manage group templates.
        (DocsDescription) Deploy and manage group templates.
    .NOTES
        MULTI
            True
        CAT
            Templates
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-12-30
        EXECUTIVETEXT
            Creates standardized groups with predefined settings, permissions, and membership rules. These templates ensure consistent group configurations across the organization, streamlining collaboration and access management while maintaining security standards.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"groupTemplate","label":"Select Group Template","api":{"url":"/api/ListGroupTemplates","labelField":"Displayname","altLabelField":"displayName","valueField":"GUID","queryKey":"ListGroupTemplates"}}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)

    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'GroupTemplate'
    $existingGroups = New-GraphGETRequest -uri 'https://graph.microsoft.com/beta/groups?$top=999' -tenantid $tenant

    $TestResult = Test-CIPPStandardLicense -StandardName 'GroupTemplate' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_LITE') -SkipLog

    $Settings.groupTemplate ? ($Settings | Add-Member -NotePropertyName 'TemplateList' -NotePropertyValue $Settings.groupTemplate) : $null

    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'GroupTemplate' and (RowKey eq '$($Settings.TemplateList.value -join "' or RowKey eq '")')"
    $GroupTemplates = (Get-CIPPAzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json

    if ('dynamicDistribution' -in $GroupTemplates.groupType) {
        # Get dynamic distro list from exchange
        $DynamicDistros = New-ExoRequest -cmdlet 'Get-DynamicDistributionGroup' -tenantid $tenant -Select 'Identity,Name,Alias,RecipientFilter,PrimarySmtpAddress'
    }

    if ($Settings.remediate -eq $true) {
        #Because the list name changed from TemplateList to groupTemplate by someone :@, we'll need to set it back to TemplateList

        Write-Host "Settings: $($Settings.TemplateList | ConvertTo-Json)"
        foreach ($Template in $GroupTemplates) {
            Write-Information "Processing template: $($Template.displayName)"
            try {
                $groupobj = $Template

                if ($Template.groupType -eq 'dynamicDistribution') {
                    $CheckExisting = $DynamicDistros | Where-Object { $_.Name -eq $Template.displayName }
                } else {
                    $CheckExisting = $existingGroups | Where-Object -Property displayName -EQ $groupobj.displayName
                }

                if (!$CheckExisting) {
                    Write-Information 'Creating group'
                    $ActionType = 'create'

                    # Check if Exchange license is required for distribution groups
                    if ($groupobj.groupType -in @('distribution', 'dynamicdistribution') -and !$TestResult) {
                        Write-LogMessage -API 'Standards' -tenant $tenant -message "Cannot create group $($groupobj.displayname) as the tenant is not licensed for Exchange." -Sev 'Error'
                        continue
                    }

                    # Use the centralized New-CIPPGroup function
                    $Result = New-CIPPGroup -GroupObject $groupobj -TenantFilter $tenant -APIName 'Standards' -ExecutingUser 'CIPP-Standards'

                    if (!$Result.Success) {
                        Write-Information "Failed to create group $($groupobj.displayname): $($Result.Message)"
                        continue
                    }
                } else {
                    $ActionType = 'update'

                    # Normalize group type like New-CIPPGroup does
                    $NormalizedGroupType = switch -Wildcard ($groupobj.groupType.ToLower()) {
                        '*dynamicdistribution*' { 'DynamicDistribution'; break }
                        '*dynamic*' { 'Dynamic'; break }
                        '*generic*' { 'Generic'; break }
                        '*security*' { 'Security'; break }
                        '*azurerole*' { 'AzureRole'; break }
                        '*m365*' { 'M365'; break }
                        '*unified*' { 'M365'; break }
                        '*microsoft*' { 'M365'; break }
                        '*distribution*' { 'Distribution'; break }
                        '*mail*' { 'Distribution'; break }
                        default { $groupobj.groupType }
                    }

                    # Handle Graph API groups (Security, Generic, AzureRole, Dynamic, M365)
                    if ($NormalizedGroupType -in @('Generic', 'Security', 'AzureRole', 'Dynamic', 'M365')) {

                        # Compare existing group with template to determine what needs updating
                        $PatchBody = [PSCustomObject]@{}
                        $ChangesNeeded = [System.Collections.Generic.List[string]]::new()

                        # Check description
                        if ($CheckExisting.description -ne $groupobj.description) {
                            $PatchBody | Add-Member -NotePropertyName 'description' -NotePropertyValue $groupobj.description
                            $ChangesNeeded.Add("description: '$($CheckExisting.description)'  '$($groupobj.description)'")
                        }

                        # Handle membership rules for dynamic groups
                        # Only update if the template specifies this should be a dynamic group
                        if ($NormalizedGroupType -eq 'Dynamic' -and $groupobj.membershipRules) {
                            if ($CheckExisting.membershipRule -ne $groupobj.membershipRules) {
                                $PatchBody | Add-Member -NotePropertyName 'membershipRule' -NotePropertyValue $groupobj.membershipRules
                                $PatchBody | Add-Member -NotePropertyName 'membershipRuleProcessingState' -NotePropertyValue 'On'
                                $ChangesNeeded.Add("membershipRule: '$($CheckExisting.membershipRule)'  '$($groupobj.membershipRules)'")
                            }
                        }

                        # Only patch if there are actual changes
                        if ($ChangesNeeded.Count -gt 0) {
                            $GraphRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/groups/$($CheckExisting.id)" -tenantid $tenant -type PATCH -body (ConvertTo-Json -InputObject $PatchBody -Depth 10)
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Updated Group '$($groupobj.displayName)' - Changes: $($ChangesNeeded -join ', ')" -Sev Info
                        } else {
                            Write-Information "Group '$($groupobj.displayName)' already matches template - no update needed"
                        }

                    } else {
                        # Handle Exchange Online groups (Distribution, DynamicDistribution)
                        if (!$TestResult) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Cannot update group $($groupobj.displayName) as the tenant is not licensed for Exchange." -Sev 'Error'
                            continue
                        }

                        # Construct email address if needed
                        $Email = if ($groupobj.username -like '*@*') {
                            $groupobj.username
                        } else {
                            "$($groupobj.username)@$($tenant)"
                        }

                        $ExoChangesNeeded = [System.Collections.Generic.List[string]]::new()

                        if ($NormalizedGroupType -eq 'DynamicDistribution') {
                            # Compare Dynamic Distribution Group properties
                            $SetParams = @{
                                Identity = $CheckExisting.Identity
                            }

                            # Check recipient filter change
                            if ($CheckExisting.RecipientFilter -notmatch $groupobj.membershipRules) {
                                $SetParams.RecipientFilter = $groupobj.membershipRules
                                $ExoChangesNeeded.Add("RecipientFilter: '$($CheckExisting.RecipientFilter)'  '$($groupobj.membershipRules)'")
                            }

                            # Only update if there are changes
                            if ($SetParams.Count -gt 1) {
                                $GraphRequest = New-ExoRequest -tenantid $tenant -cmdlet 'Set-DynamicDistributionGroup' -cmdParams $SetParams
                            }

                            # Check external sender restrictions
                            if ($null -ne $groupobj.allowExternal) {
                                $currentAuthRequired = $CheckExisting.RequireSenderAuthenticationEnabled
                                $templateAuthRequired = [bool]!$groupobj.allowExternal

                                if ($currentAuthRequired -ne $templateAuthRequired) {
                                    $ExtParams = @{
                                        Identity                           = $CheckExisting.displayName
                                        RequireSenderAuthenticationEnabled = $templateAuthRequired
                                    }
                                    $null = New-ExoRequest -tenantid $tenant -cmdlet 'Set-DynamicDistributionGroup' -cmdParams $ExtParams
                                    $ExoChangesNeeded.Add("RequireSenderAuthenticationEnabled: '$currentAuthRequired'  '$templateAuthRequired'")
                                }
                            }

                        } else {
                            # Compare Regular Distribution Group properties
                            $SetParams = @{
                                Identity = $CheckExisting.displayName
                            }

                            # Check display name change
                            if ($CheckExisting.displayName -ne $groupobj.displayName) {
                                $SetParams.DisplayName = $groupobj.displayName
                                $ExoChangesNeeded.Add("DisplayName: '$($CheckExisting.displayName)'  '$($groupobj.displayName)'")
                            }

                            # Check description change
                            if ($CheckExisting.description -ne $groupobj.description) {
                                $SetParams.Description = $groupobj.description
                                $ExoChangesNeeded.Add("Description: '$($CheckExisting.description)'  '$($groupobj.description)'")
                            }

                            # Check external sender restrictions
                            if ($null -ne $groupobj.allowExternal) {
                                $currentAuthRequired = $CheckExisting.RequireSenderAuthenticationEnabled
                                $templateAuthRequired = [bool]!$groupobj.allowExternal

                                if ($currentAuthRequired -ne $templateAuthRequired) {
                                    $SetParams.RequireSenderAuthenticationEnabled = $templateAuthRequired
                                    $ExoChangesNeeded.Add("RequireSenderAuthenticationEnabled: '$currentAuthRequired'  '$templateAuthRequired'")
                                }
                            }

                            # Only update if there are changes
                            if ($SetParams.Count -gt 0) {
                                $GraphRequest = New-ExoRequest -tenantid $tenant -cmdlet 'Set-DistributionGroup' -cmdParams $SetParams
                            }
                        }

                        # Log results
                        if ($ExoChangesNeeded.Count -gt 0) {
                            Write-LogMessage -API 'Standards' -tenant $tenant -message "Updated Exchange group '$($groupobj.displayName)' - Changes: $($ExoChangesNeeded -join ', ')" -Sev Info
                        } else {
                            Write-Information "Exchange group '$($groupobj.displayName)' already matches template - no update needed"
                        }
                    }

                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to $ActionType group $($groupobj.displayname). Error: $ErrorMessage" -sev 'Error'
            }
        }
    }
    if ($Settings.report -eq $true) {
        #check if all groups.displayName are in the existingGroups, if not $fieldvalue should contain all missing groups, else it should be true.
        $MissingGroups = foreach ($Group in $GroupTemplates) {
            if ($Group.groupType -eq 'dynamicDistribution') {
                $CheckExisting = $DynamicDistros | Where-Object { $_.Name -eq $Group.displayName }
                if (!$CheckExisting) {
                    $Group.displayName
                }
            } else {
                $CheckExisting = $existingGroups | Where-Object { $_.displayName -eq $Group.displayName }
                if (!$CheckExisting) {
                    $Group.displayName
                }
            }
        }

        if ($MissingGroups.Count -eq 0) {
            $fieldValue = $true
        } else {
            $fieldValue = $MissingGroups -join ', '
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.GroupTemplate' -FieldValue $fieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardGroupTemplate.ps1' 254
#Region './Public/Standards/Invoke-CIPPStandardGuestInvite.ps1' -1

function Invoke-CIPPStandardGuestInvite {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) GuestInvite
    .SYNOPSIS
        (Label) Guest Invite setting
    .DESCRIPTION
        (Helptext) This setting controls who can invite guests to your directory to collaborate on resources secured by your company, such as SharePoint sites or Azure resources.
        (DocsDescription) This setting controls who can invite guests to your directory to collaborate on resources secured by your company, such as SharePoint sites or Azure resources.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CISA (MS.AAD.18.1v1)"
            "EIDSCA.AP04"
            "EIDSCA.AP07"
        EXECUTIVETEXT
            Controls who within the organization can invite external partners and vendors to access company resources, ensuring proper oversight of external access while enabling necessary business collaboration. This helps maintain security while supporting partnership and vendor relationships.
        ADDEDCOMPONENT
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"label":"Who can send invites?","name":"standards.GuestInvite.allowInvitesFrom","options":[{"label":"Everyone","value":"everyone"},{"label":"Admins, Guest inviters and All Members","value":"adminsGuestInvitersAndAllMembers"},{"label":"Admins and Guest inviters","value":"adminsAndGuestInviters"},{"label":"None","value":"none"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-11-12
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the GuestInvite state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Input validation and value handling
    $AllowInvitesFromValue = $Settings.allowInvitesFrom.value ?? $Settings.allowInvitesFrom
    if (([string]::IsNullOrWhiteSpace($AllowInvitesFromValue) -or $AllowInvitesFromValue -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'GuestInvite: Invalid allowInvitesFrom parameter set' -sev Error
        Return
    }

    $StateIsCorrect = ($CurrentState.allowInvitesFrom -eq $AllowInvitesFromValue)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Guest Invite settings is already applied correctly.' -Sev Info
        } else {
            try {
                $GraphRequest = @{
                    tenantID    = $Tenant
                    uri         = 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy'
                    AsApp       = $false
                    Type        = 'PATCH'
                    ContentType = 'application/json; charset=utf-8'
                    Body        = [pscustomobject]@{
                        allowInvitesFrom = $AllowInvitesFromValue
                    } | ConvertTo-Json -Compress
                }
                New-GraphPostRequest @GraphRequest
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Successfully updated Guest Invite setting to $AllowInvitesFromValue" -Sev Info
            } catch {
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to update Guest Invite setting to $AllowInvitesFromValue" -Sev Error -LogData $_
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guest Invite settings is enabled.' -sev Info
        } else {
            $Object = $CurrentState | Select-Object -Property allowInvitesFrom
            Write-StandardsAlert -message 'Guest Invite settings is not enabled' -object $Object -tenant $tenant -standardName 'GuestInvite' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Guest Invite settings is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : ($CurrentState | Select-Object allowInvitesFrom)
        Set-CIPPStandardsCompareField -FieldName 'standards.GuestInvite' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'GuestInvite' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardGuestInvite.ps1' 95
#Region './Public/Standards/Invoke-CIPPStandardintuneBrandingProfile.ps1' -1

function Invoke-CIPPStandardintuneBrandingProfile {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) intuneBrandingProfile
    .SYNOPSIS
        (Label) Set Intune Company Portal branding profile
    .DESCRIPTION
        (Helptext) Sets the branding profile for the Intune Company Portal app. This is a tenant wide setting and overrules any settings set on the app level.
        (DocsDescription) Sets the branding profile for the Intune Company Portal app. This is a tenant wide setting and overrules any settings set on the app level.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Customizes the Intune Company Portal app with company branding, contact information, and support details, providing employees with a consistent corporate experience when managing their devices. This improves user experience and ensures employees know how to get IT support when needed.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.intuneBrandingProfile.displayName","label":"Organization name","required":false}
            {"type":"switch","name":"standards.intuneBrandingProfile.showLogo","label":"Show logo"}
            {"type":"switch","name":"standards.intuneBrandingProfile.showDisplayNameNextToLogo","label":"Show organization name next to logo","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.contactITName","label":"Contact IT name","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.contactITPhoneNumber","label":"Contact IT phone number","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.contactITEmailAddress","label":"Contact IT email address","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.contactITNotes","label":"Contact IT notes","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.onlineSupportSiteName","label":"Online support site name","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.onlineSupportSiteUrl","label":"Online support site URL","required":false}
            {"type":"textField","name":"standards.intuneBrandingProfile.privacyUrl","label":"Privacy statement URL","required":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-06-20
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'intuneBrandingProfile' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'intuneBrandingProfile'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/deviceManagement/intuneBrandingProfiles/c3a59481-1bf2-46ce-94b3-66eec07a8d60' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the intuneBrandingProfile state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ((-not $Settings.displayName) -or ($CurrentState.displayName -eq $Settings.displayName)) -and
    ((-not $Settings.showLogo) -or ($CurrentState.showLogo -eq $Settings.showLogo)) -and
    ((-not $Settings.showDisplayNameNextToLogo) -or ($CurrentState.showDisplayNameNextToLogo -eq $Settings.showDisplayNameNextToLogo)) -and
    ((-not $Settings.contactITName) -or ($CurrentState.contactITName -eq $Settings.contactITName)) -and
    ((-not $Settings.contactITPhoneNumber) -or ($CurrentState.contactITPhoneNumber -eq $Settings.contactITPhoneNumber)) -and
    ((-not $Settings.contactITEmailAddress) -or ($CurrentState.contactITEmailAddress -eq $Settings.contactITEmailAddress)) -and
    ((-not $Settings.contactITNotes) -or ($CurrentState.contactITNotes -eq $Settings.contactITNotes)) -and
    ((-not $Settings.onlineSupportSiteName) -or ($CurrentState.onlineSupportSiteName -eq $Settings.onlineSupportSiteName)) -and
    ((-not $Settings.onlineSupportSiteUrl) -or ($CurrentState.onlineSupportSiteUrl -eq $Settings.onlineSupportSiteUrl)) -and
    ((-not $Settings.privacyUrl) -or ($CurrentState.privacyUrl -eq $Settings.privacyUrl))

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Intune Branding Profile is already correctly configured' -sev Info
        } else {
            $Body = @{}
            if ($Settings.displayName) { $Body.displayName = $Settings.displayName }
            if ($Settings.showLogo) { $Body.showLogo = $Settings.showLogo }
            if ($Settings.showDisplayNameNextToLogo) { $Body.showDisplayNameNextToLogo = $Settings.showDisplayNameNextToLogo }
            if ($Settings.contactITName) { $Body.contactITName = $Settings.contactITName }
            if ($Settings.contactITPhoneNumber) { $Body.contactITPhoneNumber = $Settings.contactITPhoneNumber }
            if ($Settings.contactITEmailAddress) { $Body.contactITEmailAddress = $Settings.contactITEmailAddress }
            if ($Settings.contactITNotes) { $Body.contactITNotes = $Settings.contactITNotes }
            if ($Settings.onlineSupportSiteName) { $Body.onlineSupportSiteName = $Settings.onlineSupportSiteName }
            if ($Settings.onlineSupportSiteUrl) { $Body.onlineSupportSiteUrl = $Settings.onlineSupportSiteUrl }
            if ($Settings.privacyUrl) { $Body.privacyUrl = $Settings.privacyUrl }

            $cmdParams = @{
                tenantid    = $tenant
                uri         = 'https://graph.microsoft.com/beta/deviceManagement/intuneBrandingProfiles/c3a59481-1bf2-46ce-94b3-66eec07a8d60'
                AsApp       = $true
                Type        = 'PATCH'
                Body        = ($Body | ConvertTo-Json)
                ContentType = 'application/json; charset=utf-8'
            }

            try {
                New-GraphPostRequest @cmdParams
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Successfully updated Intune Branding Profile' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to update Intune Branding Profile. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Intune Branding Profile is correctly configured' -sev Info
        } else {
            Write-StandardsAlert -message 'Intune Branding Profile is not correctly configured' -object $CurrentState -tenant $tenant -standardName 'intuneBrandingProfile' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Intune Branding Profile is not correctly configured' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $ReportState = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.intuneBrandingProfile' -FieldValue $ReportState -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'intuneBrandingProfile' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardintuneBrandingProfile.ps1' 121
#Region './Public/Standards/Invoke-CIPPStandardIntuneComplianceSettings.ps1' -1

function Invoke-CIPPStandardIntuneComplianceSettings {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) IntuneComplianceSettings
    .SYNOPSIS
        (Label) Set Intune Compliance Settings
    .DESCRIPTION
        (Helptext) Sets the mark devices with no compliance policy assigned as compliance/non compliant and Compliance status validity period.
        (DocsDescription) Sets the mark devices with no compliance policy assigned as compliance/non compliant and Compliance status validity period.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Configures how the system treats devices that don't have specific compliance policies and sets how often devices must check in to maintain their compliance status. This ensures proper security oversight of all corporate devices and maintains current compliance information.
        ADDEDCOMPONENT
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.IntuneComplianceSettings.secureByDefault","label":"Mark devices with no compliance policy as","options":[{"label":"Compliant","value":"false"},{"label":"Non-Compliant","value":"true"}]}
            {"type":"number","name":"standards.IntuneComplianceSettings.deviceComplianceCheckinThresholdDays","label":"Compliance status validity period (days)"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-11-12
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'IntuneComplianceSettings' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/deviceManagement/settings' -tenantid $Tenant |
        Select-Object secureByDefault, deviceComplianceCheckinThresholdDays
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the intuneDeviceReg state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($null -eq $Settings.deviceComplianceCheckinThresholdDays) { $Settings.deviceComplianceCheckinThresholdDays = $CurrentState.deviceComplianceCheckinThresholdDays }
    $SecureByDefault = [bool]($Settings.secureByDefault.value ? $Settings.secureByDefault.value : $Settings.secureByDefault)
    $DeviceComplianceCheckinThresholdDays = [int]$Settings.deviceComplianceCheckinThresholdDays

    $StateIsCorrect = ($CurrentState.secureByDefault -eq $SecureByDefault) -and
    ($CurrentState.deviceComplianceCheckinThresholdDays -eq $DeviceComplianceCheckinThresholdDays)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Intune Compliance settings is already applied correctly.' -Sev Info
        } else {
            try {
                $GraphRequest = @{
                    tenantID    = $Tenant
                    uri         = 'https://graph.microsoft.com/beta/deviceManagement'
                    AsApp       = $true
                    Type        = 'PATCH'
                    ContentType = 'application/json; charset=utf-8'
                    Body        = [pscustomobject]@{
                        settings = [pscustomobject]@{
                            secureByDefault                      = $SecureByDefault
                            deviceComplianceCheckinThresholdDays = $DeviceComplianceCheckinThresholdDays
                        }
                    } | ConvertTo-Json -Compress -Depth 5
                }
                New-GraphPostRequest @GraphRequest
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully updated Intune Compliance settings.' -Sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Failed to update Intune Compliance settings.' -Sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Intune Compliance settings is enabled.' -Sev Info
        } else {
            Write-StandardsAlert -message 'Intune Compliance settings is not enabled' -object $CurrentState -tenant $Tenant -standardName 'IntuneComplianceSettings' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Intune Compliance settings is not enabled.' -Sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.IntuneComplianceSettings' -FieldValue $state -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'IntuneComplianceSettings' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardIntuneComplianceSettings.ps1' 101
#Region './Public/Standards/Invoke-CIPPStandardintuneDeviceReg.ps1' -1

function Invoke-CIPPStandardintuneDeviceReg {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) intuneDeviceReg
    .SYNOPSIS
        (Label) Set Maximum Number of Devices per user
    .DESCRIPTION
        (Helptext) Sets the maximum number of devices that can be registered by a user. A value of 0 disables device registration by users
        (DocsDescription) Sets the maximum number of devices that can be registered by a user. A value of 0 disables device registration by users
    .NOTES
        CAT
            Intune Standards
        TAG
            "CISA (MS.AAD.17.1v1)"
        EXECUTIVETEXT
            Limits how many devices each employee can register for corporate access, preventing excessive device proliferation while accommodating legitimate business needs. This helps maintain security oversight and prevents potential abuse of device registration privileges.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.intuneDeviceReg.max","label":"Maximum devices (Enter 2147483647 for unlimited.)","required":true}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-03-27
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyDeviceRegistrationPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'intuneDeviceReg' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'intuneDeviceReg'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $PreviousSetting = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the intuneDeviceReg state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = if ($PreviousSetting.userDeviceQuota -eq $Settings.max) { $true } else { $false }

    If ($Settings.remediate -eq $true) {

        if ($PreviousSetting.userDeviceQuota -eq $Settings.max) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "User device quota is already set to $($Settings.max)" -sev Info
        } else {
            try {
                $PreviousSetting.userDeviceQuota = $Settings.max
                $NewBody = ConvertTo-Json -Compress -InputObject $PreviousSetting -Depth 5
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -Type PUT -Body $NewBody -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Set user device quota to $($Settings.max)" -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set user device quota to $($Settings.max) : $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "User device quota is set to $($Settings.max)" -sev Info
        } else {
            Write-StandardsAlert -message "User device quota is not set to $($Settings.max)" -object $PreviousSetting -tenant $tenant -standardName 'intuneDeviceReg' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "User device quota is not set to $($Settings.max)" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $PreviousSetting.userDeviceQuota
        Set-CIPPStandardsCompareField -FieldName 'standards.intuneDeviceReg' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'intuneDeviceReg' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardintuneDeviceReg.ps1' 86
#Region './Public/Standards/Invoke-CIPPStandardintuneDeviceRetirementDays.ps1' -1

function Invoke-CIPPStandardintuneDeviceRetirementDays {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) intuneDeviceRetirementDays
    .SYNOPSIS
        (Label) Set inactive device retirement days
    .DESCRIPTION
        (Helptext) A value between 31 and 365 is supported. retired devices are removed from Intune after the specified number of days.
        (DocsDescription) A value between 31 and 365 is supported. retired devices are removed from Intune after the specified number of days.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Automatically removes inactive devices from management after a specified period, helping maintain a clean device inventory and reducing security risks from abandoned or lost devices. This policy ensures that only actively used corporate devices remain in the management system.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.intuneDeviceRetirementDays.days","label":"Maximum days"}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-05-19
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'intuneDeviceRetirementDays' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'intuneDeviceRetirementDays'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/deviceManagement/managedDeviceCleanupRules' -tenantid $Tenant)
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the intuneDeviceRetirementDays state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = if ($CurrentInfo.DeviceInactivityBeforeRetirementInDays -eq $Settings.days) { $true } else { $false }

    if ($Settings.remediate -eq $true) {

        if ($CurrentInfo.DeviceInactivityBeforeRetirementInDays -eq $Settings.days) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "DeviceInactivityBeforeRetirementInDays for $($Settings.days) days is already enabled." -sev Info
        } else {
            if ($CurrentInfo) {
                $Type = 'Patch'
                $id = "('$($CurrentInfo.id)')"
            } else {
                $Type = 'Post'
            }
            try {
                $body = '{"displayName":"Default Policy","description":"Default Policy","deviceCleanupRulePlatformType":"all","deviceInactivityBeforeRetirementInDays":' + $Settings.days + '}'
                (New-GraphPostRequest -tenantid $tenant -Uri "https://graph.microsoft.com/beta/deviceManagement/managedDeviceCleanupRules$id" -Type $Type -Body $body -ContentType 'application/json')
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Enabled DeviceInactivityBeforeRetirementInDays for $($Settings.days) days." -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable DeviceInactivityBeforeRetirementInDays. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DeviceInactivityBeforeRetirementInDays is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'DeviceInactivityBeforeRetirementInDays is not enabled' -object $CurrentInfo -tenant $tenant -standardName 'intuneDeviceRetirementDays' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DeviceInactivityBeforeRetirementInDays is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentInfo.DeviceInactivityBeforeRetirementInDays
        Set-CIPPStandardsCompareField -FieldName 'standards.intuneDeviceRetirementDays' -FieldValue $state -Tenant $tenant
        Add-CIPPBPAField -FieldName 'intuneDeviceRetirementDays' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardintuneDeviceRetirementDays.ps1' 92
#Region './Public/Standards/Invoke-CIPPStandardintuneRequireMFA.ps1' -1

function Invoke-CIPPStandardintuneRequireMFA {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) intuneRequireMFA
    .SYNOPSIS
        (Label) Require Multi-factor Authentication to register or join devices with Microsoft Entra
    .DESCRIPTION
        (Helptext) Requires MFA for all users to register devices with Intune. This is useful when not using Conditional Access.
        (DocsDescription) Requires MFA for all users to register devices with Intune. This is useful when not using Conditional Access.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Requires employees to use multi-factor authentication when registering devices for corporate access, adding an extra security layer to prevent unauthorized device enrollment. This helps ensure only legitimate users can connect their devices to company systems.
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-10-23
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyDeviceRegistrationPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'intuneRequireMFA'

    try {
        $PreviousSetting = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the intuneRequireMFA state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($PreviousSetting.multiFactorAuthConfiguration -eq 'required') {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Require to use MFA when joining/registering Entra Devices is already enabled.' -sev Info
        } else {
            try {
                $NewSetting = $PreviousSetting
                $NewSetting.multiFactorAuthConfiguration = 'required'
                $NewBody = ConvertTo-Json -Compress -InputObject $NewSetting -Depth 10
                New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -Type PUT -Body $NewBody
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Set required to use MFA when joining/registering Entra Devices' -sev Info
                $PreviousSetting.multiFactorAuthConfiguration = 'required'
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set require to use MFA when joining/registering Entra Devices: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($PreviousSetting.multiFactorAuthConfiguration -eq 'required') {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Require to use MFA when joining/registering Entra Devices is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Require to use MFA when joining/registering Entra Devices is not enabled' -object $PreviousSetting -tenant $Tenant -standardName 'intuneRequireMFA' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Require to use MFA when joining/registering Entra Devices is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $RequireMFA = if ($PreviousSetting.multiFactorAuthConfiguration -eq 'required') { $true } else { $false }
        Set-CIPPStandardsCompareField -FieldName 'standards.intuneRequireMFA' -FieldValue $RequireMFA -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'intuneRequireMFA' -FieldValue $RequireMFA -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardintuneRequireMFA.ps1' 76
#Region './Public/Standards/Invoke-CIPPStandardIntuneTemplate.ps1' -1

function Invoke-CIPPStandardIntuneTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) IntuneTemplate
    .SYNOPSIS
        (Label) Intune Template
    .DESCRIPTION
        (Helptext) Deploy and manage Intune templates across devices.
        (DocsDescription) Deploy and manage Intune templates across devices.
    .NOTES
        CAT
            Templates
        MULTIPLE
            True
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        IMPACT
            High Impact
        ADDEDDATE
            2023-12-30
        EXECUTIVETEXT
            Deploys standardized device management configurations across all corporate devices, ensuring consistent security policies, application settings, and compliance requirements. This template-based approach streamlines device management while maintaining uniform security standards across the organization.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"required":false,"name":"TemplateList","label":"Select Intune Template","api":{"queryKey":"ListIntuneTemplates-autcomplete","url":"/api/ListIntuneTemplates","labelField":"Displayname","valueField":"GUID"}}
            {"type":"autoComplete","multiple":false,"required":false,"creatable":false,"name":"TemplateList-Tags","label":"Or select a package of Intune Templates","api":{"queryKey":"ListIntuneTemplates-tag-autcomplete","url":"/api/ListIntuneTemplates?mode=Tag","labelField":"label","valueField":"value","addedField":{"templates":"templates"}}}
            {"name":"AssignTo","label":"Who should this template be assigned to?","type":"radio","options":[{"label":"Do not assign","value":"On"},{"label":"Assign to all users","value":"allLicensedUsers"},{"label":"Assign to all devices","value":"AllDevices"},{"label":"Assign to all users and devices","value":"AllDevicesAndUsers"},{"label":"Assign to Custom Group","value":"customGroup"}]}
            {"type":"textField","required":false,"name":"customGroup","label":"Enter the custom group name if you selected 'Assign to Custom Group'. Wildcards are allowed."}
            {"name":"excludeGroup","label":"Exclude Groups","type":"textField","required":false,"helpText":"Enter the group name(s) to exclude from the assignment. Wildcards are allowed. Multiple group names are comma-seperated."}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'IntuneTemplate_general' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'intuneTemplate'

    if ($TestResult -eq $false) {
        #writing to each item that the license is not present.
        $settings.TemplateList | ForEach-Object {
            Set-CIPPStandardsCompareField -FieldName "standards.IntuneTemplate.$($_.value)" -FieldValue 'This tenant does not have the required license for this standard.' -Tenant $Tenant
        }
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'IntuneTemplate'"
    $Request = @{body = $null }
    Write-Host "IntuneTemplate: Starting process. Settings are: $($Settings | ConvertTo-Json -Compress)"
    $CompareList = foreach ($Template in $Settings) {
        Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Trying to find template"
        $Request.body = (Get-CIPPAzDataTableEntity @Table -Filter $Filter | Where-Object -Property RowKey -Like "$($Template.TemplateList.value)*").JSON | ConvertFrom-Json -ErrorAction SilentlyContinue
        if ($null -eq $Request.body) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to find template $($Template.TemplateList.value). Has this Intune Template been deleted?" -sev 'Error'
            continue
        }
        Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Got template."

        $displayname = $request.body.Displayname
        $description = $request.body.Description
        $RawJSON = $Request.body.RawJSON
        try {
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Grabbing existing Policy"
            $ExistingPolicy = Get-CIPPIntunePolicy -tenantFilter $Tenant -DisplayName $displayname -TemplateType $Request.body.Type
        } catch {
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Failed to get existing."
        }
        if ($ExistingPolicy) {
            try {
                Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Found existing policy."
                $RawJSON = Get-CIPPTextReplacement -Text $RawJSON -TenantFilter $Tenant
                Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Grabbing JSON existing."
                $JSONExistingPolicy = $ExistingPolicy.cippconfiguration | ConvertFrom-Json
                Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Got existing JSON. Converting RawJSON to Template"
                $JSONTemplate = $RawJSON | ConvertFrom-Json
                Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Converted RawJSON to Template."
                Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Comparing JSON."
                $Compare = Compare-CIPPIntuneObject -ReferenceObject $JSONTemplate -DifferenceObject $JSONExistingPolicy -compareType $Request.body.Type -ErrorAction SilentlyContinue
            } catch {
                Write-Host "The compare failed. The error was: $($_.Exception.Message)"
            }
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Compared JSON: $($Compare | ConvertTo-Json -Compress)"
        } else {
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - No existing policy found."
            $compare = [pscustomobject]@{
                MatchFailed = $true
                Difference  = 'This policy does not exist in Intune.'
            }
        }
        if ($Compare) {
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - Compare found differences."
            [PSCustomObject]@{
                MatchFailed            = $true
                displayname            = $displayname
                description            = $description
                compare                = $Compare
                rawJSON                = $RawJSON
                body                   = $Request.body
                assignTo               = $Template.AssignTo
                excludeGroup           = $Template.excludeGroup
                remediate              = $Template.remediate
                alert                  = $Template.alert
                report                 = $Template.report
                existingPolicyId       = $ExistingPolicy.id
                templateId             = $Template.TemplateList.value
                customGroup            = $Template.customGroup
                assignmentFilter       = $Template.assignmentFilter
                assignmentFilterType   = $Template.assignmentFilterType
            }
        } else {
            Write-Host "IntuneTemplate: $($Template.TemplateList.value) - No differences found."
            [PSCustomObject]@{
                MatchFailed            = $false
                displayname            = $displayname
                description            = $description
                compare                = $false
                rawJSON                = $RawJSON
                body                   = $Request.body
                assignTo               = $Template.AssignTo
                excludeGroup           = $Template.excludeGroup
                remediate              = $Template.remediate
                alert                  = $Template.alert
                report                 = $Template.report
                existingPolicyId       = $ExistingPolicy.id
                templateId             = $Template.TemplateList.value
                customGroup            = $Template.customGroup
                assignmentFilter       = $Template.assignmentFilter
                assignmentFilterType   = $Template.assignmentFilterType
            }
        }
    }

    if ($true -in $Settings.remediate) {
        Write-Host 'starting template deploy'
        foreach ($TemplateFile in $CompareList | Where-Object -Property remediate -EQ $true) {
            Write-Host "working on template deploy: $($TemplateFile.displayname)"
            try {
                $TemplateFile.customGroup ? ($TemplateFile.AssignTo = $TemplateFile.customGroup) : $null
                
                $PolicyParams = @{
                    TemplateType  = $TemplateFile.body.Type
                    Description   = $TemplateFile.description
                    DisplayName   = $TemplateFile.displayname
                    RawJSON       = $templateFile.rawJSON
                    AssignTo      = $TemplateFile.AssignTo
                    ExcludeGroup  = $TemplateFile.excludeGroup
                    tenantFilter  = $Tenant
                }

                # Add assignment filter if specified
                if ($TemplateFile.assignmentFilter) {
                    $PolicyParams.AssignmentFilterName = $TemplateFile.assignmentFilter
                    $PolicyParams.AssignmentFilterType = $TemplateFile.assignmentFilterType ?? 'include'
                }

                Set-CIPPIntunePolicy @PolicyParams
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to create or update Intune Template $($TemplateFile.displayname), Error: $ErrorMessage" -sev 'Error'
            }
        }

    }

    if ($true -in $Settings.alert) {
        foreach ($Template in $CompareList | Where-Object -Property alert -EQ $true) {
            Write-Host "working on template alert: $($Template.displayname)"
            $AlertObj = $Template | Select-Object -Property displayname, description, compare, assignTo, excludeGroup, existingPolicyId
            if ($Template.compare) {
                Write-StandardsAlert -message "Template $($Template.displayname) does not match the expected configuration." -object $AlertObj -tenant $Tenant -standardName 'IntuneTemplate' -standardId $Settings.templateId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Template $($Template.displayname) does not match the expected configuration. We've generated an alert" -sev info
            } else {
                if ($Template.ExistingPolicyId) {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Template $($Template.displayname) has the correct configuration." -sev Info
                } else {
                    Write-StandardsAlert -message "Template $($Template.displayname) is missing." -object $AlertObj -tenant $Tenant -standardName 'IntuneTemplate' -standardId $Settings.templateId
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Template $($Template.displayname) is missing." -sev info
                }
            }
        }
    }

    if ($true -in $Settings.report) {
        foreach ($Template in $CompareList | Where-Object { $_.report -eq $true -or $_.remediate -eq $true }) {
            Write-Host "working on template report: $($Template.displayname)"
            $id = $Template.templateId
            $CompareObj = $Template.compare
            $state = $CompareObj ? $CompareObj : $true
            Set-CIPPStandardsCompareField -FieldName "standards.IntuneTemplate.$id" -FieldValue $state -TenantFilter $Tenant
        }
        #Add-CIPPBPAField -FieldName "policy-$id" -FieldValue $Compare -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardIntuneTemplate.ps1' 196
#Region './Public/Standards/Invoke-CIPPStandardlaps.ps1' -1

function Invoke-CIPPStandardlaps {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) laps
    .SYNOPSIS
        (Label) Enable LAPS on the tenant
    .DESCRIPTION
        (Helptext) Enables the tenant to use LAPS. You must still create a policy for LAPS to be active on all devices. Use the template standards to deploy this by default.
        (DocsDescription) Enables the LAPS functionality on the tenant. Prerequisite for using Windows LAPS via Azure AD.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Enables Local Administrator Password Solution (LAPS) capability, which automatically manages and rotates local administrator passwords on company computers. This significantly improves security by preventing the use of shared or static administrator passwords that could be exploited by attackers.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2023-04-25
        POWERSHELLEQUIVALENT
            Portal or Graph API
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'laps'

    try {
        $PreviousSetting = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DeviceRegistrationPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    If ($Settings.remediate -eq $true) {
        try {
            $PreviousSetting.localAdminPassword.isEnabled = $true
            $NewBody = ConvertTo-Json -Compress -InputObject $PreviousSetting -Depth 10
            New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/policies/deviceRegistrationPolicy' -Type PUT -Body $NewBody -ContentType 'application/json'
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'LAPS has been enabled.' -sev Info
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $PreviousSetting.localAdminPassword.isEnabled = $false
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable LAPS: $ErrorMessage" -sev Error
        }
    }
    if ($Settings.alert -eq $true) {
        if ($PreviousSetting.localAdminPassword.isEnabled) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'LAPS is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'LAPS is not enabled' -object $PreviousSetting -tenant $Tenant -standardName 'laps' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'LAPS is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $PreviousSetting.localAdminPassword.isEnabled ? $true : $false
        Set-CIPPStandardsCompareField -FieldName 'standards.laps' -FieldValue $state -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'laps' -FieldValue $PreviousSetting.localAdminPassword.isEnabled -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardlaps.ps1' 72
#Region './Public/Standards/Invoke-CIPPStandardLegacyEmailReportAddins.ps1' -1

function Invoke-CIPPStandardLegacyEmailReportAddins {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) LegacyEmailReportAddins
    .SYNOPSIS
        (Label) Remove legacy Outlook Report add-ins
    .DESCRIPTION
        (Helptext) Removes legacy Report Phishing and Report Message Outlook add-ins.
        (DocsDescription) Removes legacy Report Phishing and Report Message Outlook add-ins.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            The legacy Report Phishing and Report Message Outlook add-ins are security issues with the add-in which makes them unsafe for the organization.
        IMPACT
            Low Impact
        ADDEDDATE
            2025-08-26
        POWERSHELLEQUIVALENT
            None
        RECOMMENDEDBY
            "Microsoft"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    # Define the legacy add-ins to remove
    $LegacyAddins = @(
        @{
            AssetId = 'WA200002469'
            ProductId = '3f32746a-0586-4c54-b8ce-d3b611c5b6c8'
            Name = 'Report Phishing'
        },
        @{
            AssetId = 'WA104381180'
            ProductId = '6046742c-3aee-485e-a4ac-92ab7199db2e'
            Name = 'Report Message'
        }
    )

    try {
        $CurrentApps = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $Tenant -Uri 'https://admin.microsoft.com/fd/addins/api/apps?workloads=AzureActiveDirectory,WXPO,MetaOS,Teams,SharePoint'
        $InstalledApps = $CurrentApps.apps
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the installed add-ins for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Check which legacy add-ins are currently installed
    $AddinsToRemove = [System.Collections.Generic.List[PSCustomObject]]::new()
    $InstalledLegacyAddins = [System.Collections.Generic.List[string]]::new()

    foreach ($LegacyAddin in $LegacyAddins) {
        $InstalledAddin = $InstalledApps | Where-Object { $_.assetId -eq $LegacyAddin.AssetId -or $_.productId -eq $LegacyAddin.ProductId }
        if ($InstalledAddin) {
            $InstalledLegacyAddins.Add($LegacyAddin.Name)
            $AddinsToRemove.Add([PSCustomObject]@{
                AppsourceAssetID = $LegacyAddin.AssetId
                ProductID = $LegacyAddin.ProductId
                Command = 'UNDEPLOY'
                Workload = 'WXPO'
            })
        }
    }

    $StateIsCorrect = ($AddinsToRemove.Count -eq 0)
    $RemediationPerformed = $false

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Legacy Email Report Add-ins are already removed.' -Sev Info
        } else {
            foreach ($AddinToRemove in $AddinsToRemove) {
                try {
                    $Body = @{
                        Locale = 'en-US'
                        WorkloadManagementList = @($AddinToRemove)
                    } | ConvertTo-Json -Depth 10 -Compress

                    $GraphRequest = @{
                        tenantID = $Tenant
                        uri = 'https://admin.microsoft.com/fd/addins/api/apps'
                        scope = 'https://admin.microsoft.com/.default'
                        AsApp = $false
                        Type = 'POST'
                        ContentType = 'application/json; charset=utf-8'
                        Body = $Body
                    }

                    $Response = New-GraphPostRequest @GraphRequest
                    $AddinName = ($LegacyAddins | Where-Object { $_.AssetId -eq $AddinToRemove.AppsourceAssetID }).Name
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Successfully initiated removal of $AddinName add-in" -Sev Info
                    $RemediationPerformed = $true
                } catch {
                    $AddinName = ($LegacyAddins | Where-Object { $_.AssetId -eq $AddinToRemove.AppsourceAssetID }).Name
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to remove $AddinName add-in" -Sev Error -LogData $_
                }
            }
        }
    }

    # If we performed remediation and need to report/alert, get fresh state
    if ($RemediationPerformed -and ($Settings.alert -eq $true -or $Settings.report -eq $true)) {
        try {
            $FreshApps = New-GraphGetRequest -scope 'https://admin.microsoft.com/.default' -TenantID $Tenant -Uri 'https://admin.microsoft.com/fd/addins/api/apps?workloads=AzureActiveDirectory,WXPO,MetaOS,Teams,SharePoint'
            $FreshInstalledApps = $FreshApps.apps

            # Check fresh state
            $FreshInstalledLegacyAddins = [System.Collections.Generic.List[string]]::new()
            foreach ($LegacyAddin in $LegacyAddins) {
                $InstalledAddin = $FreshInstalledApps | Where-Object { $_.assetId -eq $LegacyAddin.AssetId -or $_.productId -eq $LegacyAddin.ProductId }
                if ($InstalledAddin) {
                    $FreshInstalledLegacyAddins.Add($LegacyAddin.Name)
                }
            }

            # Use fresh state for reporting/alerting
            $StateIsCorrect = ($FreshInstalledLegacyAddins.Count -eq 0)
            $InstalledLegacyAddins = $FreshInstalledLegacyAddins
        }
        catch {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get fresh add-in state after remediation for $Tenant" -Sev Warning
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Legacy Email Report Add-ins are not installed.' -sev Info
        } else {
            $InstalledAddinsText = ($InstalledLegacyAddins -join ', ')
            Write-StandardsAlert -message "Legacy Email Report Add-ins are still installed: $InstalledAddinsText" -tenant $tenant -standardName 'LegacyEmailReportAddins' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Legacy Email Report Add-ins are still installed: $InstalledAddinsText" -sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        $ReportData = if ($StateIsCorrect) {
            $true
        } else {
            @{
                InstalledLegacyAddins = $InstalledLegacyAddins
                Status = 'Legacy add-ins still installed'
            }
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.LegacyEmailReportAddins' -FieldValue $ReportData -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'LegacyEmailReportAddins' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardLegacyEmailReportAddins.ps1' 158
#Region './Public/Standards/Invoke-CIPPStandardLegacyMFA.ps1' -1

function Invoke-CIPPStandardLegacyMFA {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    Write-LogMessage -API 'Standards' -tenant $tenant -message 'Per user MFA APIs have been disabled.' -sev Info

}
#EndRegion './Public/Standards/Invoke-CIPPStandardLegacyMFA.ps1' 10
#Region './Public/Standards/Invoke-CIPPStandardLegacyMFACleanup.ps1' -1

function Invoke-CIPPStandardLegacyMFACleanup {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) LegacyMFACleanup
    .SYNOPSIS
        (Label) Remove Legacy MFA if SD or CA is active
    .DESCRIPTION
        (Helptext) This standard currently does not function and can be safely disabled
        (DocsDescription) This standard currently does not function and can be safely disabled
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            This standard is currently non-functional and should be disabled. It was previously designed to remove outdated multi-factor authentication configurations in favor of modern security policies.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-MsolUser -StrongAuthenticationRequirements \$null
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    Write-LogMessage -API 'Standards' -tenant $tenant -message 'Per User MFA APIs have been disabled.' -sev Info
    # TODO - Re-implement this standard

}
#EndRegion './Public/Standards/Invoke-CIPPStandardLegacyMFACleanup.ps1' 37
#Region './Public/Standards/Invoke-CIPPStandardMailboxRecipientLimits.ps1' -1

function Invoke-CIPPStandardMailboxRecipientLimits {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) MailboxRecipientLimits
    .SYNOPSIS
        (Label) Set Mailbox Recipient Limits
    .DESCRIPTION
        (Helptext) Sets the maximum number of recipients that can be specified in the To, Cc, and Bcc fields of a message for all mailboxes in the tenant.
        (DocsDescription) This standard configures the recipient limits for all mailboxes in the tenant. The recipient limit determines the maximum number of recipients that can be specified in the To, Cc, and Bcc fields of a message. This helps prevent spam and manage email flow.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Controls how many recipients employees can include in a single email, helping prevent spam distribution and managing email server load. This security measure protects against both accidental mass mailings and potential abuse while ensuring legitimate business communications can still reach necessary recipients.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.MailboxRecipientLimits.RecipientLimit","label":"Recipient Limit","defaultValue":500}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-05-28
        POWERSHELLEQUIVALENT
            Set-Mailbox -RecipientLimits
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'MailboxRecipientLimits' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Input validation
    if ([Int32]$Settings.RecipientLimit -lt 0 -or [Int32]$Settings.RecipientLimit -gt 10000) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'MailboxRecipientLimits: Invalid RecipientLimit parameter set. Must be between 0 and 10000.' -sev Error
        return
    }

    # Get mailbox plans first
    try {
        $MailboxPlans = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailboxPlan' -cmdParams @{ ResultSize = 'Unlimited' }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the MailboxRecipientLimits state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Create a hashtable of mailbox plans for quick lookup
    $MailboxPlanLookup = @{}
    foreach ($Plan in $MailboxPlans) {
        $MailboxPlanLookup[$Plan.Guid] = $Plan
    }

    # Get mailboxes that need updating (either different from target limit or have "Unlimited" set)
    $Requests = @(
        @{
            CmdletInput = @{
                CmdletName = 'Get-Mailbox'
                Parameters = @{
                    ResultSize = 'Unlimited'
                    Filter     = "RecipientLimits -ne '$($Settings.RecipientLimit)' -or RecipientLimits -eq 'Unlimited'"
                }
            }
        }
    )

    $Mailboxes = New-ExoBulkRequest -tenantid $Tenant -cmdletArray $Requests

    # Skip processing entirely if no mailboxes returned - most performant approach
    $MailboxResults = @()
    $MailboxesToUpdate = @()
    $MailboxesWithPlanIssues = @()

    if ($null -ne $Mailboxes -and @($Mailboxes).Count -gt 0) {
        # Process mailboxes and categorize them based on their plan limits
        $MailboxResults = @($Mailboxes) | ForEach-Object {

            $Mailbox = $_
            if ($Mailbox.UserPrincipalName -like 'DiscoverySearchMailbox*' -or $Mailbox.UserPrincipalName -like 'SystemMailbox*') {
                return
            }
            # Safe hashtable lookup - check if MailboxPlanId exists and is not null
            $Plan = $null
            if ($Mailbox.MailboxPlanId -and $MailboxPlanLookup.ContainsKey($Mailbox.MailboxPlanId)) {
                $Plan = $MailboxPlanLookup[$Mailbox.MailboxPlanId]
            }

            if ($Plan) {
                $PlanMaxRecipients = $Plan.MaxRecipientsPerMessage

                # If mailbox has "Unlimited" set but has a plan, use the plan's limit as the current limit
                $CurrentLimit = if ($Mailbox.RecipientLimits -eq 'Unlimited') {
                    $PlanMaxRecipients
                } else {
                    $Mailbox.RecipientLimits
                }

                if ($Settings.RecipientLimit -gt $PlanMaxRecipients) {
                    [PSCustomObject]@{
                        Type         = 'PlanIssue'
                        Mailbox      = $Mailbox
                        CurrentLimit = $CurrentLimit
                        PlanLimit    = $PlanMaxRecipients
                        PlanName     = $Plan.DisplayName
                    }
                } elseif ($CurrentLimit -ne $Settings.RecipientLimit) {
                    [PSCustomObject]@{
                        Type    = 'ToUpdate'
                        Mailbox = $Mailbox
                    }
                }
            } elseif ($Mailbox.RecipientLimits -ne $Settings.RecipientLimit) {
                [PSCustomObject]@{
                    Type    = 'ToUpdate'
                    Mailbox = $Mailbox
                }
            }
        }

        # Separate mailboxes into their respective categories only if we have results
        $MailboxesToUpdate = $MailboxResults | Where-Object { $_.Type -eq 'ToUpdate' } | Select-Object -ExpandProperty Mailbox
        $MailboxesWithPlanIssues = $MailboxResults | Where-Object { $_.Type -eq 'PlanIssue' } | ForEach-Object {
            [PSCustomObject]@{
                Identity     = $_.Mailbox.Identity
                CurrentLimit = $_.CurrentLimit
                PlanLimit    = $_.PlanLimit
                PlanName     = $_.PlanName
            }
        }
    }

    # Remediation
    if ($Settings.remediate -eq $true) {
        if ($MailboxesWithPlanIssues.Count -gt 0) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Found $($MailboxesWithPlanIssues.Count) mailboxes where the requested recipient limit ($($Settings.RecipientLimit)) exceeds their mailbox plan limit. These mailboxes will not be updated." -sev Info
            foreach ($Mailbox in $MailboxesWithPlanIssues) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Mailbox $($Mailbox.Identity) has plan $($Mailbox.PlanName) with maximum limit of $($Mailbox.PlanLimit)" -sev Info
            }
        }

        if ($MailboxesToUpdate.Count -gt 0) {
            try {
                # Create detailed log data for audit trail
                $MailboxChanges = $MailboxesToUpdate | ForEach-Object {
                    $CurrentLimit = if ($_.RecipientLimits -eq 'Unlimited') { 'Unlimited' } else { $_.RecipientLimits }
                    @{
                        Identity           = $_.Identity
                        DisplayName        = $_.DisplayName
                        PrimarySmtpAddress = $_.PrimarySmtpAddress
                        CurrentLimit       = $CurrentLimit
                        NewLimit           = $Settings.RecipientLimit
                    }
                }

                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updating recipient limits to $($Settings.RecipientLimit) for $($MailboxesToUpdate.Count) mailboxes" -sev Info -LogData $MailboxChanges

                # Create batch requests for mailbox updates
                $UpdateRequests = $MailboxesToUpdate | ForEach-Object {
                    @{
                        CmdletInput = @{
                            CmdletName = 'Set-Mailbox'
                            Parameters = @{
                                Identity        = $_.Identity
                                RecipientLimits = $Settings.RecipientLimit
                            }
                        }
                    }
                }

                # Execute batch update
                $null = New-ExoBulkRequest -tenantid $Tenant -cmdletArray $UpdateRequests
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully applied recipient limits to $($MailboxesToUpdate.Count) mailboxes" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set recipient limits. $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "All mailboxes already have the correct recipient limit of $($Settings.RecipientLimit)" -sev Info
        }
    }

    # Alert
    if ($Settings.alert -eq $true) {
        if ($MailboxesToUpdate.Count -eq 0 -and $MailboxesWithPlanIssues.Count -eq 0) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "All mailboxes have the correct recipient limit of $($Settings.RecipientLimit)" -sev Info
        } else {
            # Create structured alert data
            $AlertData = @{
                RequestedLimit          = $Settings.RecipientLimit
                MailboxesToUpdate       = @()
                MailboxesWithPlanIssues = @()
            }

            # Use Generic List for efficient object collection
            $AlertObjects = [System.Collections.Generic.List[Object]]::new()

            # Add mailboxes that need updating
            if ($MailboxesToUpdate.Count -gt 0) {
                $AlertData.MailboxesToUpdate = $MailboxesToUpdate | ForEach-Object {
                    $CurrentLimit = if ($_.RecipientLimits -eq 'Unlimited') { 'Unlimited' } else { $_.RecipientLimits }
                    @{
                        Identity           = $_.Identity
                        DisplayName        = $_.DisplayName
                        PrimarySmtpAddress = $_.PrimarySmtpAddress
                        CurrentLimit       = $CurrentLimit
                        RequiredLimit      = $Settings.RecipientLimit
                    }
                }
                # Add to alert objects list efficiently
                foreach ($Mailbox in $MailboxesToUpdate) {
                    $AlertObjects.Add($Mailbox)
                }
            }

            # Add mailboxes with plan issues
            if ($MailboxesWithPlanIssues.Count -gt 0) {
                $AlertData.MailboxesWithPlanIssues = $MailboxesWithPlanIssues | ForEach-Object {
                    @{
                        Identity       = $_.Identity
                        CurrentLimit   = $_.CurrentLimit
                        PlanLimit      = $_.PlanLimit
                        PlanName       = $_.PlanName
                        RequestedLimit = $Settings.RecipientLimit
                    }
                }
                # Add to alert objects list efficiently
                foreach ($Mailbox in $MailboxesWithPlanIssues) {
                    $AlertObjects.Add($Mailbox)
                }
            }

            # Build alert message efficiently
            $AlertMessage = if ($MailboxesWithPlanIssues.Count -gt 0) {
                "Found $($MailboxesToUpdate.Count) mailboxes with incorrect recipient limits and $($MailboxesWithPlanIssues.Count) mailboxes where the requested limit exceeds their mailbox plan limit"
            } else {
                "Found $($MailboxesToUpdate.Count) mailboxes with incorrect recipient limits"
            }

            Write-StandardsAlert -message $AlertMessage -object $AlertObjects.ToArray() -tenant $Tenant -standardName 'MailboxRecipientLimits' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message $AlertMessage -sev Info -LogData $AlertData
        }
    }

    # Report
    if ($Settings.report -eq $true) {
        $ReportData = @{
            MailboxesToUpdate       = $MailboxesToUpdate
            MailboxesWithPlanIssues = $MailboxesWithPlanIssues
        }
        Add-CIPPBPAField -FieldName 'MailboxRecipientLimits' -FieldValue $ReportData -StoreAs json -Tenant $Tenant

        if ($MailboxesToUpdate.Count -eq 0 -and $MailboxesWithPlanIssues.Count -eq 0) {
            $FieldValue = $true
        } else {
            $FieldValue = $ReportData
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.MailboxRecipientLimits' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardMailboxRecipientLimits.ps1' 270
#Region './Public/Standards/Invoke-CIPPStandardMailContacts.ps1' -1

function Invoke-CIPPStandardMailContacts {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) MailContacts
    .SYNOPSIS
        (Label) Set contact e-mails
    .DESCRIPTION
        (Helptext) Defines the email address to receive general updates and information related to M365 subscriptions. Leave a contact field blank if you do not want to update the contact information.
        (DocsDescription) Defines the email address to receive general updates and information related to M365 subscriptions. Leave a contact field blank if you do not want to update the contact information.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Establishes designated contact email addresses for receiving important Microsoft 365 subscription updates and notifications. This ensures proper communication channels are maintained for general, security, marketing, and technical matters, improving organizational responsiveness to critical system updates.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.MailContacts.GeneralContact","label":"General Contact","required":false}
            {"type":"textField","name":"standards.MailContacts.SecurityContact","label":"Security Contact","required":false}
            {"type":"textField","name":"standards.MailContacts.MarketingContact","label":"Marketing Contact","required":false}
            {"type":"textField","name":"standards.MailContacts.TechContact","label":"Technical Contact","required":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2022-03-13
        POWERSHELLEQUIVALENT
            Set-MsolCompanyContactInformation
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'MailContacts'

    try {
        $TenantID = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/organization' -tenantid $tenant)
        $CurrentInfo = New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/organization/$($TenantID.id)" -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the MailContacts state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $contacts = $settings
    $TechAndSecurityContacts = @($Contacts.SecurityContact, $Contacts.TechContact)

    $state = $CurrentInfo.marketingNotificationEmails -eq $Contacts.MarketingContact -and `
    ($CurrentInfo.securityComplianceNotificationMails -in $TechAndSecurityContacts -or
        $CurrentInfo.technicalNotificationMails -in $TechAndSecurityContacts) -and `
        $CurrentInfo.privacyProfile.contactEmail -eq $Contacts.GeneralContact

    if ($Settings.remediate -eq $true) {
        if ($state) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Contact emails are already set.' -sev Info
        } else {
            try {
                $Body = [pscustomobject]@{}
                switch ($Contacts) {
                    { $Contacts.MarketingContact } { $body | Add-Member -NotePropertyName marketingNotificationEmails -NotePropertyValue @($Contacts.MarketingContact) }
                    { $Contacts.SecurityContact } { $body | Add-Member -NotePropertyName technicalNotificationMails -NotePropertyValue @($Contacts.SecurityContact) }
                    { $Contacts.TechContact } { $body | Add-Member -NotePropertyName technicalNotificationMails -NotePropertyValue @($Contacts.TechContact) -ErrorAction SilentlyContinue }
                    { $Contacts.GeneralContact } { $body | Add-Member -NotePropertyName privacyProfile -NotePropertyValue @{contactEmail = $Contacts.GeneralContact } }
                }
                Write-Host (ConvertTo-Json -InputObject $body)
                New-GraphPostRequest -tenantid $tenant -Uri "https://graph.microsoft.com/v1.0/organization/$($TenantID.id)" -asApp $true -Type patch -Body (ConvertTo-Json -InputObject $body) -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Contact emails set.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set contact emails: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.marketingNotificationEmails -eq $Contacts.MarketingContact) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Marketing contact email is set to $($Contacts.MarketingContact)" -sev Info
        } else {
            $Object = $CurrentInfo | Select-Object marketingNotificationEmails
            Write-StandardsAlert -message "Marketing contact email is not set to $($Contacts.MarketingContact)" -object $Object -tenant $tenant -standardName 'MailContacts' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Marketing contact email is not set to $($Contacts.MarketingContact)" -sev Info
        }
        if (!$Contacts.SecurityContact -or $CurrentInfo.technicalNotificationMails -contains $Contacts.SecurityContact) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Security contact email is set to $($Contacts.SecurityContact)" -sev Info
        } else {
            $Object = $CurrentInfo | Select-Object technicalNotificationMails
            Write-StandardsAlert -message "Security contact email is not set to $($Contacts.SecurityContact)" -object $Object -tenant $tenant -standardName 'MailContacts' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Security contact email is not set to $($Contacts.SecurityContact)" -sev Info
        }
        if (!$Contacts.TechContact -or $CurrentInfo.technicalNotificationMails -contains $Contacts.TechContact) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Technical contact email is set to $($Contacts.TechContact)" -sev Info
        } else {
            $Object = $CurrentInfo | Select-Object technicalNotificationMails
            Write-StandardsAlert -message "Technical contact email is not set to $($Contacts.TechContact)" -object $Object -tenant $tenant -standardName 'MailContacts' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Technical contact email is not set to $($Contacts.TechContact)" -sev Info
        }
        if ($CurrentInfo.privacyProfile.contactEmail -eq $Contacts.GeneralContact) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "General contact email is set to $($Contacts.GeneralContact)" -sev Info
        } else {
            $Object = $CurrentInfo | Select-Object privacyProfile
            Write-StandardsAlert -message "General contact email is not set to $($Contacts.GeneralContact)" -object $Object -tenant $tenant -standardName 'MailContacts' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "General contact email is not set to $($Contacts.GeneralContact)" -sev Info
        }

    }
    if ($Settings.report -eq $true) {
        $ReportState = $state ? $true : ($CurrentInfo | Select-Object marketingNotificationEmails, technicalNotificationMails, privacyProfile)
        Set-CIPPStandardsCompareField -FieldName 'standards.MailContacts' -FieldValue $ReportState -Tenant $tenant
        Add-CIPPBPAField -FieldName 'MailContacts' -FieldValue $CurrentInfo -StoreAs json -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardMailContacts.ps1' 115
#Region './Public/Standards/Invoke-CIPPStandardMalwareFilterPolicy.ps1' -1

function Invoke-CIPPStandardMalwareFilterPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) MalwareFilterPolicy
    .SYNOPSIS
        (Label) Default Malware Filter Policy
    .DESCRIPTION
        (Helptext) This creates a Malware filter policy that enables the default File filter and Zero-hour auto purge for malware.
        (DocsDescription) This creates a Malware filter policy that enables the default File filter and Zero-hour auto purge for malware.
    .NOTES
        CAT
            Defender Standards
        TAG
            "CIS M365 5.0 (2.1.2)"
            "CIS M365 5.0 (2.1.3)"
            "mdo_zapspam"
            "mdo_zapphish"
            "mdo_zapmalware"
            "NIST CSF 2.0 (DE.CM-09)"
        ADDEDCOMPONENT
            {"type":"select","multiple":false,"label":"FileTypeAction","name":"standards.MalwareFilterPolicy.FileTypeAction","options":[{"label":"Reject","value":"Reject"},{"label":"Quarantine the message","value":"Quarantine"}]}
            {"type":"textField","name":"standards.MalwareFilterPolicy.OptionalFileTypes","required":false,"label":"Optional File Types, Comma separated"}
            {"type":"select","multiple":false,"creatable":true,"label":"QuarantineTag","name":"standards.MalwareFilterPolicy.QuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"switch","label":"Enable Internal Sender Admin Notifications","required":false,"name":"standards.MalwareFilterPolicy.EnableInternalSenderAdminNotifications"}
            {"type":"textField","name":"standards.MalwareFilterPolicy.InternalSenderAdminAddress","required":false,"label":"Internal Sender Admin Address","condition":{"field":"standards.MalwareFilterPolicy.EnableInternalSenderAdminNotifications","compareType":"is","compareValue":true}}
            {"type":"switch","label":"Enable External Sender Admin Notifications","required":false,"name":"standards.MalwareFilterPolicy.EnableExternalSenderAdminNotifications"}
            {"type":"textField","name":"standards.MalwareFilterPolicy.ExternalSenderAdminAddress","required":false,"label":"External Sender Admin Address","condition":{"field":"standards.MalwareFilterPolicy.EnableExternalSenderAdminNotifications","compareType":"is","compareValue":true}}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-25
        POWERSHELLEQUIVALENT
            Set-MalwareFilterPolicy or New-MalwareFilterPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'MalwareFilterPolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'MalwareFilterPolicy'

    # Use custom name if provided, otherwise use default for backward compatibility
    $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Malware Policy' }
    $PolicyList = @($PolicyName, 'CIPP Default Malware Policy', 'Default Malware Policy')
    $ExistingPolicy = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MalwareFilterPolicy' | Where-Object -Property Name -In $PolicyList | Select-Object -First 1
    if ($null -eq $ExistingPolicy.Name) {
        # No existing policy - use the configured/default name
        $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Malware Policy' }
    } else {
        # Use existing policy name if found
        $PolicyName = $ExistingPolicy.Name
    }
    # Derive rule name from policy name, but check for old names for backward compatibility
    $DesiredRuleName = "$PolicyName Rule"
    $RuleList = @($DesiredRuleName, 'CIPP Default Malware Rule', 'CIPP Default Malware Policy')
    $ExistingRule = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MalwareFilterRule' | Where-Object -Property Name -In $RuleList | Select-Object -First 1
    if ($null -eq $ExistingRule.Name) {
        # No existing rule - use the derived name
        $RuleName = $DesiredRuleName
    } else {
        # Use existing rule name if found
        $RuleName = $ExistingRule.Name
    }

    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MalwareFilterPolicy' |
            Where-Object -Property Name -EQ $PolicyName |
            Select-Object Name, EnableFileFilter, FileTypeAction, FileTypes, ZapEnabled, QuarantineTag, EnableInternalSenderAdminNotifications, InternalSenderAdminAddress, EnableExternalSenderAdminNotifications, ExternalSenderAdminAddress
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the MalwareFilterPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $DefaultFileTypes = @('ace', 'ani', 'apk', 'app', 'appx', 'arj', 'bat', 'cab', 'cmd', 'com', 'deb', 'dex', 'dll', 'docm', 'elf', 'exe', 'hta', 'img', 'iso', 'jar', 'jnlp', 'kext', 'lha', 'lib', 'library', 'lnk', 'lzh', 'macho', 'msc', 'msi', 'msix', 'msp', 'mst', 'pif', 'ppa', 'ppam', 'reg', 'rev', 'scf', 'scr', 'sct', 'sys', 'uif', 'vb', 'vbe', 'vbs', 'vxd', 'wsc', 'wsf', 'wsh', 'xll', 'xz', 'z')

    if ($null -eq $Settings.OptionalFileTypes) {
        $ExpectedFileTypes = $DefaultFileTypes
    } else {
        $ExpectedFileTypes = $DefaultFileTypes + @($Settings.OptionalFileTypes.Split(',').Trim())
    }

    $FileTypeAction = $Settings.FileTypeAction.value ?? $Settings.FileTypeAction ?? 'Quarantine'

    $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
    ($CurrentState.EnableFileFilter -eq $true) -and
    ($CurrentState.FileTypeAction -eq $FileTypeAction) -and
    (!(Compare-Object -ReferenceObject $CurrentState.FileTypes -DifferenceObject $ExpectedFileTypes)) -and
    ($CurrentState.ZapEnabled -eq $true) -and
    ($CurrentState.QuarantineTag -eq $Settings.QuarantineTag) -and
    ($CurrentState.EnableInternalSenderAdminNotifications -eq $Settings.EnableInternalSenderAdminNotifications) -and
    (($null -eq $Settings.InternalSenderAdminAddress) -or ($CurrentState.InternalSenderAdminAddress -eq $Settings.InternalSenderAdminAddress)) -and
    ($CurrentState.EnableExternalSenderAdminNotifications -eq $Settings.EnableExternalSenderAdminNotifications) -and
    (($null -eq $Settings.ExternalSenderAdminAddress) -or ($CurrentState.ExternalSenderAdminAddress -eq $Settings.ExternalSenderAdminAddress))

    $AcceptedDomains = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AcceptedDomain'

    $RuleState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MalwareFilterRule' |
        Where-Object -Property Name -EQ $RuleName |
        Select-Object Name, MalwareFilterPolicy, Priority, RecipientDomainIs

    $RuleStateIsCorrect = ($RuleState.Name -eq $RuleName) -and
    ($RuleState.MalwareFilterPolicy -eq $PolicyName) -and
    ($RuleState.Priority -eq 0) -and
    (!(Compare-Object -ReferenceObject $RuleState.RecipientDomainIs -DifferenceObject $AcceptedDomains.Name))

    if ($Settings.remediate -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Malware Filter Policy already correctly configured' -sev Info
        } else {
            $cmdParams = @{
                EnableFileFilter                       = $true
                FileTypes                              = $ExpectedFileTypes
                FileTypeAction                         = $FileTypeAction
                ZapEnabled                             = $true
                QuarantineTag                          = $Settings.QuarantineTag
                EnableInternalSenderAdminNotifications = $Settings.EnableInternalSenderAdminNotifications
                InternalSenderAdminAddress             = $Settings.InternalSenderAdminAddress
                EnableExternalSenderAdminNotifications = $Settings.EnableExternalSenderAdminNotifications
                ExternalSenderAdminAddress             = $Settings.ExternalSenderAdminAddress
            }

            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams.Add('Identity', $PolicyName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MalwareFilterPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Malware Filter policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Malware Filter policy $PolicyName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', $PolicyName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'New-MalwareFilterPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Malware Filter policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Malware Filter policy $PolicyName." -sev Error -LogData $_
                }
            }
        }

        if ($RuleStateIsCorrect -eq $false) {
            $cmdParams = @{
                Priority          = 0
                RecipientDomainIs = $AcceptedDomains.Name
            }

            if ($RuleState.MalwareFilterPolicy -ne $PolicyName) {
                $cmdParams.Add('MalwareFilterPolicy', $PolicyName)
            }

            if ($RuleState.Name -eq $RuleName) {
                try {
                    $cmdParams.Add('Identity', $RuleName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MalwareFilterRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Malware Filter rule $RuleName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Malware Filter Rule $RuleName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', $RuleName)
                    New-ExoRequest -tenantid $Tenant -cmdlet 'New-MalwareFilterRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Malware Filter rule $RuleName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Malware Filter rule $RuleName." -sev Error -LogData $_
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Malware Filter Policy is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Malware Filter Policy is not enabled' -object $CurrentState -tenant $Tenant -standardName 'MalwareFilterPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Malware Filter Policy is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $state = $StateIsCorrect ? $true : $CurrentState
        Set-CIPPStandardsCompareField -FieldName 'standards.MalwareFilterPolicy' -FieldValue $state -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'MalwareFilterPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardMalwareFilterPolicy.ps1' 201
#Region './Public/Standards/Invoke-CIPPStandardMDMScope.ps1' -1

function Invoke-CIPPStandardMDMScope {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) MDMScope
    .SYNOPSIS
        (Label) Configure MDM user scope
    .DESCRIPTION
        (Helptext) Configures the MDM user scope. This also sets the terms of use, discovery and compliance URL to default URLs.
        (DocsDescription) Configures the MDM user scope. This also sets the terms of use URL, discovery URL and compliance URL to default values.
    .NOTES
        CAT
            Intune Standards
        TAG
        EXECUTIVETEXT
            Defines which users can enroll their devices in mobile device management, controlling access to corporate resources and applications. This setting determines the scope of device management coverage and ensures appropriate users have access to necessary business tools.
        ADDEDCOMPONENT
            {"name":"appliesTo","label":"MDM User Scope?","type":"radio","options":[{"label":"All","value":"all"},{"label":"None","value":"none"},{"label":"Custom Group","value":"selected"}]}
            {"type":"textField","name":"standards.MDMScope.customGroup","label":"Custom Group Name","required":false}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-02-18
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'MDMScope' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/mobileDeviceManagementPolicies/0000000a-0000-0000-c000-000000000000?$expand=includedGroups' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the MDM Scope state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentInfo.termsOfUseUrl -eq 'https://portal.manage.microsoft.com/TermsofUse.aspx') -and
        ($CurrentInfo.discoveryUrl -eq 'https://enrollment.manage.microsoft.com/enrollmentserver/discovery.svc') -and
        ($CurrentInfo.complianceUrl -eq 'https://portal.manage.microsoft.com/?portalAction=Compliance') -and
        ($CurrentInfo.appliesTo -eq $Settings.appliesTo) -and
        ($Settings.appliesTo -ne 'selected' -or ($CurrentInfo.includedGroups.displayName -contains $Settings.customGroup))

    $CompareField = [PSCustomObject]@{
        termsOfUseUrl = $CurrentInfo.termsOfUseUrl
        discoveryUrl  = $CurrentInfo.discoveryUrl
        complianceUrl = $CurrentInfo.complianceUrl
        appliesTo     = $CurrentInfo.appliesTo
        customGroup   = $CurrentInfo.includedGroups.displayName
    }

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MDM Scope already correctly configured' -sev Info
        } else {
            $GraphParam = @{
                tenantid     = $tenant
                Uri          = 'https://graph.microsoft.com/beta/policies/mobileDeviceManagementPolicies/0000000a-0000-0000-c000-000000000000'
                ContentType  = 'application/json; charset=utf-8'
                asApp        = $false
                type         = 'PATCH'
                AddedHeaders = @{'Accept-Language' = 0 }
                Body         = @{
                    'termsOfUseUrl' = 'https://portal.manage.microsoft.com/TermsofUse.aspx'
                    'discoveryUrl'  = 'https://enrollment.manage.microsoft.com/enrollmentserver/discovery.svc'
                    'complianceUrl' = 'https://portal.manage.microsoft.com/?portalAction=Compliance'
                } | ConvertTo-Json
            }

            try {
                New-GraphPostRequest @GraphParam
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Successfully configured MDM Scope' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Failed to configure MDM Scope.' -sev Error -LogData $ErrorMessage
            }

            # Workaround for MDM Scope Assignment error: "Could not set MDM Scope for [TENANT]: Simultaneous patch requests on both the appliesTo and URL properties are currently not supported."
            if ($Settings.appliesTo -ne 'selected') {
                $GraphParam = @{
                    tenantid     = $tenant
                    Uri          = 'https://graph.microsoft.com/beta/policies/mobileDeviceManagementPolicies/0000000a-0000-0000-c000-000000000000'
                    ContentType  = 'application/json; charset=utf-8'
                    asApp        = $false
                    type         = 'PATCH'
                    AddedHeaders = @{'Accept-Language' = 0 }
                    Body         = @{
                        'appliesTo' = $Settings.appliesTo
                    } | ConvertTo-Json
                }

                try {
                    New-GraphPostRequest @GraphParam
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully assigned $($Settings.appliesTo) to MDM Scope" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to assign $($Settings.appliesTo) to MDM Scope." -sev Error -LogData $ErrorMessage
                }
            } else {
                $GroupID = (New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/groups?`$top=999&`$select=id,displayName&`$filter=displayName eq '$($Settings.customGroup)'" -tenantid $tenant -asApp $true).id
                $GraphParam = @{
                    tenantid     = $tenant
                    Uri          = 'https://graph.microsoft.com/beta/policies/mobileDeviceManagementPolicies/0000000a-0000-0000-c000-000000000000/includedGroups/$ref'
                    ContentType  = 'application/json; charset=utf-8'
                    asApp        = $false
                    type         = 'POST'
                    AddedHeaders = @{'Accept-Language' = 0 }
                    Body         = @{
                        '@odata.id' = "https://graph.microsoft.com/odata/groups('$GroupID')"
                    } | ConvertTo-Json
                }

                try {
                    New-GraphPostRequest @GraphParam
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully assigned $($Settings.customGroup) to MDM Scope" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to assign $($Settings.customGroup) to MDM Scope" -sev Error -LogData $ErrorMessage
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MDM Scope is correctly configured' -sev Info
        } else {
            Write-StandardsAlert -message 'MDM Scope is not correctly configured' -object $CompareField -tenant $tenant -standardName 'MDMScope' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'MDM Scope is not correctly configured' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Set-CIPPStandardsCompareField -FieldName 'standards.MDMScope' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'MDMScope' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardMDMScope.ps1' 153
#Region './Public/Standards/Invoke-CIPPStandardMessageExpiration.ps1' -1

function Invoke-CIPPStandardMessageExpiration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) MessageExpiration
    .SYNOPSIS
        (Label) Lower Transport Message Expiration to 12 hours
    .DESCRIPTION
        (Helptext) Sets the transport message configuration to timeout a message at 12 hours.
        (DocsDescription) Expires messages in the transport queue after 12 hours. Makes the NDR for failed messages show up faster for users. Default is 24 hours.
    .NOTES
        CAT
            Exchange Standards
        TAG
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-02-23
        POWERSHELLEQUIVALENT
            Set-TransportConfig -MessageExpirationTimeout 12.00:00:00
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'MessageExpiration' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'MessageExpiration'

    try {
        $MessageExpiration = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-TransportConfig').messageExpiration
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the MessageExpiration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($MessageExpiration -ne '12:00:00') {
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-TransportConfig' -cmdParams @{MessageExpiration = '12:00:00' }
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Set transport configuration message expiration to 12 hours' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set transport configuration message expiration to 12 hours. Error: $ErrorMessage" -sev Debug
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Transport configuration message expiration is already set to 12 hours' -sev Info
        }

    }
    if ($Settings.alert -eq $true) {
        if ($MessageExpiration -eq '12:00:00') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Transport configuration message expiration is set to 12 hours' -sev Info
        } else {
            $Object = [PSCustomObject]@{ MessageExpiration = $MessageExpiration }
            Write-StandardsAlert -message 'Transport configuration message expiration is not set to 12 hours' -object $Object -tenant $tenant -standardName 'MessageExpiration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Transport configuration message expiration is not set to 12 hours' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        if ($MessageExpiration -ne '12:00:00') { $MessageExpiration = $false } else { $MessageExpiration = $true }
        Set-CIPPStandardsCompareField -FieldName 'standards.MessageExpiration' -FieldValue $MessageExpiration -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'messageExpiration' -FieldValue $MessageExpiration -StoreAs bool -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardMessageExpiration.ps1' 78
#Region './Public/Standards/Invoke-CIPPStandardModernAuth.ps1' -1

function Invoke-CIPPStandardModernAuth {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    If ($Settings.remediate -eq $true) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'Modern Authentication is enabled by default. This standard is no longer required.' -sev Info
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardModernAuth.ps1' 11
#Region './Public/Standards/Invoke-CIPPStandardNudgeMFA.ps1' -1

function Invoke-CIPPStandardNudgeMFA {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) NudgeMFA
    .SYNOPSIS
        (Label) Sets the state for the request to setup Authenticator
    .DESCRIPTION
        (Helptext) Sets the state of the registration campaign for the tenant
        (DocsDescription) Sets the state of the registration campaign for the tenant. If enabled nudges users to set up the Microsoft Authenticator during sign-in.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Prompts employees to set up multi-factor authentication during login, gradually improving the organization's security posture by encouraging adoption of stronger authentication methods. This helps achieve better security compliance without forcing immediate mandatory changes.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.NudgeMFA.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
            {"type":"number","name":"standards.NudgeMFA.snoozeDurationInDays","label":"Number of days to allow users to skip registering Authenticator (0-14, default is 1)","defaultValue":1}
        IMPACT
            Low Impact
        ADDEDDATE
            2022-12-08
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthenticationMethodPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'NudgeMFA'
    Write-Host "NudgeMFA: $($Settings | ConvertTo-Json -Compress)"
    # Get state value using null-coalescing operator
    $State = $Settings.state.value ?? $Settings.state

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy' -tenantid $Tenant
        $StateIsCorrect = ($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.state -eq $State) -and
        ($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.snoozeDurationInDays -eq $Settings.snoozeDurationInDays) -and
        ($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.enforceRegistrationAfterAllowedSnoozes -eq $true)
    } catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to get Authenticator App Nudge state, check your permissions and try again' -sev Error -LogData (Get-CippException -Exception $_)
        return
    }

    if ($Settings.remediate -eq $true) {
        $StateName = $State.Substring(0, 1).ToUpper() + $State.Substring(1)
        try {
            $GraphRequest = @{
                tenantid    = $Tenant
                uri         = 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy'
                AsApp       = $false
                Type        = 'PATCH'
                ContentType = 'application/json'
                Body        = @{
                    registrationEnforcement = @{
                        authenticationMethodsRegistrationCampaign = @{
                            state                                  = $State
                            snoozeDurationInDays                   = $Settings.snoozeDurationInDays
                            enforceRegistrationAfterAllowedSnoozes = $true
                            includeTargets                         = $CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.includeTargets
                            excludeTargets                         = $CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.excludeTargets
                        }
                    }
                } | ConvertTo-Json -Depth 10 -Compress
            }
            New-GraphPostRequest @GraphRequest
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "$StateName Authenticator App Nudge with a snooze duration of $($Settings.snoozeDurationInDays)" -sev Info
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Authenticator App Nudge to $State. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Authenticator App Nudge is enabled with a snooze duration of $($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.snoozeDurationInDays)" -sev Info
        } else {
            Write-StandardsAlert -message "Authenticator App Nudge is not enabled with a snooze duration of $($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.snoozeDurationInDays)" -object ($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign | Select-Object snoozeDurationInDays, state) -tenant $Tenant -standardName 'NudgeMFA' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Authenticator App Nudge is not enabled with a snooze duration of $($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign.snoozeDurationInDays)" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $State = $StateIsCorrect ? $true : ($CurrentState.registrationEnforcement.authenticationMethodsRegistrationCampaign | Select-Object snoozeDurationInDays, state)
        Set-CIPPStandardsCompareField -FieldName 'standards.NudgeMFA' -FieldValue $State -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'NudgeMFA' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardNudgeMFA.ps1' 94
#Region './Public/Standards/Invoke-CIPPStandardOauthConsent.ps1' -1

function Invoke-CIPPStandardOauthConsent {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) OauthConsent
    .SYNOPSIS
        (Label) Require admin consent for applications (Prevent OAuth phishing)
    .DESCRIPTION
        (Helptext) Disables users from being able to consent to applications, except for those specified in the field below
        (DocsDescription) Requires users to get administrator consent before sharing data with applications. You can preapprove specific applications.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.5.1)"
            "CISA (MS.AAD.4.2v1)"
            "EIDSCA.AP08"
            "EIDSCA.AP09"
            "Essential 8 (1175)"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Requires administrative approval before employees can grant applications access to company data, preventing unauthorized data sharing and potential security breaches. This protects against malicious applications while allowing approved business tools to function normally.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.OauthConsent.AllowedApps","label":"Allowed application IDs, comma separated","required":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthorizationPolicy
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($tenant, $settings)

    try {
        $State = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the OauthConsent state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $StateIsCorrect = if ($State.permissionGrantPolicyIdsAssignedToDefaultUserRole -eq 'managePermissionGrantsForSelf.cipp-consent-policy') { $true } else { $false }

    if ($Settings.remediate -eq $true) {
        $AllowedAppIdsForTenant = $settings.AllowedApps -split ',' | ForEach-Object { $_.Trim() }
        try {
            $Existing = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies/' -tenantid $tenant) | Where-Object -Property id -EQ 'cipp-consent-policy'
            if (!$Existing) {
                New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies' -Type POST -Body '{ "id":"cipp-consent-policy", "displayName":"Application Consent Policy", "description":"This policy controls the current application consent policies."}' -ContentType 'application/json'
                # Replaced static web app appid with Office 365 Management by Microsoft's recommendation
                New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies/cipp-consent-policy/includes' -Type POST -Body '{"permissionClassification":"all","permissionType":"delegated","clientApplicationIds":["00b41c95-dab0-4487-9791-b9d2c32c80f2"]}' -ContentType 'application/json'
            }

            try {
                $ExistingIncludes = New-GraphGetRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies/cipp-consent-policy/includes'

                $ExistingAppIds = foreach ($entry in $ExistingIncludes.value) {
                    $entry.clientApplicationIds
                }
                $ExistingAppIds = $ExistingAppIds | Sort-Object -Unique

                foreach ($AllowedApp in $AllowedAppIdsForTenant) {
                    if ($AllowedApp -and ($AllowedApp -notin $ExistingAppIds)) {
                        Write-Host "Adding missing approved app: $AllowedApp"
                        New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies/cipp-consent-policy/includes' -Type POST -Body ('{"permissionType": "delegated","clientApplicationIds": ["' + $AllowedApp + '"]}') -ContentType 'application/json'
                        New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/permissionGrantPolicies/cipp-consent-policy/includes' -Type POST -Body ('{ "permissionType": "Application", "clientApplicationIds": ["' + $AllowedApp + '"] }') -ContentType 'application/json'
                    }
                }
            } catch {
                "Could not add exclusions, probably already exist: $($_)"
            }

            if ($State.permissionGrantPolicyIdsAssignedToDefaultUserRole -notin @('managePermissionGrantsForSelf.cipp-consent-policy')) {
                New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -Type PATCH -Body '{"permissionGrantPolicyIdsAssignedToDefaultUserRole":["managePermissionGrantsForSelf.cipp-consent-policy"]}' -ContentType 'application/json'
            }

            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode has been enabled.' -sev Info
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to apply Application Consent Mode Error: $ErrorMessage" -sev Error
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Application Consent Mode is not enabled.' -object ($State.defaultUserRolePermissions) -tenant $tenant -standardName 'OauthConsent' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'OauthConsent' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $State | Select-Object -Property permissionGrantPolicyIdsAssignedToDefaultUserRole
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.OauthConsent' -FieldValue $FieldValue -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardOauthConsent.ps1' 113
#Region './Public/Standards/Invoke-CIPPStandardOauthConsentLowSec.ps1' -1

function Invoke-CIPPStandardOauthConsentLowSec {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) OauthConsentLowSec
    .SYNOPSIS
        (Label) Allow users to consent to applications with low security risk (Prevent OAuth phishing. Lower impact, less secure)
    .DESCRIPTION
        (Helptext) Sets the default oauth consent level so users can consent to applications that have low risks.
        (DocsDescription) Allows users to consent to applications with low assigned risk.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "IntegratedApps"
        EXECUTIVETEXT
            Allows employees to approve low-risk applications without administrative intervention, balancing security with productivity. This provides a middle ground between complete restriction and open access, enabling business agility while maintaining protection against high-risk applications.
        IMPACT
            Medium Impact
        ADDEDDATE
            2022-08-16
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthorizationPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $State = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy' -tenantid $tenant)

        $PermissionState = (New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/servicePrincipals(appId='00000003-0000-0000-c000-000000000000')/delegatedPermissionClassifications" -tenantid $tenant) |
        Select-Object -Property permissionName
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the OauthConsentLowSec state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $requiredPermissions = @('offline_access', 'openid', 'User.Read', 'profile', 'email')
    $missingPermissions = $requiredPermissions | Where-Object { $PermissionState.permissionName -notcontains $_ }

    $Standards = Get-CIPPStandards -Tenant $tenant
    $ConflictingStandard = $Standards | Where-Object -Property Standard -EQ 'OauthConsent'

    if ($Settings.remediate -eq $true) {
        if ($State.permissionGrantPolicyIdsAssignedToDefaultUserRole -in @('managePermissionGrantsForSelf.microsoft-user-default-low')) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode(microsoft-user-default-low) is already enabled.' -sev Info
        } elseif ($ConflictingStandard -and $State.permissionGrantPolicyIdsAssignedToDefaultUserRole -contains 'ManagePermissionGrantsForSelf.cipp-consent-policy') {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'There is a conflicting OAuth Consent policy standard enabled for this tenant. Remove the Require admin consent for applications (Prevent OAuth phishing) standard from this tenant to apply the low security standard.' -sev Error
        } else {
            try {
                $GraphParam = @{
                    tenantid    = $tenant
                    Uri         = 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy'
                    Type        = 'PATCH'
                    Body        = @{
                        permissionGrantPolicyIdsAssignedToDefaultUserRole = @('managePermissionGrantsForSelf.microsoft-user-default-low')
                    } | ConvertTo-Json
                    ContentType = 'application/json'
                }
                $null = New-GraphPostRequest @GraphParam
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode(microsoft-user-default-low) has been enabled.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to apply Application Consent Mode (microsoft-user-default-low) Error: $ErrorMessage" -sev Error
            }
        }

        if ($missingPermissions.Count -eq 0) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'All permissions for Application Consent already assigned.' -sev Info
        } else {
            try {
                $missingPermissions | ForEach-Object {
                    $GraphParam = @{
                        tenantid    = $tenant
                        Uri         = "https://graph.microsoft.com/beta/servicePrincipals(appId='00000003-0000-0000-c000-000000000000')/delegatedPermissionClassifications"
                        Type        = 'POST'
                        Body        = @{
                            permissionName = $_
                            classification = 'low'
                        } | ConvertTo-Json
                        ContentType = 'application/json'
                    }
                    $null = New-GraphPostRequest @GraphParam
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Permission $_ has been added to low Application Consent" -sev Info
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to apply low consent permissions Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($State.permissionGrantPolicyIdsAssignedToDefaultUserRole -notin @('managePermissionGrantsForSelf.microsoft-user-default-low')) {
            Write-StandardsAlert -message 'Application Consent Mode(microsoft-user-default-low) is not enabled' -object $State -tenant $tenant -standardName 'OauthConsentLowSec' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode(microsoft-user-default-low) is not enabled.' -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode(microsoft-user-default-low) is enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($State.permissionGrantPolicyIdsAssignedToDefaultUserRole -notin @('managePermissionGrantsForSelf.microsoft-user-default-low')) {
            $State.permissionGrantPolicyIdsAssignedToDefaultUserRole = $false
            $ValueField = @{
                authorizationPolicy       = $State.permissionGrantPolicyIdsAssignedToDefaultUserRole
                permissionClassifications = $PermissionState
            }
            if ($ConflictingStandard) {
                $ValueField.conflictingStandard = @{
                    name       = $ConflictingStandard.Standard
                    templateid = $ConflictingStandard.TemplateId
                }
            }
        } else {
            $State.permissionGrantPolicyIdsAssignedToDefaultUserRole = $true
            $ValueField = $true
        }
        Add-CIPPBPAField -FieldName 'OauthConsentLowSec' -FieldValue $State.permissionGrantPolicyIdsAssignedToDefaultUserRole -StoreAs bool -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.OauthConsentLowSec' -FieldValue $ValueField -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardOauthConsentLowSec.ps1' 131
#Region './Public/Standards/Invoke-CIPPStandardOutBoundSpamAlert.ps1' -1

function Invoke-CIPPStandardOutBoundSpamAlert {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) OutBoundSpamAlert
    .SYNOPSIS
        (Label) Set Outbound Spam Alert e-mail
    .DESCRIPTION
        (Helptext) Set the Outbound Spam Alert e-mail address
        (DocsDescription) Sets the e-mail address to which outbound spam alerts are sent.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (2.1.6)"
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.OutBoundSpamAlert.OutboundSpamContact","label":"Outbound spam contact"}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-05-03
        POWERSHELLEQUIVALENT
            Set-HostedOutboundSpamFilterPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'OutBoundSpamAlert' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-HostedOutboundSpamFilterPolicy' -cmdParams @{ Identity = 'Default' } -useSystemMailbox $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the OutBoundSpamAlert state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        if ($CurrentInfo.NotifyOutboundSpam -ne $true -or $CurrentInfo.NotifyOutboundSpamRecipients -ne $settings.OutboundSpamContact) {
            $Contacts = $settings.OutboundSpamContact
            try {
                New-ExoRequest -tenantid $tenant -cmdlet 'Set-HostedOutboundSpamFilterPolicy' -cmdParams @{ Identity = 'Default'; NotifyOutboundSpam = $true; NotifyOutboundSpamRecipients = $Contacts } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Set outbound spam filter alert to $($Contacts)" -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not set outbound spam contact to $($Contacts). $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Outbound spam filter alert is already set to $($CurrentInfo.NotifyOutboundSpamRecipients)" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CurrentInfo.NotifyOutboundSpam -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Outbound spam filter alert is set to $($CurrentInfo.NotifyOutboundSpamRecipients)" -sev Info
        } else {
            $Object = $CurrentInfo | Select-Object -Property NotifyOutboundSpamRecipients, NotifyOutboundSpam
            Write-StandardsAlert -message 'Outbound spam filter alert is not set' -object $Object -tenant $tenant -standardName 'OutBoundSpamAlert' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Outbound spam filter alert is not set' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'OutboundSpamAlert' -FieldValue $CurrentInfo.NotifyOutboundSpam -StoreAs bool -Tenant $tenant
        if ($CurrentInfo.NotifyOutboundSpam -ne $true -or $CurrentInfo.NotifyOutboundSpamRecipients -ne $settings.OutboundSpamContact) {
            $ValueField = $CurrentInfo | Select-Object -Property NotifyOutboundSpamRecipients, NotifyOutboundSpam
        } else {
            $ValueField = $true
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.OutBoundSpamAlert' -FieldValue $ValueField -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardOutBoundSpamAlert.ps1' 87
#Region './Public/Standards/Invoke-CIPPStandardOWAAttachmentRestrictions.ps1' -1

function Invoke-CIPPStandardOWAAttachmentRestrictions {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) OWAAttachmentRestrictions
    .SYNOPSIS
        (Label) Restrict Email Attachments on Unmanaged Devices
    .DESCRIPTION
        (Helptext) Restricts how users on unmanaged devices can interact with email attachments in Outlook on the web and new Outlook for Windows. Prevents downloading attachments or blocks viewing them entirely.
        (DocsDescription) This standard configures the OWA mailbox policy to restrict access to email attachments on unmanaged devices. Users can be prevented from downloading attachments (but can view/edit via Office Online) or blocked from seeing attachments entirely. This helps prevent data exfiltration through email attachments on devices not managed by the organization.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.1.2)"
            "Security"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Restricts access to email attachments on personal or unmanaged devices while allowing full functionality on corporate-managed devices. This security measure prevents data theft through email attachments while maintaining productivity for employees using approved company devices.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"standards.OWAAttachmentRestrictions.ConditionalAccessPolicy","label":"Attachment Restriction Policy","options":[{"label":"Read Only (View/Edit via Office Online, no download)","value":"ReadOnly"},{"label":"Read Only Plus Attachments Blocked (Cannot see attachments)","value":"ReadOnlyPlusAttachmentsBlocked"}],"defaultValue":"ReadOnlyPlusAttachmentsBlocked"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-08-22
        POWERSHELLEQUIVALENT
            Set-OwaMailboxPolicy -Identity "OwaMailboxPolicy-Default" -ConditionalAccessPolicy ReadOnlyPlusAttachmentsBlocked
        RECOMMENDEDBY
            "Microsoft Zero Trust"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'OWAAttachmentRestrictions' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Input validation
    $ValidPolicies = @('ReadOnly', 'ReadOnlyPlusAttachmentsBlocked')
    if ($Settings.ConditionalAccessPolicy.value -notin $ValidPolicies) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "OWAAttachmentRestrictions: Invalid ConditionalAccessPolicy parameter set. Must be one of: $($ValidPolicies -join ', ')" -sev Error
        return
    }

    try {
        # Get the default OWA mailbox policy
        $CurrentPolicy = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OwaMailboxPolicy' -cmdParams @{ Identity = 'OwaMailboxPolicy-Default' }
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the OWA Attachment Restrictions state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = $CurrentPolicy.ConditionalAccessPolicy -eq $Settings.ConditionalAccessPolicy.value

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "OWA attachment restrictions are already set to $($Settings.ConditionalAccessPolicy)" -sev Info
        } else {
            try {
                $cmdParams = @{
                    Identity                = 'OwaMailboxPolicy-Default'
                    ConditionalAccessPolicy = $Settings.ConditionalAccessPolicy.value
                }

                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OwaMailboxPolicy' -cmdParams $cmdParams

                $PolicyDescription = switch ($Settings.ConditionalAccessPolicy.value) {
                    'ReadOnly' { 'Read Only (users can view/edit attachments via Office Online but cannot download)' }
                    'ReadOnlyPlusAttachmentsBlocked' { 'Read Only Plus Attachments Blocked (users cannot see attachments at all)' }
                }

                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set OWA attachment restrictions to: $PolicyDescription" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set OWA attachment restrictions. $($ErrorMessage.NormalizedError)" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect) {
            $PolicyDescription = switch ($Settings.ConditionalAccessPolicy.value) {
                'ReadOnly' { 'Read Only (view/edit via Office Online, no download)' }
                'ReadOnlyPlusAttachmentsBlocked' { 'Read Only Plus Attachments Blocked (cannot see attachments)' }
            }
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "OWA attachment restrictions are correctly set to: $PolicyDescription" -sev Info
        } else {
            $CurrentDescription = switch ($CurrentPolicy.ConditionalAccessPolicy) {
                'ReadOnly' { 'Read Only (view/edit via Office Online, no download)' }
                'ReadOnlyPlusAttachmentsBlocked' { 'Read Only Plus Attachments Blocked (cannot see attachments)' }
                $null { 'Not configured (full access to attachments)' }
                default { $CurrentPolicy.ConditionalAccessPolicy }
            }

            $RequiredDescription = switch ($Settings.ConditionalAccessPolicy.value) {
                'ReadOnly' { 'Read Only (view/edit via Office Online, no download)' }
                'ReadOnlyPlusAttachmentsBlocked' { 'Read Only Plus Attachments Blocked (cannot see attachments)' }
            }

            $AlertMessage = "OWA attachment restrictions are set to '$CurrentDescription' but should be '$RequiredDescription'"
            Write-StandardsAlert -message $AlertMessage -object @{
                CurrentPolicy       = $CurrentPolicy.ConditionalAccessPolicy
                RequiredPolicy      = $Settings.ConditionalAccessPolicy
                PolicyName          = $CurrentPolicy.Name
                CurrentDescription  = $CurrentDescription
                RequiredDescription = $RequiredDescription
            } -tenant $Tenant -standardName 'OWAAttachmentRestrictions' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message $AlertMessage -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($StateIsCorrect) {
            Set-CIPPStandardsCompareField -FieldName 'standards.OWAAttachmentRestrictions' -FieldValue $true -TenantFilter $Tenant
            Add-CIPPBPAField -FieldName 'OWAAttachmentRestrictions' -FieldValue $true -StoreAs bool -Tenant $Tenant
        } else {
            $ReportData = @{
                CurrentPolicy  = $CurrentPolicy.ConditionalAccessPolicy
                RequiredPolicy = $Settings.ConditionalAccessPolicy.value
                PolicyName     = $CurrentPolicy.Name
                IsCompliant    = $false
                Description    = 'OWA attachment restrictions not properly configured for unmanaged devices'
            }
            Set-CIPPStandardsCompareField -FieldName 'standards.OWAAttachmentRestrictions' -FieldValue $ReportData -TenantFilter $Tenant
            Add-CIPPBPAField -FieldName 'OWAAttachmentRestrictions' -FieldValue $ReportData -StoreAs json -Tenant $Tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardOWAAttachmentRestrictions.ps1' 138
#Region './Public/Standards/Invoke-CIPPStandardPasswordExpireDisabled.ps1' -1

function Invoke-CIPPStandardPasswordExpireDisabled {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PasswordExpireDisabled
    .SYNOPSIS
        (Label) Do not expire passwords
    .DESCRIPTION
        (Helptext) Disables the expiration of passwords for the tenant by setting the password expiration policy to never expire for any user.
        (DocsDescription) Sets passwords to never expire for tenant, recommended to use in conjunction with secure password requirements.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.3.1)"
            "PWAgePolicyNew"
        EXECUTIVETEXT
            Eliminates mandatory password expiration requirements, allowing employees to keep strong passwords indefinitely rather than forcing frequent changes that often lead to weaker passwords. This modern security approach reduces help desk calls and improves overall password security when combined with multi-factor authentication.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Update-MgDomain
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $GraphRequest = New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/domains' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PasswordExpireDisabled state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $DomainsWithoutPassExpire = $GraphRequest |
        Where-Object { $_.isVerified -eq $true -and $_.passwordValidityPeriodInDays -ne 2147483647 }

    if ($Settings.remediate -eq $true) {

        if ($DomainsWithoutPassExpire) {
            $DomainsWithoutPassExpire | ForEach-Object {
                try {
                    if ( $null -eq $_.passwordNotificationWindowInDays ) {
                        $Body = '{"passwordValidityPeriodInDays": 2147483647, "passwordNotificationWindowInDays": 14 }'
                        Write-Host "PasswordNotificationWindowInDays is null for $($_.id). Setting to the default of 14 days."
                    } else {
                        $Body = '{"passwordValidityPeriodInDays": 2147483647 }'
                    }
                    New-GraphPostRequest -type Patch -tenantid $Tenant -uri "https://graph.microsoft.com/v1.0/domains/$($_.id)" -body $Body
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Disabled Password Expiration for $($_.id)." -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable Password Expiration for $($_.id). Error: $ErrorMessage" -sev Error
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Password Expiration is already disabled for all $($GraphRequest.Count) domains." -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($DomainsWithoutPassExpire) {
            Write-StandardsAlert -message "Password Expiration is not disabled for the following $($DomainsWithoutPassExpire.Count) domains: $($DomainsWithoutPassExpire.id -join ', ')" -object $DomainsWithoutPassExpire -tenant $tenant -standardName 'PasswordExpireDisabled' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Password Expiration is not disabled for the following $($DomainsWithoutPassExpire.Count) domains: $($DomainsWithoutPassExpire.id -join ', ')" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Password Expiration is disabled for all $($GraphRequest.Count) domains." -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'PasswordExpireDisabled' -FieldValue $DomainsWithoutPassExpire -StoreAs json -Tenant $tenant
        if ($DomainsWithoutPassExpire) {
            $FieldValue = $DomainsWithoutPassExpire
        } else {
            $FieldValue = $true
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.PasswordExpireDisabled' -FieldValue $FieldValue -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPasswordExpireDisabled.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardPerUserMFA.ps1' -1

function Invoke-CIPPStandardPerUserMFA {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PerUserMFA
    .SYNOPSIS
        (Label) Enables per user MFA for all users.
    .DESCRIPTION
        (Helptext) Enables per user MFA for all users.
        (DocsDescription) Enables per user MFA for all users.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (1.2.1)"
            "CIS M365 5.0 (1.1.1)"
            "CIS M365 5.0 (1.1.2)"
            "CISA (MS.AAD.1.1v1)"
            "CISA (MS.AAD.1.2v1)"
            "Essential 8 (1504)"
            "Essential 8 (1173)"
            "Essential 8 (1401)"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Requires all employees to use multi-factor authentication for enhanced account security, significantly reducing the risk of unauthorized access from compromised passwords. This fundamental security measure protects against the majority of account-based attacks and is essential for maintaining strong cybersecurity posture.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2024-06-14
        POWERSHELLEQUIVALENT
            Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $GraphRequest = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$top=999&`$select=userPrincipalName,displayName,accountEnabled,perUserMfaState&`$filter=userType eq 'Member' and accountEnabled eq true and displayName ne 'On-Premises Directory Synchronization Service Account'&`$count=true" -tenantid $Tenant -ComplexFilter
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PerUserMFA state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $UsersWithoutMFA = $GraphRequest | Where-Object -Property perUserMfaState -NE 'enforced' | Select-Object -Property userPrincipalName, displayName, accountEnabled, perUserMfaState

    If ($Settings.remediate -eq $true) {
        if (($UsersWithoutMFA | Measure-Object).Count -gt 0) {
            try {
                $MFAMessage = Set-CIPPPerUserMFA -TenantFilter $Tenant -userId @($UsersWithoutMFA.userPrincipalName) -State 'enforced'
                Write-LogMessage -API 'Standards' -tenant $tenant -message $MFAMessage -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enforce MFA for all users: $ErrorMessage" -sev Error
            }
        }
    }
    if ($Settings.alert -eq $true) {
        if (($UsersWithoutMFA.userPrincipalName | Measure-Object).Count -gt 0) {
            Write-StandardsAlert -message "The following accounts do not have Legacy MFA Enforced: $($UsersWithoutMFA.userPrincipalName -join ', ')" -object $UsersWithoutMFA -tenant $tenant -standardName 'PerUserMFA' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The following accounts do not have Legacy MFA Enforced: $($UsersWithoutMFA.userPrincipalName -join ', ')" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'No accounts do not have legacy per user MFA Enforced' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        $State = $UsersWithoutMFA ? $UsersWithoutMFA : $true
        Set-CIPPStandardsCompareField -FieldName 'standards.PerUserMFA' -FieldValue $State -Tenant $tenant
        Add-CIPPBPAField -FieldName 'LegacyMFAUsers' -FieldValue $UsersWithoutMFA -StoreAs json -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPerUserMFA.ps1' 78
#Region './Public/Standards/Invoke-CIPPStandardPhishingSimulations.ps1' -1

function Invoke-CIPPStandardPhishingSimulations {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PhishingSimulations
    .SYNOPSIS
        (Label) Phishing Simulation Configuration
    .DESCRIPTION
        (Helptext) This creates a phishing simulation policy that enables phishing simulations for the entire tenant.
        (DocsDescription) This creates a phishing simulation policy that enables phishing simulations for the entire tenant.
    .NOTES
        CAT
            Defender Standards
        TAG
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":true,"creatable":true,"required":true,"label":"Phishing Simulation Domains","name":"standards.PhishingSimulations.Domains"}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":true,"label":"Phishing Simulation Sender IP Ranges","name":"standards.PhishingSimulations.SenderIpRanges"}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"label":"Phishing Simulation Urls","name":"standards.PhishingSimulations.PhishingSimUrls"}
            {"type":"switch","label":"Remove extra urls","name":"standards.PhishingSimulations.RemoveExtraUrls","defaultValue":false,"required":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-03-27
        POWERSHELLEQUIVALENT
            New-TenantAllowBlockListItems, New-PhishSimOverridePolicy and New-ExoPhishSimOverrideRule
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'PhishingSimulations' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $PolicyName = 'CIPPPhishSim'

    # Fetch current Phishing Simulations Policy settings and ensure it is correctly configured
    try {
        $PolicyState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-PhishSimOverridePolicy' |
        Where-Object -Property Name -EQ 'PhishSimOverridePolicy' |
        Select-Object -Property Identity, Name, Mode, Enabled
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PhishingSimulations state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $PolicyIsCorrect = ($PolicyState.Name -eq 'PhishSimOverridePolicy') -and ($PolicyState.Enabled -eq $true)

    # Fetch current Phishing Simulations Policy Rule settings and ensure it is correctly configured
    $RuleState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-ExoPhishSimOverrideRule' |
    Select-Object -Property Identity,Name,SenderIpRanges,Domains,SenderDomainIs

    [String[]]$AddSenderIpRanges = $Settings.SenderIpRanges.value | Where-Object { $_ -notin $RuleState.SenderIpRanges }
    if ($Settings.RemoveExtraUrls -eq $true) {
        [String[]]$RemoveSenderIpRanges = $RuleState.SenderIpRanges | Where-Object { $_ -notin $Settings.SenderIpRanges.value }
    } else {
        $RemoveSenderIpRanges = @()
    }

    [String[]]$AddDomains = $Settings.Domains.value | Where-Object { $_ -notin $RuleState.Domains }
    if ($Settings.RemoveExtraUrls -eq $true) {
        [String[]]$RemoveDomains = $RuleState.Domains | Where-Object { $_ -notin $Settings.Domains.value }
    } else {
        $RemoveDomains = @()
    }

    $RuleIsCorrect = ($RuleState.Name -like "*PhishSimOverr*") -and
    ($AddSenderIpRanges.Count -eq 0 -and $RemoveSenderIpRanges.Count -eq 0) -and
    ($AddDomains.Count -eq 0 -and $RemoveDomains.Count -eq 0)

    # Fetch current Phishing Simulations URLs and ensure it is correctly configured
    $SimUrlState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-TenantAllowBlockListItems' -cmdParams @{ListType = 'Url'; ListSubType = 'AdvancedDelivery'} |
    Select-Object -Property Value

    [String[]]$AddEntries = $Settings.PhishingSimUrls.value | Where-Object { $_ -notin $SimUrlState.value }
    if ($Settings.RemoveExtraUrls -eq $true) {
        [String[]]$RemoveEntries = $SimUrlState.value | Where-Object { $_ -notin $Settings.PhishingSimUrls.value }
    } else {
        $RemoveEntries = @()
    }

    $PhishingSimUrlsIsCorrect = ($AddEntries.Count -eq 0 -and $RemoveEntries.Count -eq 0)

    # Check state for all components
    $StateIsCorrect = $PolicyIsCorrect -and $RuleIsCorrect -and $PhishingSimUrlsIsCorrect

    $CompareField = [PSCustomObject]@{
        Domains         = $RuleState.Domains -join ', '
        SenderIpRanges  = $RuleState.SenderIpRanges -join ', '
        PhishingSimUrls = $SimUrlState.value -join ', '
    }

    If ($Settings.remediate -eq $true) {
        If ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Advanced Phishing Simulations already correctly configured' -sev Info
        } Else {
            # Remediate incorrect Phishing Simulations Policy
            If ($PolicyIsCorrect -eq $false) {
                If ($PolicyState.Name -eq 'PhishSimOverridePolicy') {
                    Try {
                        $null = New-ExoRequest -TenantId $Tenant -cmdlet 'Set-PhishSimOverridePolicy' -cmdParams @{Identity = $PolicyName; Enabled = $true}
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Enabled Phishing Simulation override policy." -sev Info
                    } Catch {
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to enable Phishing Simulation override policy." -sev Error -LogData $_
                    }
                } Else {
                    Try {
                        $null = New-ExoRequest -TenantId $Tenant -cmdlet 'New-PhishSimOverridePolicy' -cmdParams @{Name = $PolicyName; Enabled = $true}
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Created Phishing Simulation override policy." -sev Info
                    } Catch {
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to create Phishing Simulation override policy." -sev Error -LogData $_
                    }
                }
            }

            # Remediate incorrect Phishing Simulations Policy Rule
            If ($RuleIsCorrect -eq $false) {
                If ($RuleState.Name -like "*PhishSimOverr*") {
                    $cmdParams = @{
                        Identity = $RuleState.Identity
                        AddSenderIpRanges = $AddSenderIpRanges
                        AddDomains = $AddDomains
                        RemoveSenderIpRanges = $RemoveSenderIpRanges
                        RemoveDomains = $RemoveDomains
                    }
                    Try {
                        $null = New-ExoRequest -TenantId $Tenant -cmdlet 'Set-ExoPhishSimOverrideRule' -cmdParams $cmdParams
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Updated Phishing Simulation override rule." -sev Info
                    } Catch {
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to update Phishing Simulation override rule." -sev Error -LogData $_
                    }
                } Else {
                    $cmdParams = @{
                        Name = $PolicyName
                        Policy = 'PhishSimOverridePolicy'
                        SenderIpRanges = $Settings.SenderIpRanges.value
                        Domains = $Settings.Domains.value
                    }
                    Try {
                        $null = New-ExoRequest -TenantId $Tenant -cmdlet 'New-ExoPhishSimOverrideRule' -cmdParams $cmdParams
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Created Phishing Simulation override rule." -sev Info
                    } Catch {
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to create Phishing Simulation override rule." -sev Error -LogData $_
                    }
                }
            }

            # Remediate incorrect Phishing Simulations URLs
            If ($PhishingSimUrlsIsCorrect -eq $false) {
                $cmdParams = @{
                    ListType = 'Url'
                    ListSubType = 'AdvancedDelivery'
                }
                if ($Settings.RemoveExtraUrls -eq $true) {
                    # Remove entries that are not in the settings
                    If ($RemoveEntries.Count -gt 0) {
                        $cmdParams.Entries = $RemoveEntries
                        Try {
                            $null = New-ExoRequest -TenantId $Tenant -cmdlet 'Remove-TenantAllowBlockListItems' -cmdParams $cmdParams
                            Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Removed Phishing Simulation URLs from Allowlist." -sev Info
                        } Catch {
                            Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to remove Phishing Simulation URLs from Allowlist." -sev Error -LogData $_
                        }
                    }
                }
                # Add entries that are in the settings
                If ($AddEntries.Count -gt 0) {
                    $cmdParams.Entries = $AddEntries
                    $cmdParams.NoExpiration = $true
                    $cmdParams.Allow = $true
                    Try {
                        $null = New-ExoRequest -TenantId $Tenant -cmdlet 'New-TenantAllowBlockListItems' -cmdParams $cmdParams
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Added Phishing Simulation URLs to Allowlist." -sev Info
                    } Catch {
                        Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to add Phishing Simulation URLs to Allowlist." -sev Error -LogData $_
                    }
                }
            }
        }
    }

    If ($Settings.alert -eq $true) {
        If ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Phishing Simulation Configuration is correctly configured' -sev Info
        } Else {
            Write-StandardsAlert -message 'Phishing Simulation Configuration is not correctly configured' -object $CompareField -tenant $Tenant -standardName 'PhishingSimulations' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Phishing Simulation Configuration is not correctly configured' -sev Info
        }
    }

    If ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Add-CIPPBPAField -FieldName 'PhishingSimulations' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.PhishingSimulations' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPhishingSimulations.ps1' 205
#Region './Public/Standards/Invoke-CIPPStandardPhishProtection.ps1' -1

function Invoke-CIPPStandardPhishProtection {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PhishProtection
    .SYNOPSIS
        (Label) Enable Phishing Protection system via branding CSS
    .DESCRIPTION
        (Helptext) Adds branding to the logon page that only appears if the url is not login.microsoftonline.com. This potentially prevents AITM attacks via EvilNginx. This will also automatically generate alerts if a clone of your login page has been found when set to Remediate.
        (DocsDescription) Adds branding to the logon page that only appears if the url is not login.microsoftonline.com. This potentially prevents AITM attacks via EvilNginx. This will also automatically generate alerts if a clone of your login page has been found when set to Remediate.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Implements advanced phishing protection by adding visual indicators to login pages that help users identify legitimate Microsoft login pages versus fraudulent copies. This security measure protects against sophisticated phishing attacks that attempt to steal employee credentials.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-01-22
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        POWERSHELLEQUIVALENT
            Portal only
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'PhishProtection'

    $TenantId = Get-Tenants | Where-Object -Property defaultDomainName -EQ $tenant

    $Table = Get-CIPPTable -TableName Config
    $CippConfig = (Get-CIPPAzDataTableEntity @Table)
    $CIPPUrl = ($CippConfig | Where-Object { $_.RowKey -eq 'CIPPURL' }).Value

    try {
        $currentBody = (New-GraphGetRequest -Uri "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations/0/customCSS" -tenantid $tenant)
    } catch {
        Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not get the branding for $($Tenant). This tenant might not have premium licenses available: $($_.Exception.Message)" -sev Error
    }
    $CSS = @"
.ext-sign-in-box {
    background-image: url(https://clone.cipp.app/api/PublicPhishingCheck?Tenantid=$($tenant)&URL=https://$($CIPPUrl));
}
"@
    if ($Settings.remediate -eq $true) {

        $malformedCSSPattern = '\.ext-sign-in-box\s*\{\s*background-image:\s*url\(https://clone\.cipp\.app/api/PublicPhishingCheck\?Tenantid=[^&]*&URL=\);\s*\}'
        if ($currentBody -match $malformedCSSPattern) {
            if ($Settings.remediate -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Attempting to fix malformed PhishProtection CSS by removing the problematic pattern' -sev Info
                # Remove the malformed CSS pattern
                $currentBody = $currentBody -replace $malformedCSSPattern, ''
                # Clean up any duplicate .ext-sign-in-box entries
                #$currentBody = $currentBody -replace '\.ext-sign-in-box\s*\{[^}]*\}\s*\.ext-sign-in-box', '.ext-sign-in-box'
            }
        }

        try {
            if (!$currentBody) {
                $AddedHeaders = @{'Accept-Language' = 0 }
                $defaultBrandingBody = '{"usernameHintText":null,"signInPageText":null,"backgroundColor":null,"customPrivacyAndCookiesText":null,"customCannotAccessYourAccountText":null,"customForgotMyPasswordText":null,"customTermsOfUseText":null,"loginPageLayoutConfiguration":{"layoutTemplateType":"default","isFooterShown":true,"isHeaderShown":false},"loginPageTextVisibilitySettings":{"hideAccountResetCredentials":false,"hideTermsOfUse":true,"hidePrivacyAndCookies":true},"contentCustomization":{"conditionalAccess":[],"attributeCollection":[]}}'
                try {
                    New-GraphPostRequest -tenantid $tenant -Uri "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations/" -ContentType 'application/json' -asApp $true -Type POST -Body $defaultBrandingBody -AddedHeaders $AddedHeaders
                } catch {

                }
            }
            if ($currentBody -like "*$CSS*") {
                Write-Host 'Logon Screen Phishing Protection system already active'
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Logon Screen Phishing Protection system already active' -sev Info
            } else {
                $currentBody = $currentBody + $CSS
                Write-Host 'Creating Logon Screen Phishing Protection System'
                New-GraphPostRequest -tenantid $tenant -Uri "https://graph.microsoft.com/beta/organization/$($TenantId.customerId)/branding/localizations/0/customCSS" -ContentType 'text/css' -asApp $true -Type PUT -Body $currentBody

                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Enabled Logon Screen Phishing Protection system' -sev Info
            }
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not set Logon Screen Phishing Protection System for $($Tenant): $ErrorMessage" -sev Error
        }
    }

    if ($Settings.alert -eq $true) {
        if ($currentBody -like "*$CSS*") {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'PhishProtection is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'PhishProtection is not enabled' -object $currentBody -tenant $tenant -standardName 'PhishProtection' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'PhishProtection is not enabled.' -sev Info
        }
    }
    if ($Settings.report -eq $true) {
        if ($currentBody -like "*$CSS*") { $authState = $true } else { $authState = $false }
        Add-CIPPBPAField -FieldName 'PhishProtection' -FieldValue $authState -StoreAs bool -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.PhishProtection' -FieldValue $authState -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPhishProtection.ps1' 107
#Region './Public/Standards/Invoke-CIPPStandardPhishSimSpoofIntelligence.ps1' -1

function Invoke-CIPPStandardPhishSimSpoofIntelligence {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PhishSimSpoofIntelligence
    .SYNOPSIS
        (Label) Add allowed domains to Spoof Intelligence
    .DESCRIPTION
        (Helptext) This adds allowed domains to the Spoof Intelligence Allow/Block List.
        (DocsDescription) This adds allowed domains to the Spoof Intelligence Allow/Block List.
    .NOTES
        CAT
            Defender Standards
        TAG
        ADDEDCOMPONENT
            {"type":"switch","label":"Remove extra domains from the allow list","name":"standards.PhishSimSpoofIntelligence.RemoveExtraDomains","defaultValue":false,"required":false}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"label":"Allowed Domains","name":"standards.PhishSimSpoofIntelligence.AllowedDomains"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-03-28
        POWERSHELLEQUIVALENT
            New-TenantAllowBlockListSpoofItems
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'PhishSimSpoofIntelligence' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    # Fetch current Phishing Simulations Spoof Intelligence domains and ensure it is correctly configured
    try {
        $DomainState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-TenantAllowBlockListSpoofItems' |
        Select-Object -Property Identity, SendingInfrastructure
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PhishSimSpoofIntelligence state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    [String[]]$AddDomain = $Settings.AllowedDomains.value | Where-Object { $_ -notin $DomainState.SendingInfrastructure }

    if ($Settings.RemoveExtraDomains -eq $true) {
        $RemoveDomain = $DomainState | Where-Object { $_.SendingInfrastructure -notin $Settings.AllowedDomains.value } |
            Select-Object -Property Identity,SendingInfrastructure
    } else {
        $RemoveDomain = @()
    }

    $StateIsCorrect = ($AddDomain.Count -eq 0 -and $RemoveDomain.Count -eq 0)

    $CompareField = [PSCustomObject]@{
        "Missing Domains"   = $AddDomain -join ', '
        "Incorrect Domains" = $RemoveDomain.SendingInfrastructure -join ', '
    }

    If ($Settings.remediate -eq $true) {
        If ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spoof Intelligence Allow list already correctly configured' -sev Info
        } Else {
            $BulkRequests = New-Object System.Collections.Generic.List[Hashtable]

            if ($Settings.RemoveExtraDomains -eq $true) {
                # Prepare removal requests
                If ($RemoveDomain.Count -gt 0) {
                    Write-Host "Removing $($RemoveDomain.Count) domains from Spoof Intelligence"
                    $BulkRequests.Add(@{
                            CmdletInput = @{
                                CmdletName = 'Remove-TenantAllowBlockListSpoofItems'
                                Parameters = @{ Identity = 'default'; Ids = $RemoveDomain.Identity }
                            }
                        })
                }
            }

            # Prepare addition requests
            ForEach ($Domain in $AddDomain) {
                $BulkRequests.Add(@{
                    CmdletInput = @{
                        CmdletName = 'New-TenantAllowBlockListSpoofItems'
                        Parameters = @{ Identity = 'default'; Action = 'Allow'; SendingInfrastructure = $Domain; SpoofedUser = '*'; SpoofType = 'Internal' }
                    }
                })
                $BulkRequests.Add(@{
                    CmdletInput = @{
                        CmdletName = 'New-TenantAllowBlockListSpoofItems'
                        Parameters = @{ Identity = 'default'; Action = 'Allow'; SendingInfrastructure = $Domain; SpoofedUser = '*'; SpoofType = 'External' }
                    }
                })
            }
            $RawExoRequest = New-ExoBulkRequest -tenantid $Tenant -cmdletArray @($BulkRequests)

            $LastError = $RawExoRequest | Select-Object -Last 1
            If ($LastError.error) {
                Foreach ($ExoError in $LastError.error) {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to process Spoof Intelligence Domain with error: $ExoError" -Sev Error
                }
            } Else {
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Processed all Spoof Intelligence Domains successfully." -Sev Info
            }
        }
    }

    If ($Settings.alert -eq $true) {
        If ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spoof Intelligence Allow list is correctly configured' -sev Info
        } Else {
            Write-StandardsAlert -message 'Spoof Intelligence Allow list is not correctly configured' -object $CompareField -tenant $Tenant -standardName 'PhishSimSpoofIntelligence' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spoof Intelligence Allow list is not correctly configured' -sev Info
        }
    }

    If ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Set-CIPPStandardsCompareField -FieldName 'standards.PhishSimSpoofIntelligence' -FieldValue $FieldValue -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'PhishSimSpoofIntelligence' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPhishSimSpoofIntelligence.ps1' 128
#Region './Public/Standards/Invoke-CIPPStandardProfilePhotos.ps1' -1

function Invoke-CIPPStandardProfilePhotos {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ProfilePhotos
    .SYNOPSIS
        (Label) Allow users to set profile photos
    .DESCRIPTION
        (Helptext) Controls whether users can set their own profile photos in Microsoft 365.
        (DocsDescription) Controls whether users can set their own profile photos in Microsoft 365. When disabled, only User and Global administrators can update profile photos for users.
    .NOTES
        CAT
            Global Standards
        TAG
        EXECUTIVETEXT
            Manages user profile photo permissions within Microsoft 365, allowing organizations to control whether employees can upload their own photos or require administrative approval. This helps maintain professional appearance standards and prevents inappropriate images in corporate directories.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.ProfilePhotos.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-01-19
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -ProfilePhotoOptions EnablePhotos and Update-MgBetaAdminPeople
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'ProfilePhotos' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Get state value using null-coalescing operator
    $StateValue = $Settings.state.value ?? $Settings.state

    # Input validation
    if ([string]::IsNullOrWhiteSpace($StateValue)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'ProfilePhotos: Invalid state parameter set' -sev Error
        Return
    }

    # true if wanted state is enabled, false if disabled
    $DesiredState = $StateValue -eq 'enabled'

    # Get current Graph policy state
    try {
        $Uri = 'https://graph.microsoft.com/beta/admin/people/photoUpdateSettings'
        $CurrentGraphState = New-GraphGetRequest -uri $Uri -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ProfilePhotos state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }
    $UsersCanChangePhotos = if ([string]::IsNullOrWhiteSpace($CurrentGraphState.allowedRoles) ) { $true } else { $false }
    $GraphStateCorrect = $UsersCanChangePhotos -eq $DesiredState

    if ($UsersCanChangePhotos -eq $false -and $DesiredState -eq $false) {
        # Check if the correct roles are present
        $GraphStateCorrect = $CurrentGraphState.allowedRoles -contains '62e90394-69f5-4237-9190-012177145e10' -and $CurrentGraphState.allowedRoles -contains 'fe930be7-5e62-47db-91af-98c3a49a38b1'
    }

    # Get current OWA mailbox policy state
    $CurrentOWAState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OwaMailboxPolicy' -cmdParams @{Identity = 'OwaMailboxPolicy-Default' } -Select 'Identity,SetPhotoEnabled'
    $OWAStateCorrect = $CurrentOWAState.SetPhotoEnabled -eq $DesiredState

    # Check if both states are correct
    $CurrentStatesCorrect = $GraphStateCorrect -eq $true -and $OWAStateCorrect -eq $true

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CurrentStatesCorrect -eq $false) {
            Write-Host 'Settings are not correct'
            try {
                if ($StateValue -eq 'enabled') {
                    Write-Host 'Enabling'
                    # Enable photo updates
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OwaMailboxPolicy' -cmdParams @{Identity = $CurrentOWAState.Identity; SetPhotoEnabled = $true } -useSystemMailbox $true
                    $null = New-GraphPostRequest -uri $Uri -tenant $Tenant -type DELETE -AsApp $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set Profile photo settings to $StateValue" -sev Info

                } else {
                    Write-Host 'Disabling'
                    # Disable photo updates
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OwaMailboxPolicy' -cmdParams @{Identity = $CurrentOWAState.Identity; SetPhotoEnabled = $false } -useSystemMailbox $true

                    $body = @{
                        source       = 'cloud'
                        allowedRoles = @(
                            'fe930be7-5e62-47db-91af-98c3a49a38b1', # Global admin
                            '62e90394-69f5-4237-9190-012177145e10'  # User admin
                        )
                    }
                    $body = ConvertTo-Json -InputObject $body -Depth 5 -Compress
                    $null = New-GraphPostRequest -uri $Uri -tenant $Tenant -body $body -type PATCH -AsApp $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set Profile photo settings to $StateValue" -sev Info
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set profile photo settings to $StateValue. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-Host 'Settings are correct'
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Profile photo settings are already set to the desired state: $StateValue" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentStatesCorrect -eq $false) {
            Write-StandardsAlert -message "Profile photo settings do not match desired state: $StateValue" -object $CurrentOWAState -tenant $Tenant -standardName 'ProfilePhotos' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Profile photo settings do not match desired state: $StateValue" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Profile photo settings match desired state: $StateValue" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'ProfilePhotos' -FieldValue $CurrentStatesCorrect -StoreAs bool -Tenant $Tenant
        if ($CurrentStatesCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = [PSCustomObject]@{
                OwaStateCorrect   = $OWAStateCorrect
                GraphStateCorrect = $GraphStateCorrect
            }
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.ProfilePhotos' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardProfilePhotos.ps1' 139
#Region './Public/Standards/Invoke-CIPPStandardPWcompanionAppAllowedState.ps1' -1

function Invoke-CIPPStandardPWcompanionAppAllowedState {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PWcompanionAppAllowedState
    .SYNOPSIS
        (Label) Set Authenticator Lite state
    .DESCRIPTION
        (Helptext) Sets the state of Authenticator Lite, Authenticator lite is a companion app for passwordless authentication.
        (DocsDescription) Sets the Authenticator Lite state to enabled. This allows users to use the Authenticator Lite built into the Outlook app instead of the full Authenticator app.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "EIDSCA.AM01"
        EXECUTIVETEXT
            Enables a simplified authentication experience by allowing users to authenticate directly through Outlook without requiring a separate authenticator app. This improves user convenience while maintaining security standards for passwordless authentication.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.PWcompanionAppAllowedState.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"},{"label":"Microsoft managed","value":"default"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-05-18
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $AuthenticatorFeaturesState = (New-GraphGetRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy/authenticationMethodConfigurations/microsoftAuthenticator')
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PWcompanionAppAllowedState state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Get state value using null-coalescing operator
    $CurrentState = $AuthenticatorFeaturesState.featureSettings.companionAppAllowedState.state
    $WantedState = $Settings.state.value ? $Settings.state.value : $settings.state
    $AuthStateCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    # Input validation
    if (([string]::IsNullOrWhiteSpace($WantedState) -or $WantedState -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'PWcompanionAppAllowedState: Invalid state parameter set' -sev Error
        Return
    }

    If ($Settings.remediate -eq $true) {
        Write-Host "Remediating PWcompanionAppAllowedState for tenant $Tenant to $WantedState"

        if ($AuthStateCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "companionAppAllowedState is already set to the desired state of $WantedState." -sev Info
        } else {
            try {
                # Remove number matching from featureSettings because this is now Microsoft enforced and shipping it returns an error
                $AuthenticatorFeaturesState.featureSettings.PSObject.Properties.Remove('numberMatchingRequiredState')
                # Define feature body
                $featureBody = @{
                    state         = $WantedState
                    includeTarget = [PSCustomObject]@{
                        targetType = 'group'
                        id         = 'all_users'
                    }
                    excludeTarget = [PSCustomObject]@{
                        targetType = 'group'
                        id         = '00000000-0000-0000-0000-000000000000'
                    }
                }
                $AuthenticatorFeaturesState.featureSettings.companionAppAllowedState = $featureBody
                $body = ConvertTo-Json -Depth 3 -Compress -InputObject $AuthenticatorFeaturesState
                $null = (New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy/authenticationMethodConfigurations/microsoftAuthenticator' -Type patch -Body $body -ContentType 'application/json')
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set companionAppAllowedState to $WantedState." -sev Info
            } catch {
                $ErrorMessage = Get-CippExceptionMessage -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set companionAppAllowedState to $WantedState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($AuthStateCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "companionAppAllowedState is set to $WantedState." -sev Info
        } else {
            Write-StandardsAlert -message "companionAppAllowedState is not set to $WantedState. Current state is $CurrentState." -object $AuthenticatorFeaturesState -tenant $Tenant -standardName 'PWcompanionAppAllowedState' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "companionAppAllowedState is not set to $WantedState. Current state is $CurrentState." -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'companionAppAllowedState' -FieldValue $AuthStateCorrect -StoreAs bool -Tenant $Tenant
        if ($AuthStateCorrect -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $AuthenticatorFeaturesState.featureSettings.companionAppAllowedState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.PWcompanionAppAllowedState' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPWcompanionAppAllowedState.ps1' 108
#Region './Public/Standards/Invoke-CIPPStandardPWdisplayAppInformationRequiredState.ps1' -1

function Invoke-CIPPStandardPWdisplayAppInformationRequiredState {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) PWdisplayAppInformationRequiredState
    .SYNOPSIS
        (Label) Enable Passwordless with Location information and Number Matching
    .DESCRIPTION
        (Helptext) Enables the MS authenticator app to display information about the app that is requesting authentication. This displays the application name.
        (DocsDescription) Allows users to use Passwordless with Number Matching and adds location information from the last request
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CIS M365 5.0 (2.3.1)"
            "EIDSCA.AM03"
            "EIDSCA.AM04"
            "EIDSCA.AM06"
            "EIDSCA.AM07"
            "EIDSCA.AM09"
            "EIDSCA.AM10"
            "NIST CSF 2.0 (PR.AA-03)"
        EXECUTIVETEXT
            Enhances authentication security by requiring users to match numbers and showing detailed information about login requests, including application names and location data. This helps employees verify legitimate login attempts and prevents unauthorized access through more secure authentication methods.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationMethodsPolicy/authenticationMethodConfigurations/microsoftAuthenticator' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the PWdisplayAppInformationRequiredState state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.state -eq 'enabled') -and
    ($CurrentState.featureSettings.numberMatchingRequiredState.state -eq 'enabled') -and
    ($CurrentState.featureSettings.displayAppInformationRequiredState.state -eq 'enabled')

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Passwordless with Information and Number Matching is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $tenant -APIName 'Standards' -AuthenticationMethodId 'MicrosoftAuthenticator' -Enabled $true
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Passwordless with Information and Number Matching is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Passwordless with Information and Number Matching is not enabled' -object $CurrentState -tenant $tenant -standardName 'PWdisplayAppInformationRequiredState' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Passwordless with Information and Number Matching is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'PWdisplayAppInformationRequiredState' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.PWdisplayAppInformationRequiredState' -FieldValue $FieldValue -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPWdisplayAppInformationRequiredState.ps1' 86
#Region './Public/Standards/Invoke-CIPPStandardPWnumberMatchingRequiredState.ps1' -1

function Invoke-CIPPStandardPWnumberMatchingRequiredState {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    Write-LogMessage -API 'Standards' -tenant $tenant -message 'Passwordless with number matching is now enabled by default.' -sev Info
}
#EndRegion './Public/Standards/Invoke-CIPPStandardPWnumberMatchingRequiredState.ps1' 9
#Region './Public/Standards/Invoke-CIPPStandardQuarantineRequestAlert.ps1' -1

function Invoke-CIPPStandardQuarantineRequestAlert {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) QuarantineRequestAlert
    .SYNOPSIS
        (Label) Quarantine Release Request Alert
    .DESCRIPTION
        (Helptext) Sets a e-mail address to alert when a User requests to release a quarantined message.
        (DocsDescription) Sets a e-mail address to alert when a User requests to release a quarantined message. This is useful for monitoring and ensuring that the correct messages are released.
    .NOTES
        CAT
            Defender Standards
        TAG
        EXECUTIVETEXT
            Notifies IT administrators when employees request to release emails that were quarantined for security reasons, enabling oversight of potentially dangerous messages. This helps ensure that legitimate emails are released while maintaining security controls over suspicious content.
        ADDEDCOMPONENT
            {"type":"textField","name":"standards.QuarantineRequestAlert.NotifyUser","label":"E-mail to receive the alert"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-15
        POWERSHELLEQUIVALENT
            New-ProtectionAlert and Set-ProtectionAlert
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'QuarantineRequestAlert' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $PolicyName = 'CIPP User requested to release a quarantined message'

    try {
        $CurrentState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-ProtectionAlert' -Compliance |
        Where-Object { $_.Name -eq $PolicyName } |
        Select-Object -Property *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the QuarantineRequestAlert state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.NotifyUser -contains $Settings.NotifyUser)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Quarantine Request Alert is configured correctly' -sev Info
        } else {
            $cmdParams = @{
                'NotifyUser'      = $Settings.NotifyUser
                'Category'        = 'ThreatManagement'
                'Operation'       = 'QuarantineRequestReleaseMessage'
                'Severity'        = 'Informational'
                'AggregationType' = 'None'
            }

            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams['Identity'] = $PolicyName
                    New-ExoRequest -TenantId $Tenant -cmdlet 'Set-ProtectionAlert' -Compliance -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully configured Quarantine Request Alert' -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to configure Quarantine Request Alert. Error: $ErrorMessage" -sev Error
                }
            } else {
                try {
                    $cmdParams['name'] = $PolicyName
                    $cmdParams['ThreatType'] = 'Activity'

                    New-ExoRequest -TenantId $Tenant -cmdlet 'New-ProtectionAlert' -Compliance -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully created Quarantine Request Alert' -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to create Quarantine Request Alert. Error: $ErrorMessage" -sev Error
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Quarantine Request Alert is enabled' -sev Info
        } else {
            $Message = 'Quarantine Request Alert is not enabled.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'QuarantineRequestAlerts' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'QuarantineRequestAlert' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = @{NotifyUser = $CurrentState.notifyUser }
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.QuarantineRequestAlert' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardQuarantineRequestAlert.ps1' 112
#Region './Public/Standards/Invoke-CIPPStandardQuarantineTemplate.ps1' -1

function Invoke-CIPPStandardQuarantineTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) QuarantineTemplate
    .SYNOPSIS
        (Label) Custom Quarantine Policy
    .DESCRIPTION
        (Helptext) This standard creates a Custom Quarantine Policies that can be used in Anti-Spam and all MDO365 policies. Quarantine Policies can be used to specify recipients permissions, enable end-user spam notifications, and specify the release action preference
        (DocsDescription) This standard creates a Custom Quarantine Policies that can be used in Anti-Spam and all MDO365 policies. Quarantine Policies can be used to specify recipients permissions, enable end-user spam notifications, and specify the release action preference
    .NOTES
        CAT
            Defender Standards
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        TAG
        EXECUTIVETEXT
            Creates standardized quarantine policies that define how employees can interact with quarantined emails, including permissions to release, delete, or preview suspicious messages. This ensures consistent security handling across the organization while providing appropriate user access to manage quarantined content.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":true,"name":"displayName","label":"Quarantine Display Name","required":true}
            {"type":"switch","label":"Enable end-user spam notifications","name":"ESNEnabled","defaultValue":true,"required":false}
            {"type":"select","multiple":false,"label":"Select release action preference","name":"ReleaseAction","options":[{"label":"Allow recipients to request a message to be released from quarantine","value":"PermissionToRequestRelease"},{"label":"Allow recipients to release a message from quarantine","value":"PermissionToRelease"}]}
            {"type":"switch","label":"Include Messages From Blocked Sender Address","name":"IncludeMessagesFromBlockedSenderAddress","defaultValue":false,"required":false}
            {"type":"switch","label":"Allow recipients to delete message","name":"PermissionToDelete","defaultValue":false,"required":false}
            {"type":"switch","label":"Allow recipients to preview message","name":"PermissionToPreview","defaultValue":false,"required":false}
            {"type":"switch","label":"Allow recipients to block Sender Address","name":"PermissionToBlockSender","defaultValue":false,"required":false}
            {"type":"switch","label":"Allow recipients to whitelist Sender Address","name":"PermissionToAllowSender","defaultValue":false,"required":false}
        MULTIPLE
            True
        IMPACT
            Low Impact
        ADDEDDATE
            2025-05-16
        POWERSHELLEQUIVALENT
            Set-QuarantinePolicy or New-QuarantinePolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'QuarantineTemplate' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $APIName = 'Standards'

    try {
        # Get the current custom quarantine policies
        $CurrentPolicies = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-QuarantinePolicy' | Where-Object -Property Guid -ne '00000000-0000-0000-0000-000000000000' -ErrorAction Stop

        # Compare the settings from standard with the current policies
        $CompareList = foreach ($Policy in $Settings) {
            try {
                # Create hashtable with desired Quarantine Setting
                $EndUserQuarantinePermissions   = @{
                    # ViewHeader and Download are set to false because the value 0 or 1 does nothing per Microsoft documentation
                    PermissionToViewHeader = $false
                    PermissionToDownload  = $false
                    PermissionToBlockSender = $Policy.PermissionToBlockSender
                    PermissionToDelete  = $Policy.PermissionToDelete
                    PermissionToPreview = $Policy.PermissionToPreview
                    PermissionToRelease = $Policy.ReleaseAction -eq "PermissionToRelease" ? $true : $false
                    PermissionToRequestRelease  = $Policy.ReleaseAction -eq "PermissionToRequestRelease" ? $true : $false
                    PermissionToAllowSender = $Policy.PermissionToAllowSender
                }

                # If the Quarantine Policy already exists
                if ($Policy.displayName.value -in $CurrentPolicies.Name) {
                    #Get the current policy and convert EndUserQuarantinePermissions from string to hashtable for compare
                    $ExistingPolicy = $CurrentPolicies | Where-Object -Property Name -eq $Policy.displayName.value
                    $ExistingPolicyEndUserQuarantinePermissions = Convert-QuarantinePermissionsValue -InputObject $ExistingPolicy.EndUserQuarantinePermissions -ErrorAction Stop

                    #Compare the current policy
                    $StateIsCorrect = ($ExistingPolicy.Name -eq $Policy.displayName.value) -and
                                ($ExistingPolicy.ESNEnabled -eq $Policy.ESNEnabled) -and
                                ($ExistingPolicy.IncludeMessagesFromBlockedSenderAddress -eq $Policy.IncludeMessagesFromBlockedSenderAddress) -and
                                (!(Compare-Object @($ExistingPolicyEndUserQuarantinePermissions.values) @($EndUserQuarantinePermissions.values)))

                    # If the current policy is correct
                    if ($StateIsCorrect -eq $true) {
                        [PSCustomObject]@{
                            missing         = $false
                            StateIsCorrect  = $StateIsCorrect
                            Action          = "None"
                            displayName     = $Policy.displayName.value
                            EndUserQuarantinePermissions = $EndUserQuarantinePermissions
                            ESNEnabled      = $Policy.ESNEnabled
                            IncludeMessagesFromBlockedSenderAddress = $Policy.IncludeMessagesFromBlockedSenderAddress
                            remediate       = $Policy.remediate
                            alert           = $Policy.alert
                            report          = $Policy.report
                        }
                    }
                    #If the current policy doesn't match the desired settings
                    else {
                        [PSCustomObject]@{
                            missing         = $false
                            StateIsCorrect  = $StateIsCorrect
                            Action          = "Update"
                            displayName     = $Policy.displayName.value
                            EndUserQuarantinePermissions = $EndUserQuarantinePermissions
                            ESNEnabled      = $Policy.ESNEnabled
                            IncludeMessagesFromBlockedSenderAddress = $Policy.IncludeMessagesFromBlockedSenderAddress
                            remediate       = $Policy.remediate
                            alert           = $Policy.alert
                            report          = $Policy.report
                        }
                    }
                }
                #If no existing Quarantine Policy with the same name was found
                else {
                    [PSCustomObject]@{
                        missing         = $true
                        StateIsCorrect  = $false
                        Action          = "Create"
                        displayName     = $Policy.displayName.value
                        EndUserQuarantinePermissions = $EndUserQuarantinePermissions
                        ESNEnabled      = $Policy.ESNEnabled
                        IncludeMessagesFromBlockedSenderAddress = $Policy.IncludeMessagesFromBlockedSenderAddress
                        remediate       = $Policy.remediate
                        alert           = $Policy.alert
                        report          = $Policy.report
                    }
                }
            }
            catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                $Message = "Failed to compare Quarantine policy $($Policy.displayName.value), Error: $ErrorMessage"
                Write-LogMessage -API $APIName -tenant $tenant -message $Message -sev 'Error'
                Return $Message
            }
        }


        If ($true -in $Settings.remediate) {
            # Remediate each policy which is incorrect or missing
            foreach ($Policy in $CompareList | Where-Object { $_.remediate -EQ $true -and $_.StateIsCorrect -eq $false }) {
                try {
                    # Parameters for splatting to Set-CIPPQuarantinePolicy
                    $Params = @{
                        Action = $Policy.Action
                        Identity = $Policy.displayName
                        EndUserQuarantinePermissions = $Policy.EndUserQuarantinePermissions
                        ESNEnabled = $Policy.ESNEnabled
                        IncludeMessagesFromBlockedSenderAddress = $Policy.IncludeMessagesFromBlockedSenderAddress
                        tenantFilter = $Tenant
                        APIName = $APIName
                    }

                    try {
                        Set-CIPPQuarantinePolicy @Params
                        Write-LogMessage -API $APIName -tenant $Tenant -message "$($Policy.Action)d Custom Quarantine Policy '$($Policy.displayName)'" -sev Info
                    }
                    catch {
                        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                        Write-LogMessage -API $APIName -tenant $tenant -message "Failed to $($Policy.Action) Quarantine policy $($Policy.displayName), Error: $ErrorMessage" -sev 'Error'
                    }
                }
                catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API $APIName -tenant $tenant -message "Failed to create or update Quarantine policy $($Policy.displayName), Error: $ErrorMessage" -sev 'Error'
                }
            }
        }

        if ($true -in $Settings.alert) {
            foreach ($Policy in $CompareList | Where-Object -Property alert -EQ $true) {
                if ($Policy.StateIsCorrect) {
                    Write-LogMessage -API $APIName -tenant $Tenant -message "Quarantine policy $($Policy.displayName) has the correct configuration." -sev Info
                }
                else {
                    if ($Policy.missing) {
                        $CurrentInfo = $Policy | Select-Object -Property displayName, missing
                        Write-StandardsAlert -message "Quarantine policy $($Policy.displayName) is missing." -object $CurrentInfo -tenant $Tenant -standardName 'QuarantineTemplate' -standardId $Settings.templateId
                        Write-LogMessage -API $APIName -tenant $Tenant -message "Quarantine policy $($Policy.displayName) is missing." -sev info
                    }
                    else {
                        $CurrentInfo = $CurrentPolicies | Where-Object -Property Name -eq $Policy.displayName | Select-Object -Property Name, ESNEnabled, IncludeMessagesFromBlockedSenderAddress, EndUserQuarantinePermissions
                        Write-StandardsAlert -message "Quarantine policy $($Policy.displayName) does not match the expected configuration." -object $CurrentInfo -tenant $Tenant -standardName 'QuarantineTemplate' -standardId $Settings.templateId
                        Write-LogMessage -API $APIName -tenant $Tenant -message "Quarantine policy $($Policy.displayName) does not match the expected configuration. We've generated an alert" -sev info
                    }
                }
            }
        }

        if ($true -in $Settings.report) {
            foreach ($Policy in $CompareList | Where-Object -Property report -EQ $true) {
                # Convert displayName to hex to avoid invalid characters "/, \, #, ?" which are not allowed in RowKey, but "\, #, ?" can be used in quarantine displayName
                $HexName = -join ($Policy.displayName.ToCharArray() | ForEach-Object { '{0:X2}' -f [int][char]$_ })
                Set-CIPPStandardsCompareField -FieldName "standards.QuarantineTemplate.$HexName" -FieldValue $Policy.StateIsCorrect -TenantFilter $Tenant
            }
        }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API $APIName -tenant $tenant -message "Failed to create or update Quarantine policy/policies, Error: $ErrorMessage" -sev 'Error'
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardQuarantineTemplate.ps1' 206
#Region './Public/Standards/Invoke-CIPPStandardRestrictThirdPartyStorageServices.ps1' -1

function Invoke-CIPPStandardRestrictThirdPartyStorageServices {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) RestrictThirdPartyStorageServices
    .SYNOPSIS
        (Label) Restrict third-party storage services in Microsoft 365 on the web
    .DESCRIPTION
        (Helptext) Restricts third-party storage services in Microsoft 365 on the web by managing the Microsoft 365 on the web service principal. This disables integrations with services like Dropbox, Google Drive, Box, and other third-party storage providers.
        (DocsDescription) Third-party storage can be enabled for users in Microsoft 365, allowing them to store and share documents using services such as Dropbox, alongside OneDrive and team sites. This standard ensures Microsoft 365 on the web third-party storage services are restricted by creating and disabling the Microsoft 365 on the web service principal (appId: c1f33bc0-bdb4-4248-ba9b-096807ddb43e). By using external storage services an organization may increase the risk of data breaches and unauthorized access to confidential information. Additionally, third-party services may not adhere to the same security standards as the organization, making it difficult to maintain data privacy and security. Impact is highly dependent upon current practices - if users do not use other storage providers, then minimal impact is likely. However, if users regularly utilize providers outside of the tenant this will affect their ability to continue to do so.
    .NOTES
        CAT
            Global Standards
        TAG
            "CIS M365 5.0 (1.3.7)"
        EXECUTIVETEXT
            Prevents employees from using external cloud storage services like Dropbox, Google Drive, and Box within Microsoft 365, reducing data security risks and ensuring all company data remains within controlled corporate systems. This helps maintain data governance and prevents potential data leaks to unauthorized platforms.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-06-06
        POWERSHELLEQUIVALENT
            New-MgServicePrincipal and Update-MgServicePrincipal
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'RestrictThirdPartyStorageServices'
    $TestResult = Test-CIPPStandardLicense -StandardName 'ThirdPartyStorageServicesRestricted' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $AppId = 'c1f33bc0-bdb4-4248-ba9b-096807ddb43e'
    $Uri = "https://graph.microsoft.com/beta/servicePrincipals?`$filter=appId eq '$AppId'"

    try {
        $CurrentState = New-GraphGetRequest -Uri $Uri -tenantid $Tenant | Select-Object displayName, accountEnabled, appId
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not get current state for Microsoft 365 on the web service principal. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate third-party storage services restriction'

        # Check if service principal is already disabled
        if ($CurrentState.accountEnabled -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Third-party storage services are already restricted (service principal is disabled).' -sev Info
        } else {
            # Disable the service principal to restrict third-party storage services
            try {
                $DisableBody = @{
                    accountEnabled = $false
                } | ConvertTo-Json -Depth 10 -Compress

                # Normal /servicePrincipal/AppId does not find the service principal, so gotta use the Upsert method. Also handles if the service principal does not exist nicely.
                # https://learn.microsoft.com/en-us/graph/api/serviceprincipal-upsert?view=graph-rest-beta&tabs=http
                $UpdateUri = "https://graph.microsoft.com/beta/servicePrincipals(appId='$AppId')"
                $null = New-GraphPostRequest -Uri $UpdateUri -Body $DisableBody -TenantID $Tenant -Type PATCH -AddedHeaders @{'Prefer' = 'create-if-missing' }

                # Refresh the current state after disabling
                $CurrentState = New-GraphGetRequest -Uri $Uri -tenantid $Tenant | Select-Object displayName, accountEnabled, appId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Successfully restricted third-party storage services in Microsoft 365 on the web.' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to restrict third-party storage services. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentState.accountEnabled -eq $false) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Third-party storage services are restricted (service principal is disabled).' -sev Info
        } else {
            Write-StandardsAlert -message 'Third-party storage services are not restricted in Microsoft 365 on the web' -object $CurrentState -tenant $Tenant -standardName 'RestrictThirdPartyStorageServices' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Third-party storage services are not restricted.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($null -eq $CurrentState.accountEnabled -or $CurrentState.accountEnabled -eq $true) {
            Set-CIPPStandardsCompareField -FieldName 'standards.RestrictThirdPartyStorageServices' -FieldValue $false -Tenant $Tenant
            Add-CIPPBPAField -FieldName 'ThirdPartyStorageServicesRestricted' -FieldValue $false -StoreAs bool -Tenant $Tenant
        } else {
            $CorrectState = $CurrentState.accountEnabled -eq $false ? $true : $false
            Set-CIPPStandardsCompareField -FieldName 'standards.RestrictThirdPartyStorageServices' -FieldValue $CorrectState -Tenant $Tenant
            Add-CIPPBPAField -FieldName 'ThirdPartyStorageServicesRestricted' -FieldValue $CorrectState -StoreAs bool -Tenant $Tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardRestrictThirdPartyStorageServices.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandardRetentionPolicyTag.ps1' -1

function Invoke-CIPPStandardRetentionPolicyTag {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) RetentionPolicyTag
    .SYNOPSIS
        (Label) Retention Policy, permanently delete items in Deleted Items after X days
    .DESCRIPTION
        (Helptext) Creates a CIPP - Deleted Items retention policy tag that permanently deletes items in the Deleted Items folder after X days.
        (DocsDescription) Creates a CIPP - Deleted Items retention policy tag that permanently deletes items in the Deleted Items folder after X days.
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.4.1)"
        EXECUTIVETEXT
            Automatically and permanently removes deleted emails after a specified number of days, helping manage storage costs and ensuring compliance with data retention policies. This prevents accumulation of unnecessary deleted items while maintaining a reasonable recovery window for accidentally deleted emails.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.RetentionPolicyTag.AgeLimitForRetention","label":"Retention Days","required":true}
        IMPACT
            High Impact
        ADDEDDATE
            2025-02-02
        POWERSHELLEQUIVALENT
            Set-RetentionPolicyTag
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'RetentionPolicyTag' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $PolicyName = 'CIPP Deleted Items'

    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-RetentionPolicyTag' |
        Where-Object -Property Identity -EQ $PolicyName

        $PolicyState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-RetentionPolicy' |
        Where-Object -Property Identity -EQ 'Default MRM Policy'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the RetentionPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
    ($CurrentState.RetentionEnabled -eq $true) -and
    ($CurrentState.RetentionAction -eq 'PermanentlyDelete') -and
    ($CurrentState.AgeLimitForRetention -eq ([timespan]::FromDays($Settings.AgeLimitForRetention))) -and
    ($CurrentState.Type -eq 'DeletedItems') -and
    ($PolicyState.RetentionPolicyTagLinks -contains $PolicyName)

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Retention policy tag already correctly configured' -sev Info
        } else {
            $cmdParams = @{
                RetentionEnabled     = $true
                AgeLimitForRetention = $Settings.AgeLimitForRetention
                RetentionAction      = 'PermanentlyDelete'
            }

            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams.Add('Identity', $PolicyName)
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-RetentionPolicyTag' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Retention policy tag $PolicyName." -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Retention policy tag $PolicyName." -sev Error -LogData $ErrorMessage
                }
            } else {
                try {
                    $cmdParams.Add('Name', $PolicyName)
                    $cmdParams.Add('Type', 'DeletedItems')
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-RetentionPolicyTag' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Retention policy tag $PolicyName." -sev Info
                } catch {

                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Retention policy tag $PolicyName." -sev Error -LogData $ErrorMessage
                }
            }

            if ($PolicyState.RetentionPolicyTagLinks -notcontains $PolicyName) {
                try {
                    $cmdParams = @{
                        Identity                = 'Default MRM Policy'
                        RetentionPolicyTagLinks = @($PolicyState.RetentionPolicyTagLinks + $PolicyName)
                    }
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-RetentionPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Added $PolicyName Retention tag to $($PolicyState.Identity)." -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to add $PolicyName Retention tag to $($PolicyState.Identity)." -sev Error -LogData $ErrorMessage
                }
            }

        }

    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Retention Policy is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Retention Policy is not enabled' -object $CurrentState -tenant $Tenant -standardName 'RetentionPolicyTag' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Retention Policy is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'RetentionPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = @{ CurrentState = $CurrentState; PolicyState = $PolicyState }
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.RetentionPolicyTag' -FieldValue $FieldValue -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardRetentionPolicyTag.ps1' 138
#Region './Public/Standards/Invoke-CIPPStandardRotateDKIM.ps1' -1

function Invoke-CIPPStandardRotateDKIM {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) RotateDKIM
    .SYNOPSIS
        (Label) Rotate DKIM keys that are 1024 bit to 2048 bit
    .DESCRIPTION
        (Helptext) Rotate DKIM keys that are 1024 bit to 2048 bit
        (DocsDescription) Rotate DKIM keys that are 1024 bit to 2048 bit
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (2.1.9)"
        EXECUTIVETEXT
            Upgrades email security by replacing older 1024-bit encryption keys with stronger 2048-bit keys for email authentication. This improves the organization's email security posture and helps prevent email spoofing and tampering, maintaining trust with email recipients.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2023-03-14
        POWERSHELLEQUIVALENT
            Rotate-DkimSigningConfig
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'RotateDKIM' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $DKIM = (New-ExoRequest -tenantid $tenant -cmdlet 'Get-DkimSigningConfig') | Where-Object { $_.Selector1KeySize -eq 1024 -and $_.Enabled -eq $true }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the DKIM state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        if ($DKIM) {
            $DKIM | ForEach-Object {
                try {
                    (New-ExoRequest -tenantid $tenant -cmdlet 'Rotate-DkimSigningConfig' -cmdParams @{ KeySize = 2048; Identity = $_.Identity } -useSystemMailbox $true)
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Rotated DKIM for $($_.Identity)" -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to rotate DKIM Error: $ErrorMessage" -sev Error
                }
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DKIM is already rotated for all domains' -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($DKIM) {
            Write-StandardsAlert -message "DKIM is not rotated for $($DKIM.Identity -join ';')" -object $DKIM -tenant $tenant -standardName 'RotateDKIM' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "DKIM is not rotated for $($DKIM.Identity -join ';')" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'DKIM is rotated for all domains' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'DKIM' -FieldValue $DKIM -StoreAs json -Tenant $tenant
        if ($DKIM) {
            Set-CIPPStandardsCompareField -FieldName 'standards.RotateDKIM' -FieldValue $DKIM -Tenant $tenant
        } else {
            Set-CIPPStandardsCompareField -FieldName 'standards.RotateDKIM' -FieldValue $true -Tenant $tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardRotateDKIM.ps1' 88
#Region './Public/Standards/Invoke-CIPPStandardSafeAttachmentPolicy.ps1' -1

function Invoke-CIPPStandardSafeAttachmentPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SafeAttachmentPolicy
    .SYNOPSIS
        (Label) Default Safe Attachment Policy
    .DESCRIPTION
        (Helptext) This creates a Safe Attachment policy
        (DocsDescription) This creates a Safe Attachment policy
    .NOTES
        CAT
            Defender Standards
        TAG
            "CIS M365 5.0 (2.1.4)"
            "mdo_safedocuments"
            "mdo_commonattachmentsfilter"
            "mdo_safeattachmentpolicy"
            "NIST CSF 2.0 (DE.CM-09)"
        ADDEDCOMPONENT
            {"type":"select","multiple":false,"label":"Safe Attachment Action","name":"standards.SafeAttachmentPolicy.SafeAttachmentAction","options":[{"label":"Allow","value":"Allow"},{"label":"Block","value":"Block"},{"label":"DynamicDelivery","value":"DynamicDelivery"}]}
            {"type":"select","multiple":false,"creatable":true,"label":"QuarantineTag","name":"standards.SafeAttachmentPolicy.QuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"switch","label":"Redirect","name":"standards.SafeAttachmentPolicy.Redirect"}
            {"type":"textField","name":"standards.SafeAttachmentPolicy.RedirectAddress","label":"Redirect Address","required":false,"condition":{"field":"standards.SafeAttachmentPolicy.Redirect","compareType":"is","compareValue":true}}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-25
        POWERSHELLEQUIVALENT
            Set-SafeAttachmentPolicy or New-SafeAttachmentPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SafeAttachmentPolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $ServicePlans = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus?$select=servicePlans' -tenantid $Tenant
    $ServicePlans = $ServicePlans.servicePlans.servicePlanName
    $MDOLicensed = $ServicePlans -contains 'ATP_ENTERPRISE'

    if ($MDOLicensed) {
        # Use custom name if provided, otherwise use default for backward compatibility
        $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Safe Attachment Policy' }
        $PolicyList = @($PolicyName, 'CIPP Default Safe Attachment Policy', 'Default Safe Attachment Policy')
        $ExistingPolicy = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeAttachmentPolicy' | Where-Object -Property Name -In $PolicyList | Select-Object -First 1
        if ($null -eq $ExistingPolicy.Name) {
            # No existing policy - use the configured/default name
            $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Safe Attachment Policy' }
        } else {
            # Use existing policy name if found
            $PolicyName = $ExistingPolicy.Name
        }
        # Derive rule name from policy name, but check for old names for backward compatibility
        $DesiredRuleName = "$PolicyName Rule"
        $RuleList = @($DesiredRuleName, 'CIPP Default Safe Attachment Rule', 'CIPP Default Safe Attachment Policy')
        $ExistingRule = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeAttachmentRule' | Where-Object -Property Name -In $RuleList | Select-Object -First 1
        if ($null -eq $ExistingRule.Name) {
            # No existing rule - use the derived name
            $RuleName = $DesiredRuleName
        } else {
            # Use existing rule name if found
            $RuleName = $ExistingRule.Name
        }

        try {
            $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeAttachmentPolicy' |
            Where-Object -Property Name -EQ $PolicyName |
            Select-Object Name, Enable, Action, QuarantineTag, Redirect, RedirectAddress
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SafeAttachmentPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
            return
        }

        $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
        ($CurrentState.Enable -eq $true) -and
        ($CurrentState.Action -eq $Settings.SafeAttachmentAction) -and
        ($CurrentState.QuarantineTag -eq $Settings.QuarantineTag) -and
        ($CurrentState.Redirect -eq $Settings.Redirect) -and
        (($null -eq $Settings.RedirectAddress) -or ($CurrentState.RedirectAddress -eq $Settings.RedirectAddress))

        $AcceptedDomains = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AcceptedDomain'

        $RuleState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeAttachmentRule' |
        Where-Object -Property Name -EQ $RuleName |
        Select-Object Name, SafeAttachmentPolicy, Priority, RecipientDomainIs

        $RuleStateIsCorrect = ($RuleState.Name -eq $RuleName) -and
        ($RuleState.SafeAttachmentPolicy -eq $PolicyName) -and
        ($RuleState.Priority -eq 0) -and
        (!(Compare-Object -ReferenceObject $RuleState.RecipientDomainIs -DifferenceObject $AcceptedDomains.Name))

        if ($Settings.remediate -eq $true) {

            if ($StateIsCorrect -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Safe Attachment Policy already correctly configured' -sev Info
            } else {
                $cmdParams = @{
                    Enable          = $true
                    Action          = $Settings.SafeAttachmentAction
                    QuarantineTag   = $Settings.QuarantineTag
                    Redirect        = $Settings.Redirect
                    RedirectAddress = $Settings.RedirectAddress
                }

                if ($CurrentState.Name -eq $PolicyName) {
                    try {
                        $cmdParams.Add('Identity', $PolicyName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeAttachmentPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Safe Attachment policy $PolicyName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Safe Attachment policy $PolicyName." -sev Error -LogData $_
                    }
                } else {
                    try {
                        $cmdParams.Add('Name', $PolicyName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeAttachmentPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Safe Attachment policy $PolicyName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Safe Attachment policy $PolicyName." -sev Error -LogData $_
                    }
                }
            }

            if ($RuleStateIsCorrect -eq $false) {
                $cmdParams = @{
                    Priority          = 0
                    RecipientDomainIs = $AcceptedDomains.Name
                }

                if ($RuleState.SafeAttachmentPolicy -ne $PolicyName) {
                    $cmdParams.Add('SafeAttachmentPolicy', $PolicyName)
                }

                if ($RuleState.Name -eq $RuleName) {
                    try {
                        $cmdParams.Add('Identity', $RuleName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeAttachmentRule' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Safe Attachment rule $RuleName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update Safe Attachment rule $RuleName." -sev Error -LogData $_
                    }
                } else {
                    try {
                        $cmdParams.Add('Name', $RuleName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeAttachmentRule' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created Safe Attachment rule $RuleName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create Safe Attachment rule $RuleName." -sev Error -LogData $_
                    }
                }
            }
        }

        if ($Settings.alert -eq $true) {

            if ($StateIsCorrect -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Safe Attachment Policy is enabled' -sev Info
            } else {
                Write-StandardsAlert -message 'Safe Attachment Policy is not enabled' -object $CurrentState -tenant $Tenant -standardName 'SafeAttachmentPolicy' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Safe Attachment Policy is not enabled' -sev Info
            }
        }

        if ($Settings.report -eq $true) {
            Add-CIPPBPAField -FieldName 'SafeAttachmentPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
            if ($StateIsCorrect) {
                $FieldValue = $true
            } else {
                $FieldValue = $CurrentState
            }
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeAttachmentPolicy' -FieldValue $FieldValue -Tenant $Tenant
        }
    } else {
        if ($Settings.remediate -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to create Safe Attachment policy: Tenant does not have Microsoft Defender for Office 365 license' -sev Error
        }

        if ($Settings.alert -eq $true) {
            Write-StandardsAlert -message 'Safe Attachment Policy is not enabled: Tenant does not have Microsoft Defender for Office 365 license' -object $MDOLicensed -tenant $Tenant -standardName 'SafeAttachmentPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Safe Attachment Policy is not enabled: Tenant does not have Microsoft Defender for Office 365 license' -sev Info
        }

        if ($Settings.report -eq $true) {
            $state = @{ License = 'Failed to set policy: This tenant might not be licensed for this feature' }
            Add-CIPPBPAField -FieldName 'SafeAttachmentPolicy' -FieldValue $false -StoreAs bool -Tenant $tenant
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeAttachmentPolicy' -FieldValue $state -Tenant $Tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSafeAttachmentPolicy.ps1' 203
#Region './Public/Standards/Invoke-CIPPStandardSafeLinksPolicy.ps1' -1

function Invoke-CIPPStandardSafeLinksPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SafeLinksPolicy
    .SYNOPSIS
        (Label) Default Safe Links Policy
    .DESCRIPTION
        (Helptext) This creates a Safe Links policy that automatically scans, tracks, and and enables safe links for Email, Office, and Teams for both external and internal senders
        (DocsDescription) This creates a Safe Links policy that automatically scans, tracks, and and enables safe links for Email, Office, and Teams for both external and internal senders
    .NOTES
        CAT
            Defender Standards
        TAG
            "CIS M365 5.0 (2.1.1)"
            "mdo_safelinksforemail"
            "mdo_safelinksforOfficeApps"
            "NIST CSF 2.0 (DE.CM-09)"
        ADDEDCOMPONENT
            {"type":"switch","label":"AllowClickThrough","name":"standards.SafeLinksPolicy.AllowClickThrough"}
            {"type":"switch","label":"DisableUrlRewrite","name":"standards.SafeLinksPolicy.DisableUrlRewrite"}
            {"type":"switch","label":"EnableOrganizationBranding","name":"standards.SafeLinksPolicy.EnableOrganizationBranding"}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"name":"standards.SafeLinksPolicy.DoNotRewriteUrls","label":"Do not rewrite the following URLs in email"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-03-25
        POWERSHELLEQUIVALENT
            Set-SafeLinksPolicy or New-SafeLinksPolicy
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SafeLinksPolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $ServicePlans = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus?$select=servicePlans' -tenantid $Tenant
    $ServicePlans = $ServicePlans.servicePlans.servicePlanName
    $MDOLicensed = $ServicePlans -contains 'ATP_ENTERPRISE'

    if ($MDOLicensed) {
        # Use custom name if provided, otherwise use default for backward compatibility
        $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default SafeLinks Policy' }
        $PolicyList = @($PolicyName, 'CIPP Default SafeLinks Policy', 'Default SafeLinks Policy')
        $ExistingPolicy = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksPolicy' | Where-Object -Property Name -In $PolicyList | Select-Object -First 1
        if ($null -eq $ExistingPolicy.Name) {
            # No existing policy - use the configured/default name
            $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default SafeLinks Policy' }
        } else {
            # Use existing policy name if found
            $PolicyName = $ExistingPolicy.Name
        }
        # Derive rule name from policy name, but check for old names for backward compatibility
        $DesiredRuleName = "$PolicyName Rule"
        $RuleList = @($DesiredRuleName, 'CIPP Default SafeLinks Rule', 'CIPP Default SafeLinks Policy')
        $ExistingRule = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksRule' | Where-Object -Property Name -In $RuleList | Select-Object -First 1
        if ($null -eq $ExistingRule.Name) {
            # No existing rule - use the derived name
            $RuleName = $DesiredRuleName
        } else {
            # Use existing rule name if found
            $RuleName = $ExistingRule.Name
        }

        try {
            $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksPolicy' |
            Where-Object -Property Name -EQ $PolicyName |
            Select-Object Name, EnableSafeLinksForEmail, EnableSafeLinksForTeams, EnableSafeLinksForOffice, TrackClicks, AllowClickThrough, ScanUrls, EnableForInternalSenders, DeliverMessageAfterScan, DisableUrlRewrite, EnableOrganizationBranding, DoNotRewriteUrls
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SafeLinksPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
            return
        }

        $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
        ($CurrentState.EnableSafeLinksForEmail -eq $true) -and
        ($CurrentState.EnableSafeLinksForTeams -eq $true) -and
        ($CurrentState.EnableSafeLinksForOffice -eq $true) -and
        ($CurrentState.TrackClicks -eq $true) -and
        ($CurrentState.ScanUrls -eq $true) -and
        ($CurrentState.EnableForInternalSenders -eq $true) -and
        ($CurrentState.DeliverMessageAfterScan -eq $true) -and
        ($CurrentState.AllowClickThrough -eq $Settings.AllowClickThrough) -and
        ($CurrentState.DisableUrlRewrite -eq $Settings.DisableUrlRewrite) -and
        ($CurrentState.EnableOrganizationBranding -eq $Settings.EnableOrganizationBranding) -and
        (!(Compare-Object -ReferenceObject $CurrentState.DoNotRewriteUrls -DifferenceObject ($Settings.DoNotRewriteUrls.value ?? $Settings.DoNotRewriteUrls ?? @())))

        $AcceptedDomains = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-AcceptedDomain'

        $RuleState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksRule' |
            Where-Object -Property Name -EQ $RuleName |
            Select-Object Name, SafeLinksPolicy, Priority, RecipientDomainIs

        $RuleStateIsCorrect = ($RuleState.Name -eq $RuleName) -and
        ($RuleState.SafeLinksPolicy -eq $PolicyName) -and
        ($RuleState.Priority -eq 0) -and
        (!(Compare-Object -ReferenceObject $RuleState.RecipientDomainIs -DifferenceObject $AcceptedDomains.Name))

        if ($Settings.remediate -eq $true) {

            if ($StateIsCorrect -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'SafeLink Policy already correctly configured' -sev Info
            } else {
                $cmdParams = @{
                    EnableSafeLinksForEmail    = $true
                    EnableSafeLinksForTeams    = $true
                    EnableSafeLinksForOffice   = $true
                    TrackClicks                = $true
                    ScanUrls                   = $true
                    EnableForInternalSenders   = $true
                    DeliverMessageAfterScan    = $true
                    AllowClickThrough          = $Settings.AllowClickThrough
                    DisableUrlRewrite          = $Settings.DisableUrlRewrite
                    EnableOrganizationBranding = $Settings.EnableOrganizationBranding
                    DoNotRewriteUrls           = $Settings.DoNotRewriteUrls.value ?? @{'@odata.type' = '#Exchange.GenericHashTable' }
                }

                if ($CurrentState.Name -eq $Policyname) {
                    try {
                        $cmdParams.Add('Identity', $PolicyName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeLinksPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated SafeLink policy $PolicyName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update SafeLink policy $PolicyName." -sev Error -LogData $_
                    }
                } else {
                    try {
                        $cmdParams.Add('Name', $PolicyName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeLinksPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created SafeLink policy $PolicyName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create SafeLink policy $PolicyName." -sev Error -LogData $_
                    }
                }
            }

            if ($RuleStateIsCorrect -eq $false) {
                $cmdParams = @{
                    Priority          = 0
                    RecipientDomainIs = $AcceptedDomains.Name
                }

                if ($RuleState.SafeLinksPolicy -ne $PolicyName) {
                    $cmdParams.Add('SafeLinksPolicy', $PolicyName)
                }

                if ($RuleState.Name -eq $RuleName) {
                    try {
                        $cmdParams.Add('Identity', $RuleName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeLinksRule' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated SafeLink rule $RuleName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to update SafeLink rule $RuleName." -sev Error -LogData $_
                    }
                } else {
                    try {
                        $cmdParams.Add('Name', $RuleName)
                        New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeLinksRule' -cmdParams $cmdParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created SafeLink rule $RuleName." -sev Info
                    } catch {
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create SafeLink rule $RuleName." -sev Error -LogData $_
                    }
                }
            }
        }

        if ($Settings.alert -eq $true) {

            if ($StateIsCorrect -eq $true) {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'SafeLink Policy is enabled' -sev Info
            } else {
                Write-StandardsAlert -message 'SafeLink Policy is not enabled' -object $CurrentState -tenant $Tenant -standardName 'SafeLinksPolicy' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'SafeLink Policy is not enabled' -sev Info
            }
        }

        if ($Settings.report -eq $true) {
            Add-CIPPBPAField -FieldName 'SafeLinksPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
            if ($StateIsCorrect) {
                $FieldValue = $true
            } else {
                $FieldValue = $CurrentState
            }
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeLinksPolicy' -FieldValue $FieldValue -Tenant $Tenant
        }
    } else {
        if ($Settings.remediate -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to create SafeLink policy: Tenant does not have Microsoft Defender for Office 365 license' -sev Error
        }

        if ($Settings.alert -eq $true) {
            Write-StandardsAlert -message 'SafeLink Policy is not enabled: Tenant does not have Microsoft Defender for Office 365 license' -object $MDOLicensed -tenant $Tenant -standardName 'SafeLinksPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'SafeLink Policy is not enabled: Tenant does not have Microsoft Defender for Office 365 license' -sev Info
        }

        if ($Settings.report -eq $true) {
            Add-CIPPBPAField -FieldName 'SafeLinksPolicy' -FieldValue $false -StoreAs bool -Tenant $tenant
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeLinksPolicy' -FieldValue $false -Tenant $Tenant
        }
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSafeLinksPolicy.ps1' 213
#Region './Public/Standards/Invoke-CIPPStandardSafeLinksTemplatePolicy.ps1' -1

function Invoke-CIPPStandardSafeLinksTemplatePolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SafeLinksTemplatePolicy
    .SYNOPSIS
        (Label) SafeLinks Policy Template
    .DESCRIPTION
        (Helptext) Deploy and manage SafeLinks policy templates to protect against malicious URLs in emails and Office documents.
        (DocsDescription) Deploy and manage SafeLinks policy templates to protect against malicious URLs in emails and Office documents.
    .NOTES
        CAT
            Templates
        MULTIPLE
            False
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-04-29
        EXECUTIVETEXT
            Deploys standardized URL protection policies that automatically scan and verify links in emails and documents before users click them. This template-based approach ensures consistent protection against malicious websites and phishing attacks across the organization.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":true,"creatable":false,"name":"standards.SafeLinksTemplatePolicy.TemplateIds","label":"Select SafeLinks Policy Templates","api":{"url":"/api/ListSafeLinksPolicyTemplates","labelField":"TemplateName","valueField":"GUID","queryKey":"ListSafeLinksPolicyTemplates"}}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SafeLinksTemplatePolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Processing SafeLinks template with settings: $($Settings | ConvertTo-Json -Compress)" -sev Debug

    # Verify tenant has necessary license
    if (-not (Test-MDOLicense -Tenant $Tenant -Settings $Settings)) {
        return
    }

    # Normalize template list property
    $TemplateList = Get-NormalizedTemplateList -Settings $Settings
    if (-not $TemplateList) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "No templates selected for SafeLinks policy deployment" -sev Error
        return
    }

    # Handle different modes
    switch ($true) {
        ($Settings.remediate -eq $true) {
            Invoke-SafeLinksRemediation -Tenant $Tenant -TemplateList $TemplateList -Settings $Settings
        }
        ($Settings.alert -eq $true) {
            Invoke-SafeLinksAlert -Tenant $Tenant -TemplateList $TemplateList -Settings $Settings
        }
        ($Settings.report -eq $true) {
            Invoke-SafeLinksReport -Tenant $Tenant -TemplateList $TemplateList -Settings $Settings
        }
    }
}

function Test-MDOLicense {
    param($Tenant, $Settings)

    $ServicePlans = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscribedSkus?$select=servicePlans' -tenantid $Tenant
    $ServicePlans = $ServicePlans.servicePlans.servicePlanName
    $MDOLicensed = $ServicePlans -contains 'ATP_ENTERPRISE'

    if (-not $MDOLicensed) {
        $Message = 'Tenant does not have Microsoft Defender for Office 365 license'

        if ($Settings.remediate -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to apply SafeLinks templates: $Message" -sev Error
        }

        if ($Settings.alert -eq $true) {
            Write-StandardsAlert -message "SafeLinks templates could not be applied: $Message" -object $MDOLicensed -tenant $Tenant -standardName 'SafeLinksTemplatePolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "SafeLinks templates could not be applied: $Message" -sev Info
        }

        if ($Settings.report -eq $true) {
            Add-CIPPBPAField -FieldName 'SafeLinksTemplatePolicy' -FieldValue $false -StoreAs bool -Tenant $Tenant
            Set-CIPPStandardsCompareField -FieldName 'standards.SafeLinksTemplatePolicy' -FieldValue $false -Tenant $Tenant
        }

        return $false
    }

    return $true
}

function Get-NormalizedTemplateList {
    param($Settings)

    if ($Settings.'standards.SafeLinksTemplatePolicy.TemplateIds') {
        return $Settings.'standards.SafeLinksTemplatePolicy.TemplateIds'
    }
    elseif ($Settings.TemplateIds) {
        return $Settings.TemplateIds
    }

    return $null
}

function Get-SafeLinksTemplateFromStorage {
    param($TemplateId)

    $Table = Get-CippTable -tablename 'templates'
    $Filter = "PartitionKey eq 'SafeLinksTemplate' and RowKey eq '$TemplateId'"
    $Template = Get-CIPPAzDataTableEntity @Table -Filter $Filter

    if (-not $Template) {
        throw "Template with ID $TemplateId not found"
    }

    return $Template.JSON | ConvertFrom-Json -ErrorAction Stop
}

function ConvertTo-SafeArray {
    param($Field)

    if ($null -eq $Field) { return @() }

    $ResultList = [System.Collections.Generic.List[string]]::new()

    if ($Field -is [array]) {
        foreach ($item in $Field) {
            if ($item -is [string]) {
                $ResultList.Add($item)
            }
            elseif ($item.value) {
                $ResultList.Add($item.value)
            }
            elseif ($item.userPrincipalName) {
                $ResultList.Add($item.userPrincipalName)
            }
            elseif ($item.id) {
                $ResultList.Add($item.id)
            }
            else {
                $ResultList.Add($item.ToString())
            }
        }
        return $ResultList.ToArray()
    }

    if ($Field -is [hashtable] -or $Field -is [PSCustomObject]) {
        if ($Field.value) {
            $ResultList.Add($Field.value)
            return $ResultList.ToArray()
        }
        if ($Field.userPrincipalName) {
            $ResultList.Add($Field.userPrincipalName)
            return $ResultList.ToArray()
        }
        if ($Field.id) {
            $ResultList.Add($Field.id)
            return $ResultList.ToArray()
        }
    }

    if ($Field -is [string]) {
        $ResultList.Add($Field)
        return $ResultList.ToArray()
    }

    $ResultList.Add($Field.ToString())
    return $ResultList.ToArray()
}

function Get-ExistingSafeLinksObjects {
    param($Tenant, $PolicyName, $RuleName)

    $PolicyExists = $null
    $RuleExists = $null

    try {
        $ExistingPolicies = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksPolicy' -useSystemMailbox $true
        $PolicyExists = $ExistingPolicies | Where-Object { $_.Name -eq $PolicyName }
    }
    catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to retrieve existing policies: $($_.Exception.Message)" -sev Warning
    }

    try {
        $ExistingRules = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-SafeLinksRule' -useSystemMailbox $true
        $RuleExists = $ExistingRules | Where-Object { $_.Name -eq $RuleName }
    }
    catch {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to retrieve existing rules: $($_.Exception.Message)" -sev Warning
    }

    return @{
        PolicyExists = $PolicyExists
        RuleExists = $RuleExists
    }
}

function New-SafeLinksPolicyParameters {
    param($Template)

    $PolicyMappings = @{
        'EnableSafeLinksForEmail' = 'EnableSafeLinksForEmail'
        'EnableSafeLinksForTeams' = 'EnableSafeLinksForTeams'
        'EnableSafeLinksForOffice' = 'EnableSafeLinksForOffice'
        'TrackClicks' = 'TrackClicks'
        'AllowClickThrough' = 'AllowClickThrough'
        'ScanUrls' = 'ScanUrls'
        'EnableForInternalSenders' = 'EnableForInternalSenders'
        'DeliverMessageAfterScan' = 'DeliverMessageAfterScan'
        'DisableUrlRewrite' = 'DisableUrlRewrite'
        'AdminDisplayName' = 'AdminDisplayName'
        'CustomNotificationText' = 'CustomNotificationText'
        'EnableOrganizationBranding' = 'EnableOrganizationBranding'
    }

    $PolicyParams = @{}

    foreach ($templateKey in $PolicyMappings.Keys) {
        if ($null -ne $Template.$templateKey) {
            $PolicyParams[$PolicyMappings[$templateKey]] = $Template.$templateKey
        }
    }

    $DoNotRewriteUrls = ConvertTo-SafeArray -Field $Template.DoNotRewriteUrls
    if ($DoNotRewriteUrls.Count -gt 0) {
        $PolicyParams['DoNotRewriteUrls'] = $DoNotRewriteUrls
    }

    return $PolicyParams
}

function New-SafeLinksRuleParameters {
    param($Template)

    $RuleParams = @{}

    # Basic rule parameters
    if ($null -ne $Template.Priority) { $RuleParams['Priority'] = $Template.Priority }
    if ($null -ne $Template.Description) { $RuleParams['Comments'] = $Template.Description }
    if ($null -ne $Template.TemplateDescription) { $RuleParams['Comments'] = $Template.TemplateDescription }

    # Array-based rule parameters
    $ArrayMappings = @{
        'SentTo' = ConvertTo-SafeArray -Field $Template.SentTo
        'SentToMemberOf' = ConvertTo-SafeArray -Field $Template.SentToMemberOf
        'RecipientDomainIs' = ConvertTo-SafeArray -Field $Template.RecipientDomainIs
        'ExceptIfSentTo' = ConvertTo-SafeArray -Field $Template.ExceptIfSentTo
        'ExceptIfSentToMemberOf' = ConvertTo-SafeArray -Field $Template.ExceptIfSentToMemberOf
        'ExceptIfRecipientDomainIs' = ConvertTo-SafeArray -Field $Template.ExceptIfRecipientDomainIs
    }

    foreach ($paramName in $ArrayMappings.Keys) {
        if ($ArrayMappings[$paramName].Count -gt 0) {
            $RuleParams[$paramName] = $ArrayMappings[$paramName]
        }
    }

    return $RuleParams
}

function Set-SafeLinksRuleState {
    param($Tenant, $RuleName, $State)

    if ($null -eq $State) { return }

    $IsEnabled = switch ($State) {
        "Enabled" { $true }
        "Disabled" { $false }
        $true { $true }
        $false { $false }
        default { $null }
    }

    if ($null -ne $IsEnabled) {
        $Cmdlet = $IsEnabled ? 'Enable-SafeLinksRule' : 'Disable-SafeLinksRule'
        $null = New-ExoRequest -tenantid $Tenant -cmdlet $Cmdlet -cmdParams @{ Identity = $RuleName } -useSystemMailbox $true
        return $IsEnabled ? "enabled" : "disabled"
    }

    return $null
}

function Invoke-SafeLinksRemediation {
    param($Tenant, $TemplateList, $Settings)

    $OverallSuccess = $true
    $TemplateResults = @{}

    foreach ($TemplateItem in $TemplateList) {
        $TemplateId = $TemplateItem.value

        try {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Processing SafeLinks template with ID: $TemplateId" -sev Info

            # Get template from storage
            $Template = Get-SafeLinksTemplateFromStorage -TemplateId $TemplateId

            $PolicyName = $Template.PolicyName ?? $Template.Name
            $RuleName = $Template.RuleName ?? "$($PolicyName)_Rule"

            # Check existing objects
            $ExistingObjects = Get-ExistingSafeLinksObjects -Tenant $Tenant -PolicyName $PolicyName -RuleName $RuleName

            $ActionsTaken = [System.Collections.Generic.List[string]]::new()

            # Process Policy
            $PolicyParams = New-SafeLinksPolicyParameters -Template $Template

            if ($ExistingObjects.PolicyExists) {
                # Update existing policy to keep it in line
                $PolicyParams['Identity'] = $PolicyName
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeLinksPolicy' -cmdParams $PolicyParams -useSystemMailbox $true
                $ActionsTaken.Add("Updated SafeLinks policy '$PolicyName'")
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated SafeLinks policy '$PolicyName'" -sev Info
            }
            else {
                # Create new policy
                $PolicyParams['Name'] = $PolicyName
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeLinksPolicy' -cmdParams $PolicyParams -useSystemMailbox $true
                $ActionsTaken.Add("Created new SafeLinks policy '$PolicyName'")
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created new SafeLinks policy '$PolicyName'" -sev Info
            }

            # Process Rule
            $RuleParams = New-SafeLinksRuleParameters -Template $Template

            if ($ExistingObjects.RuleExists) {
                # Update existing rule to keep it in line
                $RuleParams['Identity'] = $RuleName
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-SafeLinksRule' -cmdParams $RuleParams -useSystemMailbox $true
                $ActionsTaken.Add("Updated SafeLinks rule '$RuleName'")
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated SafeLinks rule '$RuleName'" -sev Info
            }
            else {
                # Create new rule
                $RuleParams['Name'] = $RuleName
                $RuleParams['SafeLinksPolicy'] = $PolicyName
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-SafeLinksRule' -cmdParams $RuleParams -useSystemMailbox $true
                $ActionsTaken.Add("Created new SafeLinks rule '$RuleName'")
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created new SafeLinks rule '$RuleName'" -sev Info
            }

            # Set rule state
            $StateResult = Set-SafeLinksRuleState -Tenant $Tenant -RuleName $RuleName -State $Template.State
            if ($StateResult) {
                $ActionsTaken.Add("Rule $StateResult")
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "SafeLinks rule '$RuleName' $StateResult" -sev Info
            }

            $TemplateResults[$TemplateId] = @{
                Success = $true
                ActionsTaken = $ActionsTaken.ToArray()
                TemplateName = $Template.TemplateName ?? $Template.Name
                PolicyName = $PolicyName
                RuleName = $RuleName
            }

            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully applied SafeLinks template '$($Template.TemplateName ?? $Template.Name)'" -sev Info
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $TemplateResults[$TemplateId] = @{
                Success = $false
                Message = $ErrorMessage
                TemplateName = $Template.TemplateName ?? $Template.Name ?? "Unknown"
            }
            $OverallSuccess = $false

            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to apply SafeLinks template ID $TemplateId : $ErrorMessage" -sev Error
        }
    }

    # Report overall results
    if ($OverallSuccess) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully applied all SafeLinks templates" -sev Info
    }
    else {
        $SuccessCount = ($TemplateResults.Values | Where-Object { $_.Success -eq $true }).Count
        $TotalCount = $TemplateList.Count
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Applied $SuccessCount out of $TotalCount SafeLinks templates" -sev Info
    }
}

function Invoke-SafeLinksAlert {
    param($Tenant, $TemplateList, $Settings)

    $AllTemplatesApplied = $true
    $AlertMessages = [System.Collections.Generic.List[string]]::new()

    foreach ($TemplateItem in $TemplateList) {
        $TemplateId = $TemplateItem.value

        try {
            $Template = Get-SafeLinksTemplateFromStorage -TemplateId $TemplateId
            $PolicyName = $Template.PolicyName ?? $Template.Name
            $RuleName = $Template.RuleName ?? "$($PolicyName)_Rule"

            $ExistingObjects = Get-ExistingSafeLinksObjects -Tenant $Tenant -PolicyName $PolicyName -RuleName $RuleName

            if (-not $ExistingObjects.PolicyExists -or -not $ExistingObjects.RuleExists) {
                $AllTemplatesApplied = $false
                $Status = "SafeLinks template '$($Template.TemplateName ?? $Template.Name)' is not applied"

                if (-not $ExistingObjects.PolicyExists) {
                    $Status = "$Status - policy '$PolicyName' does not exist"
                }

                if (-not $ExistingObjects.RuleExists) {
                    $Status = "$Status - rule '$RuleName' does not exist"
                }

                $AlertMessages.Add($Status)
            }
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $AlertMessages.Add("Failed to check template with ID $TemplateId : $ErrorMessage")
            $AllTemplatesApplied = $false
        }
    }

    if ($AllTemplatesApplied) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "All SafeLinks templates are correctly applied" -sev Info
    }
    else {
        $AlertMessage = "One or more SafeLinks templates are not correctly applied: " + ($AlertMessages.ToArray() -join " | ")
        Write-StandardsAlert -message $AlertMessage -object @{
            Templates = $TemplateList
            Issues = $AlertMessages.ToArray()
        } -tenant $Tenant -standardName 'SafeLinksTemplatePolicy' -standardId $Settings.standardId

        Write-LogMessage -API 'Standards' -tenant $Tenant -message $AlertMessage -sev Info
    }
}

function Invoke-SafeLinksReport {
    param($Tenant, $TemplateList, $Settings)

    $AllTemplatesApplied = $true
    $ReportResults = @{}

    foreach ($TemplateItem in $TemplateList) {
        $TemplateId = $TemplateItem.value

        try {
            $Template = Get-SafeLinksTemplateFromStorage -TemplateId $TemplateId
            $PolicyName = $Template.PolicyName ?? $Template.Name
            $RuleName = $Template.RuleName ?? "$($PolicyName)_Rule"

            $ExistingObjects = Get-ExistingSafeLinksObjects -Tenant $Tenant -PolicyName $PolicyName -RuleName $RuleName

            $ReportResults[$TemplateId] = @{
                Success = ($ExistingObjects.PolicyExists -and $ExistingObjects.RuleExists)
                TemplateName = $Template.TemplateName ?? $Template.Name
                PolicyName = $PolicyName
                RuleName = $RuleName
                PolicyExists = [bool]$ExistingObjects.PolicyExists
                RuleExists = [bool]$ExistingObjects.RuleExists
            }

            if (-not $ExistingObjects.PolicyExists -or -not $ExistingObjects.RuleExists) {
                $AllTemplatesApplied = $false
            }
        }
        catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            $ReportResults[$TemplateId] = @{
                Success = $false
                Message = $ErrorMessage
            }
            $AllTemplatesApplied = $false
        }
    }

    Add-CIPPBPAField -FieldName 'SafeLinksTemplatePolicy' -FieldValue $AllTemplatesApplied -StoreAs bool -Tenant $Tenant

    if ($AllTemplatesApplied) {
        Set-CIPPStandardsCompareField -FieldName 'standards.SafeLinksTemplatePolicy' -FieldValue $true -Tenant $Tenant
    }
    else {
        Set-CIPPStandardsCompareField -FieldName 'standards.SafeLinksTemplatePolicy' -FieldValue @{
            TemplateResults = $ReportResults
            ProcessedTemplates = $TemplateList.Count
            SuccessfulTemplates = ($ReportResults.Values | Where-Object { $_.Success -eq $true }).Count
        } -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSafeLinksTemplatePolicy.ps1' 496
#Region './Public/Standards/Invoke-CIPPStandardSafeSendersDisable.ps1' -1

function Invoke-CIPPStandardSafeSendersDisable {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SafeSendersDisable
    .SYNOPSIS
        (Label) Remove Safe Senders to prevent SPF bypass
    .DESCRIPTION
        (Helptext) Loops through all users and removes the Safe Senders list. This is to prevent SPF bypass attacks, as the Safe Senders list is not checked by SPF.
        (DocsDescription) Loops through all users and removes the Safe Senders list. This is to prevent SPF bypass attacks, as the Safe Senders list is not checked by SPF.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Removes user-defined safe sender lists to prevent security bypasses where malicious emails could avoid spam filtering. This ensures all emails go through proper security screening, even if users have previously marked senders as 'safe', improving overall email security.
        ADDEDCOMPONENT
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-10-26
        POWERSHELLEQUIVALENT
            Set-MailboxJunkEmailConfiguration
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SafeSendersDisable' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    if ($Settings.remediate -eq $true) {
        try {
            $Mailboxes = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-Mailbox' -select 'UserPrincipalName'
            $Request = $Mailboxes | ForEach-Object {
                @{
                    CmdletInput = @{
                        CmdletName = 'Set-MailboxJunkEmailConfiguration'
                        Parameters = @{
                            Identity                    = $_.UserPrincipalName
                            TrustedRecipientsAndDomains = $null
                        }
                    }
                }
            }

            $BatchResults = New-ExoBulkRequest -tenantid $tenant -cmdletArray @($Request)
            $BatchResults | ForEach-Object {
                if ($_.error) {
                    $ErrorMessage = Get-NormalizedError -Message $_.error
                    Write-Host "Failed to Disable SafeSenders for $($_.target). Error: $ErrorMessage"
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to Disable SafeSenders for $($_.target). Error: $ErrorMessage" -sev Error
                }
            }
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Safe Senders disabled' -sev Info
        } catch {
            $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
            Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to disable SafeSenders. Error: $ErrorMessage" -sev Error
        }
    }

    if ($Settings.report -eq $true) {
        #This script always returns true, as it only disables the Safe Senders list
        Set-CIPPStandardsCompareField -FieldName 'standards.SafeSendersDisable' -FieldValue $true -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardSafeSendersDisable.ps1' 79
#Region './Public/Standards/Invoke-CIPPStandardSecureScoreRemediation.ps1' -1

function Invoke-CIPPStandardSecureScoreRemediation {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SecureScoreRemediation
    .SYNOPSIS
        (Label) Update Secure Score Control Profiles
    .DESCRIPTION
        (Helptext) Allows bulk updating of Secure Score control profiles across tenants. Select controls and assign them to different states: Default, Ignored, Third-Party, or Reviewed.
        (DocsDescription) Enables automated or template-based updates to Microsoft Secure Score recommendations. This is particularly useful for MSPs managing multiple tenants, allowing you to mark controls as "Third-party" (e.g., when using Mimecast, IronScales, or other third-party security tools) or set them to other states in bulk. This ensures Secure Scores accurately reflect each tenant's true security posture without repetitive manual updates.
    .NOTES
        CAT
            Global Standards
        TAG
            "lowimpact"
        EXECUTIVETEXT
            Automates the management of Secure Score control profiles by allowing bulk updates across tenants. This ensures accurate representation of security posture when using third-party security tools or when certain controls need to be marked as resolved or ignored, significantly reducing manual administrative overhead for MSPs managing multiple clients.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":true,"creatable":true,"name":"standards.SecureScoreRemediation.Default","label":"Controls to set to Default"}
            {"type":"autoComplete","multiple":true,"creatable":true,"name":"standards.SecureScoreRemediation.Ignored","label":"Controls to set to Ignored"}
            {"type":"autoComplete","multiple":true,"creatable":true,"name":"standards.SecureScoreRemediation.ThirdParty","label":"Controls to set to Third-Party"}
            {"type":"autoComplete","multiple":true,"creatable":true,"name":"standards.SecureScoreRemediation.Reviewed","label":"Controls to set to Reviewed"}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-11-19
        POWERSHELLEQUIVALENT
            New-GraphPostRequest to /beta/security/secureScoreControlProfiles/{id}
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)


    # Get current secure score controls
    try {
        $CurrentControls = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/security/secureScoreControlProfiles' -tenantid $Tenant
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not retrieve Secure Score controls for $Tenant. Error: $ErrorMessage" -sev Error
        return
    }

    # Build list of controls with their desired states
    $ControlsToUpdate = [System.Collections.Generic.List[object]]::new()

    # Process Default controls
    $DefaultControls = $Settings.Default.value ?? $Settings.Default
    if ($DefaultControls) {
        foreach ($ControlName in $DefaultControls) {
            $ControlsToUpdate.Add(@{
                    ControlName = $ControlName
                    State       = 'default'
                    Reason      = 'Default'
                })
        }
    }

    # Process Ignored controls
    $IgnoredControls = $Settings.Ignored.value ?? $Settings.Ignored
    if ($IgnoredControls) {
        foreach ($ControlName in $IgnoredControls) {
            $ControlsToUpdate.Add(@{
                    ControlName = $ControlName
                    State       = 'ignored'
                    Reason      = 'Ignored'
                })
        }
    }

    # Process ThirdParty controls
    $ThirdPartyControls = $Settings.ThirdParty.value ?? $Settings.ThirdParty
    if ($ThirdPartyControls) {
        foreach ($ControlName in $ThirdPartyControls) {
            $ControlsToUpdate.Add(@{
                    ControlName = $ControlName
                    State       = 'thirdParty'
                    Reason      = 'ThirdParty'
                })
        }
    }

    # Process Reviewed controls
    $ReviewedControls = $Settings.Reviewed.value ?? $Settings.Reviewed
    if ($ReviewedControls) {
        foreach ($ControlName in $ReviewedControls) {
            $ControlsToUpdate.Add(@{
                    ControlName = $ControlName
                    State       = 'reviewed'
                    Reason      = 'Reviewed'
                })
        }
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Processing Secure Score control updates'

        foreach ($Control in $ControlsToUpdate) {
            # Skip if this is a Defender control (starts with scid_)
            if ($Control.ControlName -match '^scid_') {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Skipping Defender control $($Control.ControlName) - cannot be updated via this API" -sev Info
                continue
            }

            # Build the request body
            $Body = @{
                state             = $Control.State
                comment           = $Control.Reason
                vendorInformation = @{
                    vendor   = 'Microsoft'
                    provider = 'SecureScore'
                }
            }

            try {
                $CurrentControl = $CurrentControls | Where-Object { $_.id -eq $Control.ControlName }

                # Check if already in desired state
                if ($CurrentControl.state -eq $Control.State) {
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Control $($Control.ControlName) is already in state $($Control.State)" -sev Info
                } else {
                    # Update the control
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/security/secureScoreControlProfiles/$($Control.ControlName)" -tenantid $Tenant -type PATCH -Body (ConvertTo-Json -InputObject $Body -Compress)
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set control $($Control.ControlName) to $($Control.State)" -sev Info
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set control $($Control.ControlName) to $($Control.State). Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        $AlertMessages = [System.Collections.Generic.List[string]]::new()

        foreach ($Control in $ControlsToUpdate) {
            if ($Control.ControlName -match '^scid_') {
                continue
            }

            $CurrentControl = $CurrentControls | Where-Object { $_.id -eq $Control.ControlName }

            if ($CurrentControl) {
                if ($CurrentControl.state -eq $Control.State) {
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Control $($Control.ControlName) is in expected state: $($Control.State)" -sev Info
                } else {
                    $AlertMessage = "Control $($Control.ControlName) is in state $($CurrentControl.state), expected $($Control.State)"
                    $AlertMessages.Add($AlertMessage)
                    Write-LogMessage -API 'Standards' -tenant $tenant -message $AlertMessage -sev Alert
                }
            } else {
                $AlertMessage = "Control $($Control.ControlName) not found in tenant"
                $AlertMessages.Add($AlertMessage)
                Write-LogMessage -API 'Standards' -tenant $tenant -message $AlertMessage -sev Warning
            }
        }

        if ($AlertMessages.Count -gt 0) {
            Write-StandardsAlert -message 'Secure Score controls not in expected state' -object @{Issues = $AlertMessages.ToArray() } -tenant $Tenant -standardName 'SecureScoreRemediation' -standardId $Settings.standardId
        }
    }

    if ($Settings.report -eq $true) {
        $ReportData = [System.Collections.Generic.List[object]]::new()

        foreach ($Control in $ControlsToUpdate) {
            if ($Control.ControlName -match '^scid_') {
                continue
            }

            $CurrentControl = $CurrentControls | Where-Object { $_.id -eq $Control.ControlName }
            $LatestState = ($CurrentControl.controlStateUpdates | Select-Object -Last 1).state
            if ($LatestState -ne $Control.State) {
                $ReportData.Add(@{
                        ControlName  = $Control.ControlName
                        CurrentState = $LatestState
                        DesiredState = $Control.State
                        InCompliance = $false
                    })
            }
        }
        if ($ReportData.count -eq 0) {
            $ReportData = $true
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.SecureScoreRemediation' -FieldValue $ReportData -Tenant $tenant
        Add-CIPPBPAField -FieldName 'SecureScoreRemediation' -FieldValue $ReportData -StoreAs json -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSecureScoreRemediation.ps1' 195
#Region './Public/Standards/Invoke-CIPPStandardSecurityDefaults.ps1' -1

function Invoke-CIPPStandardSecurityDefaults {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SecurityDefaults
    .SYNOPSIS
        (Label) Enable Security Defaults
    .DESCRIPTION
        (Helptext) Enables security defaults for the tenant, for newer tenants this is enabled by default. Do not enable this feature if you use Conditional Access.
        (DocsDescription) Enables SD for the tenant, which disables all forms of basic authentication and enforces users to configure MFA. Users are only prompted for MFA when a logon is considered 'suspect' by Microsoft.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "CISA (MS.AAD.11.1v1)"
        EXECUTIVETEXT
            Activates Microsoft's baseline security configuration that requires multi-factor authentication and blocks legacy authentication methods. This provides essential security protection for organizations without complex conditional access policies, significantly improving security posture with minimal configuration.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2021-11-19
        POWERSHELLEQUIVALENT
            [Read more here](https://www.cyberdrain.com/automating-with-powershell-enabling-secure-defaults-and-sd-explained/)
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    try {
        $SecureDefaultsState = (New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -tenantid $tenant)
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Security Defaults state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        if ($SecureDefaultsState.IsEnabled -ne $true) {
            try {
                Write-Host "Secure Defaults is disabled. Enabling for $tenant" -ForegroundColor Yellow
                $body = '{ "isEnabled": true }'
                $null = New-GraphPostRequest -tenantid $tenant -Uri 'https://graph.microsoft.com/beta/policies/identitySecurityDefaultsEnforcementPolicy' -Type patch -Body $body -ContentType 'application/json'

                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Enabled Security Defaults.' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable Security Defaults. Error: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Security Defaults is already enabled.' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($SecureDefaultsState.IsEnabled -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Security Defaults is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Security Defaults is not enabled' -object ($SecureDefaultsState | Select-Object displayName, isEnabled, description) -tenant $tenant -standardName 'SecurityDefaults' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Security Defaults is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SecurityDefaults' -FieldValue $SecureDefaultsState.IsEnabled -StoreAs bool -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.SecurityDefaults' -FieldValue $SecureDefaultsState.IsEnabled -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSecurityDefaults.ps1' 76
#Region './Public/Standards/Invoke-CIPPStandardSendFromAlias.ps1' -1

function Invoke-CIPPStandardSendFromAlias {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SendFromAlias
    .SYNOPSIS
        (Label) Allow users to send from their alias addresses
    .DESCRIPTION
        (Helptext) Enables the ability for users to send from their alias addresses.
        (DocsDescription) Allows users to change the 'from' address to any set in their Azure AD Profile.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Allows employees to send emails from their alternative email addresses (aliases) rather than just their primary address. This is useful for employees who manage multiple roles or departments, enabling them to send emails from the most appropriate address for the context.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2022-05-25
        POWERSHELLEQUIVALENT
            Set-Mailbox
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SendFromAlias' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').SendFromAliasEnabled
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SendFromAlias state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($CurrentInfo -ne $true) {
            try {
                New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ SendFromAliasEnabled = $true }
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Send from alias enabled.' -sev Info
                $CurrentInfo = $true
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to enable send from alias. Error: $ErrorMessage" -sev Error
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Send from alias is already enabled.' -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Send from alias is enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Send from alias is not enabled' -object $CurrentInfo -tenant $tenant -standardName 'SendFromAlias' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Send from alias is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SendFromAlias' -FieldValue $CurrentInfo -StoreAs bool -Tenant $tenant
        Set-CIPPStandardsCompareField -FieldName 'standards.SendFromAlias' -FieldValue $CurrentInfo -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSendFromAlias.ps1' 79
#Region './Public/Standards/Invoke-CIPPStandardSendReceiveLimitTenant.ps1' -1

function Invoke-CIPPStandardSendReceiveLimitTenant {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SendReceiveLimitTenant
    .SYNOPSIS
        (Label) Set send/receive size limits
    .DESCRIPTION
        (Helptext) Sets the Send and Receive limits for new users. Valid values are 1MB to 150MB
        (DocsDescription) Sets the Send and Receive limits for new users. Valid values are 1MB to 150MB
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Establishes standard email attachment size limits for all new employees, balancing functionality with system performance and security. This prevents email system overload from large attachments while ensuring employees can share necessary files through appropriate channels.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.SendReceiveLimitTenant.SendLimit","label":"Send limit in MB (Default is 35)","defaultValue":35}
            {"type":"number","name":"standards.SendReceiveLimitTenant.ReceiveLimit","label":"Receive Limit in MB (Default is 36)","defaultValue":36}
        IMPACT
            Low Impact
        ADDEDDATE
            2023-11-16
        POWERSHELLEQUIVALENT
            Set-MailboxPlan
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SendReceiveLimitTenant' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Input validation
    if ([Int32]$Settings.SendLimit -lt 1 -or [Int32]$Settings.SendLimit -gt 150) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'SendReceiveLimitTenant: Invalid SendLimit parameter set' -sev Error
        return
    }

    # Input validation
    if ([Int32]$Settings.ReceiveLimit -lt 1 -or [Int32]$Settings.ReceiveLimit -gt 150) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'SendReceiveLimitTenant: Invalid ReceiveLimit parameter set' -sev Error
        return
    }

    try {
        $AllMailBoxPlans = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-MailboxPlan' |
            Select-Object DisplayName, MaxSendSize, MaxReceiveSize, GUID
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SendReceiveLimitTenant state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    $MaxSendSize = [int64]"$($Settings.SendLimit)MB"
    $MaxReceiveSize = [int64]"$($Settings.ReceiveLimit)MB"

    $NotSetCorrectly = foreach ($MailboxPlan in $AllMailBoxPlans) {
        # Handle "Unlimited" values - treat them as not matching the desired limit.
        if ($MailboxPlan.MaxSendSize -match 'Unlimited' -or $MailboxPlan.MaxReceiveSize -match 'Unlimited') {
            $MailboxPlan
            continue
        }

        $PlanMaxSendSize = [int64]($MailboxPlan.MaxSendSize -replace '.*\(([\d,]+).*', '$1' -replace ',', '')
        $PlanMaxReceiveSize = [int64]($MailboxPlan.MaxReceiveSize -replace '.*\(([\d,]+).*', '$1' -replace ',', '')
        if ($PlanMaxSendSize -ne $MaxSendSize -or $PlanMaxReceiveSize -ne $MaxReceiveSize) {
            $MailboxPlan
        }
    }

    if ($Settings.remediate -eq $true) {
        Write-Host "Time to remediate. Our Settings are $($Settings.SendLimit)MB and $($Settings.ReceiveLimit)MB"

        if ($NotSetCorrectly.Count -gt 0) {
            Write-Host "Found $($NotSetCorrectly.Count) Mailbox Plans that are not set correctly. Setting them to $($Settings.SendLimit)MB and $($Settings.ReceiveLimit)MB"
            try {
                foreach ($MailboxPlan in $NotSetCorrectly) {
                    New-ExoRequest -tenantid $Tenant -cmdlet 'Set-MailboxPlan' -cmdParams @{Identity = $MailboxPlan.GUID; MaxSendSize = $MaxSendSize; MaxReceiveSize = $MaxReceiveSize } -useSystemMailbox $true
                }
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set the tenant send($($Settings.SendLimit)MB) and receive($($Settings.ReceiveLimit)MB) limits" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set the tenant send and receive limits. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The tenant send($($Settings.SendLimit)MB) and receive($($Settings.ReceiveLimit)MB) limits are already set correctly" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {

        if ($NotSetCorrectly.Count -eq 0) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The tenant send($($Settings.SendLimit)MB) and receive($($Settings.ReceiveLimit)MB) limits are set correctly" -sev Info
        } else {
            Write-StandardsAlert -message "The tenant send($($Settings.SendLimit)MB) and receive($($Settings.ReceiveLimit)MB) limits are not set correctly" -object $NotSetCorrectly -tenant $tenant -standardName 'SendReceiveLimitTenant' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The tenant send($($Settings.SendLimit)MB) and receive($($Settings.ReceiveLimit)MB) limits are not set correctly" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SendReceiveLimit' -FieldValue $NotSetCorrectly -StoreAs json -Tenant $tenant

        if ($NotSetCorrectly.Count -eq 0) {
            $FieldValue = $true
        } else {
            $FieldValue = $NotSetCorrectly
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SendReceiveLimitTenant' -FieldValue $FieldValue -Tenant $tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSendReceiveLimitTenant.ps1' 120
#Region './Public/Standards/Invoke-CIPPStandardSharePointMassDeletionAlert.ps1' -1

function Invoke-CIPPStandardSharePointMassDeletionAlert {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SharePointMassDeletionAlert
    .SYNOPSIS
        (Label) SharePoint Mass Deletion Alert
    .DESCRIPTION
        (Helptext) Sets a e-mail address to alert when a User deletes more than 20 SharePoint files within 60 minutes. NB: Requires a Office 365 E5 subscription, Office 365 E3 with Threat Intelligence or Office 365 EquivioAnalytics add-on.
        (DocsDescription) Sets a e-mail address to alert when a User deletes more than 20 SharePoint files within 60 minutes. This is useful for monitoring and ensuring that the correct SharePoint files are deleted. NB: Requires a Office 365 E5 subscription, Office 365 E3 with Threat Intelligence or Office 365 EquivioAnalytics add-on.
    .NOTES
        CAT
            Defender Standards
        TAG
        EXECUTIVETEXT
            Alerts administrators when employees delete large numbers of SharePoint files in a short time period, helping detect potential data destruction attacks, ransomware, or accidental mass deletions. This early warning system enables rapid response to protect critical business documents and data.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.SharePointMassDeletionAlert.Threshold","label":"Max files to delete within the time frame","defaultValue":20}
            {"type":"number","name":"standards.SharePointMassDeletionAlert.TimeWindow","label":"Time frame in minutes","defaultValue":60}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":true,"name":"standards.SharePointMassDeletionAlert.NotifyUser","label":"E-mail to receive the alert"}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-04-07
        POWERSHELLEQUIVALENT
            New-ProtectionAlert and Set-ProtectionAlert
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param ($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'DeletedUserRentention' -TenantFilter $Tenant -RequiredCapabilities @('RMS_S_PREMIUM2')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    $PolicyName = 'CIPP SharePoint mass deletion of files by a user'

    try {
        $CurrentState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-ProtectionAlert' -Compliance |
        Where-Object { $_.Name -eq $PolicyName } |
        Select-Object -Property *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the sharingCapability state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $EmailsOutsideSettings = $CurrentState.NotifyUser | Where-Object { $_ -notin $Settings.NotifyUser.value }
    $MissingEmailsInSettings = $Settings.NotifyUser.value | Where-Object { $_ -notin $CurrentState.NotifyUser }

    $StateIsCorrect = ($EmailsOutsideSettings.Count -eq 0) -and
    ($MissingEmailsInSettings.Count -eq 0) -and
    ($CurrentState.Threshold -eq $Settings.Threshold) -and
    ($CurrentState.TimeWindow -eq $Settings.TimeWindow)

    $CompareField = [PSCustomObject]@{
        'Threshold'  = $CurrentState.Threshold
        'TimeWindow' = $CurrentState.TimeWindow
        'NotifyUser' = $CurrentState.NotifyUser -join ', '
    }

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint mass deletion of files alert is configured correctly' -sev Info
        } else {
            $cmdParams = @{
                'NotifyUser'      = $Settings.NotifyUser.value
                'Category'        = 'DataGovernance'
                'Operation'       = 'FileDeleted'
                'Severity'        = 'High'
                'AggregationType' = '1'
                'Threshold'       = $Settings.Threshold
                'TimeWindow'      = $Settings.TimeWindow
            }

            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams['Identity'] = $PolicyName
                    New-ExoRequest -TenantId $Tenant -cmdlet 'Set-ProtectionAlert' -Compliance -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully configured SharePoint mass deletion of files alert' -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to configure SharePoint mass deletion of files alert. Error: $ErrorMessage" -sev Error
                }
            } else {
                try {
                    $cmdParams['name'] = $PolicyName
                    $cmdParams['ThreatType'] = 'Activity'

                    New-ExoRequest -TenantId $Tenant -cmdlet 'New-ProtectionAlert' -Compliance -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully created SharePoint mass deletion of files alert' -sev Info
                } catch {
                    $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to create SharePoint mass deletion of files alert. Error: $ErrorMessage" -sev Error
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint mass deletion of files alert is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'SharePoint mass deletion of files alert is disabled' -object $CompareField -tenant $tenant -standardName 'SharePointMassDeletionAlert' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint mass deletion of files alert is disabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $FieldValue = $StateIsCorrect ? $true : $CompareField
        Set-CIPPStandardsCompareField -FieldName 'standards.SharePointMassDeletionAlert' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'SharePointMassDeletionAlert' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSharePointMassDeletionAlert.ps1' 123
#Region './Public/Standards/Invoke-CIPPStandardsharingCapability.ps1' -1

function Invoke-CIPPStandardsharingCapability {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) sharingCapability
    .SYNOPSIS
        (Label) Set Sharing Level for OneDrive and SharePoint
    .DESCRIPTION
        (Helptext) Sets the default sharing level for OneDrive and SharePoint. This is a tenant wide setting and overrules any settings set on the site level
        (DocsDescription) Sets the default sharing level for OneDrive and SharePoint. This is a tenant wide setting and overrules any settings set on the site level
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.3)"
            "CISA (MS.AAD.14.1v1)"
            "CISA (MS.SPO.1.1v1)"
        EXECUTIVETEXT
            Defines the organization's default policy for sharing files and folders in SharePoint and OneDrive, balancing collaboration needs with security requirements. This fundamental setting determines whether employees can share with external users, anonymous links, or only internal colleagues.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select Sharing Level","name":"standards.sharingCapability.Level","options":[{"label":"Users can share only with people in the organization. No external sharing is allowed.","value":"disabled"},{"label":"Users can share with new and existing guests. Guests must sign in or provide a verification code.","value":"externalUserSharingOnly"},{"label":"Users can share with anyone by using links that do not require sign-in.","value":"externalUserAndGuestSharing"},{"label":"Users can share with existing guests (those already in the directory of the organization).","value":"existingExternalUserSharingOnly"}]}
        IMPACT
            High Impact
        ADDEDDATE
            2022-06-15
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminSharePointSetting
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'sharingCapability' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the sharingCapability state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'sharingCapability' -FieldValue $CurrentInfo.sharingCapability -StoreAs string -Tenant $Tenant
    }

    # Get level value using null-coalescing operator
    $level = $Settings.Level.value ?? $Settings.Level

    # Input validation
    if (([string]::IsNullOrWhiteSpace($level) -or $level -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'sharingCapability: Invalid sharingCapability parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {

        if ($CurrentInfo.sharingCapability -eq $level) {
            Write-Host "Sharing level is already set to $level"
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sharing level is already set to $level" -sev Info
        } else {
            Write-Host "Setting sharing level to $level from $($CurrentInfo.sharingCapability)"
            try {
                $body = @{
                    sharingCapability = $level
                }
                $bodyJson = ConvertTo-Json -InputObject $body -Compress
                $null = New-GraphPostRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type patch -Body $bodyJson -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Set sharing level to $level from $($CurrentInfo.sharingCapability)" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set sharing level to $level : $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.sharingCapability -eq $level) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sharing level is set to $level" -sev Info
        } else {
            Write-StandardsAlert -message "Sharing level is not set to $level" -object $CurrentInfo -tenant $Tenant -standardName 'sharingCapability' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sharing level is not set to $level" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($CurrentInfo.sharingCapability -eq $level) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentInfo | Select-Object -Property sharingCapability
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.sharingCapability' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardsharingCapability.ps1' 107
#Region './Public/Standards/Invoke-CIPPStandardsharingDomainRestriction.ps1' -1

function Invoke-CIPPStandardsharingDomainRestriction {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) sharingDomainRestriction
    .SYNOPSIS
        (Label) Restrict sharing to a specific domain
    .DESCRIPTION
        (Helptext) Restricts sharing to only users with the specified domain. This is useful for organizations that only want to share with their own domain.
        (DocsDescription) Restricts sharing to only users with the specified domain. This is useful for organizations that only want to share with their own domain.
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.6)"
            "CISA (MS.AAD.14.3v1)"
            "CISA (MS.SPO.1.3v1)"
        EXECUTIVETEXT
            Controls which external domains employees can share files with, enabling secure collaboration with trusted partners while blocking sharing with unauthorized organizations. This targeted approach maintains necessary business relationships while preventing data exposure to unknown entities.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"name":"standards.sharingDomainRestriction.Mode","label":"Limit external sharing by domains","options":[{"label":"Off","value":"none"},{"label":"Restrict sharing to specific domains","value":"allowList"},{"label":"Block sharing to specific domains","value":"blockList"}]}
            {"type":"textField","name":"standards.sharingDomainRestriction.Domains","label":"Domains to allow/block, comma separated","required":false}
        IMPACT
            High Impact
        ADDEDDATE
            2024-06-20
        POWERSHELLEQUIVALENT
            Update-MgAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'sharingDomainRestriction' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SharingDomainRestriction state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Get mode value using null-coalescing operator
    $mode = $Settings.Mode.value ?? $Settings.Mode

    if ($mode -eq 'none' -or $null -eq $mode) {
        $StateIsCorrect = $CurrentState.sharingDomainRestrictionMode -eq 'none'
    } else {
        $SelectedDomains = [String[]]$Settings.Domains.Split(',').Trim() ?? @()
        $CurrentAllowedDomains = $CurrentState.sharingAllowedDomainList ?? @()
        $CurrentBlockedDomains = $CurrentState.sharingBlockedDomainList ?? @()

        $StateIsCorrect = ($CurrentState.sharingDomainRestrictionMode -eq $mode) -and (
            ($mode -eq 'allowList' -and ([string[]]($CurrentAllowedDomains | Sort-Object) -join ',') -eq ([string[]]($SelectedDomains | Sort-Object) -join ',')) -or
            ($mode -eq 'blockList' -and ([string[]]($CurrentBlockedDomains | Sort-Object) -join ',') -eq ([string[]]($SelectedDomains | Sort-Object) -join ','))
        )
    }
    Write-Host "StateIsCorrect: $StateIsCorrect"

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Sharing Domain Restriction is already correctly configured' -sev Info
        } else {
            $Body = @{
                sharingDomainRestrictionMode = $mode
            }

            if ($mode -eq 'AllowList') {
                $Body.Add('sharingAllowedDomainList', $SelectedDomains)
            } elseif ($mode -eq 'BlockList') {
                $Body.Add('sharingBlockedDomainList', $SelectedDomains)
            }

            $cmdParams = @{
                tenantid = $tenant
                uri      = 'https://graph.microsoft.com/beta/admin/sharepoint/settings'
                AsApp    = $true
                Type     = 'PATCH'
                body     = ($Body | ConvertTo-Json)
            }

            Write-Host ($cmdParams | ConvertTo-Json -Depth 5)

            try {
                $null = New-GraphPostRequest @cmdParams
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Successfully updated Sharing Domain Restriction settings' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to update Sharing Domain Restriction settings. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Sharing Domain Restriction is correctly configured' -sev Info
        } else {
            Write-StandardsAlert -message 'Sharing Domain Restriction is not correctly configured' -object $CurrentState -tenant $tenant -standardName 'sharingDomainRestriction' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message 'Sharing Domain Restriction is not correctly configured' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'sharingDomainRestriction' -FieldValue [bool]$StateIsCorrect -StoreAs bool -Tenant $tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object sharingAllowedDomainList, sharingDomainRestrictionMode
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.sharingDomainRestriction' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardsharingDomainRestriction.ps1' 125
#Region './Public/Standards/Invoke-CIPPStandardShortenMeetings.ps1' -1

function Invoke-CIPPStandardShortenMeetings {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) ShortenMeetings
    .SYNOPSIS
        (Label) Set shorten meetings state
    .DESCRIPTION
        (Helptext) Sets the shorten meetings settings on a tenant level. This will shorten meetings by the selected amount of minutes. Valid values are 0 to 29. Short meetings are under 60 minutes, long meetings are over 60 minutes.
        (DocsDescription) Sets the shorten meetings settings on a tenant level. This will shorten meetings by the selected amount of minutes. Valid values are 0 to 29. Short meetings are under 60 minutes, long meetings are over 60 minutes.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Automatically shortens calendar meetings by a specified number of minutes to provide buffer time between meetings, reducing back-to-back scheduling stress and allowing employees time to transition between meetings. This improves work-life balance and meeting effectiveness.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.ShortenMeetings.ShortenEventScopeDefault","options":[{"label":"Disabled/None","value":"None"},{"label":"End early","value":"EndEarly"},{"label":"Start late","value":"StartLate"}]}
            {"type":"number","name":"standards.ShortenMeetings.DefaultMinutesToReduceShortEventsBy","label":"Minutes to reduce short calendar events by (Default is 5)","defaultValue":5}
            {"type":"number","name":"standards.ShortenMeetings.DefaultMinutesToReduceLongEventsBy","label":"Minutes to reduce long calendar events by (Default is 10)","defaultValue":10}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-05-27
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -ShortenEventScopeDefault -DefaultMinutesToReduceShortEventsBy -DefaultMinutesToReduceLongEventsBy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'ShortenMeetings' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    Write-Host "ShortenMeetings: $($Settings | ConvertTo-Json -Compress)"
    # Get state value using null-coalescing operator
    $scopeDefault = $Settings.ShortenEventScopeDefault.value ? $Settings.ShortenEventScopeDefault.value : $Settings.ShortenEventScopeDefault

    try {
        $CurrentState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig' |
        Select-Object -Property ShortenEventScopeDefault, DefaultMinutesToReduceShortEventsBy, DefaultMinutesToReduceLongEventsBy
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the ShortenMeetings state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $CorrectState = if ($CurrentState.ShortenEventScopeDefault -eq $scopeDefault -and
        $CurrentState.DefaultMinutesToReduceShortEventsBy -eq $Settings.DefaultMinutesToReduceShortEventsBy -and
        $CurrentState.DefaultMinutesToReduceLongEventsBy -eq $Settings.DefaultMinutesToReduceLongEventsBy) { $true } else { $false }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($CorrectState -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Shorten meetings settings are already in the correct state. ' -sev Info
        } else {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ShortenEventScopeDefault = $scopeDefault ; DefaultMinutesToReduceShortEventsBy = $Settings.DefaultMinutesToReduceShortEventsBy; DefaultMinutesToReduceLongEventsBy = $Settings.DefaultMinutesToReduceLongEventsBy }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Shorten meetings settings have been set to the following state. State: $($scopeDefault), Short:$($Settings.DefaultMinutesToReduceShortEventsBy), Long: $($Settings.DefaultMinutesToReduceLongEventsBy)" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set shorten meetings settings. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($CorrectState -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Shorten meetings settings are already in the correct state. Current state: $($CurrentState.ShortenEventScopeDefault), Short:$($CurrentState.DefaultMinutesToReduceShortEventsBy), Long: $($CurrentState.DefaultMinutesToReduceLongEventsBy)" -sev Info
        } else {
            Write-StandardsAlert -message 'Shorten meetings settings are not in the correct state.' -object $CurrentState -tenant $Tenant -standardName 'ShortenMeetings' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Shorten meetings settings are not in the correct state. Current state: $($CurrentState.ShortenEventScopeDefault), Short:$($CurrentState.DefaultMinutesToReduceShortEventsBy), Long: $($CurrentState.DefaultMinutesToReduceLongEventsBy)" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        $BPAField = @{
            FieldName  = 'ShortenMeetings'
            FieldValue = $CorrectState
            Tenant     = $Tenant
        }

        if ($CorrectState -eq $true) {
            Add-CIPPBPAField @BPAField -StoreAs bool
        } else {
            Add-CIPPBPAField @BPAField -StoreAs json
        }

        if ($CorrectState -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.ShortenMeetings' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardShortenMeetings.ps1' 107
#Region './Public/Standards/Invoke-CIPPStandardSpamFilterPolicy.ps1' -1

function Invoke-CIPPStandardSpamFilterPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SpamFilterPolicy
    .SYNOPSIS
        (Label) Default Spam Filter Policy
    .DESCRIPTION
        (Helptext) This standard creates a Spam filter policy similar to the default strict policy.
        (DocsDescription) This standard creates a Spam filter policy similar to the default strict policy, the following settings are configured to on by default: IncreaseScoreWithNumericIps, IncreaseScoreWithRedirectToOtherPort, MarkAsSpamEmptyMessages, MarkAsSpamJavaScriptInHtml, MarkAsSpamSpfRecordHardFail, MarkAsSpamFromAddressAuthFail, MarkAsSpamNdrBackscatter, MarkAsSpamBulkMail, InlineSafetyTipsEnabled, PhishZapEnabled, SpamZapEnabled
    .NOTES
        CAT
            Defender Standards
        TAG
        ADDEDCOMPONENT
            {"type":"number","label":"Bulk email threshold (Default 7)","name":"standards.SpamFilterPolicy.BulkThreshold","defaultValue":7}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"label":"Spam Action","name":"standards.SpamFilterPolicy.SpamAction","options":[{"label":"Quarantine the message","value":"Quarantine"},{"label":"Move message to Junk Email folder","value":"MoveToJmf"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":true,"label":"Spam Quarantine Tag","name":"standards.SpamFilterPolicy.SpamQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"label":"High Confidence Spam Action","name":"standards.SpamFilterPolicy.HighConfidenceSpamAction","options":[{"label":"Quarantine the message","value":"Quarantine"},{"label":"Move message to Junk Email folder","value":"MoveToJmf"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":true,"label":"High Confidence Spam Quarantine Tag","name":"standards.SpamFilterPolicy.HighConfidenceSpamQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"label":"Bulk Spam Action","name":"standards.SpamFilterPolicy.BulkSpamAction","options":[{"label":"Quarantine the message","value":"Quarantine"},{"label":"Move message to Junk Email folder","value":"MoveToJmf"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":true,"label":"Bulk Quarantine Tag","name":"standards.SpamFilterPolicy.BulkQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"label":"Phish Spam Action","name":"standards.SpamFilterPolicy.PhishSpamAction","options":[{"label":"Quarantine the message","value":"Quarantine"},{"label":"Move message to Junk Email folder","value":"MoveToJmf"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":true,"label":"Phish Quarantine Tag","name":"standards.SpamFilterPolicy.PhishQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":true,"label":"High Confidence Phish Quarantine Tag","name":"standards.SpamFilterPolicy.HighConfidencePhishQuarantineTag","options":[{"label":"AdminOnlyAccessPolicy","value":"AdminOnlyAccessPolicy"},{"label":"DefaultFullAccessPolicy","value":"DefaultFullAccessPolicy"},{"label":"DefaultFullAccessWithNotificationPolicy","value":"DefaultFullAccessWithNotificationPolicy"}]}
            {"type":"switch","name":"standards.SpamFilterPolicy.IncreaseScoreWithImageLinks","label":"Increase score if message contains image links to remote websites","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.IncreaseScoreWithBizOrInfoUrls","label":"Increase score if message contains links to .biz or .info domains","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamFramesInHtml","label":"Mark as spam if message contains HTML or iframe tags","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamObjectTagsInHtml","label":"Mark as spam if message contains HTML object tags","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamEmbedTagsInHtml","label":"Mark as spam if message contains HTML embed tags","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamFormTagsInHtml","label":"Mark as spam if message contains HTML form tags","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamWebBugsInHtml","label":"Mark as spam if message contains web bugs (also known as web beacons)","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.MarkAsSpamSensitiveWordList","label":"Mark as spam if message contains words from the sensitive words list","defaultValue":false}
            {"type":"switch","name":"standards.SpamFilterPolicy.EnableLanguageBlockList","label":"Enable language block list","defaultValue":false}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"name":"standards.SpamFilterPolicy.LanguageBlockList","label":"Languages to block (uppercase ISO 639-1 two-letter)","condition":{"field":"standards.SpamFilterPolicy.EnableLanguageBlockList","compareType":"is","compareValue":true}}
            {"type":"switch","name":"standards.SpamFilterPolicy.EnableRegionBlockList","label":"Enable region block list","defaultValue":false}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"name":"standards.SpamFilterPolicy.RegionBlockList","label":"Regions to block (uppercase ISO 3166-1 two-letter)","condition":{"field":"standards.SpamFilterPolicy.EnableRegionBlockList","compareType":"is","compareValue":true}}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"name":"standards.SpamFilterPolicy.AllowedSenderDomains","label":"Allowed sender domains"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-15
        POWERSHELLEQUIVALENT
            New-HostedContentFilterPolicy or Set-HostedContentFilterPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SpamFilterPolicy' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    # Use custom name if provided, otherwise use default for backward compatibility
    $PolicyName = if ($Settings.name) { $Settings.name } else { 'CIPP Default Spam Filter Policy' }

    try {
        $CurrentState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-HostedContentFilterPolicy' |
        Where-Object -Property Name -EQ $PolicyName |
        Select-Object -Property *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SpamFilterPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $SpamAction = $Settings.SpamAction.value ?? $Settings.SpamAction
    $SpamQuarantineTag = $Settings.SpamQuarantineTag.value ?? $Settings.SpamQuarantineTag
    $HighConfidenceSpamAction = $Settings.HighConfidenceSpamAction.value ?? $Settings.HighConfidenceSpamAction
    $HighConfidenceSpamQuarantineTag = $Settings.HighConfidenceSpamQuarantineTag.value ?? $Settings.HighConfidenceSpamQuarantineTag
    $BulkSpamAction = $Settings.BulkSpamAction.value ?? $Settings.BulkSpamAction
    $BulkQuarantineTag = $Settings.BulkQuarantineTag.value ?? $Settings.BulkQuarantineTag
    $PhishSpamAction = $Settings.PhishSpamAction.value ?? $Settings.PhishSpamAction
    $PhishQuarantineTag = $Settings.PhishQuarantineTag.value ?? $Settings.PhishQuarantineTag
    $HighConfidencePhishQuarantineTag = $Settings.HighConfidencePhishQuarantineTag.value ?? $Settings.HighConfidencePhishQuarantineTag

    $IncreaseScoreWithImageLinks = if ($Settings.IncreaseScoreWithImageLinks) { 'On' } else { 'Off' }
    $IncreaseScoreWithBizOrInfoUrls = if ($Settings.IncreaseScoreWithBizOrInfoUrls) { 'On' } else { 'Off' }
    $MarkAsSpamFramesInHtml = if ($Settings.MarkAsSpamFramesInHtml) { 'On' } else { 'Off' }
    $MarkAsSpamObjectTagsInHtml = if ($Settings.MarkAsSpamObjectTagsInHtml) { 'On' } else { 'Off' }
    $MarkAsSpamEmbedTagsInHtml = if ($Settings.MarkAsSpamEmbedTagsInHtml) { 'On' } else { 'Off' }
    $MarkAsSpamFormTagsInHtml = if ($Settings.MarkAsSpamFormTagsInHtml) { 'On' } else { 'Off' }
    $MarkAsSpamWebBugsInHtml = if ($Settings.MarkAsSpamWebBugsInHtml) { 'On' } else { 'Off' }
    $MarkAsSpamSensitiveWordList = if ($Settings.MarkAsSpamSensitiveWordList) { 'On' } else { 'Off' }

    try {
        $StateIsCorrect = ($CurrentState.Name -eq $PolicyName) -and
        ($CurrentState.SpamAction -eq $SpamAction) -and
        ($CurrentState.SpamQuarantineTag -eq $SpamQuarantineTag) -and
        ($CurrentState.HighConfidenceSpamAction -eq $HighConfidenceSpamAction) -and
        ($CurrentState.HighConfidenceSpamQuarantineTag -eq $HighConfidenceSpamQuarantineTag) -and
        ($CurrentState.BulkSpamAction -eq $BulkSpamAction) -and
        ($CurrentState.BulkQuarantineTag -eq $BulkQuarantineTag) -and
        ($CurrentState.PhishSpamAction -eq $PhishSpamAction) -and
        ($CurrentState.PhishQuarantineTag -eq $PhishQuarantineTag) -and
        ($CurrentState.HighConfidencePhishAction -eq 'Quarantine') -and
        ($CurrentState.HighConfidencePhishQuarantineTag -eq $HighConfidencePhishQuarantineTag) -and
        ($CurrentState.BulkThreshold -eq [int]$Settings.BulkThreshold) -and
        ($CurrentState.QuarantineRetentionPeriod -eq 30) -and
        ($CurrentState.IncreaseScoreWithImageLinks -eq $IncreaseScoreWithImageLinks) -and
        ($CurrentState.IncreaseScoreWithNumericIps -eq 'On') -and
        ($CurrentState.IncreaseScoreWithRedirectToOtherPort -eq 'On') -and
        ($CurrentState.IncreaseScoreWithBizOrInfoUrls -eq $IncreaseScoreWithBizOrInfoUrls) -and
        ($CurrentState.MarkAsSpamEmptyMessages -eq 'On') -and
        ($CurrentState.MarkAsSpamJavaScriptInHtml -eq 'On') -and
        ($CurrentState.MarkAsSpamFramesInHtml -eq $MarkAsSpamFramesInHtml) -and
        ($CurrentState.MarkAsSpamObjectTagsInHtml -eq $MarkAsSpamObjectTagsInHtml) -and
        ($CurrentState.MarkAsSpamEmbedTagsInHtml -eq $MarkAsSpamEmbedTagsInHtml) -and
        ($CurrentState.MarkAsSpamFormTagsInHtml -eq $MarkAsSpamFormTagsInHtml) -and
        ($CurrentState.MarkAsSpamWebBugsInHtml -eq $MarkAsSpamWebBugsInHtml) -and
        ($CurrentState.MarkAsSpamSensitiveWordList -eq $MarkAsSpamSensitiveWordList) -and
        ($CurrentState.MarkAsSpamSpfRecordHardFail -eq 'On') -and
        ($CurrentState.MarkAsSpamFromAddressAuthFail -eq 'On') -and
        ($CurrentState.MarkAsSpamNdrBackscatter -eq 'On') -and
        ($CurrentState.MarkAsSpamBulkMail -eq 'On') -and
        ($CurrentState.InlineSafetyTipsEnabled -eq $true) -and
        ($CurrentState.PhishZapEnabled -eq $true) -and
        ($CurrentState.SpamZapEnabled -eq $true) -and
        ($CurrentState.EnableLanguageBlockList -eq $Settings.EnableLanguageBlockList) -and
        ((($null -eq $CurrentState.LanguageBlockList -or $CurrentState.LanguageBlockList.Count -eq 0) -and ($null -eq $Settings.LanguageBlockList.value)) -or ($null -ne $CurrentState.LanguageBlockList -and $CurrentState.LanguageBlockList.Count -gt 0 -and $null -ne $Settings.LanguageBlockList.value -and !(Compare-Object -ReferenceObject $CurrentState.LanguageBlockList -DifferenceObject $Settings.LanguageBlockList.value))) -and
        ($CurrentState.EnableRegionBlockList -eq $Settings.EnableRegionBlockList) -and
        ((($null -eq $CurrentState.RegionBlockList -or $CurrentState.RegionBlockList.Count -eq 0) -and ($null -eq $Settings.RegionBlockList.value)) -or ($null -ne $CurrentState.RegionBlockList -and $CurrentState.RegionBlockList.Count -gt 0 -and $null -ne $Settings.RegionBlockList.value -and !(Compare-Object -ReferenceObject $CurrentState.RegionBlockList -DifferenceObject $Settings.RegionBlockList.value))) -and
        ((($null -eq $CurrentState.AllowedSenderDomains -or $CurrentState.AllowedSenderDomains.Count -eq 0) -and ($null -eq ($Settings.AllowedSenderDomains.value ?? $Settings.AllowedSenderDomains))) -or ($null -ne $CurrentState.AllowedSenderDomains -and $CurrentState.AllowedSenderDomains.Count -gt 0 -and $null -ne ($Settings.AllowedSenderDomains.value ?? $Settings.AllowedSenderDomains) -and !(Compare-Object -ReferenceObject $CurrentState.AllowedSenderDomains -DifferenceObject ($Settings.AllowedSenderDomains.value ?? $Settings.AllowedSenderDomains))))
    }
    catch {
        $StateIsCorrect = $false
    }

    $AcceptedDomains = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-AcceptedDomain'

    $RuleState = New-ExoRequest -TenantId $Tenant -cmdlet 'Get-HostedContentFilterRule' |
        Where-Object -Property Name -EQ $PolicyName |
        Select-Object -Property *

    $RuleStateIsCorrect = ($RuleState.Name -eq $PolicyName) -and
    ($RuleState.HostedContentFilterPolicy -eq $PolicyName) -and
    ($RuleState.Priority -eq 0) -and
    (!(Compare-Object -ReferenceObject $RuleState.RecipientDomainIs -DifferenceObject $AcceptedDomains.Name))

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spam Filter Policy already correctly configured' -sev Info
        } else {
            $cmdParams = @{
                SpamAction                           = $SpamAction
                SpamQuarantineTag                    = $SpamQuarantineTag
                HighConfidenceSpamAction             = $HighConfidenceSpamAction
                HighConfidenceSpamQuarantineTag      = $HighConfidenceSpamQuarantineTag
                BulkSpamAction                       = $BulkSpamAction
                BulkQuarantineTag                    = $BulkQuarantineTag
                PhishSpamAction                      = $PhishSpamAction
                PhishQuarantineTag                   = $PhishQuarantineTag
                HighConfidencePhishAction            = 'Quarantine'
                HighConfidencePhishQuarantineTag     = $HighConfidencePhishQuarantineTag
                BulkThreshold                        = [int]$Settings.BulkThreshold
                QuarantineRetentionPeriod            = 30
                IncreaseScoreWithImageLinks          = $IncreaseScoreWithImageLinks
                IncreaseScoreWithNumericIps          = 'On'
                IncreaseScoreWithRedirectToOtherPort = 'On'
                IncreaseScoreWithBizOrInfoUrls       = $IncreaseScoreWithBizOrInfoUrls
                MarkAsSpamEmptyMessages              = 'On'
                MarkAsSpamJavaScriptInHtml           = 'On'
                MarkAsSpamFramesInHtml               = $MarkAsSpamFramesInHtml
                MarkAsSpamObjectTagsInHtml           = $MarkAsSpamObjectTagsInHtml
                MarkAsSpamEmbedTagsInHtml            = $MarkAsSpamEmbedTagsInHtml
                MarkAsSpamFormTagsInHtml             = $MarkAsSpamFormTagsInHtml
                MarkAsSpamWebBugsInHtml              = $MarkAsSpamWebBugsInHtml
                MarkAsSpamSensitiveWordList          = $MarkAsSpamSensitiveWordList
                MarkAsSpamSpfRecordHardFail          = 'On'
                MarkAsSpamFromAddressAuthFail        = 'On'
                MarkAsSpamNdrBackscatter             = 'On'
                MarkAsSpamBulkMail                   = 'On'
                InlineSafetyTipsEnabled              = $true
                PhishZapEnabled                      = $true
                SpamZapEnabled                       = $true
                AllowedSenderDomains                 = $Settings.AllowedSenderDomains.value ?? @{'@odata.type' = '#Exchange.GenericHashTable' }
            }

            # Remove optional block lists if not configured
            if ($Settings.EnableLanguageBlockList -eq $true -and $Settings.LanguageBlockList.value) {
                $cmdParams.Add('EnableLanguageBlockList', $Settings.EnableLanguageBlockList)
                $cmdParams.Add('LanguageBlockList', $Settings.LanguageBlockList.value)
            } else {
                $cmdParams.Add('EnableLanguageBlockList', $false)
            }
            if ($Settings.EnableRegionBlockList -eq $true -and $Settings.RegionBlockList.value) {
                $cmdParams.Add('EnableRegionBlockList', $Settings.EnableRegionBlockList)
                $cmdParams.Add('RegionBlockList', $Settings.RegionBlockList.value)
            } else {
                $cmdParams.Add('EnableRegionBlockList', $false)
            }


            if ($CurrentState.Name -eq $PolicyName) {
                try {
                    $cmdParams.Add('Identity', $PolicyName)
                    $null = New-ExoRequest -TenantId $Tenant -cmdlet 'Set-HostedContentFilterPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Updated Spam Filter policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to update Spam Filter policy $PolicyName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', $PolicyName)
                    $null = New-ExoRequest -TenantId $Tenant -cmdlet 'New-HostedContentFilterPolicy' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Created Spam Filter policy $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to create Spam Filter policy $PolicyName." -sev Error -LogData $_
                }
            }
        }

        if ($RuleStateIsCorrect -eq $false) {
            $cmdParams = @{
                Priority          = 0
                RecipientDomainIs = $AcceptedDomains.Name
            }

            if ($RuleState.HostedContentFilterPolicy -ne $PolicyName) {
                $cmdParams.Add('HostedContentFilterPolicy', $PolicyName)
            }

            if ($RuleState.Name -eq $PolicyName) {
                try {
                    $cmdParams.Add('Identity', "$PolicyName")
                    $null = New-ExoRequest -TenantId $Tenant -cmdlet 'Set-HostedContentFilterRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Updated Spam Filter rule $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to update Spam Filter rule $PolicyName." -sev Error -LogData $_
                }
            } else {
                try {
                    $cmdParams.Add('Name', "$PolicyName")
                    $null = New-ExoRequest -TenantId $Tenant -cmdlet 'New-HostedContentFilterRule' -cmdParams $cmdParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Created Spam Filter rule $PolicyName." -sev Info
                } catch {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -message "Failed to create Spam Filter rule $PolicyName." -sev Error -LogData $_
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spam Filter Policy is enabled' -sev Info
        } else {
            Write-StandardsAlert -message 'Spam Filter Policy is not enabled' -object $CurrentState -tenant $Tenant -standardName 'SpamFilterPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -message 'Spam Filter Policy is not enabled' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SpamFilterPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $StateIsCorrect -eq $true ? $true : ($CurrentState ?? @{ state = 'Spam filter policy not found' })
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SpamFilterPolicy' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSpamFilterPolicy.ps1' 270
#Region './Public/Standards/Invoke-CIPPStandardSPAzureB2B.ps1' -1

function Invoke-CIPPStandardSPAzureB2B {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPAzureB2B
    .SYNOPSIS
        (Label) Enable SharePoint and OneDrive integration with Azure AD B2B
    .DESCRIPTION
        (Helptext) Ensure SharePoint and OneDrive integration with Azure AD B2B is enabled
        (DocsDescription) Ensure SharePoint and OneDrive integration with Azure AD B2B is enabled
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.2)"
        EXECUTIVETEXT
            Enables secure collaboration with external partners through SharePoint and OneDrive by integrating with Azure B2B guest access. This allows controlled sharing with external organizations while maintaining security oversight and proper access management.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-09
        POWERSHELLEQUIVALENT
            Set-SPOTenant -EnableAzureADB2BIntegration \$true
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPAzureB2B' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, EnableAzureADB2BIntegration
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPAzureB2B state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.EnableAzureADB2BIntegration -eq $true)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint Azure B2B is already enabled' -Sev Info
        } else {
            $Properties = @{
                EnableAzureADB2BIntegration = $true
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully set the SharePoint Azure B2B to enabled' -Sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set the SharePoint Azure B2B to enabled. Error: $ErrorMessage" -Sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint Azure B2B is enabled' -Sev Info
        } else {
            $Message = 'SharePoint Azure B2B is not enabled.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPAzureB2B' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'AzureB2B' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPAzureB2B' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPAzureB2B.ps1' 92
#Region './Public/Standards/Invoke-CIPPStandardSPDirectSharing.ps1' -1

function Invoke-CIPPStandardSPDirectSharing {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPDirectSharing
    .SYNOPSIS
        (Label) Default sharing to Direct users
    .DESCRIPTION
        (Helptext) This standard has been deprecated in favor of the Default Sharing Link standard. 
        (DocsDescription) This standard has been deprecated in favor of the Default Sharing Link standard. 
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Configures SharePoint and OneDrive to share files directly with specific people rather than creating anonymous links, improving security by ensuring only intended recipients can access shared documents. This reduces the risk of accidental data exposure through link sharing.
        ADDEDCOMPONENT
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-09
        POWERSHELLEQUIVALENT
            Set-SPOTenant -DefaultSharingLinkType Direct
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPDirectSharing' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.


    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'The default sharing to Direct users standard has been deprecated in favor of the "Set Default Sharing Link Settings" standard. Please update your standards to use new standard. However this will continue to function.' -Sev Alert
    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, DefaultSharingLinkType
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPDirectSharing state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.DefaultSharingLinkType -eq 'Direct' -or $CurrentState.DefaultSharingLinkType -eq 1)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint Default Direct Sharing is already enabled' -Sev Info
        } else {
            $Properties = @{
                DefaultSharingLinkType = 1
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully set the SharePoint Default Direct Sharing to Direct' -Sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set the SharePoint Default Direct Sharing to Direct. Error: $ErrorMessage" -Sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint Direct Sharing is enabled' -Sev Info
        } else {
            $Message = 'SharePoint Default Direct Sharing is not enabled.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPDirectSharing' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'DirectSharing' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPDirectSharing' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPDirectSharing.ps1' 95
#Region './Public/Standards/Invoke-CIPPStandardSPDisableLegacyWorkflows.ps1' -1

function Invoke-CIPPStandardSPDisableLegacyWorkflows {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPDisableLegacyWorkflows
    .SYNOPSIS
        (Label) Disable Legacy Workflows
    .DESCRIPTION
        (Helptext) Disables the creation of new SharePoint 2010 and 2013 classic workflows and removes the 'Return to classic SharePoint' link on modern SharePoint list and library pages.
        (DocsDescription) Disables the creation of new SharePoint 2010 and 2013 classic workflows and removes the 'Return to classic SharePoint' link on modern SharePoint list and library pages.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Disables outdated SharePoint workflow features and classic interface options, encouraging use of modern, more secure and efficient collaboration tools. This helps maintain security standards while guiding users toward current, supported functionality.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-15
        POWERSHELLEQUIVALENT
            Set-SPOTenant -DisableWorkflow2010 \$true -DisableWorkflow2013 \$true -DisableBackToClassic \$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPDisableLegacyWorkflows' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPDisableLegacyWorkflows state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.StopNew2010Workflows -eq $true) -and
    ($CurrentState.StopNew2013Workflows -eq $true) -and
    ($CurrentState.DisableBackToClassic -eq $true)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Legacy Workflows are already disabled.' -Sev Info
        } else {
            $Properties = @{
                StopNew2010Workflows = $true
                StopNew2013Workflows = $true
                DisableBackToClassic = $true
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully disabled Legacy Workflows' -Sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to disable Legacy Workflows. Error: $ErrorMessage" -Sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint Legacy Workflows are disabled' -Sev Info
        } else {
            $Message = 'SharePoint Legacy Workflows is not disabled.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPDisableLegacyWorkflows' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SPDisableLegacyWorkflows' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPDisableLegacyWorkflows' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPDisableLegacyWorkflows.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardSPDisallowInfectedFiles.ps1' -1

function Invoke-CIPPStandardSPDisallowInfectedFiles {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPDisallowInfectedFiles
    .SYNOPSIS
        (Label) Disallow downloading infected files from SharePoint
    .DESCRIPTION
        (Helptext) Ensure Office 365 SharePoint infected files are disallowed for download
        (DocsDescription) Ensure Office 365 SharePoint infected files are disallowed for download
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.3.1)"
            "CISA (MS.SPO.3.1v1)"
            "NIST CSF 2.0 (DE.CM-09)"
        EXECUTIVETEXT
            Prevents employees from downloading files that have been identified as containing malware or viruses from SharePoint and OneDrive. This security measure protects against malware distribution through file sharing while maintaining access to clean, safe documents.
        ADDEDCOMPONENT
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-09
        POWERSHELLEQUIVALENT
            Set-SPOTenant -DisallowInfectedFileDownload \$true
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPDisallowInfectedFiles' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, DisallowInfectedFileDownload
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPDisallowInfectedFiles state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.DisallowInfectedFileDownload -eq $true)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -Message 'Downloading SharePoint infected files are already disallowed.' -Sev Info
        } else {
            $Properties = @{
                DisallowInfectedFileDownload = $true
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -tenant $tenant -Message 'Successfully disallowed downloading SharePoint infected files.' -Sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -Message "Failed to disallow downloading SharePoint infected files. Error: $ErrorMessage" -Sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -Message 'Downloading SharePoint infected files are disallowed.' -Sev Info
        } else {
            $Message = 'Downloading SharePoint infected files is not set to the desired value.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPDisallowInfectedFiles' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SPDisallowInfectedFiles' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPDisallowInfectedFiles' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPDisallowInfectedFiles.ps1' 96
#Region './Public/Standards/Invoke-CIPPStandardSPEmailAttestation.ps1' -1

function Invoke-CIPPStandardSPEmailAttestation {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPEmailAttestation
    .SYNOPSIS
        (Label) Require re-authentication with verification code
    .DESCRIPTION
        (Helptext) Ensure re-authentication with verification code is restricted
        (DocsDescription) Ensure re-authentication with verification code is restricted
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.10)"
            "CISA (MS.SPO.1.6v1)"
        EXECUTIVETEXT
            Requires external users to periodically re-verify their identity through email verification codes when accessing SharePoint resources, adding an extra security layer for external collaboration. This helps ensure continued legitimacy of external access over time.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.SPEmailAttestation.Days","label":"Require re-authentication every X Days (Default 15)"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-09
        POWERSHELLEQUIVALENT
            Set-SPOTenant -EmailAttestationRequired \$true -EmailAttestationReAuthDays 15
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPEmailAttestation' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, EmailAttestationReAuthDays, EmailAttestationRequired
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPEmailAttestation state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.EmailAttestationReAuthDays -eq [int]$Settings.Days) -and
    ($CurrentState.EmailAttestationRequired -eq $true)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint re-authentication with verification code is already restricted.' -Sev Info
        } else {
            $Properties = @{
                EmailAttestationReAuthDays = [int]$Settings.Days
                EmailAttestationRequired   = $true
            }

            try {
                $Response = $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                if ($Response.ErrorInfo.ErrorMessage) {
                    $ErrorMessage = Get-NormalizedError -Message $Response.ErrorInfo.ErrorMessage
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set re-authentication with verification code restriction. Error: $ErrorMessage" -Sev Error
                } else {
                    Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully set re-authentication with verification code restriction.' -Sev Info
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set re-authentication with verification code restriction. Error: $ErrorMessage" -Sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Re-authentication with verification code is restricted.' -Sev Info
        } else {
            $Message = 'Re-authentication with verification code is not set to the desired value.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPEmailAttestation' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SPEmailAttestation' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPEmailAttestation' -FieldValue $FieldValue -TenantFilter $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPEmailAttestation.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandardSPExternalUserExpiration.ps1' -1

function Invoke-CIPPStandardSPExternalUserExpiration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPExternalUserExpiration
    .SYNOPSIS
        (Label) Set guest access to expire automatically
    .DESCRIPTION
        (Helptext) Ensure guest access to a site or OneDrive will expire automatically
        (DocsDescription) Ensure guest access to a site or OneDrive will expire automatically
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.9)"
            "CISA (MS.SPO.1.5v1)"
        EXECUTIVETEXT
            Automatically expires external user access to SharePoint sites and OneDrive after a specified period, reducing security risks from forgotten or unnecessary guest accounts. This ensures external access is regularly reviewed and maintained only when actively needed.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.SPExternalUserExpiration.Days","label":"Days until expiration (Default 60)"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-09
        POWERSHELLEQUIVALENT
            Set-SPOTenant -ExternalUserExpireInDays 30 -ExternalUserExpirationRequired \$True
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPExternalUserExpiration' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object -Property _ObjectIdentity_, TenantFilter, ExternalUserExpireInDays, ExternalUserExpirationRequired
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPExternalUserExpiration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.ExternalUserExpireInDays -eq $Settings.Days) -and
    ($CurrentState.ExternalUserExpirationRequired -eq $true)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'SharePoint External User Expiration is already enabled.' -Sev Info
        } else {
            $Properties = @{
                ExternalUserExpireInDays       = $Settings.Days
                ExternalUserExpirationRequired = $true
            }

            try {
                $CurrentState | Set-CIPPSPOTenant -Properties $Properties
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'Successfully set External User Expiration' -Sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Failed to set External User Expiration. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message 'External User Expiration is enabled' -Sev Info
        } else {
            $Message = 'External User Expiration is not set to the desired value.'
            Write-StandardsAlert -message $Message -object $CurrentState -tenant $Tenant -standardName 'SPExternalUserExpiration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -Tenant $Tenant -Message $Message -Sev Alert
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'ExternalUserExpiration' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPExternalUserExpiration' -FieldValue $FieldValue -TenantFilter $Tenant
        Add-CIPPBPAField -FieldName 'standards.SPExternalUserExpiration' -FieldValue $FieldValue -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPExternalUserExpiration.ps1' 97
#Region './Public/Standards/Invoke-CIPPStandardSPFileRequests.ps1' -1

function Invoke-CIPPStandardSPFileRequests {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPFileRequests
    .SYNOPSIS
        (Label) Set SharePoint and OneDrive File Requests
    .DESCRIPTION
        (Helptext) Enables or disables File Requests for SharePoint and OneDrive, allowing users to create secure upload-only links. Optionally sets the maximum number of days for the link to remain active before expiring.
        (DocsDescription) File Requests allow users to create secure upload-only share links where uploads are hidden from other people using the link. This creates a secure and private way for people to upload files to a folder. This feature is not enabled by default on new tenants and requires PowerShell configuration. This standard enables or disables this feature and optionally configures link expiration settings for both SharePoint and OneDrive.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Enables secure file upload functionality that allows external users to submit files directly to company folders without seeing other submissions or folder contents. This provides a professional and secure way to collect documents from clients, vendors, and partners while maintaining data privacy and security.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.SPFileRequests.state","label":"Enable File Requests"}
            {"type":"number","name":"standards.SPFileRequests.expirationDays","label":"Link Expiration 1-730 Days (Optional)","required":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-07-30
        POWERSHELLEQUIVALENT
            Set-SPOTenant -CoreRequestFilesLinkEnabled \$true -OneDriveRequestFilesLinkEnabled \$true -CoreRequestFilesLinkExpirationInDays 30 -OneDriveRequestFilesLinkExpirationInDays 30
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPFileRequests' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'The tenant is not licenced for this standard SPFileRequests' -sev Error
        return $true
    }

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant | Select-Object _ObjectIdentity_, TenantFilter, CoreRequestFilesLinkEnabled, OneDriveRequestFilesLinkEnabled, CoreRequestFilesLinkExpirationInDays, OneDriveRequestFilesLinkExpirationInDays
    }
    catch {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'Failed to get current state of SPO tenant details' -sev Error
        return
    }

    # Input validation
    if (($Settings.state -eq $null) -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'Invalid state parameter set for standard SPFileRequests' -sev Error
        return
    }

    $WantedState = $Settings.state
    $ExpirationDays = $Settings.expirationDays
    $HumanReadableState = if ($WantedState -eq $true) { 'enabled' } else { 'disabled' }

    # Check if current state matches desired state
    $CoreStateIsCorrect = if ($CurrentState.CoreRequestFilesLinkEnabled -eq $WantedState) { $true } else { $false }
    $OneDriveStateIsCorrect = if ($CurrentState.OneDriveRequestFilesLinkEnabled -eq $WantedState) { $true } else { $false }
    $StateIsCorrect = $CoreStateIsCorrect -and $OneDriveStateIsCorrect

    # Check expiration settings if specified
    $ExpirationIsCorrect = $true
    if ($ExpirationDays -ne $null -and $WantedState -eq $true) {
        $CoreExpirationIsCorrect = ($CurrentState.CoreRequestFilesLinkExpirationInDays -eq $ExpirationDays)
        $OneDriveExpirationIsCorrect = ($CurrentState.OneDriveRequestFilesLinkExpirationInDays -eq $ExpirationDays)
        $ExpirationIsCorrect = $CoreExpirationIsCorrect -and $OneDriveExpirationIsCorrect
    }

    $AllSettingsCorrect = $StateIsCorrect -and $ExpirationIsCorrect

    if ($Settings.remediate -eq $true) {

        if ($AllSettingsCorrect -eq $false) {
            try {
                $Properties = @{
                    CoreRequestFilesLinkEnabled = $WantedState
                    OneDriveRequestFilesLinkEnabled = $WantedState
                }

                # Add expiration settings if specified and feature is being enabled
                if ($ExpirationDays -ne $null -and $WantedState -eq $true) {
                    $Properties['CoreRequestFilesLinkExpirationInDays'] = $ExpirationDays
                    $Properties['OneDriveRequestFilesLinkExpirationInDays'] = $ExpirationDays
                }

                $CurrentState | Set-CIPPSPOTenant -Properties $Properties

                $ExpirationMessage = if ($ExpirationDays -ne $null -and $WantedState -eq $true) { " with $ExpirationDays day expiration" } else { "" }
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set File Requests to $HumanReadableState$ExpirationMessage" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set File Requests to $HumanReadableState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            $ExpirationMessage = if ($ExpirationDays -ne $null -and $WantedState -eq $true) { " with $ExpirationDays day expiration" } else { "" }
            Write-LogMessage -API 'Standards' -tenant $tenant -message "File Requests are already set to the wanted state of $HumanReadableState$ExpirationMessage" -sev Info
        }
    }

    if ($Settings.alert -eq $true) {
        if ($AllSettingsCorrect -eq $true) {
            $ExpirationMessage = if ($ExpirationDays -ne $null -and $WantedState -eq $true) { " with $ExpirationDays day expiration" } else { "" }
            Write-LogMessage -API 'Standards' -tenant $tenant -message "File Requests are already set to the wanted state of $HumanReadableState$ExpirationMessage" -sev Info
        } else {
            $AlertMessage = "File Requests are not set to the wanted state of $HumanReadableState"
            if ($ExpirationDays -ne $null -and $WantedState -eq $true) {
                $AlertMessage += " with $ExpirationDays day expiration"
            }
            Write-StandardsAlert -message $AlertMessage -object $CurrentState -tenant $tenant -standardName 'SPFileRequests' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message $AlertMessage -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SPFileRequestsEnabled' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'SPCoreFileRequestsEnabled' -FieldValue $CurrentState.CoreRequestFilesLinkEnabled -StoreAs bool -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'SPOneDriveFileRequestsEnabled' -FieldValue $CurrentState.OneDriveRequestFilesLinkEnabled -StoreAs bool -Tenant $Tenant

        if ($ExpirationDays -ne $null) {
            Add-CIPPBPAField -FieldName 'SPCoreFileRequestsExpirationDays' -FieldValue $CurrentState.CoreRequestFilesLinkExpirationInDays -StoreAs string -Tenant $Tenant
            Add-CIPPBPAField -FieldName 'SPOneDriveFileRequestsExpirationDays' -FieldValue $CurrentState.OneDriveRequestFilesLinkExpirationInDays -StoreAs string -Tenant $Tenant
        }

        if ($AllSettingsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPFileRequests' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPFileRequests.ps1' 137
#Region './Public/Standards/Invoke-CIPPStandardSpoofWarn.ps1' -1

function Invoke-CIPPStandardSpoofWarn {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SpoofWarn
    .SYNOPSIS
        (Label) Enable or disable 'external' warning in Outlook
    .DESCRIPTION
        (Helptext) Adds or removes indicators to e-mail messages received from external senders in Outlook. Works on all Outlook clients/OWA
        (DocsDescription) Adds or removes indicators to e-mail messages received from external senders in Outlook. You can read more about this feature on [Microsoft's Exchange Team Blog.](https://techcommunity.microsoft.com/t5/exchange-team-blog/native-external-sender-callouts-on-email-in-outlook/ba-p/2250098)
    .NOTES
        CAT
            Exchange Standards
        TAG
            "CIS M365 5.0 (6.2.3)"
        EXECUTIVETEXT
            Displays visual warnings in Outlook when emails come from external senders, helping employees identify potentially suspicious messages and reducing the risk of phishing attacks. This security feature makes it easier for staff to distinguish between internal and external communications.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.SpoofWarn.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
            {"type":"autoComplete","multiple":true,"creatable":true,"required":false,"label":"Enter allowed senders(domain.com, *.domain.com or test@domain.com)","name":"standards.SpoofWarn.AllowListAdd"}
        IMPACT
            Low Impact
        ADDEDDATE
            2021-11-16
        POWERSHELLEQUIVALENT
            Set-ExternalInOutlook Enabled \$true or \$false
        RECOMMENDEDBY
            "CIS"
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SpoofWarn' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentInfo = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-ExternalInOutlook')
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SpoofWarn state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state

    $IsEnabled = $state -eq 'enabled'
    $AllowListAdd = $Settings.AllowListAdd.value ?? $Settings.AllowListAdd

    # Test if all entries in the AllowListAdd variable are in the AllowList
    $AllowListCorrect = $true

    if ($AllowListAdd -eq $null -or $AllowListAdd.Count -eq 0) {
        Write-Host 'No AllowList entries provided, skipping AllowList check.'
        $AllowListAdd = @{'@odata.type' = '#Exchange.GenericHashTable'; Add = @() }
    } else {
        $AllowListAddEntries = foreach ($entry in $AllowListAdd) {
            if ($CurrentInfo.AllowList -notcontains $entry) {
                $AllowListCorrect = $false
                Write-Host "AllowList entry $entry not found in current AllowList"
                $entry
            } else {
                Write-Host "AllowList entry $entry found in current AllowList."
            }
        }
        $AllowListAdd = @{'@odata.type' = '#Exchange.GenericHashTable'; Add = $AllowListAddEntries }
    }

    # Debug output
    # Write-Host ($CurrentInfo | ConvertTo-Json -Depth 10)
    # Write-Host ($AllowListAdd | ConvertTo-Json -Depth 10)

    # Input validation
    if (([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'SpoofWarn: Invalid state parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate!'
        $status = if ($Settings.enable -and $Settings.disable) {
            # Handle pre standards v2.0 legacy settings when this was 2 separate standards
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'You cannot both enable and disable the Spoof Warnings setting' -sev Error
            return
        } elseif ($state -eq 'enabled' -or $Settings.enable) { $true } else { $false }

        try {
            if ($CurrentInfo.Enabled -eq $status -and $AllowListCorrect -eq $true) {
                # Status correct, AllowList correct
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Outlook external spoof warnings are already set to $status and the AllowList is correct." -sev Info

            } elseif ($CurrentInfo.Enabled -eq $status -and $AllowListCorrect -eq $false) {
                # Status correct, AllowList incorrect
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-ExternalInOutlook' -cmdParams @{ AllowList = $AllowListAdd; }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Outlook external spoof warnings already set to $status. Added $($AllowListAdd.Add -join ', ') to the AllowList." -sev Info

            } elseif ($CurrentInfo.Enabled -ne $status -and $AllowListCorrect -eq $false) {
                # Status incorrect, AllowList incorrect
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-ExternalInOutlook' -cmdParams @{ Enabled = $status; AllowList = $AllowListAdd; }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Outlook external spoof warnings set to $status. Added $($AllowListAdd.Add -join ', ') to the AllowList." -sev Info

            } else {
                # Status incorrect, AllowList correct
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-ExternalInOutlook' -cmdParams @{ Enabled = $status; }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Outlook external spoof warnings set to $status." -sev Info

            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not set Outlook external spoof warnings to $status. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        }
    }

    if ($Settings.alert -eq $true) {
        if ($CurrentInfo.Enabled -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Outlook external spoof warnings are enabled.' -sev Info
        } else {
            Write-StandardsAlert -message 'Outlook external spoof warnings are not enabled.' -object $CurrentInfo -tenant $Tenant -standardName 'SpoofWarn' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Outlook external spoof warnings are not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SpoofingWarnings' -FieldValue $CurrentInfo.Enabled -StoreAs bool -Tenant $Tenant

        if ($AllowListCorrect -eq $true -and $CurrentInfo.Enabled -eq $IsEnabled) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentInfo | Select-Object Enabled, AllowList
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SpoofWarn' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardSpoofWarn.ps1' 143
#Region './Public/Standards/Invoke-CIPPStandardSPSyncButtonState.ps1' -1

function Invoke-CIPPStandardSPSyncButtonState {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) SPSyncButtonState
    .SYNOPSIS
        (Label) Set SharePoint sync button state
    .DESCRIPTION
        (Helptext) If disabled, users in the tenant will no longer be able to use the Sync button to sync SharePoint content on all sites. However, existing synced content will remain functional on the user's computer.
        (DocsDescription) If disabled, users in the tenant will no longer be able to use the Sync button to sync SharePoint content on all sites. However, existing synced content will remain functional on the user's computer.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Controls whether employees can synchronize SharePoint files to their local devices, balancing productivity benefits with data security concerns. This setting helps manage data distribution while maintaining access to cloud-based collaboration when sync is disabled.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"SharePoint Sync Button state","name":"standards.SPSyncButtonState.state","options":[{"label":"Disabled","value":"true"},{"label":"Enabled","value":"false"}]}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-26
        POWERSHELLEQUIVALENT
            Set-SPOTenant -HideSyncButtonOnTeamSite \$true or \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'SPSyncButtonState' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant | Select-Object _ObjectIdentity_, TenantFilter, HideSyncButtonOnDocLib
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the SPSyncButtonState state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }


    # Input validation
    $StateValue = $Settings.state.value ?? $Settings.state
    if (([string]::IsNullOrWhiteSpace($StateValue) -or $StateValue -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $tenant -message 'SPSyncButtonState: Invalid state parameter set' -sev Error
        return
    }

    $WantedState = [System.Convert]::ToBoolean($StateValue)
    $StateIsCorrect = if ($CurrentState.HideSyncButtonOnDocLib -eq $WantedState) { $true } else { $false }
    $HumanReadableState = if ($WantedState -eq $true) { 'disabled' } else { 'enabled' }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'

        if ($StateIsCorrect -eq $false) {
            try {
                $CurrentState | Set-CIPPSPOTenant -Properties @{HideSyncButtonOnDocLib = $WantedState }
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set the SharePoint Sync Button state to $HumanReadableState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set the SharePoint Sync Button state to $HumanReadableState. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The SharePoint Sync Button is already set to the wanted state of $HumanReadableState" -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The SharePoint Sync Button is already set to the wanted state of $HumanReadableState" -sev Info
        } else {
            Write-StandardsAlert -message "The SharePoint Sync Button is not set to the wanted state of $HumanReadableState" -object $CurrentState -tenant $tenant -standardName 'SPSyncButtonState' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $tenant -message "The SharePoint Sync Button is not set to the wanted state of $HumanReadableState" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'SPSyncButtonDisabled' -FieldValue $CurrentState.HideSyncButtonOnDocLib -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.SPSyncButtonState' -FieldValue $FieldValue -Tenant $Tenant
    }

}
#EndRegion './Public/Standards/Invoke-CIPPStandardSPSyncButtonState.ps1' 99
#Region './Public/Standards/Invoke-CIPPStandardSSPR.ps1' -1

function Invoke-CIPPStandardSSPR {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)

    Write-LogMessage -API 'Standards' -tenant $tenant -message 'SSPR standard is no longer available' -sev Error

}
#EndRegion './Public/Standards/Invoke-CIPPStandardSSPR.ps1' 11
#Region './Public/Standards/Invoke-CIPPStandardStaleEntraDevices.ps1' -1

function Invoke-CIPPStandardStaleEntraDevices {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) StaleEntraDevices
    .SYNOPSIS
        (Label) Cleanup stale Entra devices
    .DESCRIPTION
        (Helptext) Remediate is currently not available. Cleans up Entra devices that have not connected/signed in for the specified number of days.
        (DocsDescription) Remediate is currently not available. Cleans up Entra devices that have not connected/signed in for the specified number of days. First disables and later deletes the devices. More info can be found in the [Microsoft documentation](https://learn.microsoft.com/en-us/entra/identity/devices/manage-stale-devices)
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
            "Essential 8 (1501)"
            "NIST CSF 2.0 (ID.AM-08)"
            "NIST CSF 2.0 (PR.PS-03)"
        EXECUTIVETEXT
            Automatically identifies and removes inactive devices that haven't connected to company systems for a specified period, reducing security risks from abandoned or lost devices. This maintains a clean device inventory and prevents potential unauthorized access through dormant device registrations.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.StaleEntraDevices.deviceAgeThreshold","label":"Days before stale(Do not set below 30)"}
        DISABLEDFEATURES
            {"report":false,"warn":false,"remediate":false}
        IMPACT
            High Impact
        ADDEDDATE
            2025-01-19
        POWERSHELLEQUIVALENT
            Remove-MgDevice, Update-MgDevice or Graph API
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'StaleEntraDevices' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')

    # Get all Entra devices

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $AllDevices = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/devices' -tenantid $Tenant | Where-Object { $null -ne $_.approximateLastSignInDateTime }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the StaleEntraDevices state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $Date = (Get-Date).AddDays( - [int]$Settings.deviceAgeThreshold)
    $StaleDevices = $AllDevices | Where-Object { $_.approximateLastSignInDateTime -lt $Date }

    if ($Settings.remediate -eq $true) {

        Write-Host 'Remediation not implemented yet'
        # TODO: Implement remediation. For others in the future that want to try this:
        # Good MS guide on what to watch out for https://learn.microsoft.com/en-us/entra/identity/devices/manage-stale-devices#clean-up-stale-devices
        # https://learn.microsoft.com/en-us/graph/api/device-list?view=graph-rest-beta&tabs=http
        # Properties to look at:
        # approximateLastSignInDateTime: For knowing when the device last signed in
        # enrollmentProfileName and operatingSystem: For knowing if it's an AutoPilot device
        # managementType or isManaged: For knowing if it's an Intune managed device. If it is, should be removed from Intune also. Stale intune standard could possibly be used for this.
        # profileType: For knowing if it's only registered or also managed
        # accountEnabled: For knowing if the device is disabled or not

    }


    if ($Settings.alert -eq $true) {

        if ($StaleDevices.Count -gt 0) {
            Write-StandardsAlert -message "$($StaleDevices.Count) Stale devices found" -object $StaleDevices -tenant $Tenant -standardName 'StaleEntraDevices' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "$($StaleDevices.Count) Stale devices found" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'No stale devices found' -sev Info
        }
    }


    if ($Settings.report -eq $true) {

        if ($StaleDevices.Count -gt 0) {
            $StaleReport = ConvertTo-Json -InputObject ($StaleDevices | Select-Object -Property displayName, id, approximateLastSignInDateTime, accountEnabled, enrollmentProfileName, operatingSystem, managementType, profileType) -Depth 10 -Compress
            Add-CIPPBPAField -FieldName 'StaleEntraDevices' -FieldValue $StaleReport -StoreAs json -Tenant $Tenant
        } else {
            Add-CIPPBPAField -FieldName 'StaleEntraDevices' -FieldValue $true -StoreAs bool -Tenant $Tenant
        }

        if ($StaleDevices.Count -gt 0) {
            $FieldValue = $StaleDevices | Select-Object -Property displayName, id, approximateLastSignInDateTime, accountEnabled, enrollmentProfileName, operatingSystem, managementType, profileType
        } else {
            $FieldValue = $true
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.StaleEntraDevices' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardStaleEntraDevices.ps1' 104
#Region './Public/Standards/Invoke-CIPPStandardTAP.ps1' -1

function Invoke-CIPPStandardTAP {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TAP
    .SYNOPSIS
        (Label) Enable Temporary Access Passwords
    .DESCRIPTION
        (Helptext) Enables TAP and sets the default TAP lifetime to 1 hour. This configuration also allows you to select if a TAP is single use or multi-logon.
        (DocsDescription) Enables Temporary Password generation for the tenant.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Enables temporary access passwords that IT administrators can generate for employees who are locked out or need emergency access to systems. These time-limited passwords provide a secure way to restore access without compromising long-term security policies.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select TAP Lifetime","name":"standards.TAP.config","options":[{"label":"Only Once","value":"true"},{"label":"Multiple Logons","value":"false"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2022-03-15
        POWERSHELLEQUIVALENT
            Update-MgBetaPolicyAuthenticationMethodPolicyAuthenticationMethodConfiguration
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TAP'

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/policies/authenticationmethodspolicy/authenticationMethodConfigurations/TemporaryAccessPass' -tenantid $Tenant
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TAP state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    # Get config value using null-coalescing operator
    $config = $Settings.config.value ?? $Settings.config
    if ($null -eq $config) { $config = $True }

    $StateIsCorrect = ($CurrentState.state -eq 'enabled') -and
    ([System.Convert]::ToBoolean($CurrentState.isUsableOnce) -eq [System.Convert]::ToBoolean($config))

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Temporary Access Passwords is already enabled.' -sev Info
        } else {
            try {
                Set-CIPPAuthenticationPolicy -Tenant $Tenant -APIName 'Standards' -AuthenticationMethodId 'TemporaryAccessPass' -Enabled $true -TAPisUsableOnce $config
            } catch {
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Temporary Access Passwords is enabled.' -sev Info
        } else {
            $Object = $CurrentState | Select-Object -Property state, isUsableOnce, defaultLifetimeInMinutes, defaultLength, maximumLifetimeInMinutes
            Write-StandardsAlert -message 'Temporary Access Passwords is not enabled.' -object $Object -tenant $Tenant -standardName 'TAP' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Temporary Access Passwords is not enabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TemporaryAccessPass' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object state, isUsableOnce
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TAP' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTAP.ps1' 85
#Region './Public/Standards/Invoke-CIPPStandardTeamsChatProtection.ps1' -1

function Invoke-CIPPStandardTeamsChatProtection {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsChatProtection
    .SYNOPSIS
        (Label) Set Teams Chat Protection Settings
    .DESCRIPTION
        (Helptext) Configures Teams chat protection settings including weaponizable file protection and malicious URL protection.
        (DocsDescription) Configures Teams messaging safety features to protect users from weaponizable files and malicious URLs in chats and channels. Weaponizable File Protection automatically blocks messages containing potentially dangerous file types (like .exe, .dll, .bat, etc.). Malicious URL Protection scans URLs in messages and displays warnings when potentially harmful links are detected. These protections work across internal and external collaboration scenarios.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Enables automated security protections in Microsoft Teams to block dangerous files and warn users about malicious links in chat messages. This helps protect employees from file-based attacks and phishing attempts. These safeguards work seamlessly in the background, providing essential protection without disrupting normal business communication.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsChatProtection.FileTypeCheck","label":"Enable Weaponizable File Protection","defaultValue":true}
            {"type":"switch","name":"standards.TeamsChatProtection.UrlReputationCheck","label":"Enable Malicious URL Protection","defaultValue":true}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-10-02
        POWERSHELLEQUIVALENT
            Set-CsTeamsMessagingConfiguration -FileTypeCheck 'Enabled' -UrlReputationCheck 'Enabled' -ReportIncorrectSecurityDetections 'Enabled'
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsChatProtection' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1', 'Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMessagingConfiguration' | Select-Object -Property Identity, FileTypeCheck, UrlReputationCheck
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Teams Chat Protection state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    # Set defaults to enabled if not specified
    $Settings.FileTypeCheck ??= $true
    $Settings.UrlReputationCheck ??= $true

    # Convert boolean to Enabled/Disabled string
    $FileTypeCheckState = $Settings.FileTypeCheck ? 'Enabled' : 'Disabled'
    $UrlReputationCheckState = $Settings.UrlReputationCheck ? 'Enabled' : 'Disabled'

    $StateIsCorrect = ($CurrentState.FileTypeCheck -eq $FileTypeCheckState) -and
    ($CurrentState.UrlReputationCheck -eq $UrlReputationCheckState)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Chat Protection settings already correctly configured.' -sev Info
        } else {
            $cmdParams = @{
                Identity           = 'Global'
                FileTypeCheck      = $FileTypeCheckState
                UrlReputationCheck = $UrlReputationCheckState
            }

            try {
                $null = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMessagingConfiguration' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully updated Teams Chat Protection settings to FileTypeCheck: $FileTypeCheckState, UrlReputationCheck: $UrlReputationCheckState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to configure Teams Chat Protection settings. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Chat Protection settings are configured correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Chat Protection settings are not configured correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsChatProtection' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Chat Protection settings are not configured correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsChatProtection' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsChatProtection' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsChatProtection.ps1' 102
#Region './Public/Standards/Invoke-CIPPStandardTeamsEmailIntegration.ps1' -1

Function Invoke-CIPPStandardTeamsEmailIntegration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsEmailIntegration
    .SYNOPSIS
        (Label) Disallow emails to be sent to channel email addresses
    .DESCRIPTION
        (Helptext) Should users be allowed to send emails directly to a channel email addresses?
        (DocsDescription) Teams channel email addresses are an optional feature that allows users to email the Teams channel directly.
    .NOTES
        CAT
            Teams Standards
        EXECUTIVETEXT
            Controls whether Teams channels can receive emails directly, enabling integration between email and team collaboration. This feature can improve workflow efficiency by allowing external communications to flow into team discussions, though it may need management for security or organizational reasons.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsEmailIntegration.AllowEmailIntoChannel","label":"Allow channel emails"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-30
        POWERSHELLEQUIVALENT
            Set-CsTeamsClientConfiguration -AllowEmailIntoChannel \$false
        RECOMMENDEDBY
            "CIS"
        TAG
            "CIS M365 5.0 (8.1.2)"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsEmailIntegration' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsEmailIntegration'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsClientConfiguration' -CmdParams @{Identity = 'Global' } |
        Select-Object AllowEmailIntoChannel
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsEmailIntegration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $AllowEmailIntoChannel = $Settings.AllowEmailIntoChannel ?? $false

    $StateIsCorrect = ($CurrentState.AllowEmailIntoChannel -eq $AllowEmailIntoChannel)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Email Integration settings already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity              = 'Global'
                AllowEmailIntoChannel = $AllowEmailIntoChannel
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsClientConfiguration' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Teams Email Integration settings' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Email Integration settings. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Email Integration settings is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Email Integration settings is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsEmailIntegration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Email Integration settings is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsEmailIntegration' -FieldValue $FieldValue -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'TeamsEmailIntoChannel' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsEmailIntegration.ps1' 98
#Region './Public/Standards/Invoke-CIPPStandardTeamsEnrollUser.ps1' -1

function Invoke-CIPPStandardTeamsEnrollUser {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsEnrollUser
    .SYNOPSIS
        (Label) Default voice and face enrollment
    .DESCRIPTION
        (Helptext) Controls whether users with this policy can set the voice profile capture and enrollment through the Recognition tab in their Teams client settings.
        (DocsDescription) Controls whether users with this policy can set the voice profile capture and enrollment through the Recognition tab in their Teams client settings.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Determines whether employees can enroll their voice and face profiles for recognition features in Teams, enabling personalized experiences like voice identification. This setting balances convenience features with privacy considerations and organizational policies regarding biometric data collection.
        ADDEDCOMPONENT
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.TeamsEnrollUser.EnrollUserOverride","label":"Voice and Face Enrollment","options":[{"label":"Disabled","value":"Disabled"},{"label":"Enabled","value":"Enabled"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-11-12
        POWERSHELLEQUIVALENT
            Set-CsTeamsMeetingPolicy -Identity Global -EnrollUserOverride \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsEnrollUser' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')

    # Get EnrollUserOverride value using null-coalescing operator

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $enrollUserOverride = $Settings.EnrollUserOverride.value ?? $Settings.EnrollUserOverride

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMeetingPolicy' -cmdParams @{Identity = 'Global' } |
        Select-Object EnrollUserOverride
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsEnrollUser state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.EnrollUserOverride -eq $enrollUserOverride)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams Enroll User Override settings already set to $enrollUserOverride." -sev Info
        } else {
            $cmdParams = @{
                Identity           = 'Global'
                EnrollUserOverride = $enrollUserOverride
            }

            try {
                $null = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMeetingPolicy' -cmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Updated Teams Enroll User Override setting to $enrollUserOverride." -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Enroll User Override setting to $enrollUserOverride." -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Enroll User Override settings is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Enroll User Override settings is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsEnrollUser' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Enroll User Override settings is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsEnrollUser' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsEnrollUser' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsEnrollUser.ps1' 95
#Region './Public/Standards/Invoke-CIPPStandardTeamsExternalAccessPolicy.ps1' -1

function Invoke-CIPPStandardTeamsExternalAccessPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsExternalAccessPolicy
    .SYNOPSIS
        (Label) External Access Settings for Microsoft Teams
    .DESCRIPTION
        (Helptext) Sets the properties of the Global external access policy.
        (DocsDescription) Sets the properties of the Global external access policy. External access policies determine whether or not your users can: 1) communicate with users who have Session Initiation Protocol (SIP) accounts with a federated organization; 2) communicate with users who are using custom applications built with Azure Communication Services; 3) access Skype for Business Server over the Internet, without having to log on to your internal network; 4) communicate with users who have SIP accounts with a public instant messaging (IM) provider such as Skype; and, 5) communicate with people who are using Teams with an account that's not managed by an organization.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Defines the organization's policy for communicating with external users through Teams, including other organizations, Skype users, and unmanaged accounts. This fundamental setting determines the scope of external collaboration while maintaining security boundaries for business communications.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsExternalAccessPolicy.EnableFederationAccess","label":"Allow communication from trusted organizations"}
            {"type":"switch","name":"standards.TeamsExternalAccessPolicy.EnableTeamsConsumerAccess","label":"Allow communication with unmanaged Teams accounts"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-30
        POWERSHELLEQUIVALENT
            Set-CsExternalAccessPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsExternalAccessPolicy' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsExternalAccessPolicy'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsExternalAccessPolicy' -CmdParams @{Identity = 'Global' } |
        Select-Object *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsExternalAccessPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $EnableFederationAccess = $Settings.EnableFederationAccess ?? $false
    $EnableTeamsConsumerAccess = $Settings.EnableTeamsConsumerAccess ?? $false

    $StateIsCorrect = ($CurrentState.EnableFederationAccess -eq $EnableFederationAccess) -and
    ($CurrentState.EnableTeamsConsumerAccess -eq $EnableTeamsConsumerAccess)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'External Access Policy already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity                  = 'Global'
                EnableFederationAccess    = $EnableFederationAccess
                EnableTeamsConsumerAccess = $EnableTeamsConsumerAccess
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsExternalAccessPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated External Access Policy' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set External Access Policy. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'External Access Policy is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'External Access Policy is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsExternalAccessPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'External Access Policy is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsExternalAccessPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object EnableFederationAccess, EnableTeamsConsumerAccess
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsExternalAccessPolicy' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsExternalAccessPolicy.ps1' 100
#Region './Public/Standards/Invoke-CIPPStandardTeamsExternalChatWithAnyone.ps1' -1

function Invoke-CIPPStandardTeamsExternalChatWithAnyone {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsExternalChatWithAnyone
    .SYNOPSIS
        (Label) Control Teams "Chat with anyone" feature
    .DESCRIPTION
        (Helptext) Manages whether users can initiate Microsoft Teams chats with any email address, inviting non-Teams users as guests via email.
        (DocsDescription) Manages the UseB2BInvitesToAddExternalUsers setting on the global Teams messaging policy. When enabled, users can start chats with any email address and external recipients receive an invitation to join as guests. Disabling the setting prevents external email-based chats from being created, keeping conversations restricted to approved collaborators.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Controls whether employees can start Microsoft Teams chats with anyone using just their email address. Turning this off keeps chat conversations restricted to internal users and pre-approved guests, reducing the risk of data exposure through unexpected external invitations.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsExternalChatWithAnyone.UseB2BInvitesToAddExternalUsers","label":"Allow chatting with anyone via email","defaultValue":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-11-03
        POWERSHELLEQUIVALENT
            Set-CsTeamsMessagingPolicy -Identity Global -UseB2BInvitesToAddExternalUsers $false
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsExternalChatWithAnyone' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1', 'Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    }

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMessagingPolicy' -CmdParams @{ Identity = 'Global' } | Select-Object -Property Identity, UseB2BInvitesToAddExternalUsers
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the Teams external chat state for $Tenant. Error: $($ErrorMessage.NormalizedError)" -Sev Error -LogData $ErrorMessage
        return
    }

    # Set default to Disabled if not specified. Should not be possible without some serious misconfiguration via the API
    $Settings.UseB2BInvitesToAddExternalUsers ??= $false
    $DesiredState = [System.Convert]::ToBoolean($Settings.UseB2BInvitesToAddExternalUsers)
    $StateIsCorrect = ($CurrentState.UseB2BInvitesToAddExternalUsers -eq $DesiredState)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams external chat with anyone setting already set to: $DesiredState" -sev Info
        } else {
            $cmdParams = @{
                Identity                        = 'Global'
                UseB2BInvitesToAddExternalUsers = $DesiredState
            }

            try {
                $null = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMessagingPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully updated Teams external chat with anyone setting to UseB2BInvitesToAddExternalUsers: $DesiredState" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to configure Teams external chat with anyone setting. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams external chat setting is configured correctly as: $DesiredState" -sev Info
        } else {
            Write-StandardsAlert -message 'Teams external chat setting is not configured correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsExternalChatWithAnyone' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams external chat setting is not configured correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsExternalChatWithAnyone' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsExternalChatWithAnyone' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsExternalChatWithAnyone.ps1' 94
#Region './Public/Standards/Invoke-CIPPStandardTeamsExternalFileSharing.ps1' -1

function Invoke-CIPPStandardTeamsExternalFileSharing {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsExternalFileSharing
    .SYNOPSIS
        (Label) Define approved cloud storage services for external file sharing in Teams
    .DESCRIPTION
        (Helptext) Ensure external file sharing in Teams is enabled for only approved cloud storage services.
        (DocsDescription) Ensure external file sharing in Teams is enabled for only approved cloud storage services.
    .NOTES
        CAT
            Teams Standards
        TAG
            "CIS M365 5.0 (8.4.1)"
        EXECUTIVETEXT
            Controls which external cloud storage services (like Google Drive, Dropbox, Box) employees can access through Teams, ensuring file sharing occurs only through approved and secure platforms. This helps maintain data governance while supporting necessary business integrations.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsExternalFileSharing.AllowGoogleDrive","label":"Allow Google Drive"}
            {"type":"switch","name":"standards.TeamsExternalFileSharing.AllowShareFile","label":"Allow ShareFile"}
            {"type":"switch","name":"standards.TeamsExternalFileSharing.AllowBox","label":"Allow Box"}
            {"type":"switch","name":"standards.TeamsExternalFileSharing.AllowDropBox","label":"Allow Dropbox"}
            {"type":"switch","name":"standards.TeamsExternalFileSharing.AllowEgnyte","label":"Allow Egnyte"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-07-28
        POWERSHELLEQUIVALENT
            Set-CsTeamsClientConfiguration -AllowGoogleDrive \$false -AllowShareFile \$false -AllowBox \$false -AllowDropBox \$false -AllowEgnyte \$false
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsExternalFileSharing' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsExternalFileSharing'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsClientConfiguration' |
        Select-Object AllowGoogleDrive, AllowShareFile, AllowBox, AllowDropBox, AllowEgnyte
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsExternalFileSharing state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.AllowGoogleDrive -eq $Settings.AllowGoogleDrive ?? $false ) -and
    ($CurrentState.AllowShareFile -eq $Settings.AllowShareFile ?? $false ) -and
    ($CurrentState.AllowBox -eq $Settings.AllowBox ?? $false ) -and
    ($CurrentState.AllowDropBox -eq $Settings.AllowDropBox ?? $false ) -and
    ($CurrentState.AllowEgnyte -eq $Settings.AllowEgnyte ?? $false )

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams External File Sharing already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity         = 'Global'
                AllowGoogleDrive = $Settings.AllowGoogleDrive
                AllowShareFile   = $Settings.AllowShareFile
                AllowBox         = $Settings.AllowBox
                AllowDropBox     = $Settings.AllowDropBox
                AllowEgnyte      = $Settings.AllowEgnyte
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsClientConfiguration' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Teams External File Sharing' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams External File Sharing. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams External File Sharing is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams External File Sharing is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsExternalFileSharing' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams External File Sharing is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsExternalFileSharing' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsExternalFileSharing' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsExternalFileSharing.ps1' 107
#Region './Public/Standards/Invoke-CIPPStandardTeamsFederationConfiguration.ps1' -1

function Invoke-CIPPStandardTeamsFederationConfiguration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsFederationConfiguration
    .SYNOPSIS
        (Label) Federation Configuration for Microsoft Teams
    .DESCRIPTION
        (Helptext) Sets the properties of the Global federation configuration.
        (DocsDescription) Sets the properties of the Global federation configuration. Federation configuration settings determine whether or not your users can communicate with users who have SIP accounts with a federated organization.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Configures how the organization federates with external organizations for Teams communication, controlling whether employees can communicate with specific external domains or all external organizations. This setting enables secure inter-organizational collaboration while maintaining control over external communications.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsFederationConfiguration.AllowTeamsConsumer","label":"Allow users to communicate with other organizations"}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.TeamsFederationConfiguration.DomainControl","label":"Communication Mode","options":[{"label":"Allow all external domains","value":"AllowAllExternal"},{"label":"Block all external domains","value":"BlockAllExternal"},{"label":"Allow specific external domains","value":"AllowSpecificExternal"},{"label":"Block specific external domains","value":"BlockSpecificExternal"}]}
            {"type":"textField","name":"standards.TeamsFederationConfiguration.DomainList","label":"Domains, Comma separated","required":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-07-31
        POWERSHELLEQUIVALENT
            Set-CsTenantFederationConfiguration
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsFederationConfiguration' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsFederationConfiguration'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTenantFederationConfiguration' -CmdParams @{Identity = 'Global' } |
        Select-Object *
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsFederationConfiguration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $AllowAllKnownDomains = New-CsEdgeAllowAllKnownDomains
    $DomainControl = $Settings.DomainControl.value ?? $Settings.DomainControl
    $AllowedDomainsAsAList = @()
    switch ($DomainControl) {
        'AllowAllExternal' {
            $AllowFederatedUsers = $true
            $AllowedDomains = $AllowAllKnownDomains
            $BlockedDomains = @()
        }
        'BlockAllExternal' {
            $AllowFederatedUsers = $false
            $AllowedDomains = $AllowAllKnownDomains
            $BlockedDomains = @()
        }
        'AllowSpecificExternal' {
            $AllowFederatedUsers = $true
            $BlockedDomains = @()
            if ($null -ne $Settings.DomainList) {
                $AllowedDomainsAsAList = @($Settings.DomainList).Split(',').Trim()
            } else {
                $AllowedDomainsAsAList = @()
            }
        }
        'BlockSpecificExternal' {
            $AllowFederatedUsers = $true
            $AllowedDomainsAsAList = 'AllowAllKnownDomains'
            if ($null -ne $Settings.DomainList) {
                $BlockedDomains = @($Settings.DomainList).Split(',').Trim()
            } else {
                $BlockedDomains = @()
            }
        }
        default {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Federation Configuration: Invalid $DomainControl parameter" -sev Error
            return
        }
    }

    $CurrentAllowedDomains = $CurrentState.AllowedDomains
    if ($CurrentAllowedDomains.GetType().Name -eq 'PSObject') {
        $CurrentAllowedDomains = $CurrentAllowedDomains.Domain | Sort-Object
        $DomainList = ($CurrentAllowedDomains | Sort-Object) ?? @()
        $AllowedDomainsMatches = -not (Compare-Object -ReferenceObject $AllowedDomainsAsAList -DifferenceObject $DomainList)
    } elseif ($CurrentAllowedDomains.GetType().Name -eq 'Deserialized.Microsoft.Rtc.Management.WritableConfig.Settings.Edge.AllowAllKnownDomains') {
        $CurrentAllowedDomains = $CurrentAllowedDomains.ToString()
        $AllowedDomainsMatches = $CurrentAllowedDomains -eq $AllowedDomains.ToString()
    }

    $BlockedDomainsMatches = -not (Compare-Object -ReferenceObject $BlockedDomains -DifferenceObject $CurrentState.BlockedDomains)

    $StateIsCorrect = ($CurrentState.AllowTeamsConsumer -eq $Settings.AllowTeamsConsumer) -and
    ($CurrentState.AllowFederatedUsers -eq $AllowFederatedUsers) -and
    $AllowedDomainsMatches -and
    $BlockedDomainsMatches

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Federation Configuration already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity            = 'Global'
                AllowTeamsConsumer  = $Settings.AllowTeamsConsumer
                AllowFederatedUsers = $AllowFederatedUsers
                BlockedDomains      = $BlockedDomains
            }

            if (!$AllowedDomainsAsAList) {
                $cmdParams.AllowedDomains = $AllowedDomains
            } else {
                $cmdParams.AllowedDomainsAsAList = $AllowedDomainsAsAList
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTenantFederationConfiguration' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Federation Configuration Policy' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Federation Configuration Policy. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Federation Configuration is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Federation Configuration is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsFederationConfiguration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Federation Configuration is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'FederationConfiguration' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect -eq $true) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object AllowTeamsConsumer, AllowFederatedUsers, AllowedDomains, BlockedDomains
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsFederationConfiguration' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsFederationConfiguration.ps1' 155
#Region './Public/Standards/Invoke-CIPPStandardTeamsGlobalMeetingPolicy.ps1' -1

function Invoke-CIPPStandardTeamsGlobalMeetingPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsGlobalMeetingPolicy
    .SYNOPSIS
        (Label) Define Global Meeting Policy for Teams
    .DESCRIPTION
        (Helptext) Defines the CIS recommended global meeting policy for Teams. This includes AllowAnonymousUsersToJoinMeeting, AllowAnonymousUsersToStartMeeting, AutoAdmittedUsers, AllowPSTNUsersToBypassLobby, MeetingChatEnabledType, DesignatedPresenterRoleMode, AllowExternalParticipantGiveRequestControl
        (DocsDescription) Defines the CIS recommended global meeting policy for Teams. This includes AllowAnonymousUsersToJoinMeeting, AllowAnonymousUsersToStartMeeting, AutoAdmittedUsers, AllowPSTNUsersToBypassLobby, MeetingChatEnabledType, DesignatedPresenterRoleMode, AllowExternalParticipantGiveRequestControl
    .NOTES
        CAT
            Teams Standards
        TAG
            "CIS M365 5.0 (8.5.1)"
            "CIS M365 5.0 (8.5.2)"
            "CIS M365 5.0 (8.5.3)"
            "CIS M365 5.0 (8.5.4)"
            "CIS M365 5.0 (8.5.5)"
            "CIS M365 5.0 (8.5.6)"
        EXECUTIVETEXT
            Establishes security-focused default settings for Teams meetings, controlling who can join meetings, present content, and participate in chats. These policies balance collaboration needs with security requirements, ensuring meetings remain productive while protecting against unauthorized access and disruption.
            ADDEDCOMPONENT
                {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.TeamsGlobalMeetingPolicy.DesignatedPresenterRoleMode","label":"Default value of the `Who can present?`","options":[{"label":"EveryoneUserOverride","value":"EveryoneUserOverride"},{"label":"EveryoneInCompanyUserOverride","value":"EveryoneInCompanyUserOverride"},{"label":"EveryoneInSameAndFederatedCompanyUserOverride","value":"EveryoneInSameAndFederatedCompanyUserOverride"},{"label":"OrganizerOnlyUserOverride","value":"OrganizerOnlyUserOverride"}]}
                {"type":"switch","name":"standards.TeamsGlobalMeetingPolicy.AllowAnonymousUsersToJoinMeeting","label":"Allow anonymous users to join meeting"}
                {"type":"autoComplete","required":false,"multiple":false,"creatable":false,"name":"standards.TeamsGlobalMeetingPolicy.AutoAdmittedUsers","label":"Who can bypass the lobby?","helperText":"If left blank, People in my org remains enforced.","options":[{"label":"Everyone","value":"Everyone"},{"label":"People in my org","value":"EveryoneInCompanyExcludingGuests"},{"label":"People in or federated orgs","value":"EveryoneInSameAndFederatedCompany"},{"label":"People invited","value":"InvitedUsers"},{"label":"Only me","value":"OrganizerOnly"}]}
                {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.TeamsGlobalMeetingPolicy.MeetingChatEnabledType","label":"Meeting chat policy","options":[{"label":"On for everyone","value":"Enabled"},{"label":"On for everyone but anonymous users","value":"EnabledExceptAnonymous"},{"label":"Off for everyone","value":"Disabled"}]}
                {"type":"switch","name":"standards.TeamsGlobalMeetingPolicy.AllowExternalParticipantGiveRequestControl","label":"External participants can give or request control"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-11-12
            POWERSHELLEQUIVALENT
                Set-CsTeamsMeetingPolicy -AllowAnonymousUsersToJoinMeeting $false -AllowAnonymousUsersToStartMeeting $false -AutoAdmittedUsers $AutoAdmittedUsers -AllowPSTNUsersToBypassLobby $false -MeetingChatEnabledType EnabledExceptAnonymous -DesignatedPresenterRoleMode $DesignatedPresenterRoleMode -AllowExternalParticipantGiveRequestControl $false
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsGlobalMeetingPolicy'

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsGlobalMeetingPolicy' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1', 'Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMeetingPolicy' -CmdParams @{Identity = 'Global' } |
            Select-Object AllowAnonymousUsersToJoinMeeting, AllowAnonymousUsersToStartMeeting, AutoAdmittedUsers, AllowPSTNUsersToBypassLobby, MeetingChatEnabledType, DesignatedPresenterRoleMode, AllowExternalParticipantGiveRequestControl
    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsGlobalMeetingPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $MeetingChatEnabledType = $Settings.MeetingChatEnabledType.value ?? $Settings.MeetingChatEnabledType
    $DesignatedPresenterRoleMode = $Settings.DesignatedPresenterRoleMode.value ?? $Settings.DesignatedPresenterRoleMode
    $AutoAdmittedUsers = $Settings.AutoAdmittedUsers.value ?? $Settings.AutoAdmittedUsers ?? $CurrentState.AutoAdmittedUsers # Default to current state if not set, for backward compatibility pre v8.6.0

    $StateIsCorrect = ($CurrentState.AllowAnonymousUsersToJoinMeeting -eq $Settings.AllowAnonymousUsersToJoinMeeting) -and
    ($CurrentState.AllowAnonymousUsersToStartMeeting -eq $false) -and
    ($CurrentState.AutoAdmittedUsers -eq $AutoAdmittedUsers) -and
    ($CurrentState.AllowPSTNUsersToBypassLobby -eq $false) -and
    ($CurrentState.MeetingChatEnabledType -eq $MeetingChatEnabledType) -and
    ($CurrentState.DesignatedPresenterRoleMode -eq $DesignatedPresenterRoleMode) -and
    ($CurrentState.AllowExternalParticipantGiveRequestControl -eq $Settings.AllowExternalParticipantGiveRequestControl)


    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Global Policy already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity                                   = 'Global'
                AllowAnonymousUsersToJoinMeeting           = $Settings.AllowAnonymousUsersToJoinMeeting
                AllowAnonymousUsersToStartMeeting          = $false
                AutoAdmittedUsers                          = $AutoAdmittedUsers
                AllowPSTNUsersToBypassLobby                = $false
                MeetingChatEnabledType                     = $MeetingChatEnabledType
                DesignatedPresenterRoleMode                = $DesignatedPresenterRoleMode
                AllowExternalParticipantGiveRequestControl = $Settings.AllowExternalParticipantGiveRequestControl
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMeetingPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Teams Global Policy' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Global Policy. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Global Policy is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Global Policy is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsGlobalMeetingPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Global Policy is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsGlobalMeetingPolicy' -FieldValue $FieldValue -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'TeamsGlobalMeetingPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsGlobalMeetingPolicy.ps1' 121
#Region './Public/Standards/Invoke-CIPPStandardTeamsGuestAccess.ps1' -1

function Invoke-CIPPStandardTeamsGuestAccess {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsGuestAccess
    .SYNOPSIS
        (Label) Allow guest users in Teams
    .DESCRIPTION
        (Helptext) Allow guest users access to teams.
        (DocsDescription) Allow guest users access to teams. Guest users are users who are not part of your organization but have been invited to collaborate with your organization in Teams. This setting allows you to control whether guest users can access Teams.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Determines whether external partners, vendors, and collaborators can be invited to participate in Teams conversations and meetings. This fundamental setting enables external collaboration while requiring careful management to balance openness with security and information protection.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsGuestAccess.AllowGuestUser","label":"Allow guest users"}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-03
        POWERSHELLEQUIVALENT
            Set-CsTeamsClientConfiguration -AllowGuestUser \$true
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsGuestAccess' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsClientConfiguration' -CmdParams @{Identity = 'Global' } |
        Select-Object AllowGuestUser
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsGuestAccess state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $AllowGuestUser = $Settings.AllowGuestUser ?? $false

    $StateIsCorrect = ($CurrentState.AllowGuestUser -eq $AllowGuestUser)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Guest Access already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity       = 'Global'
                AllowGuestUser = $AllowGuestUser
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsClientConfiguration' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Teams Guest Access settings' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Guest Access settings. Error: $ErrorMessage" -sev Error
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Guest Access settings is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Guest Access settings is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsGuestAccess' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Guest Access settings is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsGuestAccess' -FieldValue $FieldValue -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'TeamsGuestAccess' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsGuestAccess.ps1' 94
#Region './Public/Standards/Invoke-CIPPStandardTeamsMeetingRecordingExpiration.ps1' -1

function Invoke-CIPPStandardTeamsMeetingRecordingExpiration {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsMeetingRecordingExpiration
    .SYNOPSIS
        (Label) Set Teams Meeting Recording Expiration
    .DESCRIPTION
        (Helptext) Sets the default number of days after which Teams meeting recordings automatically expire. Valid values are -1 (Never Expire) or between 1 and 99999. The default value is 120 days.
        (DocsDescription) Allows administrators to configure a default expiration period (in days) for Teams meeting recordings. Recordings older than this period will be automatically moved to the recycle bin. This setting helps manage storage consumption and enforce data retention policies.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Automatically removes old Teams meeting recordings after a specified period to manage storage costs and comply with data retention policies. This helps organizations balance the need to preserve important meeting content with storage efficiency and regulatory compliance requirements.
        ADDEDCOMPONENT
            {"type":"number","name":"standards.TeamsMeetingRecordingExpiration.ExpirationDays","label":"Recording Expiration Days (e.g., 365)","required":true}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-04-17
        POWERSHELLEQUIVALENT
            Set-CsTeamsMeetingPolicy -Identity Global -MeetingRecordingExpirationDays \<days\>
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsMeetingRecordingExpiration'

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsMeetingRecordingExpiration' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')

    # Input validation

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    $ExpirationDays = try { [int64]$Settings.ExpirationDays } catch { Write-Warning "Invalid ExpirationDays value provided: $($Settings.ExpirationDays)"; return }
    if (($ExpirationDays -ne -1) -and ($ExpirationDays -lt 1 -or $ExpirationDays -gt 99999)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Invalid ExpirationDays value: $ExpirationDays. Must be -1 (Never Expire) or between 1 and 99999." -sev Error
        return
    }

    try {
        $CurrentExpirationDays = (New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMeetingPolicy' -CmdParams @{Identity = 'Global' }).NewMeetingRecordingExpirationDays
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsMeetingRecordingExpiration state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = if ($CurrentExpirationDays -eq $ExpirationDays) { $true } else { $false }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams Meeting Recording Expiration Policy already set to $ExpirationDays days." -sev Info
        } else {
            $cmdParams = @{
                Identity                          = 'Global'
                NewMeetingRecordingExpirationDays = $ExpirationDays
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMeetingPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully updated Teams Meeting Recording Expiration Policy to $ExpirationDays days." -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Meeting Recording Expiration Policy. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams Meeting Recording Expiration Policy is set correctly ($($CurrentExpirationDays) days)." -sev Info
        } else {
            Write-StandardsAlert -message "Teams Meeting Recording Expiration Policy is not set correctly. Current: $CurrentExpirationDays days, Desired: $ExpirationDays days." -object $CurrentExpirationDays -tenant $Tenant -standardName 'TeamsMeetingRecordingExpiration' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Teams Meeting Recording Expiration Policy is not set correctly (Current: $CurrentExpirationDays, Desired: $ExpirationDays)." -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsMeetingRecordingExpiration' -FieldValue $CurrentExpirationDays -StoreAs string -Tenant $Tenant

        $CurrentExpirationDays = if ($StateIsCorrect) { $true } else { $CurrentExpirationDays }

        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsMeetingRecordingExpiration' -FieldValue $CurrentExpirationDays -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsMeetingRecordingExpiration.ps1' 97
#Region './Public/Standards/Invoke-CIPPStandardTeamsMeetingsByDefault.ps1' -1

function Invoke-CIPPStandardTeamsMeetingsByDefault {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsMeetingsByDefault
    .SYNOPSIS
        (Label) Set Teams Meetings by default state
    .DESCRIPTION
        (Helptext) Sets the default state for automatically turning meetings into Teams meetings for the tenant. This can be overridden by the user in Outlook.
        (DocsDescription) Sets the default state for automatically turning meetings into Teams meetings for the tenant. This can be overridden by the user in Outlook.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Automatically adds Microsoft Teams meeting links to calendar invitations by default, streamlining the process of creating virtual meetings. This improves collaboration efficiency and ensures consistent meeting experiences across the organization, though users can override this setting when needed.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.TeamsMeetingsByDefault.state","options":[{"label":"Enabled","value":"true"},{"label":"Disabled","value":"false"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-05-31
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -OnlineMeetingsByDefaultEnabled
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsMeetingsByDefault' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsMeetingsByDefault'

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').OnlineMeetingsByDefaultEnabled
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsMeetingsByDefault state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $WantedState = if ($state -eq 'true') { $true } else { $false }
    $StateIsCorrect = if ($CurrentState -eq $WantedState) { $true } else { $false }

    # Input validation
    if (([string]::IsNullOrWhiteSpace($state) -or $state -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'TeamsMeetingsByDefault: Invalid state parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate'
        if ($StateIsCorrect -eq $false) {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ OnlineMeetingsByDefaultEnabled = $WantedState } -useSystemMailbox $true
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set the tenant TeamsMeetingsByDefault state to $state" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set the tenant TeamsMeetingsByDefault state to $state. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant TeamsMeetingsByDefault state is already set correctly to $state" -sev Info
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant TeamsMeetingsByDefault is set correctly to $state" -sev Info
        } else {
            Write-StandardsAlert -message "The tenant TeamsMeetingsByDefault is not set correctly to $state" -object @{CurrentState = $CurrentState; WantedState = $WantedState } -tenant $Tenant -standardName 'TeamsMeetingsByDefault' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The tenant TeamsMeetingsByDefault is not set correctly to $state" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        # Default is not set, not set means it's enabled
        if ($null -eq $CurrentState ) { $CurrentState = $true }
        Add-CIPPBPAField -FieldName 'TeamsMeetingsByDefault' -FieldValue $CurrentState -StoreAs bool -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsMeetingsByDefault' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsMeetingsByDefault.ps1' 100
#Region './Public/Standards/Invoke-CIPPStandardTeamsMeetingVerification.ps1' -1

function Invoke-CIPPStandardTeamsMeetingVerification {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsMeetingVerification
    .SYNOPSIS
        (Label) Teams Meeting Verification (CAPTCHA)
    .DESCRIPTION
        (Helptext) Configures CAPTCHA verification for external users joining Teams meetings. This helps prevent unauthorized AI notetakers and bots from joining meetings.
        (DocsDescription) Configures CAPTCHA verification for external users joining Teams meetings. This security feature requires external participants to complete a CAPTCHA challenge before joining, which helps prevent unauthorized AI notetakers, bots, and other automated systems from accessing meetings.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Requires external meeting participants to complete verification challenges before joining Teams meetings, preventing automated bots and unauthorized AI systems from accessing confidential discussions. This security measure protects against meeting infiltration while maintaining legitimate external collaboration.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"CAPTCHA Verification Setting","name":"standards.TeamsMeetingVerification.CaptchaVerificationForMeetingJoin","options":[{"label":"Not Required","value":"NotRequired"},{"label":"Anonymous Users and Untrusted Organizations","value":"AnonymousUsersAndUntrustedOrganizations"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-14
        POWERSHELLEQUIVALENT
            Set-CsTeamsMeetingPolicy -CaptchaVerificationForMeetingJoin
        RECOMMENDEDBY
            "CIPP"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsMeetingVerification'

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsMeetingVerification' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMeetingPolicy' -CmdParams @{Identity = 'Global' } |
        Select-Object CaptchaVerificationForMeetingJoin
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsMeetingVerification state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $CaptchaVerificationForMeetingJoin = $Settings.CaptchaVerificationForMeetingJoin.value ?? $Settings.CaptchaVerificationForMeetingJoin
    $StateIsCorrect = ($CurrentState.CaptchaVerificationForMeetingJoin -eq $CaptchaVerificationForMeetingJoin)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Meeting Verification Policy already set.' -sev Info
        } else {
            $cmdParams = @{
                Identity                         = 'Global'
                CaptchaVerificationForMeetingJoin = $CaptchaVerificationForMeetingJoin
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMeetingPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated Teams Meeting Verification Policy' -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Teams Meeting Verification Policy. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Meeting Verification Policy is set correctly.' -sev Info
        } else {
            Write-StandardsAlert -message 'Teams Meeting Verification Policy is not set correctly.' -object $CurrentState -tenant $Tenant -standardName 'TeamsMeetingVerification' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Teams Meeting Verification Policy is not set correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsMeetingVerification' -FieldValue $FieldValue -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'TeamsMeetingVerification' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsMeetingVerification.ps1' 94
#Region './Public/Standards/Invoke-CIPPStandardTeamsMessagingPolicy.ps1' -1

Function Invoke-CIPPStandardTeamsMessagingPolicy {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TeamsMessagingPolicy
    .SYNOPSIS
        (Label) Global Messaging Policy for Microsoft Teams
    .DESCRIPTION
        (Helptext) Sets the properties of the Global messaging policy.
        (DocsDescription) Sets the properties of the Global messaging policy. Messaging policies control which chat and channel messaging features are available to users in Teams.
    .NOTES
        CAT
            Teams Standards
        TAG
        EXECUTIVETEXT
            Defines what messaging capabilities employees have in Teams, including the ability to edit or delete messages, create custom emojis, and report inappropriate content. These policies help maintain professional communication standards while enabling necessary collaboration features.
        ADDEDCOMPONENT
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowOwnerDeleteMessage","label":"Allow Owner to Delete Messages","defaultValue":false}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowUserDeleteMessage","label":"Allow User to Delete Messages","defaultValue":true}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowUserEditMessage","label":"Allow User to Edit Messages","defaultValue":true}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowUserDeleteChat","label":"Allow User to Delete Chats","defaultValue":true}
            {"type":"autoComplete","required":true,"multiple":false,"creatable":false,"name":"standards.TeamsMessagingPolicy.ReadReceiptsEnabledType","label":"Read Receipts Enabled Type","options":[{"label":"User controlled","value":"UserPreference"},{"label":"Turned on for everyone","value":"Everyone"},{"label":"Turned off for everyone","value":"None"}]}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.CreateCustomEmojis","label":"Allow Creating Custom Emojis","defaultValue":true}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.DeleteCustomEmojis","label":"Allow Deleting Custom Emojis","defaultValue":false}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowSecurityEndUserReporting","label":"Allow reporting message as security concern","defaultValue":true}
            {"type":"switch","name":"standards.TeamsMessagingPolicy.AllowCommunicationComplianceEndUserReporting","label":"Allow reporting message as inappropriate content","defaultValue":true}
        IMPACT
            Medium Impact
        ADDEDDATE
            2025-01-10
        POWERSHELLEQUIVALENT
            Set-CsTeamsMessagingPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TeamsMessagingPolicy'

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TeamsMessagingPolicy' -TenantFilter $Tenant -RequiredCapabilities @('MCOSTANDARD', 'MCOEV', 'MCOIMP', 'TEAMS1','Teams_Room_Standard')

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Get-CsTeamsMessagingPolicy' -CmdParams @{Identity = 'Global' }
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TeamsMessagingPolicy state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($null -eq $Settings.AllowOwnerDeleteMessage) { $Settings.AllowOwnerDeleteMessage = $CurrentState.AllowOwnerDeleteMessage }
    if ($null -eq $Settings.AllowUserDeleteMessage) { $Settings.AllowUserDeleteMessage = $CurrentState.AllowUserDeleteMessage }
    if ($null -eq $Settings.AllowUserEditMessage) { $Settings.AllowUserEditMessage = $CurrentState.AllowUserEditMessage }
    if ($null -eq $Settings.AllowUserDeleteChat) { $Settings.AllowUserDeleteChat = $CurrentState.AllowUserDeleteChat }
    if ($null -eq $Settings.CreateCustomEmojis) { $Settings.CreateCustomEmojis = $CurrentState.CreateCustomEmojis }
    if ($null -eq $Settings.DeleteCustomEmojis) { $Settings.DeleteCustomEmojis = $CurrentState.DeleteCustomEmojis }
    if ($null -eq $Settings.AllowSecurityEndUserReporting) { $Settings.AllowSecurityEndUserReporting = $CurrentState.AllowSecurityEndUserReporting }
    if ($null -eq $Settings.AllowCommunicationComplianceEndUserReporting) { $Settings.AllowCommunicationComplianceEndUserReporting = $CurrentState.AllowCommunicationComplianceEndUserReporting }

    $ReadReceiptsEnabledType = $Settings.ReadReceiptsEnabledType.value ?? $Settings.ReadReceiptsEnabledType

    $StateIsCorrect = ($CurrentState.AllowOwnerDeleteMessage -eq $Settings.AllowOwnerDeleteMessage) -and
                        ($CurrentState.AllowUserDeleteMessage -eq $Settings.AllowUserDeleteMessage) -and
                        ($CurrentState.AllowUserEditMessage -eq $Settings.AllowUserEditMessage) -and
                        ($CurrentState.AllowUserDeleteChat -eq $Settings.AllowUserDeleteChat) -and
                        ($CurrentState.ReadReceiptsEnabledType -eq $ReadReceiptsEnabledType) -and
                        ($CurrentState.CreateCustomEmojis -eq $Settings.CreateCustomEmojis) -and
                        ($CurrentState.DeleteCustomEmojis -eq $Settings.DeleteCustomEmojis) -and
                        ($CurrentState.AllowSecurityEndUserReporting -eq $Settings.AllowSecurityEndUserReporting) -and
                        ($CurrentState.AllowCommunicationComplianceEndUserReporting -eq $Settings.AllowCommunicationComplianceEndUserReporting)

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Global Teams Messaging policy already configured.' -sev Info
        } else {
            $cmdParams = @{
                Identity                                     = 'Global'
                AllowOwnerDeleteMessage                      = $Settings.AllowOwnerDeleteMessage
                AllowUserDeleteMessage                       = $Settings.AllowUserDeleteMessage
                AllowUserEditMessage                         = $Settings.AllowUserEditMessage
                AllowUserDeleteChat                          = $Settings.AllowUserDeleteChat
                ReadReceiptsEnabledType                      = $ReadReceiptsEnabledType
                CreateCustomEmojis                           = $Settings.CreateCustomEmojis
                DeleteCustomEmojis                           = $Settings.DeleteCustomEmojis
                AllowSecurityEndUserReporting                = $Settings.AllowSecurityEndUserReporting
                AllowCommunicationComplianceEndUserReporting = $Settings.AllowCommunicationComplianceEndUserReporting
            }

            try {
                New-TeamsRequest -TenantFilter $Tenant -Cmdlet 'Set-CsTeamsMessagingPolicy' -CmdParams $cmdParams
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Updated global Teams messaging policy' -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Failed to configure global Teams messaging policy.' -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Global Teams messaging policy is configured correctly.' -sev Info
        } else {
            Write-StandardsAlert -message "Global Teams messaging policy is not configured correctly." -object $CurrentState -tenant $Tenant -standardName 'TeamsMessagingPolicy' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Global Teams messaging policy is not configured correctly.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TeamsMessagingPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TeamsMessagingPolicy' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTeamsMessagingPolicy.ps1' 127
#Region './Public/Standards/Invoke-CIPPStandardTenantDefaultTimezone.ps1' -1

function Invoke-CIPPStandardTenantDefaultTimezone {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TenantDefaultTimezone
    .SYNOPSIS
        (Label) Set Default Timezone for Tenant
    .DESCRIPTION
        (Helptext) Sets the default timezone for the tenant. This will be used for all new users and sites.
        (DocsDescription) Sets the default timezone for the tenant. This will be used for all new users and sites.
    .NOTES
        CAT
            SharePoint Standards
        TAG
        EXECUTIVETEXT
            Standardizes the timezone setting across all SharePoint sites and new user accounts, ensuring consistent scheduling and time-based operations throughout the organization. This improves collaboration efficiency and reduces confusion in global or multi-timezone organizations.
        ADDEDCOMPONENT
            {"type":"TimezoneSelect","name":"standards.TenantDefaultTimezone.Timezone","label":"Timezone"}
        IMPACT
            Low Impact
        ADDEDDATE
            2024-04-20
        POWERSHELLEQUIVALENT
            Update-MgBetaAdminSharePointSetting
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TenantDefaultTimezone' -TenantFilter $Tenant -RequiredCapabilities @('SHAREPOINTWAC', 'SHAREPOINTSTANDARD', 'SHAREPOINTENTERPRISE', 'SHAREPOINTENTERPRISE_EDU','ONEDRIVE_BASIC', 'ONEDRIVE_ENTERPRISE')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TenantDefaultTimezone'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = New-GraphGetRequest -Uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -tenantid $Tenant -AsApp $true
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the TenantDefaultTimezone state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $ExpectedTimezone = $Settings.Timezone.value
    $StateIsCorrect = $CurrentState.tenantDefaultTimezone -eq $ExpectedTimezone

    # Input validation
    if (([string]::IsNullOrWhiteSpace($Settings.Timezone) -or $Settings.Timezone -eq 'Select a value') -and ($Settings.remediate -eq $true -or $Settings.alert -eq $true)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'TenantDefaultTimezone: Invalid Timezone parameter set' -sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Tenant Default Timezone is already set to $ExpectedTimezone" -sev Info
        } else {
            try {
                New-GraphPostRequest -tenantid $Tenant -uri 'https://graph.microsoft.com/beta/admin/sharepoint/settings' -AsApp $true -Type PATCH -Body "{`"tenantDefaultTimezone`": `"$ExpectedTimezone`"}" -ContentType 'application/json'
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully updated Tenant Default Timezone to $ExpectedTimezone" -sev Info
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set Tenant Default Timezone. Error: $ErrorMessage" -sev Error
            }
        }

    }
    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Tenant Default Timezone is set to $ExpectedTimezone." -sev Info
        } else {
            Write-StandardsAlert -message 'Tenant Default Timezone is not set to the desired value.' -object $CurrentState -tenant $Tenant -standardName 'TenantDefaultTimezone' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Tenant Default Timezone is not set to the desired value.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'TenantDefaultTimezone' -FieldValue $CurrentState.tenantDefaultTimezone -StoreAs string -Tenant $Tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState | Select-Object tenantDefaultTimezone
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.TenantDefaultTimezone' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTenantDefaultTimezone.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardTransportRuleTemplate.ps1' -1

function Invoke-CIPPStandardTransportRuleTemplate {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TransportRuleTemplate
    .SYNOPSIS
        (Label) Transport Rule Template
    .DESCRIPTION
        (Helptext) Deploy transport rules to manage email flow.
        (DocsDescription) Deploy transport rules to manage email flow.
    .NOTES
        CAT
            Templates
        DISABLEDFEATURES
            {"report":true,"warn":true,"remediate":false}
        IMPACT
            Medium Impact
        ADDEDDATE
            2023-12-30
        EXECUTIVETEXT
            Deploys standardized email flow rules that automatically manage how emails are processed, filtered, and routed within the organization. These templates ensure consistent email security policies, compliance requirements, and business rules are applied across all email communications.
        ADDEDCOMPONENT
            {"type":"autoComplete","name":"transportRuleTemplate","label":"Select Transport Rule Template","api":{"url":"/api/ListTransportRulesTemplates","labelField":"name","valueField":"GUID","queryKey":"ListTransportRulesTemplates"}}
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>
    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TransportRuleTemplate' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TransportRuleTemplate'
    $existingRules = New-ExoRequest -ErrorAction SilentlyContinue -tenantid $Tenant -cmdlet 'Get-TransportRule' -useSystemMailbox $true
    if ($Settings.remediate -eq $true) {
        Write-Host "Settings: $($Settings | ConvertTo-Json)"
        $Settings.transportRuleTemplate ? ($Settings | Add-Member -NotePropertyName 'TemplateList' -NotePropertyValue $Settings.transportRuleTemplate) : $null
        foreach ($Template in $Settings.TemplateList) {
            Write-Host "working on $($Template.value)"
            $Table = Get-CippTable -tablename 'templates'
            $Filter = "PartitionKey eq 'TransportTemplate' and RowKey eq '$($Template.value)'"
            $RequestParams = (Get-AzDataTableEntity @Table -Filter $Filter).JSON | ConvertFrom-Json
            $Existing = $existingRules | Where-Object -Property Identity -EQ $RequestParams.name

            try {
                if ($Existing) {
                    Write-Host 'Found existing'
                    $RequestParams | Add-Member -NotePropertyValue $RequestParams.name -NotePropertyName Identity
                    $GraphRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-TransportRule' -cmdParams ($RequestParams | Select-Object -Property * -ExcludeProperty GUID, Comments, HasSenderOverride, ExceptIfHasSenderOverride, ExceptIfMessageContainsDataClassifications, MessageContainsDataClassifications, UseLegacyRegex) -useSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully set transport rule for $tenant" -sev 'Info'
                } else {
                    Write-Host 'Creating new'
                    $GraphRequest = New-ExoRequest -tenantid $Tenant -cmdlet 'New-TransportRule' -cmdParams ($RequestParams | Select-Object -Property * -ExcludeProperty GUID, Comments, HasSenderOverride, ExceptIfHasSenderOverride, ExceptIfMessageContainsDataClassifications, MessageContainsDataClassifications, UseLegacyRegex) -useSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $tenant -message "Successfully created transport rule for $tenant" -sev 'Info'
                }

                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Created transport rule for $($tenantFilter)" -sev 'Debug'
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Could not create transport rule for $($tenantFilter): $ErrorMessage" -sev 'Error'
            }
        }
    }
    if ($Settings.report -eq $true) {
        $rules = $Settings.transportRuleTemplate.JSON | ConvertFrom-Json -Depth 10
        $MissingRules = foreach ($rule in $rules) {
            $CheckExististing = $existingRules | Where-Object -Property identity -EQ $rule.displayname
            if (!$CheckExististing) {
                $rule.displayname
            }
        }

        if ($MissingRules.Count -eq 0) {
            $fieldValue = $true
        } else {
            $fieldValue = $MissingRules -join ', '
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.TransportRuleTemplate' -FieldValue $fieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTransportRuleTemplate.ps1' 86
#Region './Public/Standards/Invoke-CIPPStandardTwoClickEmailProtection.ps1' -1

function Invoke-CIPPStandardTwoClickEmailProtection {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) TwoClickEmailProtection
    .SYNOPSIS
        (Label) Set two-click confirmation for encrypted emails in New Outlook
    .DESCRIPTION
        (Helptext) Configures the two-click confirmation requirement for viewing encrypted/protected emails in OWA and new Outlook. When enabled, users must click "View message" before accessing protected content, providing an additional layer of privacy protection.
        (DocsDescription) Configures the TwoClickMailPreviewEnabled setting in Exchange Online organization configuration. This security feature requires users to click "View message" before accessing encrypted or protected emails in Outlook on the web (OWA) and new Outlook for Windows. This provides additional privacy protection by preventing protected content from automatically displaying, giving users time to ensure their screen is not visible to others before viewing sensitive content. The feature helps protect against shoulder surfing and accidental disclosure of confidential information.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Requires employees to click twice before viewing encrypted or sensitive emails, preventing accidental exposure of confidential information when screens might be visible to others. This privacy protection helps prevent shoulder surfing and ensures employees are intentional about viewing sensitive content.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"label":"Select value","name":"standards.TwoClickEmailProtection.state","options":[{"label":"Enabled","value":"enabled"},{"label":"Disabled","value":"disabled"}]}
        IMPACT
            Low Impact
        ADDEDDATE
            2025-06-13
        POWERSHELLEQUIVALENT
            Set-OrganizationConfig -TwoClickMailPreviewEnabled \$true \| \$false
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'TwoClickEmailProtection' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'TwoClickEmailProtection'

    # Get state value using null-coalescing operator
    $State = $Settings.state.value ?? $Settings.state

    # Input validation
    if ([string]::IsNullOrWhiteSpace($State)) {
        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'TwoClickEmailProtection: Invalid state parameter set' -sev Error
        Return
    }

    try {
        $CurrentState = (New-ExoRequest -tenantid $Tenant -cmdlet 'Get-OrganizationConfig').TwoClickMailPreviewEnabled
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Could not get current two-click email protection state. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
        Return
    }

    $WantedState = $State -eq 'enabled' ? $true : $false
    $StateIsCorrect = $CurrentState -eq $WantedState ? $true : $false

    if ($Settings.remediate -eq $true) {
        Write-Host 'Time to remediate two-click email protection'

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Two-click email protection is already set to $State." -sev Info
        } else {
            try {
                $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-OrganizationConfig' -cmdParams @{ TwoClickMailPreviewEnabled = $WantedState } -useSystemMailbox $true
                $StateIsCorrect = -not $StateIsCorrect # Toggle the state to reflect the change
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set two-click email protection to $State." -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set two-click email protection to $State. Error: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Two-click email protection is correctly set to $State." -sev Info
        } else {
            Write-StandardsAlert -message "Two-click email protection is not correctly set to $State, but instead $($CurrentState ? 'enabled' : 'disabled')" -object @{TwoClickMailPreviewEnabled = $CurrentState } -tenant $Tenant -standardName 'TwoClickEmailProtection' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Two-click email protection is not correctly set to $State, but instead $($CurrentState ? 'enabled' : 'disabled')" -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Set-CIPPStandardsCompareField -FieldName 'standards.TwoClickEmailProtection' -FieldValue $StateIsCorrect -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'TwoClickEmailProtection' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardTwoClickEmailProtection.ps1' 93
#Region './Public/Standards/Invoke-CIPPStandardUndoOauth.ps1' -1

function Invoke-CIPPStandardUndoOauth {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) UndoOauth
    .SYNOPSIS
        (Label) Undo App Consent Standard
    .DESCRIPTION
        (Helptext) Disables App consent and set to Allow user consent for apps
        (DocsDescription) Disables App consent and set to Allow user consent for apps
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        EXECUTIVETEXT
            Reverses application consent restrictions, allowing employees to approve applications independently without administrative oversight. This increases productivity and user autonomy but reduces security controls over data access permissions.
        ADDEDCOMPONENT
        IMPACT
            High Impact
        ADDEDDATE
            2022-01-07
        POWERSHELLEQUIVALENT
            Update-MgPolicyAuthorizationPolicy
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'UndoOauth'

    try {
        $CurrentState = New-GraphGetRequest -tenantid $Tenant -Uri 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy?$select=permissionGrantPolicyIdsAssignedToDefaultUserRole'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the App Consent state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $StateIsCorrect = ($CurrentState.permissionGrantPolicyIdsAssignedToDefaultUserRole -eq 'ManagePermissionGrantsForSelf.microsoft-user-default-legacy')

    If ($Settings.remediate -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Application Consent Mode is already disabled.' -sev Info
        } else {
            try {
                $GraphRequest = @{
                    tenantid = $tenant
                    uri = 'https://graph.microsoft.com/beta/policies/authorizationPolicy/authorizationPolicy'
                    AsApp = $false
                    Type = 'PATCH'
                    ContentType = 'application/json'
                    Body = '{"permissionGrantPolicyIdsAssignedToDefaultUserRole":["ManagePermissionGrantsForSelf.microsoft-user-default-legacy"]}'
                }
                New-GraphPostRequest @GraphRequest
                Write-LogMessage -API 'Standards' -tenant $tenant -message 'Application Consent Mode has been disabled.' -sev Info
            } catch {
                Write-LogMessage -API 'Standards' -tenant $tenant -message "Failed to set Application Consent Mode to disabled." -sev Error -LogData $_
            }
        }

    }

    if ($Settings.alert -eq $true) {
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Application Consent Mode is disabled.' -sev Info
        } else {
            Write-StandardsAlert -message "Application Consent Mode is not disabled." -object $CurrentState -tenant $Tenant -standardName 'UndoOauth' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'Application Consent Mode is not disabled.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'UndoOauth' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $tenant
        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $FieldValue = $CurrentState
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.UndoOauth' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardUndoOauth.ps1' 87
#Region './Public/Standards/Invoke-CIPPStandardUndoSSPR.ps1' -1

function Invoke-CIPPStandardUndoSSPR {
    <#
    .FUNCTIONALITY
    Internal
    #>
    param($Tenant, $Settings)
    If ($Settings.remediate -eq $true) {

        Write-LogMessage -API 'Standards' -tenant $tenant -message 'The standard for SSPR is no longer supported.' -sev Error
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardUndoSSPR.ps1' 12
#Region './Public/Standards/Invoke-CIPPStandardunmanagedSync.ps1' -1

function Invoke-CIPPStandardunmanagedSync {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) unmanagedSync
    .SYNOPSIS
        (Label) Restrict access to SharePoint and OneDrive from unmanaged devices
    .DESCRIPTION
        (Helptext) Entra P1 required. Block or limit access to SharePoint and OneDrive content from unmanaged devices (those not hybrid AD joined or compliant in Intune). These controls rely on Microsoft Entra Conditional Access policies and can take up to 24 hours to take effect.
        (DocsDescription) Entra P1 required. Block or limit access to SharePoint and OneDrive content from unmanaged devices (those not hybrid AD joined or compliant in Intune). These controls rely on Microsoft Entra Conditional Access policies and can take up to 24 hours to take effect. 0 = Allow Access, 1 = Allow limited, web-only access, 2 = Block access. All information about this can be found in Microsofts documentation [here.](https://learn.microsoft.com/en-us/sharepoint/control-access-from-unmanaged-devices)
    .NOTES
        CAT
            SharePoint Standards
        TAG
            "CIS M365 5.0 (7.2.3)"
            "CISA (MS.SPO.2.1v1)"
            "NIST CSF 2.0 (PR.AA-05)"
        EXECUTIVETEXT
            Restricts access to company files from personal or unmanaged devices, ensuring corporate data can only be accessed from properly secured and monitored devices. This critical security control prevents data leaks while allowing controlled access through web browsers when necessary.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"name":"standards.unmanagedSync.state","label":"State","options":[{"label":"Allow limited, web-only access","value":"1"},{"label":"Block access","value":"2"}],"required":false}
        IMPACT
            High Impact
        ADDEDDATE
            2025-06-13
        POWERSHELLEQUIVALENT
            Set-SPOTenant -ConditionalAccessPolicy AllowFullAccess \| AllowLimitedAccess \| BlockAccess
        RECOMMENDEDBY
            "CIS"
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'unmanagedSync' -TenantFilter $Tenant -RequiredCapabilities @('INTUNE_A', 'MDM_Services', 'EMS', 'SCCM', 'MICROSOFTINTUNEPLAN1')
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'unmanagedSync'

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.

    try {
        $CurrentState = Get-CIPPSPOTenant -TenantFilter $Tenant |
        Select-Object _ObjectIdentity_, TenantFilter, ConditionalAccessPolicy
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the unmanagedSync state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    $WantedState = [int]($Settings.state.value ?? 2) # Default to 2 (Block Access) if not set, for pre v8.0.3 standard compatibility
    $Label = $Settings.state.label ?? 'Block Access' # Default label if not set, for pre v8.0.3 standard compatibility
    $StateIsCorrect = ($CurrentState.ConditionalAccessPolicy -eq $WantedState)

    if ($Settings.remediate -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sync for unmanaged devices is already correctly set to: $Label" -sev Info
        } else {
            try {
                $CurrentState | Set-CIPPSPOTenant -Properties @{ConditionalAccessPolicy = $WantedState }
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Successfully set the unmanaged Sync state to: $Label" -sev Info
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to disable Sync for unmanaged devices: $($ErrorMessage.NormalizedError)" -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sync for unmanaged devices is correctly set to: $Label" -sev Info
        } else {
            Write-StandardsAlert -message "Sync for unmanaged devices is not correctly set to $Label, but instead $($CurrentState.ConditionalAccessPolicy)" -object $CurrentState -tenant $Tenant -standardName 'unmanagedSync' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "Sync for unmanaged devices is not correctly set to $Label, but instead $($CurrentState.ConditionalAccessPolicy)" -sev Info
        }
    }

    if ($Settings.report -eq $true) {

        $State = $StateIsCorrect ? $true : $CurrentState.ConditionalAccessPolicy
        Set-CIPPStandardsCompareField -FieldName 'standards.unmanagedSync' -FieldValue $State -Tenant $Tenant
        Add-CIPPBPAField -FieldName 'unmanagedSync' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardunmanagedSync.ps1' 92
#Region './Public/Standards/Invoke-CIPPStandardUserPreferredLanguage.ps1' -1

function Invoke-CIPPStandardUserPreferredLanguage {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) UserPreferredLanguage
    .SYNOPSIS
        (Label) Preferred language for all users
    .DESCRIPTION
        (Helptext) Sets the preferred language property for all users in the tenant. This will override the user's language settings.
        (DocsDescription) Sets the preferred language property for all users in the tenant. This will override the user's language settings.
    .NOTES
        CAT
            Entra (AAD) Standards
        TAG
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"creatable":false,"name":"standards.UserPreferredLanguage.preferredLanguage","label":"Preferred Language","api":{"url":"/languageList.json","labelField":"tag","valueField":"tag"}}
        IMPACT
            High Impact
        ADDEDDATE
            2025-02-26
        POWERSHELLEQUIVALENT
            Update-MgUser -UserId user@domain.com -BodyParameter @{preferredLanguage='en-US'}
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)

    $preferredLanguage = $Settings.preferredLanguage.value

    try {
        $IncorrectUsers = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$top=999&`$select=userPrincipalName,displayName,preferredLanguage,userType,onPremisesSyncEnabled&`$filter=preferredLanguage ne '$preferredLanguage' and userType eq 'Member' and onPremisesSyncEnabled ne true&`$count=true" -tenantid $Tenant -ComplexFilter
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the UserPreferredLanguage state for $Tenant. Error: $ErrorMessage" -Sev Error
        return
    }

    if ($Settings.remediate -eq $true) {
        if (($IncorrectUsers | Measure-Object).Count -gt 0) {
            try {
                foreach ($user in $IncorrectUsers) {
                    $cmdParams = @{
                        tenantid    = $Tenant
                        uri         = "https://graph.microsoft.com/beta/users/$($user.userPrincipalName)"
                        AsApp       = $true
                        Type        = 'PATCH'
                        Body        = @{
                            preferredLanguage = $preferredLanguage
                        } | ConvertTo-Json
                        ContentType = 'application/json; charset=utf-8'
                    }
                    $null = New-GraphPOSTRequest @cmdParams
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Preferred language for $($user.userPrincipalName) has been set to $preferredLanguage" -sev Info
                }
            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set preferred language to $preferredLanguage for all users." -sev Error -LogData $ErrorMessage
            }
        }
    }

    if ($Settings.alert -eq $true) {
        if (($IncorrectUsers.userPrincipalName | Measure-Object).Count -gt 0) {
            Write-StandardsAlert -message "The following accounts do not have the preferred language set to $preferredLanguage" -object $IncorrectUsers -tenant $Tenant -standardName 'UserPreferredLanguage' -standardId $Settings.standardId
            Write-LogMessage -API 'Standards' -tenant $Tenant -message "The following accounts do not have the preferred language set to $preferredLanguage : $($IncorrectUsers.userPrincipalName -join ', ')" -sev Info
        } else {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'All accounts have the preferred language set.' -sev Info
        }
    }

    if ($Settings.report -eq $true) {
        Add-CIPPBPAField -FieldName 'IncorrectUsers' -FieldValue $IncorrectUsers -StoreAs json -Tenant $Tenant

        if ($IncorrectUsers.userPrincipalName) {
            $FieldValue = $IncorrectUsers | Select-Object -Property userPrincipalName, displayName, preferredLanguage, userType
        } else {
            $FieldValue = $true
        }
        Set-CIPPStandardsCompareField -FieldName 'standards.UserPreferredLanguage' -FieldValue $FieldValue -Tenant $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardUserPreferredLanguage.ps1' 88
#Region './Public/Standards/Invoke-CIPPStandardUserSubmissions.ps1' -1

function Invoke-CIPPStandardUserSubmissions {
    <#
    .FUNCTIONALITY
        Internal
    .COMPONENT
        (APIName) UserSubmissions
    .SYNOPSIS
        (Label) Set the state of the built-in Report button in Outlook
    .DESCRIPTION
        (Helptext) Set the state of the spam submission button in Outlook
        (DocsDescription) Set the state of the built-in Report button in Outlook. This gives the users the ability to report emails as spam or phish.
    .NOTES
        CAT
            Exchange Standards
        TAG
        EXECUTIVETEXT
            Enables employees to easily report suspicious emails directly from Outlook, helping improve the organization's spam and phishing detection systems. This crowdsourced approach to security allows users to contribute to threat detection while providing valuable feedback to enhance email security filters.
        ADDEDCOMPONENT
            {"type":"autoComplete","multiple":false,"label":"Select value","name":"standards.UserSubmissions.state","options":[{"label":"Enabled","value":"enable"},{"label":"Disabled","value":"disable"}]}
            {"type":"textField","name":"standards.UserSubmissions.email","required":false,"label":"Destination email address"}
        IMPACT
            Medium Impact
        ADDEDDATE
            2024-06-28
        POWERSHELLEQUIVALENT
            New-ReportSubmissionPolicy or Set-ReportSubmissionPolicy and New-ReportSubmissionRule or Set-ReportSubmissionRule
        RECOMMENDEDBY
        UPDATECOMMENTBLOCK
            Run the Tools\Update-StandardsComments.ps1 script to update this comment block
    .LINK
        https://docs.cipp.app/user-documentation/tenant/standards/list-standards
    #>

    param($Tenant, $Settings)
    $TestResult = Test-CIPPStandardLicense -StandardName 'UserSubmissions' -TenantFilter $Tenant -RequiredCapabilities @('EXCHANGE_S_STANDARD', 'EXCHANGE_S_ENTERPRISE', 'EXCHANGE_S_STANDARD_GOV', 'EXCHANGE_S_ENTERPRISE_GOV', 'EXCHANGE_LITE') #No Foundation because that does not allow powershell access

    if ($TestResult -eq $false) {
        Write-Host "We're exiting as the correct license is not present for this standard."
        return $true
    } #we're done.
    ##$Rerun -Type Standard -Tenant $Tenant -Settings $Settings 'UserSubmissions'

    # Get state value using null-coalescing operator
    $state = $Settings.state.value ?? $Settings.state
    $Email = Get-CIPPTextReplacement -TenantFilter $Tenant -Text $Settings.email

    # Input validation
    if ($Settings.remediate -eq $true -or $Settings.alert -eq $true) {
        if (!($state -eq 'enable' -or $state -eq 'disable')) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'UserSubmissions: Invalid state parameter set' -sev Error
            return
        }

        if (!([string]::IsNullOrWhiteSpace($Email))) {
            if ($Email -notmatch '@') {
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'UserSubmissions: Invalid Email parameter set' -sev Error
                return
            }
        }
    }

    try {
        $PolicyState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-ReportSubmissionPolicy'
        $RuleState = New-ExoRequest -tenantid $Tenant -cmdlet 'Get-ReportSubmissionRule'
    }
    catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'Standards' -Tenant $Tenant -Message "Could not get the UserSubmissions state for $Tenant. Error: $ErrorMessage" -Sev Error
    }

    if ($state -eq 'enable') {
        if (([string]::IsNullOrWhiteSpace($Email))) {
            $PolicyIsCorrect = ($PolicyState.EnableReportToMicrosoft -eq $true) -and
            ($PolicyState.ReportJunkToCustomizedAddress -eq $false) -and
            ($PolicyState.ReportNotJunkToCustomizedAddress -eq $false) -and
            ($PolicyState.ReportPhishToCustomizedAddress -eq $false)
            $RuleIsCorrect = $true
        } else {
            $PolicyIsCorrect = ($PolicyState.EnableReportToMicrosoft -eq $true) -and
            ($PolicyState.ReportJunkToCustomizedAddress -eq $true) -and
            ($PolicyState.ReportJunkAddresses -eq $Email) -and
            ($PolicyState.ReportNotJunkToCustomizedAddress -eq $true) -and
            ($PolicyState.ReportNotJunkAddresses -eq $Email) -and
            ($PolicyState.ReportPhishToCustomizedAddress -eq $true) -and
            ($PolicyState.ReportPhishAddresses -eq $Email)
            $RuleIsCorrect = ($RuleState.State -eq 'Enabled') -and
            ($RuleState.SentTo -eq $Email)
        }
    } else {
        if ($PolicyState.length -eq 0) {
            $PolicyIsCorrect = $true
            $RuleIsCorrect = $true
        } else {
            $PolicyIsCorrect = ($PolicyState.EnableReportToMicrosoft -eq $false) -and
            ($PolicyState.ReportJunkToCustomizedAddress -eq $false) -and
            ($PolicyState.ReportNotJunkToCustomizedAddress -eq $false) -and
            ($PolicyState.ReportPhishToCustomizedAddress -eq $false)
            $RuleIsCorrect = $true
        }
    }

    $StateIsCorrect = $PolicyIsCorrect -and $RuleIsCorrect

    if ($Settings.remediate -eq $true) {
        # If policy is set correctly, log and skip setting the policy
        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission policy is already configured' -sev Info
        } else {
            if ($state -eq 'enable') {
                if (([string]::IsNullOrWhiteSpace($Email))) {
                    $PolicyParams = @{
                        EnableReportToMicrosoft          = $true
                        ReportJunkToCustomizedAddress    = $false
                        ReportJunkAddresses              = $null
                        ReportNotJunkToCustomizedAddress = $false
                        ReportNotJunkAddresses           = $null
                        ReportPhishToCustomizedAddress   = $false
                        ReportPhishAddresses             = $null
                    }
                } else {
                    $PolicyParams = @{
                        EnableReportToMicrosoft          = $true
                        ReportJunkToCustomizedAddress    = $true
                        ReportJunkAddresses              = $Email
                        ReportNotJunkToCustomizedAddress = $true
                        ReportNotJunkAddresses           = $Email
                        ReportPhishToCustomizedAddress   = $true
                        ReportPhishAddresses             = $Email
                    }
                    $RuleParams = @{
                        SentTo = $Email
                    }
                }
            } else {
                $PolicyParams = @{
                    EnableReportToMicrosoft          = $false
                    ReportJunkToCustomizedAddress    = $false
                    ReportNotJunkToCustomizedAddress = $false
                    ReportPhishToCustomizedAddress   = $false
                }
            }

            if ($PolicyState.length -eq 0) {
                try {
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-ReportSubmissionPolicy' -cmdParams $PolicyParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission policy created.' -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create User Submission policy. Error: $($ErrorMessage.NormalizedError)" -sev Error
                }
            } else {
                try {
                    $PolicyParams.Add('Identity', 'DefaultReportSubmissionPolicy')
                    $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-ReportSubmissionPolicy' -cmdParams $PolicyParams -UseSystemMailbox $true
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "User Submission policy state set to $state." -sev Info
                } catch {
                    $ErrorMessage = Get-CippException -Exception $_
                    Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to set User Submission policy state to $state. Error: $($ErrorMessage.NormalizedError)" -sev Error
                }
            }

            if ($RuleParams) {
                if ($RuleState.length -eq 0) {
                    try {
                        $RuleParams.Add('Name', 'DefaultReportSubmissionRule')
                        $RuleParams.Add('ReportSubmissionPolicy', 'DefaultReportSubmissionPolicy')
                        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'New-ReportSubmissionRule' -cmdParams $RuleParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission rule created.' -sev Info
                    } catch {
                        $ErrorMessage = Get-CippException -Exception $_
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to create User Submission rule. Error: $($ErrorMessage.NormalizedError)" -sev Error
                    }
                } else {
                    try {
                        $RuleParams.Add('Identity', 'DefaultReportSubmissionRule')
                        $null = New-ExoRequest -tenantid $Tenant -cmdlet 'Set-ReportSubmissionRule' -cmdParams $RuleParams -UseSystemMailbox $true
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission rule set to enabled.' -sev Info
                    } catch {
                        $ErrorMessage = Get-CippException -Exception $_
                        Write-LogMessage -API 'Standards' -tenant $Tenant -message "Failed to enable User Submission rule. Error: $($ErrorMessage.NormalizedError)" -sev Error
                    }
                }
            }
        }
    }

    if ($Settings.alert -eq $true) {

        if ($StateIsCorrect -eq $true) {
            Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission policy is properly configured.' -sev Info
        } else {
            if ($Policy.EnableReportToMicrosoft -eq $true) {
                Write-StandardsAlert -message 'User Submission policy is enabled but incorrectly configured' -object $PolicyState -tenant $Tenant -standardName 'UserSubmissions' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission policy is enabled but incorrectly configured' -sev Info
            } else {
                Write-StandardsAlert -message 'User Submission policy is disabled.' -object $PolicyState -tenant $Tenant -standardName 'UserSubmissions' -standardId $Settings.standardId
                Write-LogMessage -API 'Standards' -tenant $Tenant -message 'User Submission policy is disabled.' -sev Info
            }
        }
    }


    if ($Settings.report -eq $true) {
        if ($PolicyState.length -eq 0) {
            Add-CIPPBPAField -FieldName 'UserSubmissionPolicy' -FieldValue $false -StoreAs bool -Tenant $Tenant
        } else {
            Add-CIPPBPAField -FieldName 'UserSubmissionPolicy' -FieldValue $StateIsCorrect -StoreAs bool -Tenant $Tenant
        }

        if ($StateIsCorrect) {
            $FieldValue = $true
        } else {
            $PolicyState = $PolicyState | Select-Object EnableReportToMicrosoft, ReportJunkToCustomizedAddress, ReportNotJunkToCustomizedAddress, ReportPhishToCustomizedAddress, ReportJunkAddresses, ReportNotJunkAddresses, ReportPhishAddresses
            $RuleState = $RuleState | Select-Object State, SentTo
            $FieldValue = @{ PolicyState = $PolicyState; RuleState = $RuleState }
        }

        Set-CIPPStandardsCompareField -FieldName 'standards.UserSubmissions' -FieldValue $FieldValue -TenantFilter $Tenant
    }
}
#EndRegion './Public/Standards/Invoke-CIPPStandardUserSubmissions.ps1' 221
#Region './Public/Standards/Merge-CippStandards.ps1' -1

function Merge-CippStandards {
    param(
        [Parameter(Mandatory = $true)][object]$Existing,
        [Parameter(Mandatory = $true)][object]$New,
        [Parameter(Mandatory = $true)][string]$StandardName
    )

    # If $Existing or $New is $null/empty, just return the other.
    if (-not $Existing) { return $New }
    if (-not $New) { return $Existing }

    # If the standard name ends with 'Template', we treat them as arrays to merge.
    if ($StandardName -like '*Template') {
        $ExistingIsArray = $Existing -is [System.Collections.IEnumerable] -and -not ($Existing -is [string])
        $NewIsArray = $New -is [System.Collections.IEnumerable] -and -not ($New -is [string])

        # Make sure both are arrays
        if (-not $ExistingIsArray) { $Existing = @($Existing) }
        if (-not $NewIsArray) { $New = @($New) }

        return $Existing + $New
    } else {
        # Singlevalue standard: override the old with the new
        return $New
    }
}
#EndRegion './Public/Standards/Merge-CippStandards.ps1' 27
#Region './Public/TenantGroups/Expand-CIPPTenantGroups.ps1' -1

function Expand-CIPPTenantGroups {
    <#
        .SYNOPSIS
            Expands a list of groups to their members.
        .DESCRIPTION
            This function takes a a tenant filter object and expands it to include all members of the groups.
        .EXAMPLE

    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        [Parameter(Mandatory = $true)]
        $TenantFilter
    )
    $TenantList = Get-Tenants -IncludeErrors
    $ExpandedGroups = $TenantFilter | ForEach-Object {
        $FilterValue = $_
        # Group lookup
        if ($_.type -eq 'Group') {
            $members = (Get-TenantGroups -GroupId $_.value).members
            $TenantList | Where-Object -Property customerId -In $members.customerId | ForEach-Object {
                $GroupMember = $_
                [PSCustomObject]@{
                    value       = $GroupMember.defaultDomainName
                    label       = $GroupMember.displayName
                    addedFields = $GroupMember | Select-Object defaultDomainName, displayName, customerId
                    type        = 'Tenant'
                }
            }
        } else {
            $FilterValue
        }
    }
    return $ExpandedGroups | Sort-Object -Property value -Unique
}
#EndRegion './Public/TenantGroups/Expand-CIPPTenantGroups.ps1' 36
#Region './Public/TenantGroups/Get-CIPPTenantVariables.ps1' -1

function Get-CIPPTenantVariables {
    <#
    .SYNOPSIS
        Retrieves custom variables for a specific tenant
    .DESCRIPTION
        This function retrieves custom variables from the CippReplacemap table for a specific tenant,
        including both tenant-specific and global (AllTenants) variables. Tenant-specific variables
        take precedence over global variables.
    .PARAMETER TenantFilter
        The tenant filter (customerId or defaultDomainName)
    .PARAMETER IncludeGlobal
        Include global variables (AllTenants) in the results
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Get-CIPPTenantVariables -TenantFilter 'contoso.com'
    .EXAMPLE
        Get-CIPPTenantVariables -TenantFilter 'eda053f2-4add-41dc-9feb-78a5fc0934c9' -IncludeGlobal
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [switch]$IncludeGlobal
    )

    try {
        $ReplaceTable = Get-CIPPTable -tablename 'CippReplacemap'
        $Variables = @{}

        # Get tenant information to resolve both customerId and defaultDomainName
        $Tenant = Get-Tenants -TenantFilter $TenantFilter
        if (!$Tenant) {
            Write-Warning "Tenant not found: $TenantFilter"
            return $Variables
        }

        # Load global variables first if requested (lower priority)
        if ($IncludeGlobal) {
            $GlobalMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq 'AllTenants'"
            if ($GlobalMap) {
                foreach ($Var in $GlobalMap) {
                    $Variables[$Var.RowKey] = @{
                        Value       = $Var.Value
                        Description = $Var.Description
                        Scope       = 'Global'
                    }
                }
            }
        }

        # Load tenant-specific variables (higher priority - will overwrite global)
        # Try by customerId first
        $TenantMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$($Tenant.customerId)'"

        # If no results found by customerId, try by defaultDomainName
        if (!$TenantMap) {
            $TenantMap = Get-CIPPAzDataTableEntity @ReplaceTable -Filter "PartitionKey eq '$($Tenant.defaultDomainName)'"
        }

        if ($TenantMap) {
            foreach ($Var in $TenantMap) {
                $Variables[$Var.RowKey] = @{
                    Value       = $Var.Value
                    Description = $Var.Description
                    Scope       = 'Tenant'
                }
            }
        }

        return $Variables

    } catch {
        Write-LogMessage -API 'TenantGroups' -message "Failed to retrieve tenant variables for $TenantFilter : $($_.Exception.Message)" -sev Error
        return @{}
    }
}
#EndRegion './Public/TenantGroups/Get-CIPPTenantVariables.ps1' 78
#Region './Public/TenantGroups/Get-TenantGroups.ps1' -1

if (-not $script:TenantGroupsCache) {
    $script:TenantGroupsCache = @{
        Groups         = $null
        Members        = $null
        LastRefresh    = $null
        MembersByGroup = $null  # Dictionary: GroupId -> members array
    }
}

# Result cache: keyed by "GroupId|TenantFilter|Dynamic"
if (-not $script:TenantGroupsResultCache) {
    $script:TenantGroupsResultCache = @{}
}

function Get-TenantGroups {
    <#
    .SYNOPSIS
        Get tenant groups
    .DESCRIPTION
        Get tenant groups from Azure Table Storage with performance optimizations
        using script-scoped caches and in-memory indexing
    .PARAMETER GroupId
        The group id to filter on
    .PARAMETER TenantFilter
        The tenant filter to apply to get the groups for a specific tenant
    .PARAMETER Dynamic
        Filter to only dynamic groups
    #>
    [CmdletBinding()]
    param(
        [string]$GroupId,
        [string]$TenantFilter,
        [switch]$Dynamic
    )
    $CacheKey = "$GroupId|$TenantFilter|$($Dynamic.IsPresent)"

    if ($script:TenantGroupsResultCache.ContainsKey($CacheKey)) {
        Write-Verbose "Returning cached result for: $CacheKey"
        return $script:TenantGroupsResultCache[$CacheKey]
    }

    # Early exit if specific GroupId requested but not allowed
    if ($GroupId -and $script:CippAllowedGroupsStorage -and $script:CippAllowedGroupsStorage.Value) {
        if ($script:CippAllowedGroupsStorage.Value -notcontains $GroupId) {
            return @()
        }
    }

    # Load table data into cache if not already loaded
    if (-not $script:TenantGroupsCache.Groups -or -not $script:TenantGroupsCache.Members) {
        Write-Verbose 'Loading TenantGroups and TenantGroupMembers tables into cache'

        $GroupTable = Get-CippTable -tablename 'TenantGroups'
        $MembersTable = Get-CippTable -tablename 'TenantGroupMembers'

        $GroupTable.Filter = "PartitionKey eq 'TenantGroup'"

        # Load all groups and members once
        $script:TenantGroupsCache.Groups = @(Get-CIPPAzDataTableEntity @GroupTable)
        $script:TenantGroupsCache.Members = @(Get-CIPPAzDataTableEntity @MembersTable)
        $script:TenantGroupsCache.LastRefresh = Get-Date

        # Build MembersByGroup index: GroupId -> array of member objects
        $script:TenantGroupsCache.MembersByGroup = @{}
        foreach ($Member in $script:TenantGroupsCache.Members) {
            $GId = $Member.GroupId
            if (-not $script:TenantGroupsCache.MembersByGroup.ContainsKey($GId)) {
                $script:TenantGroupsCache.MembersByGroup[$GId] = [System.Collections.Generic.List[object]]::new()
            }
            $script:TenantGroupsCache.MembersByGroup[$GId].Add($Member)
        }

        Write-Verbose "Cache loaded: $($script:TenantGroupsCache.Groups.Count) groups, $($script:TenantGroupsCache.Members.Count) members"
    }

    # Get tenants (already cached and fast per requirements)
    if ($TenantFilter -and $TenantFilter -ne 'allTenants') {
        $TenantParams = @{
            TenantFilter  = $TenantFilter
            IncludeErrors = $true
        }
    } else {
        $TenantParams = @{
            IncludeErrors = $true
        }
    }
    $Tenants = Get-Tenants @TenantParams

    $TenantByCustomerId = @{}
    foreach ($Tenant in $Tenants) {
        $TenantByCustomerId[$Tenant.customerId] = $Tenant
    }

    $Groups = $script:TenantGroupsCache.Groups

    if ($Dynamic.IsPresent) {
        $Groups = $Groups | Where-Object { $_.GroupType -eq 'dynamic' }
    }

    if ($GroupId) {
        $Groups = $Groups | Where-Object { $_.RowKey -eq $GroupId }
    }

    if ($script:CippAllowedGroupsStorage -and $script:CippAllowedGroupsStorage.Value) {
        $Groups = $Groups | Where-Object { $script:CippAllowedGroupsStorage.Value -contains $_.RowKey }
    }

    if (!$Groups -or $Groups.Count -eq 0) {
        $script:TenantGroupsResultCache[$CacheKey] = @()
        return @()
    }

    # Process results based on TenantFilter
    if ($TenantFilter -and $TenantFilter -ne 'allTenants') {
        # Return simplified group list for specific tenant
        $Results = [System.Collections.Generic.List[PSCustomObject]]::new()
        $TargetCustomerId = $Tenants.customerId

        foreach ($Group in $Groups) {
            $GroupMembers = $script:TenantGroupsCache.MembersByGroup[$Group.RowKey]

            if ($GroupMembers) {
                # Check if this group has the target tenant as a member
                $HasTenant = $false
                foreach ($Member in $GroupMembers) {
                    if ($Member.customerId -eq $TargetCustomerId) {
                        $HasTenant = $true
                        break
                    }
                }

                if ($HasTenant) {
                    $Results.Add([PSCustomObject]@{
                            Id          = $Group.RowKey
                            Name        = $Group.Name
                            Description = $Group.Description
                        })
                }
            }
        }

        $FinalResults = $Results | Sort-Object Name
        $script:TenantGroupsResultCache[$CacheKey] = $FinalResults
        return $FinalResults
    } else {
        # Return full group details with members
        $Results = [System.Collections.Generic.List[PSCustomObject]]::new()

        foreach ($Group in $Groups) {
            $GroupMembers = $script:TenantGroupsCache.MembersByGroup[$Group.RowKey]
            $MembersList = [System.Collections.Generic.List[hashtable]]::new()

            if ($GroupMembers) {
                foreach ($Member in $GroupMembers) {
                    # Use indexed lookup instead of Where-Object
                    $Tenant = $TenantByCustomerId[$Member.customerId]
                    if ($Tenant) {
                        $MembersList.Add(@{
                                customerId        = $Tenant.customerId
                                displayName       = $Tenant.displayName
                                defaultDomainName = $Tenant.defaultDomainName
                            })
                    }
                }
                $SortedMembers = $MembersList | Sort-Object displayName
            } else {
                $SortedMembers = @()
            }

            $Results.Add([PSCustomObject]@{
                    Id           = $Group.RowKey
                    Name         = $Group.Name
                    Description  = $Group.Description
                    GroupType    = $Group.GroupType ?? 'static'
                    RuleLogic    = $Group.RuleLogic ?? 'and'
                    DynamicRules = $Group.DynamicRules ? @($Group.DynamicRules | ConvertFrom-Json) : @()
                    Members      = @($SortedMembers)
                })
        }

        $FinalResults = $Results | Sort-Object Name
        $script:TenantGroupsResultCache[$CacheKey] = $FinalResults
        return $FinalResults
    }
}
#EndRegion './Public/TenantGroups/Get-TenantGroups.ps1' 186
#Region './Public/TenantGroups/Update-CIPPDynamicTenantGroups.ps1' -1

function Update-CIPPDynamicTenantGroups {
    <#
    .SYNOPSIS
        Update dynamic tenant groups based on their rules
    .DESCRIPTION
        This function processes dynamic tenant group rules and updates membership accordingly
    .PARAMETER GroupId
        The specific group ID to update. If not provided, all dynamic groups will be updated
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        [string]$GroupId
    )

    try {
        $GroupTable = Get-CippTable -tablename 'TenantGroups'
        $MembersTable = Get-CippTable -tablename 'TenantGroupMembers'
        $LicenseCacheTable = Get-CippTable -tablename 'cachetenantskus'

        $Skus = Get-CIPPAzDataTableEntity @LicenseCacheTable -Filter "PartitionKey eq 'sku' and Timestamp ge datetime'$( (Get-Date).ToUniversalTime().AddHours(-8).ToString('yyyy-MM-ddTHH:mm:ssZ') )'"

        $SkuHashtable = @{}
        foreach ($Sku in $Skus) {
            if ($Sku.JSON -and (Test-Json -Json $Sku.JSON -ErrorAction SilentlyContinue)) {
                $SkuHashtable[$Sku.RowKey] = $Sku.JSON | ConvertFrom-Json
            }
        }

        if ($GroupId) {
            $DynamicGroups = Get-CIPPAzDataTableEntity @GroupTable -Filter "PartitionKey eq 'TenantGroup' and RowKey eq '$GroupId'"
        } else {
            $DynamicGroups = Get-CIPPAzDataTableEntity @GroupTable -Filter "PartitionKey eq 'TenantGroup' and GroupType eq 'dynamic'"
        }

        if (-not $DynamicGroups) {
            Write-LogMessage -API 'TenantGroups' -message 'No dynamic groups found to process' -sev Info
            return @{ MembersAdded = 0; MembersRemoved = 0; GroupsProcessed = 0 }
        }

        $AllTenants = Get-Tenants -IncludeErrors
        $TotalMembersAdded = 0
        $TotalMembersRemoved = 0
        $GroupsProcessed = 0

        # Pre-load tenant group memberships for tenantGroupMember rules
        # This creates a cache to avoid repeated table queries during rule evaluation
        $script:TenantGroupMembersCache = @{}
        $AllGroupMembers = Get-CIPPAzDataTableEntity @MembersTable -Filter "PartitionKey eq 'Member'"
        foreach ($Member in $AllGroupMembers) {
            if (-not $script:TenantGroupMembersCache.ContainsKey($Member.GroupId)) {
                $script:TenantGroupMembersCache[$Member.GroupId] = [system.collections.generic.list[string]]::new()
            }
            $script:TenantGroupMembersCache[$Member.GroupId].Add($Member.customerId)
        }        foreach ($Group in $DynamicGroups) {
            try {
                Write-LogMessage -API 'TenantGroups' -message "Processing dynamic group: $($Group.Name)" -sev Info
                $Rules = @($Group.DynamicRules | ConvertFrom-Json)
                # Build a single Where-Object string for AND logic
                $WhereConditions = foreach ($Rule in $Rules) {
                    $Property = $Rule.property
                    $Operator = $Rule.operator
                    $Value = $Rule.value

                    switch ($Property) {
                        'delegatedAccessStatus' {
                            "`$_.delegatedPrivilegeStatus -$Operator '$($Value.value)'"
                        }
                        'availableLicense' {
                            if ($Operator -in @('in', 'notin')) {
                                $arrayValues = if ($Value -is [array]) { $Value.guid } else { @($Value.guid) }
                                $arrayAsString = $arrayValues | ForEach-Object { "'$_'" }
                                if ($Operator -eq 'in') {
                                    "(`$_.skuId | Where-Object { `$_ -in @($($arrayAsString -join ', ')) }).Count -gt 0"
                                } else {
                                    "(`$_.skuId | Where-Object { `$_ -in @($($arrayAsString -join ', ')) }).Count -eq 0"
                                }
                            } else {
                                "`$_.skuId -$Operator '$($Value.guid)'"
                            }
                        }
                        'availableServicePlan' {
                            if ($Operator -in @('in', 'notin')) {
                                $arrayValues = if ($Value -is [array]) { $Value.value } else { @($Value.value) }
                                $arrayAsString = $arrayValues | ForEach-Object { "'$_'" }
                                if ($Operator -eq 'in') {
                                    # Keep tenants with ANY of the provided plans
                                    "(`$_.servicePlans | Where-Object { `$_ -in @($($arrayAsString -join ', ')) }).Count -gt 0"
                                } else {
                                    # Exclude tenants with ANY of the provided plans
                                    "(`$_.servicePlans | Where-Object { `$_ -in @($($arrayAsString -join ', ')) }).Count -eq 0"
                                }
                            } else {
                                "`$_.servicePlans -$Operator '$($Value.value)'"
                            }
                        }
                        'tenantGroupMember' {
                            # Get members of the referenced tenant group
                            $ReferencedGroupId = $Value.value
                            if ($Operator -eq 'in') {
                                "`$_.customerId -in `$script:TenantGroupMembersCache['$ReferencedGroupId']"
                            } else {
                                "`$_.customerId -notin `$script:TenantGroupMembersCache['$ReferencedGroupId']"
                            }
                        }
                        'customVariable' {
                            # Custom variable matching - value contains variable name and expected value
                            # Handle case where variableName might be an object (autocomplete option) or a string
                            $VariableName = if ($Value.variableName -is [string]) {
                                $Value.variableName
                            } elseif ($Value.variableName.value) {
                                $Value.variableName.value
                            } else {
                                $Value.variableName
                            }
                            $ExpectedValue = $Value.value
                            # Escape single quotes in expected value for the condition string
                            $EscapedExpectedValue = $ExpectedValue -replace "'", "''"

                            switch ($Operator) {
                                'eq' {
                                    "(`$_.customVariables.ContainsKey('$VariableName') -and `$_.customVariables['$VariableName'].Value -eq '$EscapedExpectedValue')"
                                }
                                'ne' {
                                    "(-not `$_.customVariables.ContainsKey('$VariableName') -or `$_.customVariables['$VariableName'].Value -ne '$EscapedExpectedValue')"
                                }
                                'like' {
                                    "(`$_.customVariables.ContainsKey('$VariableName') -and `$_.customVariables['$VariableName'].Value -like '*$EscapedExpectedValue*')"
                                }
                                'notlike' {
                                    "(-not `$_.customVariables.ContainsKey('$VariableName') -or `$_.customVariables['$VariableName'].Value -notlike '*$EscapedExpectedValue*')"
                                }
                            }
                        }
                        default {
                            Write-LogMessage -API 'TenantGroups' -message "Unknown property type: $Property" -sev Warning
                            $null
                        }
                    }

                }
                if (!$WhereConditions) {
                    throw 'Generating the conditions failed. The conditions seem to be empty.'
                }
                Write-Information "Generated where conditions: $($WhereConditions | ConvertTo-Json )"
                $TenantObj = $AllTenants | ForEach-Object {
                    if ($Rules.property -contains 'availableLicense') {
                        if ($SkuHashtable.ContainsKey($_.customerId)) {
                            Write-Information "Using cached licenses for tenant $($_.defaultDomainName)"
                            $LicenseInfo = $SkuHashtable[$_.customerId]
                        } else {
                            Write-Information "Fetching licenses for tenant $($_.defaultDomainName)"
                            try {
                                $LicenseInfo = New-GraphGetRequest -uri 'https://graph.microsoft.com/v1.0/subscribedSkus' -TenantId $_.defaultDomainName
                                # Cache the result
                                $CacheEntity = @{
                                    PartitionKey = 'sku'
                                    RowKey       = [string]$_.customerId
                                    JSON         = [string]($LicenseInfo | ConvertTo-Json -Depth 5 -Compress)
                                }
                                Add-CIPPAzDataTableEntity @LicenseCacheTable -Entity $CacheEntity -Force
                            } catch {
                                Write-LogMessage -API 'TenantGroups' -message 'Error getting licenses' -Tenant $_.defaultDomainName -sev Warning -LogData (Get-CippException -Exception $_)
                            }
                        }
                    }

                    # Fetch custom variables for this tenant if any rules use customVariable
                    $TenantVariables = @{}
                    if ($Rules.property -contains 'customVariable') {
                        try {
                            $TenantVariables = Get-CIPPTenantVariables -TenantFilter $_.customerId -IncludeGlobal
                        } catch {
                            Write-Information "Error fetching custom variables for tenant $($_.defaultDomainName): $($_.Exception.Message)"
                            Write-LogMessage -API 'TenantGroups' -message 'Error getting tenant variables' -Tenant $_.defaultDomainName -sev Warning -LogData (Get-CippException -Exception $_)
                        }
                    }

                    try {
                        $SKUId = $LicenseInfo.SKUId ?? @()
                        $ServicePlans = (Get-CIPPTenantCapabilities -TenantFilter $_.defaultDomainName).psobject.properties.name
                    } catch {
                        Write-Information "Error fetching capabilities for tenant $($_.defaultDomainName): $($_.Exception.Message)"
                        Write-LogMessage -API 'TenantGroups' -message 'Error getting tenant capabilities' -Tenant $_.defaultDomainName -sev Warning -LogData (Get-CippException -Exception $_)
                    }
                    [pscustomobject]@{
                        customerId               = $_.customerId
                        defaultDomainName        = $_.defaultDomainName
                        displayName              = $_.displayName
                        skuId                    = $SKUId
                        servicePlans             = $ServicePlans
                        delegatedPrivilegeStatus = $_.delegatedPrivilegeStatus
                        customVariables          = $TenantVariables
                    }
                }
                # Combine all conditions with the specified logic (AND or OR)
                $LogicOperator = if ($Group.RuleLogic -eq 'or') { ' -or ' } else { ' -and ' }
                $WhereString = $WhereConditions -join $LogicOperator
                Write-Information "Evaluating tenants with condition: $WhereString"
                Write-LogMessage -API 'TenantGroups' -message "Evaluating tenants for group '$($Group.Name)' with condition: $WhereString" -sev Info

                $ScriptBlock = [ScriptBlock]::Create($WhereString)
                $MatchingTenants = $TenantObj | Where-Object $ScriptBlock

                Write-Information "Found $($MatchingTenants.Count) matching tenants for group '$($Group.Name)'"

                $CurrentMembers = Get-CIPPAzDataTableEntity @MembersTable -Filter "PartitionKey eq 'Member' and GroupId eq '$($Group.RowKey)'"
                $CurrentMemberIds = $CurrentMembers.customerId
                $NewMemberIds = $MatchingTenants.customerId

                $ToAdd = $NewMemberIds | Where-Object { $_ -notin $CurrentMemberIds }
                $ToRemove = $CurrentMemberIds | Where-Object { $_ -notin $NewMemberIds }

                foreach ($TenantId in $ToAdd) {
                    $TenantInfo = $AllTenants | Where-Object { $_.customerId -eq $TenantId }
                    $MemberEntity = @{
                        PartitionKey = 'Member'
                        RowKey       = '{0}-{1}' -f $Group.RowKey, $TenantId
                        GroupId      = $Group.RowKey
                        customerId   = "$TenantId"
                    }
                    Add-CIPPAzDataTableEntity @MembersTable -Entity $MemberEntity -Force
                    Write-LogMessage -API 'TenantGroups' -message "Added tenant '$($TenantInfo.displayName)' to dynamic group '$($Group.Name)'" -sev Info
                    $TotalMembersAdded++
                }

                foreach ($TenantId in $ToRemove) {
                    $TenantInfo = $AllTenants | Where-Object { $_.customerId -eq $TenantId }
                    $MemberToRemove = $CurrentMembers | Where-Object { $_.customerId -eq $TenantId }
                    if ($MemberToRemove) {
                        Remove-AzDataTableEntity @MembersTable -Entity $MemberToRemove -Force
                        Write-LogMessage -API 'TenantGroups' -message "Removed tenant '$($TenantInfo.displayName)' from dynamic group '$($Group.Name)'" -sev Info
                        $TotalMembersRemoved++
                    }
                }

                $GroupsProcessed++
                Write-LogMessage -API 'TenantGroups' -message "Group '$($Group.Name)' updated: +$($ToAdd.Count) members, -$($ToRemove.Count) members" -sev Info

            } catch {
                $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
                Write-LogMessage -API 'TenantGroups' -message "Failed to process group '$($Group.Name)': $ErrorMessage" -sev Error
            }
        }

        Write-LogMessage -API 'TenantGroups' -message "Dynamic tenant group update completed. Groups processed: $GroupsProcessed, Members added: $TotalMembersAdded, Members removed: $TotalMembersRemoved" -sev Info

        return @{
            MembersAdded    = $TotalMembersAdded
            MembersRemoved  = $TotalMembersRemoved
            GroupsProcessed = $GroupsProcessed
        }

    } catch {
        $ErrorMessage = Get-NormalizedError -Message $_.Exception.Message
        Write-LogMessage -API 'TenantGroups' -message "Failed to update dynamic tenant groups: $ErrorMessage" -sev Error
        throw
    }
}

#EndRegion './Public/TenantGroups/Update-CIPPDynamicTenantGroups.ps1' 262
#Region './Public/Test-CIPPAccessPermissions.ps1' -1

function Test-CIPPAccessPermissions {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $APIName = 'Access Check',
        $Headers
    )

    $User = $request.headers.'x-ms-client-principal'
    Write-LogMessage -Headers $User -API $APINAME -message 'Started permissions check' -Sev 'Debug'
    $Messages = [System.Collections.Generic.List[string]]::new()
    $ErrorMessages = [System.Collections.Generic.List[string]]::new()
    $MissingPermissions = [System.Collections.Generic.List[string]]::new()
    $Links = [System.Collections.Generic.List[object]]::new()
    $AccessTokenDetails = [PSCustomObject]@{
        AppId             = ''
        AppName           = ''
        Audience          = ''
        AuthMethods       = ''
        IPAddress         = ''
        Name              = ''
        Scope             = ''
        TenantId          = ''
        UserPrincipalName = ''
    }
    $Success = $true
    try {
        Set-Location (Get-Item $PSScriptRoot).FullName
        $null = Get-CIPPAuthentication
        $GraphToken = Get-GraphToken -returnRefresh $true -SkipCache $true
        if ($GraphToken) {
            $GraphPermissions = Get-CippSamPermissions
        }
        if ($env:MSI_SECRET) {
            try {
                Disable-AzContextAutosave -Scope Process | Out-Null
                $null = Connect-AzAccount -Identity
                $SubscriptionId = $env:WEBSITE_OWNER_NAME -split '\+' | Select-Object -First 1
                $null = Set-AzContext -SubscriptionId $SubscriptionId

                $KV = $env:WEBSITE_DEPLOYMENT_ID
                $KeyVaultRefresh = Get-AzKeyVaultSecret -VaultName $kv -Name 'RefreshToken' -AsPlainText
                if ($env:RefreshToken -ne $KeyVaultRefresh) {
                    $Success = $false
                    $ErrorMessages.Add('Your refresh token does not match key vault, wait 30 minutes for the function app to update.') | Out-Null
                } else {
                    $Messages.Add('Your refresh token matches key vault.') | Out-Null
                }
            } catch {
                $ErrorMessage = Get-CippException -Exception $_
                Write-LogMessage -Headers $User -API $APINAME -tenant $tenant -message "Key vault exception: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
            }
        } else {
            $Messages.Add('Your refresh token matches key vault.') | Out-Null
        }

        try {
            $AccessTokenDetails = Read-JwtAccessDetails -Token $GraphToken.access_token -erroraction SilentlyContinue
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $AccessTokenDetails = [PSCustomObject]@{
                Name        = ''
                AuthMethods = @()
            }
            Write-LogMessage -Headers $User -API $APINAME -tenant $tenant -message "Token exception: $($ErrorMessage.NormalizedError_) " -Sev 'Error' -LogData $ErrorMessage
            $Success = $false
        }

        if ($AccessTokenDetails.Name -eq '') {
            $ErrorMessages.Add('Your refresh token is invalid, check for line breaks or missing characters.') | Out-Null
            $Success = $false
        } else {
            if ($AccessTokenDetails.Name -match 'CIPP' -or $AccessTokenDetails.UserPrincipalName -match 'CIPP' -or $AccessTokenDetails.Name -match 'Service' -or $AccessTokenDetails.UserPrincipalName -match 'Service') {
                $Messages.Add('You are running CIPP as a service account.') | Out-Null
            } else {
                $ErrorMessages.Add('You do not appear to be running CIPP as a service account.') | Out-Null
                $Success = $false
                $Links.Add([PSCustomObject]@{
                        Text = 'Creating the CIPP Service Account'
                        Href = 'https://docs.cipp.app/setup/installation/creating-the-cipp-service-account-gdap-ready'
                    }
                ) | Out-Null
            }

            if ($AccessTokenDetails.AuthMethods -contains 'mfa') {
                $Messages.Add('Your access token contains the MFA claim.') | Out-Null
            } else {
                $ErrorMessages.Add('Your access token does not contain the MFA claim, Refresh your SAM tokens.') | Out-Null

                $Success = $false
                $Links.Add([PSCustomObject]@{
                        Text = 'MFA Troubleshooting'
                        Href = 'https://docs.cipp.app/troubleshooting/troubleshooting#multi-factor-authentication-troubleshooting'
                    }
                ) | Out-Null
            }
        }


        $MissingSamPermissions = $GraphPermissions.MissingPermissions
        if (($MissingSamPermissions.PSObject.Properties.Name | Measure-Object).Count -gt 0) {

            $MissingPermissions = foreach ($AppId in $MissingSamPermissions.PSObject.Properties.Name) {
                $ServicePrincipal = $GraphPermissions.UsedServicePrincipals | Where-Object -Property appId -EQ $AppId

                foreach ($Permission in $MissingSamPermissions.$AppId.applicationPermissions) {
                    [PSCustomObject]@{
                        Application  = $ServicePrincipal.displayName
                        Type         = 'Application'
                        PermissionId = $Permission.id
                        Permission   = $Permission.value
                    }
                }
                foreach ($Permission in $MissingSamPermissions.$AppId.delegatedPermissions) {
                    [PSCustomObject]@{
                        Application  = $ServicePrincipal.displayName
                        Type         = 'Delegated'
                        PermissionId = $Permission.id
                        Permission   = $Permission.value
                    }
                }
            }
            $Success = $false
            $Links.Add([PSCustomObject]@{
                    Text = 'Permissions'
                    Href = 'https://docs.cipp.app/setup/installation/permissions'
                }
            ) | Out-Null
        } else {
            $Messages.Add('You have all the required permissions.') | Out-Null
        }

        $ApplicationToken = Get-GraphToken -returnRefresh $true -SkipCache $true -AsApp $true
        $ApplicationTokenDetails = Read-JwtAccessDetails -Token $ApplicationToken.access_token -erroraction SilentlyContinue | Select-Object

        $LastUpdate = [DateTime]::SpecifyKind($GraphPermissions.Timestamp.ToString('yyyy-MM-ddTHH:mm:ssZ'), [DateTimeKind]::Utc)
        $CpvTable = Get-CippTable -tablename 'cpvtenants'
        $CpvRefresh = Get-CippAzDataTableEntity @CpvTable -Filter "PartitionKey eq 'Tenant'"
        $TenantList = Get-Tenants -IncludeErrors | Where-Object { $_.customerId -ne $env:TenantID -and $_.Excluded -eq $false }
        $CPVRefreshList = [System.Collections.Generic.List[object]]::new()
        $CPVSuccess = $true
        foreach ($Tenant in $TenantList) {
            $LastRefresh = ($CpvRefresh | Where-Object { $_.RowKey -eq $Tenant.customerId }).Timestamp.DateTime
            if ($LastRefresh -lt $LastUpdate) {
                $CPVSuccess = $false
                $CPVRefreshList.Add([PSCustomObject]@{
                        CustomerId        = $Tenant.customerId
                        DisplayName       = $Tenant.displayName
                        DefaultDomainName = $Tenant.DefaultDomainName
                        LastRefresh       = $LastRefresh
                    })
            }
        }
        if (!$CPVSuccess) {
            $ErrorMessages.Add('Some tenants need a CPV refresh.') | Out-Null
            $Success = $false
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -Headers $User -API $APINAME -message "Permissions check failed: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
        $ErrorMessages.Add("We could not connect to the API to retrieve the permissions. There might be a problem with the secure application model configuration. The returned error is: $($ErrorMessage.NormalizedError)") | Out-Null

        try {
            $MFAServicePolicy = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/policies/mfaServicePolicy' -tenantid $env:TenantID -AsApp $true -NoAuthCheck $true
            if ($MFAServicePolicy.rememberMfaOnTrustedDevice.isEnabled -eq $true -and $MFAServicePolicy.rememberMfaOnTrustedDevice.allowedNumberOfDays -gt 0) {
                $ErrorMessages.Add("MFA Service Policy has a session lifetime of $($MFAServicePolicy.rememberMfaOnTrustedDevice.allowedNumberOfDays) days. This may cause authentication issues for your service account.") | Out-Null
                $Links.Add([PSCustomObject]@{
                        Text = 'Troubleshooting'
                        Href = 'https://docs.cipp.app/troubleshooting/troubleshooting#multi-factor-authentication-troubleshooting'
                    }
                ) | Out-Null
            }
        } catch {}

        $Success = $false
    }

    if ($Success -eq $true) {
        $Messages.Add('No service account issues have been found. CIPP is ready for use.') | Out-Null
    }

    $AccessCheck = [PSCustomObject]@{
        AccessTokenDetails      = $AccessTokenDetails
        ApplicationTokenDetails = $ApplicationTokenDetails
        Messages                = @($Messages)
        ErrorMessages           = @($ErrorMessages)
        MissingPermissions      = @($MissingPermissions)
        CPVRefreshList          = @($CPVRefreshList)
        Links                   = @($Links)
        Success                 = $Success
    }

    $Table = Get-CIPPTable -TableName AccessChecks
    $Data = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AccessCheck' and RowKey eq 'AccessPermissions'"
    if ($Data) {
        $Data.Data = [string](ConvertTo-Json -InputObject $AccessCheck -Depth 10 -Compress)
    } else {
        $Data = @{
            PartitionKey = 'AccessCheck'
            RowKey       = 'AccessPermissions'
            Data         = [string](ConvertTo-Json -InputObject $AccessCheck -Depth 10 -Compress)
        }
    }
    try {
        Add-CIPPAzDataTableEntity @Table -Entity $Data -Force
    } catch {}

    return $AccessCheck
}
#EndRegion './Public/Test-CIPPAccessPermissions.ps1' 210
#Region './Public/Test-CIPPAccessTenant.ps1' -1

function Test-CIPPAccessTenant {
    [CmdletBinding()]
    param (
        $Tenant = 'AllTenants',
        $APIName = 'Access Check',
        $Headers
    )
    $ExpectedRoles = @(
        @{ Name = 'Application Administrator'; Id = '9b895d92-2cd3-44c7-9d02-a6ac2d5ea5c3' },
        @{ Name = 'User Administrator'; Id = 'fe930be7-5e62-47db-91af-98c3a49a38b1' },
        @{ Name = 'Intune Administrator'; Id = '3a2c62db-5318-420d-8d74-23affee5d9d5' },
        @{ Name = 'Exchange Administrator'; Id = '29232cdf-9323-42fd-ade2-1d097af3e4de' },
        @{ Name = 'Security Administrator'; Id = '194ae4cb-b126-40b2-bd5b-6091b380977d' },
        @{ Name = 'Cloud App Security Administrator'; Id = '892c5842-a9a6-463a-8041-72aa08ca3cf6' },
        @{ Name = 'Cloud Device Administrator'; Id = '7698a772-787b-4ac8-901f-60d6b08affd2' },
        @{ Name = 'Teams Administrator'; Id = '69091246-20e8-4a56-aa4d-066075b2a7a8' },
        @{ Name = 'SharePoint Administrator'; Id = 'f28a1f50-f6e7-4571-818b-6a12f2af6b6c' },
        @{ Name = 'Authentication Policy Administrator'; Id = '0526716b-113d-4c15-b2c8-68e3c22b9f80' },
        @{ Name = 'Privileged Role Administrator'; Id = 'e8611ab8-c189-46e8-94e1-60213ab1f814' },
        @{ Name = 'Privileged Authentication Administrator'; Id = '7be44c8a-adaf-4e2a-84d6-ab2649e08a13' }
    )

    $TenantParams = @{
        IncludeErrors = $true
    }
    if ($Tenant -eq 'AllTenants') {
        $TenantList = Get-Tenants @TenantParams
        $Queue = New-CippQueueEntry -Name 'Tenant Access Check' -TotalTasks ($TenantList | Measure-Object).Count

        $InputObject = [PSCustomObject]@{
            QueueFunction    = @{
                FunctionName = 'GetTenants'
                TenantParams = $TenantParams
                DurableName  = 'CIPPAccessTenantTest'
                QueueId      = $Queue.RowKey
            }
            OrchestratorName = 'CippAccessTenantTest'
            SkipLog          = $true
        }
        $null = Start-NewOrchestration -FunctionName CIPPOrchestrator -InputObject ($InputObject | ConvertTo-Json -Depth 10)
        $Results = "Queued $($TenantList.Count) tenants for access checks"

    } else {
        $TenantParams.TenantFilter = $Tenant
        $Tenant = Get-Tenants @TenantParams

        $GraphStatus = $false
        $ExchangeStatus = $false

        $Results = [PSCustomObject]@{
            TenantName                = $Tenant.defaultDomainName
            GraphStatus               = $false
            GraphTest                 = ''
            ExchangeStatus            = $false
            ExchangeTest              = ''
            GDAPRoles                 = ''
            MissingRoles              = ''
            OrgManagementRoles        = @()
            OrgManagementRolesMissing = @()
            LastRun                   = (Get-Date).ToUniversalTime()
        }

        $AddedText = ''
        try {
            $TenantId = $Tenant.customerId
            $BulkRequests = $ExpectedRoles | ForEach-Object { @(
                    @{
                        id     = "roleManagement_$($_.Id)"
                        method = 'GET'
                        url    = "roleManagement/directory/roleAssignments?`$filter=roleDefinitionId eq '$($_.Id)'&`$expand=principal"
                    }
                )
            }
            $GDAPRolesGraph = New-GraphBulkRequest -tenantid $TenantId -Requests $BulkRequests
            $GDAPRoles = [System.Collections.Generic.List[object]]::new()
            $MissingRoles = [System.Collections.Generic.List[object]]::new()

            foreach ($RoleId in $ExpectedRoles) {
                $GraphRole = $GDAPRolesGraph.body.value | Where-Object -Property roleDefinitionId -EQ $RoleId.Id
                $Role = $GraphRole.principal | Where-Object -Property organizationId -EQ $env:TenantID

                if (!$Role) {
                    $MissingRoles.Add(
                        [PSCustomObject]@{
                            Name = $RoleId.Name
                            Type = 'Tenant'
                        }
                    )
                    $AddedText = 'but missing GDAP roles'
                } else {
                    $GDAPRoles.Add([PSCustomObject]@{
                            Role  = $RoleId.Name
                            Group = $Role.displayName
                        })
                }
            }

            $GraphTest = "Successfully connected to Graph $($AddedText)"
            $GraphStatus = $true
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $GraphTest = "Failed to connect to Graph: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APINAME -tenant $tenant.defaultDomainName -message "Tenant access check failed: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
        }

        try {
            $null = New-ExoRequest -tenantid $Tenant.customerId -cmdlet 'Get-OrganizationConfig' -ErrorAction Stop

            $OrgManagementRoles = New-ExoRequest -tenantid $Tenant.customerId -cmdlet 'Get-ManagementRoleAssignment' -cmdParams @{ Delegating = $false } | Where-Object { $_.RoleAssigneeName -eq 'Organization Management' } | Select-Object -Property Role, Guid
            Write-Information "Found $($OrgManagementRoles.Count) Organization Management roles in Exchange"
            $Results.OrgManagementRoles = $OrgManagementRoles

            $RoleDefinitions = New-GraphGetRequest -tenantid $Tenant.customerId -uri 'https://graph.microsoft.com/beta/roleManagement/exchange/roleDefinitions'
            Write-Information "Found $($RoleDefinitions.Count) Exchange role definitions"

            $BasePath = Get-Module -Name 'CIPPCore' | Select-Object -ExpandProperty ModuleBase
            $AllOrgManagementRoles = Get-Content -Path "$BasePath\lib\data\OrganizationManagementRoles.json" -ErrorAction Stop | ConvertFrom-Json
            Write-Information "Loaded all Organization Management roles from $BasePath\lib\data\OrganizationManagementRoles.json"

            $AvailableRoles = $RoleDefinitions | Where-Object -Property displayName -In $AllOrgManagementRoles | Select-Object -Property displayName, id, description
            Write-Information "Found $($AvailableRoles.Count) available Organization Management roles in Exchange"
            $MissingOrgMgmtRoles = $AvailableRoles | Where-Object { $OrgManagementRoles.Role -notcontains $_.displayName }
            if (($MissingOrgMgmtRoles | Measure-Object).Count -gt 0) {
                $Results.OrgManagementRolesMissing = $MissingOrgMgmtRoles
                Write-Warning "Found $($MissingRoles.Count) missing Organization Management roles in Exchange"
                $ExchangeStatus = $false
                $ExchangeTest = 'Connected to Exchange but missing permissions in Organization Management. This may impact the ability to manage Exchange features'
                Write-LogMessage -headers $Headers -API $APINAME -tenant $tenant.defaultDomainName -message 'Tenant access check for Exchange failed: Missing Organization Management roles' -Sev 'Warning' -LogData $MissingOrgMgmtRoles
            } else {
                Write-Warning 'All available Organization Management roles are present in Exchange'
                $ExchangeStatus = $true
                $ExchangeTest = 'Successfully connected to Exchange'
            }
        } catch {
            $ErrorMessage = Get-CippException -Exception $_
            $ReportedError = ($_.ErrorDetails | ConvertFrom-Json -ErrorAction SilentlyContinue)
            $Message = if ($ReportedError.error.details.message) { $ReportedError.error.details.message } else { $ReportedError.error.innererror.internalException.message }
            if ($null -eq $Message) { $Message = $($_.Exception.Message) }

            $ExchangeTest = "Failed to connect to Exchange: $($ErrorMessage.NormalizedError)"
            Write-LogMessage -headers $Headers -API $APINAME -tenant $tenant.defaultDomainName -message "Tenant access check for Exchange failed: $($ErrorMessage.NormalizedError) " -Sev 'Error' -LogData $ErrorMessage
            Write-Warning "Failed to connect to Exchange: $($_.Exception.Message)"
        }

        if ($GraphStatus -and $ExchangeStatus) {
            Write-LogMessage -headers $Headers -API $APINAME -tenant $Tenant.defaultDomainName -tenantId $Tenant.customerId -message 'Tenant access check executed successfully' -Sev 'Info'
        }

        $Results.GraphStatus = $GraphStatus
        $Results.GraphTest = $GraphTest
        $Results.ExchangeStatus = $ExchangeStatus
        $Results.ExchangeTest = $ExchangeTest
        $Results.GDAPRoles = @($GDAPRoles)
        $Results.MissingRoles = @($MissingRoles)

        $Headers = $Headers.UserDetails
        $Entity = @{
            PartitionKey = 'TenantAccessChecks'
            RowKey       = $Tenant.customerId
            Data         = [string]($Results | ConvertTo-Json -Depth 10 -Compress)
        }
        $Table = Get-CIPPTable -TableName 'AccessChecks'
        try {
            $null = Add-CIPPAzDataTableEntity @Table -Entity $Entity -Force
        } catch {
            Write-LogMessage -headers $Headers -API $APINAME -tenant $Tenant.defaultDomainName -message "Failed to add access check for $($Tenant.customerId): $($_.Exception.Message)" -Sev 'Error' -LogData (Get-CippException -Exception $_)
        }
    }

    return $Results
}
#EndRegion './Public/Test-CIPPAccessTenant.ps1' 172
#Region './Public/Test-CIPPGDAPRelationships.ps1' -1

function Test-CIPPGDAPRelationships {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $APIName = 'Access Check',
        $Headers
    )

    $GDAPissues = [System.Collections.Generic.List[object]]@()
    $MissingGroups = [System.Collections.Generic.List[object]]@()
    try {
        #Get graph request to list all relationships.
        $Relationships = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/tenantRelationships/delegatedAdminRelationships?`$filter=status eq 'active'" -tenantid $env:TenantID -NoAuthCheck $true
        #Group relationships by tenant. The tenant information is in $relationships.customer.TenantId.
        $RelationshipsByTenant = $Relationships | Group-Object -Property { $_.customer.TenantId }
        foreach ($Tenant in $RelationshipsByTenant) {
            if ($Tenant.Group.displayName.count -le 1 -and $Tenant.Group.displayName -like 'MLT_*') {
                $GDAPissues.add([PSCustomObject]@{
                        Type         = 'Error'
                        Issue        = 'This tenant only has a MLT(Microsoft Led Transition) relationship. This is a read-only relationship. You must migrate this tenant to GDAP.'
                        Tenant       = [string]$Tenant.Group.customer.displayName
                        Relationship = [string]$Tenant.Group.displayName
                        Link         = 'https://docs.cipp.app/setup/gdap/index'
                    }) | Out-Null
            }
            foreach ($Group in $Tenant.Group) {
                if ('62e90394-69f5-4237-9190-012177145e10' -in $Group.accessDetails.unifiedRoles.roleDefinitionId) {
                    $GDAPissues.add([PSCustomObject]@{
                            Type         = 'Warning'
                            Issue        = 'The relationship has global administrator access. Auto-Extend is not available.'
                            Tenant       = [string]$Group.customer.displayName
                            Relationship = [string]$Group.displayName
                            Link         = 'https://docs.cipp.app/setup/installation/recommended-roles'

                        }) | Out-Null
                }
            }

        }
        $me = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/me?$select=UserPrincipalName' -NoAuthCheck $true).UserPrincipalName
        $CIPPGroupCount = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups/`$count?`$filter=startsWith(displayName,'M365 GDAP')" -NoAuthCheck $true -ComplexFilter
        $SAMUserMemberships = New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/me/memberOf?$select=id,displayName,isAssignableToRole' -NoAuthCheck $true
        $ExpectedGroups = @(
            'AdminAgents',
            'M365 GDAP Application Administrator',
            'M365 GDAP User Administrator',
            'M365 GDAP Intune Administrator',
            'M365 GDAP Exchange Administrator',
            'M365 GDAP Security Administrator',
            'M365 GDAP Cloud App Security Administrator',
            'M365 GDAP Cloud Device Administrator',
            'M365 GDAP Teams Administrator',
            'M365 GDAP SharePoint Administrator',
            'M365 GDAP Authentication Policy Administrator',
            'M365 GDAP Privileged Role Administrator',
            'M365 GDAP Privileged Authentication Administrator'
        )
        $RoleAssignableGroups = $SAMUserMemberships | Where-Object { $_.isAssignableToRole }
        $NestedGroups = foreach ($Group in $RoleAssignableGroups) {
            Write-Information "Getting nested group memberships for $($Group.displayName)"
            New-GraphGetRequest -uri "https://graph.microsoft.com/beta/groups/$($Group.id)/memberOf?`$select=id,displayName" -NoAuthCheck $true
        }
        foreach ($Group in $ExpectedGroups) {
            $GroupFound = $false
            foreach ($Membership in ($SAMUserMemberships + $NestedGroups)) {
                if ($Membership.displayName -match $Group) {
                    Write-Information "Found $Group in group memberships"
                    $GroupFound = $true
                }
            }
            if (-not $GroupFound) {
                if ($Group -eq 'AdminAgents') { $Type = 'Error' } else { $Type = 'Warning' }
                $GDAPissues.add([PSCustomObject]@{
                        Type         = $Type
                        Issue        = "$($Group) is not assigned to the SAM user $me. If you have migrated outside of CIPP this is to be expected. Please perform an access check to make sure you have the correct set of permissions."
                        Tenant       = '*Partner Tenant'
                        Relationship = 'None'
                        Link         = 'https://docs.cipp.app/setup/gdap/troubleshooting#groups'

                    }) | Out-Null
                $MissingGroups.Add([PSCustomObject]@{
                        Name = $Group
                        Type = 'SAM User Membership'
                    }) | Out-Null
            }
        }
        if ($CIPPGroupCount -lt 12) {
            $GDAPissues.add([PSCustomObject]@{
                    Type         = 'Warning'
                    Issue        = "We only found $($CIPPGroupCount) of the 12 required groups. If you have migrated outside of CIPP this is to be expected. Please perform an access check to make sure you have the correct set of permissions."
                    Tenant       = '*Partner Tenant'
                    Relationship = 'None'
                    Link         = 'https://docs.cipp.app/setup/gdap/troubleshooting#groups'

                }) | Out-Null
        }

    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-LogMessage -headers $Headers -API $APINAME -message "Failed to run GDAP check for $($TenantFilter): $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData $ErrorMessage
    }

    $GDAPRelationships = [PSCustomObject]@{
        GDAPIssues     = @($GDAPissues)
        MissingGroups  = @($MissingGroups)
        Memberships    = @($SAMUserMemberships)
        CIPPGroupCount = $CIPPGroupCount
    }

    $Table = Get-CIPPTable -TableName AccessChecks
    $Data = Get-CIPPAzDataTableEntity @Table -Filter "PartitionKey eq 'AccessCheck' and RowKey eq 'GDAPRelationships'"

    if ($Data) {
        $Data.Data = [string](ConvertTo-Json -InputObject $GDAPRelationships -Depth 10 -Compress)
    } else {
        $Data = @{
            PartitionKey = 'AccessCheck'
            RowKey       = 'GDAPRelationships'
            Data         = [string](ConvertTo-Json -InputObject $GDAPRelationships -Depth 10 -Compress)
        }
    }
    try {
        Add-CIPPAzDataTableEntity @Table -Entity $Data -Force
    } catch {}

    return $GDAPRelationships
}
#EndRegion './Public/Test-CIPPGDAPRelationships.ps1' 128
#Region './Public/Test-CIPPRerun.ps1' -1

function Test-CIPPRerun {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $Type,
        $API,
        $Settings,
        $Headers,
        [switch]$Clear,
        [switch]$ClearAll
    )
    $RerunTable = Get-CIPPTable -tablename 'RerunCache'
    $EstimatedDifference = switch ($Type) {
        'Standard' { 9800 } # 2 hours 45 minutes ish.
        'BPA' { 85000 } # 24 hours ish.
        default { throw "Unknown type: $Type" }
    }
    $CurrentUnixTime = [int][double]::Parse((Get-Date -UFormat %s))
    $EstimatedNextRun = $CurrentUnixTime + $EstimatedDifference

    try {
        $RerunData = Get-CIPPAzDataTableEntity @RerunTable -filter "PartitionKey eq '$($TenantFilter)'" | Where-Object { $_.RowKey -match "^$($Type)_$($API)" }
        if ($ClearAll.IsPresent) {
            $AllRerunData = Get-CIPPAzDataTableEntity @RerunTable
            if ($AllRerunData) {
                Write-Information "Clearing all rerun cache entries for $($Type)_$($API)"
                Remove-AzDataTableEntity @RerunTable -Entity $AllRerunData -Force
            }
            return $false
        }

        if ($Clear.IsPresent) {
            if ($RerunData) {
                Remove-AzDataTableEntity @RerunTable -Entity $RerunData
            }
            return $false
        } elseif ($RerunData) {
            if ($Settings -and $RerunData.Settings) {
                Write-Host 'Testing rerun settings'
                $PreviousSettings = $RerunData.Settings
                $NewSettings = $($Settings | ConvertTo-Json -Depth 10 -Compress)
                if ($NewSettings.Length -ne $PreviousSettings.Length) {
                    Write-Host "$($NewSettings.Length) vs $($PreviousSettings.Length) - settings have changed."
                    $RerunData.EstimatedNextRun = $EstimatedNextRun
                    $RerunData.Settings = "$($Settings | ConvertTo-Json -Depth 10 -Compress)"
                    Add-CIPPAzDataTableEntity @RerunTable -Entity $RerunData -Force
                    return $false # Not a rerun because settings have changed.
                }
            }
            if ($RerunData.EstimatedNextRun -gt $CurrentUnixTime) {
                Write-LogMessage -API $API -message "Standard rerun detected for $($API). Prevented from running again." -tenant $TenantFilter -headers $Headers -Sev 'Info'
                return $true
            } else {
                $RerunData.EstimatedNextRun = $EstimatedNextRun
                $RerunData.Settings = "$($Settings | ConvertTo-Json -Depth 10 -Compress)"
                Add-CIPPAzDataTableEntity @RerunTable -Entity $RerunData -Force
                return $false
            }
        } else {
            $EstimatedNextRun = $CurrentUnixTime + $EstimatedDifference
            $NewEntity = @{
                PartitionKey     = "$TenantFilter"
                RowKey           = "$($Type)_$($API)"
                Settings         = "$($Settings | ConvertTo-Json -Depth 10 -Compress)"
                EstimatedNextRun = $EstimatedNextRun
            }
            Add-CIPPAzDataTableEntity @RerunTable -Entity $NewEntity -Force
            return $false
        }
    } catch {
        $ErrorMessage = Get-CippException -Exception $_
        Write-Host "Could not detect if this is a rerun: $($ErrorMessage.NormalizedError)"
        Write-LogMessage -headers $Headers -API $API -message "Could not detect if this is a rerun: $($ErrorMessage.NormalizedError)" -Sev 'Error' -LogData (Get-CippException -Exception $_)
        return $false
    }
}
#EndRegion './Public/Test-CIPPRerun.ps1' 77
#Region './Public/Tools/Enable-CippConsoleLogging.ps1' -1

# Define log level enum at script scope
enum CippConsoleLogLevel {
    Debug = 0
    Verbose = 1
    Information = 2
    Warning = 3
    Error = 4
}

function Enable-CippConsoleLogging {
    <#
    .SYNOPSIS
        Enable console output logging to Application Insights
    .DESCRIPTION
        Overrides Write-Information, Write-Warning, Write-Error, Write-Verbose, and Write-Debug
        functions to send telemetry to Application Insights while maintaining normal console output
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Enable-CippConsoleLogging

        # Now all Write-* calls will be logged to Application Insights
        Write-Information "This will be logged"
        Write-Warning "This warning will be logged"
    #>
    [CmdletBinding()]
    param()

    # Initialize AsyncLocal storage for InvocationId (thread-safe)
    if (-not $script:CippInvocationIdStorage) {
        $script:CippInvocationIdStorage = [System.Threading.AsyncLocal[string]]::new()
    }

    # Set minimum log level from environment variable (default: Information)
    $validLevels = @('Debug', 'Verbose', 'Information', 'Warning', 'Error')
    $configuredLevel = $env:CIPP_CONSOLE_LOG_LEVEL
    $global:CippConsoleLogMinLevel = if ($configuredLevel -and $configuredLevel -in $validLevels) {
        $configuredLevel
    } else {
        'Information'
    }

    # Override Write-Information
    function global:Write-Information {
        [CmdletBinding()]
        param(
            [Parameter(Position = 0, ValueFromPipeline)]
            [object]$MessageData,
            [string[]]$Tags
        )

        # Only process and call original if MessageData is provided
        if ($PSBoundParameters.ContainsKey('MessageData') -and $MessageData) {
            # Send to telemetry
            if (-not [string]::IsNullOrWhiteSpace(($MessageData | Out-String).Trim())) {
                Send-CippConsoleLog -Message ($MessageData | Out-String).Trim() -Level 'Information'
            }

            # Call original function
            Microsoft.PowerShell.Utility\Write-Information @PSBoundParameters
        }
    }

    # Override Write-Warning
    function global:Write-Warning {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory, Position = 0, ValueFromPipeline)]
            [string]$Message
        )

        # Send to telemetry
        if ($Message -and -not [string]::IsNullOrWhiteSpace($Message)) {
            Send-CippConsoleLog -Message $Message -Level 'Warning'
        }

        # Call original function
        Microsoft.PowerShell.Utility\Write-Warning @PSBoundParameters
    }

    # Override Write-Error
    function global:Write-Error {
        [CmdletBinding()]
        param(
            [Parameter(Position = 0, ValueFromPipeline)]
            [object]$Message,
            [object]$Exception,
            [object]$ErrorRecord,
            [string]$ErrorId,
            [System.Management.Automation.ErrorCategory]$Category,
            [object]$TargetObject,
            [string]$RecommendedAction,
            [string]$CategoryActivity,
            [string]$CategoryReason,
            [string]$CategoryTargetName,
            [string]$CategoryTargetType
        )

        # Send to telemetry
        $errorMessage = if ($Message) { ($Message | Out-String).Trim() }
        elseif ($Exception) { $Exception.Message }
        elseif ($ErrorRecord) { $ErrorRecord.Exception.Message }
        else { 'Unknown error' }

        if ($errorMessage -and -not [string]::IsNullOrWhiteSpace($errorMessage)) {
            Send-CippConsoleLog -Message $errorMessage -Level 'Error'
        }

        # Call original function
        Microsoft.PowerShell.Utility\Write-Error @PSBoundParameters
    }

    # Override Write-Verbose
    function global:Write-Verbose {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory, Position = 0, ValueFromPipeline)]
            [string]$Message
        )

        # Send to telemetry
        if ($Message -and -not [string]::IsNullOrWhiteSpace($Message)) {
            Send-CippConsoleLog -Message $Message -Level 'Verbose'
        }

        # Call original function
        Microsoft.PowerShell.Utility\Write-Verbose @PSBoundParameters
    }

    # Override Write-Debug
    function global:Write-Debug {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory, Position = 0, ValueFromPipeline)]
            [string]$Message
        )

        # Send to telemetry
        if ($Message -and -not [string]::IsNullOrWhiteSpace($Message)) {
            Send-CippConsoleLog -Message $Message -Level 'Debug'
        }

        # Call original function
        Microsoft.PowerShell.Utility\Write-Debug @PSBoundParameters
    }

    # Override Write-Host
    function global:Write-Host {
        [CmdletBinding()]
        param(
            [Parameter(Position = 0, ValueFromPipeline)]
            [object]$Object,
            [switch]$NoNewline,
            [object]$Separator,
            [System.ConsoleColor]$ForegroundColor,
            [System.ConsoleColor]$BackgroundColor
        )

        # Send to telemetry
        $message = if ($Object) { ($Object | Out-String).Trim() } else { '' }
        if ($message -and -not [string]::IsNullOrWhiteSpace($message)) {
            Send-CippConsoleLog -Message $message -Level 'Information'
        }

        # Call original function
        Microsoft.PowerShell.Utility\Write-Host @PSBoundParameters
    }
}
#EndRegion './Public/Tools/Enable-CippConsoleLogging.ps1' 169
#Region './Public/Tools/Import-CommunityTemplate.ps1' -1

function Import-CommunityTemplate {
    <#

    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $Template,
        $SHA,
        $MigrationTable,
        $LocationData,
        [switch]$Force
    )

    $Table = Get-CippTable -TableName 'templates'

    try {
        if ($Template.RowKey) {
            Write-Host "This is going to be a direct write to table, it's a CIPP template. We're writing $($Template.RowKey)"
            $Template = $Template | Select-Object * -ExcludeProperty Timestamp

            # Support both objects and json string in repo (support pretty printed json in repo)
            if (Test-Json $Template.JSON -ErrorAction SilentlyContinue) {
                $NewJSON = $Template.JSON | ConvertFrom-Json
            } else {
                $NewJSON = $Template.JSON
            }

            # Check for existing object
            $Existing = Get-CIPPAzDataTableEntity @Table -Filter "RowKey eq '$($Template.RowKey)' and PartitionKey eq '$($Template.PartitionKey)'" -ErrorAction SilentlyContinue

            if ($Existing) {
                if ($Existing.PartitionKey -eq 'StandardsTemplateV2') {
                    # Convert existing JSON to object for updates
                    if (Test-Json $Existing.JSON -ErrorAction SilentlyContinue) {
                        $ExistingJSON = $Existing.JSON | ConvertFrom-Json
                    } else {
                        $ExistingJSON = $Existing.JSON
                    }
                    # Extract existing tenantFilter and excludedTenants
                    $tenantFilter = $ExistingJSON.tenantFilter
                    $excludedTenants = $ExistingJSON.excludedTenants
                    $NewJSON.tenantFilter = $tenantFilter
                    $NewJSON.excludedTenants = $excludedTenants

                    # Extract package tag from existing template
                    $PackageTag = $Existing.Package
                    if ($PackageTag) {
                        $Template | Add-Member -MemberType NoteProperty -Name Package -Value $PackageTag -Force
                    }
                }
            }

            if ($Template.PartitionKey -eq 'AppApprovalTemplate') {
                # Extract the Permission Set name,id,permissions from the JSON and add to the AppPermissions table
                $AppPermissionsTable = Get-CIPPTable -TableName 'AppPermissions'
                $Permissions = $NewJSON.Permissions
                $Entity = @{
                    'PartitionKey' = 'Templates'
                    'RowKey'       = $NewJSON.PermissionSetId
                    'TemplateName' = $NewJSON.PermissionSetName
                    'Permissions'  = [string]($Permissions | ConvertTo-Json -Depth 10 -Compress)
                    'UpdatedBy'    = $NewJSON.UpdatedBy ?? $NewJSON.CreatedBy ?? 'System'
                }
                $null = Add-CIPPAzDataTableEntity @AppPermissionsTable -Entity $Entity -Force
                Write-Information 'Added App Permissions to AppPermissions table'
            }

            # Re-compress JSON and save to table
            $NewJSON = [string]($NewJSON | ConvertTo-Json -Depth 100 -Compress)
            $Template.JSON = $NewJSON
            $Template | Add-Member -MemberType NoteProperty -Name SHA -Value $SHA -Force
            Add-CIPPAzDataTableEntity @Table -Entity $Template -Force
        } else {
            if ($Template.mailNickname) { $Type = 'Group' }
            if ($Template.'@odata.type' -like '*conditionalAccessPolicy*') { $Type = 'ConditionalAccessPolicy' }
            Write-Host "The type is $Type"
            switch -Wildcard ($Type) {

                '*Group*' {
                    $RawJsonObj = [PSCustomObject]@{
                        Displayname     = $Template.displayName
                        Description     = $Template.Description
                        MembershipRules = $Template.membershipRule
                        username        = $Template.mailNickname
                        GUID            = $Template.id
                        groupType       = 'generic'
                    } | ConvertTo-Json -Depth 100
                    $entity = @{
                        JSON         = "$RawJsonObj"
                        PartitionKey = 'GroupTemplate'
                        SHA          = $SHA
                        GUID         = $Template.id
                        RowKey       = $Template.id
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $entity -Force
                    break
                }
                '*conditionalAccessPolicy*' {
                    Write-Host $MigrationTable
                    $Template = ([pscustomobject]$Template) | ForEach-Object {
                        $NonEmptyProperties = $_.psobject.Properties | Where-Object { $null -ne $_.Value } | Select-Object -ExpandProperty Name
                        $_ | Select-Object -Property $NonEmptyProperties
                    }
                    $id = $Template.id
                    $Template = $Template | Select-Object * -ExcludeProperty lastModifiedDateTime, 'assignments', '#microsoft*', '*@odata.navigationLink', '*@odata.associationLink', '*@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime', '@odata.id', '@odata.editLink', '*odata.type', 'roleScopeTagIds@odata.type', createdDateTime, 'createdDateTime@odata.type'
                    Remove-ODataProperties -Object $Template

                    $LocationInfo = [system.collections.generic.list[object]]::new()
                    if ($LocationData) {
                        $LocationData | ForEach-Object {
                            if ($Template.conditions.locations.includeLocations -contains $_.id -or $Template.conditions.locations.excludeLocations -contains $_.id) {
                                Write-Information "Adding location info for location ID $($_.id)"
                                $LocationInfo.Add($_)
                            }
                        }
                        if ($LocationInfo.Count -gt 0) {
                            $Template | Add-Member -MemberType NoteProperty -Name LocationInfo -Value $LocationInfo -Force
                        }
                    }

                    $RawJson = ConvertTo-Json -InputObject $Template -Depth 100 -Compress
                    #Replace the ids with the displayname by using the migration table, this is a simple find and replace each instance in the JSON.
                    $MigrationTable.objects | ForEach-Object {
                        if ($RawJson -match $_.ID) {
                            $RawJson = $RawJson.Replace($_.ID, $($_.DisplayName))
                        }
                    }


                    $entity = @{
                        JSON         = "$RawJson"
                        PartitionKey = 'CATemplate'
                        SHA          = $SHA
                        GUID         = $ID
                        RowKey       = $ID
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $entity -Force
                    break
                }
                default {
                    $URLName = switch -Wildcard ($Template.'@odata.id') {
                        '*CompliancePolicies*' { 'DeviceCompliancePolicies' }
                        '*deviceConfigurations*' { 'Device' }
                        '*DriverUpdateProfiles*' { 'windowsDriverUpdateProfiles' }
                        '*SettingsCatalog*' { 'Catalog' }
                        '*configurationPolicies*' { 'Catalog' }
                        '*managedAppPolicies*' { 'AppProtection' }
                        '*deviceAppManagement*' { 'AppProtection' }
                    }
                    $id = $Template.id
                    $RawJson = $Template | Select-Object * -ExcludeProperty id, lastModifiedDateTime, 'assignments', '#microsoft*', '*@odata.navigationLink', '*@odata.associationLink', '*@odata.context', 'ScopeTagIds', 'supportsScopeTags', 'createdDateTime', '@odata.id', '@odata.editLink', 'lastModifiedDateTime@odata.type', 'roleScopeTagIds@odata.type', createdDateTime, 'createdDateTime@odata.type'
                    Remove-ODataProperties -Object $RawJson
                    $RawJson = $RawJson | ConvertTo-Json -Depth 100 -Compress

                    #create a new template
                    $RawJsonObj = [PSCustomObject]@{
                        Displayname = $Template.displayName ?? $template.Name
                        Description = $Template.Description
                        RAWJson     = $RawJson
                        Type        = $URLName
                        GUID        = $ID
                    } | ConvertTo-Json -Depth 100 -Compress

                    $entity = @{
                        JSON         = "$RawJsonObj"
                        PartitionKey = 'IntuneTemplate'
                        SHA          = $SHA
                        GUID         = $ID
                        RowKey       = $ID
                    }
                    Add-CIPPAzDataTableEntity @Table -Entity $entity -Force

                }
            }
        }
    } catch {
        Write-Warning "Community template import failed. Error: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }
}
#EndRegion './Public/Tools/Import-CommunityTemplate.ps1' 182
#Region './Public/Tools/Measure-CippTask.ps1' -1

function Measure-CippTask {
    <#
    .SYNOPSIS
        Measure and track CIPP task execution with Application Insights telemetry
    .DESCRIPTION
        Wraps task execution in a timer, sends custom event to Application Insights with duration and metadata
    .PARAMETER TaskName
        The name of the task being executed (e.g., "New-CIPPTemplateRun")
    .PARAMETER Script
        The scriptblock to execute and measure
    .PARAMETER Metadata
        Optional hashtable of metadata to include in telemetry (e.g., Command, Tenant, TaskInfo)
    .PARAMETER EventName
        Optional custom event name (default: "CIPP.TaskCompleted")
    .FUNCTIONALITY
        Internal
    .EXAMPLE
        Measure-CippTask -TaskName "ApplyTemplate" -Script {
            # Task logic here
        } -Metadata @{
            Command = "New-CIPPTemplateRun"
            Tenant = "contoso.onmicrosoft.com"
        }
    .EXAMPLE
        Measure-CippTask -TaskName "DisableGuests" -EventName "CIPP.StandardCompleted" -Script {
            # Standard logic here
        } -Metadata @{
            Standard = "DisableGuests"
            Tenant = "contoso.onmicrosoft.com"
        }
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TaskName,

        [Parameter(Mandatory = $true)]
        [scriptblock]$Script,

        [Parameter(Mandatory = $false)]
        [hashtable]$Metadata,

        [Parameter(Mandatory = $false)]
        [string]$EventName = 'CIPP.TaskCompleted'
    )

    # Initialize tracking variables
    $sw = [System.Diagnostics.Stopwatch]::StartNew()
    $result = $null
    $errorOccurred = $false
    $errorMessage = $null

    try {
        # Execute the actual task
        $result = & $Script
    } catch {
        $errorOccurred = $true
        $errorMessage = $_.Exception.Message
        # Re-throw to preserve original error behavior
        throw
    } finally {
        # Stop the timer
        $sw.Stop()
        $durationMs = [int]$sw.Elapsed.TotalMilliseconds

        # Send telemetry if TelemetryClient is available
        if ($global:TelemetryClient) {
            try {
                # Build properties dictionary for customDimensions
                $props = New-Object 'System.Collections.Generic.Dictionary[string,string]'
                $props['TaskName'] = $TaskName
                $props['Success'] = (-not $errorOccurred).ToString()

                if ($errorOccurred) {
                    $props['ErrorMessage'] = $errorMessage
                }

                # Add all metadata to properties
                if ($Metadata) {
                    foreach ($key in $Metadata.Keys) {
                        $value = $Metadata[$key]
                        # Convert value to string, handling nulls
                        if ($null -ne $value) {
                            $props[$key] = [string]$value
                        } else {
                            $props[$key] = ''
                        }
                    }
                }

                # Metrics dictionary for customMeasurements
                $metrics = New-Object 'System.Collections.Generic.Dictionary[string,double]'
                $metrics['DurationMs'] = [double]$durationMs

                # Send custom event to Application Insights
                $global:TelemetryClient.TrackEvent($EventName, $props, $metrics)
                $global:TelemetryClient.Flush()

                Write-Verbose "Telemetry sent for task '$TaskName' to event '$EventName' (${durationMs}ms)"
            } catch {
                Write-Warning "Failed to send telemetry for task '${TaskName}': $($_.Exception.Message)"
            }
        } else {
            Write-Verbose "TelemetryClient not initialized, skipping telemetry for task '$TaskName'"
        }
    }

    return $result
}
#EndRegion './Public/Tools/Measure-CippTask.ps1' 110
#Region './Public/Tools/Remove-ODataProperties.ps1' -1

function Remove-ODataProperties {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        $Object,
        [switch]$SkipRemovingProperties,
        [string[]]$PropertiesToRemove = @(),
        [string[]]$SkipRemoveProperties = @(),
        [switch]$SkipRemoveDefaultProperties,
        [switch]$SkipRemovingChildProperties
    )
    if ($SkipRemovingProperties) {
        return
    }
    $defaultProperties = @(
        'id',
        'createdDateTime',
        'lastModifiedDateTime',
        'supportsScopeTags',
        'modifiedDateTime'
    )
    if (-not $Object) {
        return
    }
    $removeProps = New-Object System.Collections.Generic.List[string]
    if ($PropertiesToRemove) {
        $removeProps.AddRange($PropertiesToRemove)
    }
    if (-not $SkipRemoveDefaultProperties) {
        foreach ($defProp in $defaultProperties) {
            if (-not $removeProps.Contains($defProp)) {
                $removeProps.Add($defProp)
            }
        }
    }
    function Remove-PropertyIfPresent {
        param(
            [Parameter(Mandatory)]
            $psObject,
            [Parameter(Mandatory)]
            [string]$propName
        )
        $propExists = $psObject.PSObject.Properties | Where-Object { $_.Name -eq $propName }
        if ($propExists) {
            $psObject.PSObject.Properties.Remove($propName) | Out-Null
        }
    }

    if ($Object -is [System.Collections.IEnumerable] -and -not ($Object -is [string])) {
        foreach ($element in $Object) {
            Remove-ODataProperties -Object $element -SkipRemovingProperties:$SkipRemovingProperties -PropertiesToRemove $PropertiesToRemove -SkipRemoveProperties $SkipRemoveProperties -SkipRemoveDefaultProperties:$SkipRemoveDefaultProperties -SkipRemovingChildProperties:$SkipRemovingChildProperties
        }
        return
    }
    if ($Object -is [PSCustomObject]) {
        $odataProps = $Object.PSObject.Properties | Where-Object {
            $_.Name -like '*@odata*Link' -or
            $_.Name -like '*@odata.context' -or
            $_.Name -like '*@odata.id' -or
            ($_.Name -like '*@odata.type' -and $_.Name -ne '@odata.type')
        }

        foreach ($oProp in $odataProps) {
            if (-not $removeProps.Contains($oProp.Name)) {
                $removeProps.Add($oProp.Name)
            }
        }

        foreach ($propName in $removeProps) {
            if ($SkipRemoveProperties -notcontains $propName) {
                Remove-PropertyIfPresent -psObject $Object -propName $propName
            }
        }

        if (-not $SkipRemovingChildProperties) {
            foreach ($prop in $Object.PSObject.Properties) {
                $val = $prop.Value

                if ($val -is [System.Collections.IEnumerable] -and -not ($val -is [string])) {
                    foreach ($child in $val) {

                        if ($child -is [PSCustomObject]) {
                            Remove-ODataProperties -Object $child -SkipRemovingProperties:$SkipRemovingProperties -PropertiesToRemove $PropertiesToRemove -SkipRemoveProperties $SkipRemoveProperties -SkipRemoveDefaultProperties:$SkipRemoveDefaultProperties -SkipRemovingChildProperties:$SkipRemovingChildProperties
                        }
                    }
                }
                # If $val is a single PSCustomObject, recurse into it as well.
                elseif ($val -is [PSCustomObject]) {
                    Remove-ODataProperties -Object $val -SkipRemovingProperties:$SkipRemovingProperties -PropertiesToRemove $PropertiesToRemove -SkipRemoveProperties $SkipRemoveProperties -SkipRemoveDefaultProperties:$SkipRemoveDefaultProperties -SkipRemovingChildProperties:$SkipRemovingChildProperties
                }
            }
        }
    }
}
#EndRegion './Public/Tools/Remove-ODataProperties.ps1' 95
#Region './Public/Tools/Send-CippConsoleLog.ps1' -1

function Send-CippConsoleLog {
    <#
    .SYNOPSIS
        Send console log message to Application Insights
    .DESCRIPTION
        Helper function to send console output to Application Insights telemetry
    .PARAMETER Message
        The message to log
    .PARAMETER Level
        The log level (Debug, Verbose, Information, Warning, Error)
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Message,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Debug', 'Verbose', 'Information', 'Warning', 'Error')]
        [string]$Level
    )

    if ($global:TelemetryClient) {
        try {
            # Map level names to numeric values for comparison
            $levelMap = @{
                'Debug'       = 0
                'Verbose'     = 1
                'Information' = 2
                'Warning'     = 3
                'Error'       = 4
            }

            $currentLevelValue = $levelMap[$Level]
            $minLevelValue = $levelMap[$global:CippConsoleLogMinLevel]

            # Check if this level should be logged
            if ($null -ne $minLevelValue -and $currentLevelValue -ge $minLevelValue) {
                $props = New-Object 'System.Collections.Generic.Dictionary[string,string]'
                $props['Message'] = $Message
                $props['Level'] = $Level
                $props['Timestamp'] = (Get-Date).ToString('o')

                # Add InvocationId if available (from AsyncLocal storage)
                if ($script:CippInvocationIdStorage -and $script:CippInvocationIdStorage.Value) {
                    $props['InvocationId'] = $script:CippInvocationIdStorage.Value
                }

                $global:TelemetryClient.TrackEvent('CIPP.ConsoleLog', $props, $null)
            }
        } catch {
            # Silently fail to avoid infinite loops
        }
    }
}
#EndRegion './Public/Tools/Send-CippConsoleLog.ps1' 57
#Region './Public/Webhooks/Get-CIPPAuditLogContent.ps1' -1

function Get-CIPPAuditLogContent {
    <#
    .SYNOPSIS
        Get the content of an audit log.
    .PARAMETER ContentUri
        The URI of the content to get.
    .PARAMETER TenantFilter
        The tenant to filter on.
    .EXAMPLE
        Get-CIPPAuditLogContent -ContentUri 'https://manage.office.com/api/v1.0/contoso.com/activity/feed/subscriptions/content?contentType=Audit.General&PublisherIdentifier=00000000-0000-0000-0000-000000000000' -TenantFilter 'contoso.com'
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    Param(
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [string[]]$ContentUri,
        [Parameter(ValueFromPipelineByPropertyName = $true, Mandatory = $true)]
        [string]$TenantFilter
    )

    Process {
        foreach ($Uri in $ContentUri) {
            New-GraphPOSTRequest -type GET -uri $Uri -tenantid $TenantFilter -scope 'https://manage.office.com/.default'
        }
    }
}
#EndRegion './Public/Webhooks/Get-CIPPAuditLogContent.ps1' 28
#Region './Public/Webhooks/Get-CIPPAuditLogContentBundles.ps1' -1

function Get-CIPPAuditLogContentBundles {
    <#
    .SYNOPSIS
        Get the available audit log bundles
    .DESCRIPTION
        Query the Office 365 Activity Log API for available content bundles.
    .PARAMETER TenantFilter
        The tenant to filter on.
    .PARAMETER ContentType
        The type of content to get.
    .PARAMETER StartTime
        The start time to filter on.
    .PARAMETER EndTime
        The end time to filter on.
    .PARAMETER ShowAll
        Show all content, default is only show new content
    .EXAMPLE
        Get-CIPPAuditLogContentBundles -TenantFilter 'contoso.com' -ContentType 'Audit.AzureActiveDirectory'
    .FUNCTIONALITY
        Internal
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$TenantFilter,
        [Parameter(Mandatory = $true)]
        [ValidateSet('Audit.AzureActiveDirectory', 'Audit.Exchange')]
        [string]$ContentType,
        [datetime]$StartTime,
        [datetime]$EndTime,
        [switch]$ShowAll
    )

    if ($TenantFilter -eq 'AllTenants') {
        throw 'AllTenants is not a valid tenant filter for webhooks'
    }

    $Tenant = Get-Tenants -TenantFilter $TenantFilter -IncludeErrors
    if (!($TenantFilter -match '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$')) {
        $DefaultDomainName = $TenantFilter
        $TenantFilter = $Tenant.customerId
    } else {
        $DefaultDomainName = $Tenant.defaultDomainName
    }

    $WebhookTable = Get-CippTable -tablename 'webhookTable'
    $WebhookConfig = Get-CIPPAzDataTableEntity @WebhookTable -Filter "PartitionKey eq '$DefaultDomainName' and Version eq '3' and Resource eq '$ContentType'"

    if (!$WebhookConfig) {
        throw "No webhook config found for $DefaultDomainName - $ContentType"
    }

    $Parameters = @{
        'contentType'         = $ContentType
        'PublisherIdentifier' = $env:TenantID
    }

    if (!$ShowAll.IsPresent) {
        if (!$StartTime) {
            $StartTime = (Get-Date).AddMinutes(-30)
            $EndTime = Get-Date
        }
    }

    if ($StartTime) {
        $Parameters.Add('startTime', $StartTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss'))
        if ($EndTime) {
            $Parameters.Add('endTime', $EndTime.ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss'))
        } else {
            $Parameters.Add('endTime', ($StartTime).AddHours(24).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss'))
        }
    }

    Write-Information "StartTime: $StartTime"
    Write-Information "EndTime: $EndTime"
    $GraphQuery = [System.UriBuilder]('https://manage.office.com/api/v1.0/{0}/activity/feed/subscriptions/content' -f $TenantFilter)
    $ParamCollection = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
    foreach ($Item in ($Parameters.GetEnumerator())) {
        $ParamCollection.Add($Item.Key, $Item.Value)
    }
    $GraphQuery.Query = $ParamCollection.ToString()

    Write-Verbose "GET [ $($GraphQuery.ToString()) ]"
    try {
        $LogBundles = New-GraphGetRequest -uri $GraphQuery.ToString() -tenantid $TenantFilter -scope 'https://manage.office.com/.default' -IncludeResponseHeaders
        $AuditLogContents = $LogBundles | Select-Object contentId, contentUri, contentCreated, contentExpiration, contentType, @{Name = 'TenantFilter'; Expression = { $TenantFilter } }, @{ Name = 'DefaultDomainName'; Expression = { $DefaultDomainName } }
        return $AuditLogContents
    } catch {
        # service principal disabled error
        if ($_.Exception.Message -match "The service principal for resource 'https://manage.office.com' is disabled") {
            $WebhookConfig.Status = 'Disabled'
            $WebhookConfig.Error = $_.Exception.Message
            Add-CIPPAzDataTableEntity @WebhookTable -Entity $WebhookConfig -Force
            Write-LogMessage -API 'Webhooks' -message 'This tenant may not have an Exchange Online license. Audit log subscription disabled.' -sev Error -LogData (Get-CippException -Exception $_)
        }
        Write-Host ( 'Audit log collection error {0} line {1} - {2}' -f $_.InvocationInfo.ScriptName, $_.InvocationInfo.ScriptLineNumber, $_.Exception.Message)
    }
}
#EndRegion './Public/Webhooks/Get-CIPPAuditLogContentBundles.ps1' 99
#Region './Public/Webhooks/Invoke-CIPPGraphWebhookProcessing.ps1' -1

function Invoke-CippGraphWebhookProcessing {
    [CmdletBinding()]
    param (
        $Data,
        $CIPPID,
        $WebhookInfo    
    )

    $Table = Get-CIPPTable -TableName Extensionsconfig

    $Configuration = ((Get-AzDataTableEntity @Table).config | ConvertFrom-Json)

        Switch ($WebhookInfo.Resource) {
            'devices' {
                # NinjaOne Extension
                if ($Configuration.NinjaOne.Enabled -eq $True) {
                Invoke-NinjaOneDeviceWebhook -Data $Data -Configuration $Configuration.NinjaOne
                }
            }
        }
        

    }
#EndRegion './Public/Webhooks/Invoke-CIPPGraphWebhookProcessing.ps1' 24
#Region './Public/Webhooks/Invoke-CIPPGraphWebhookRenewal.ps1' -1

function Invoke-CippGraphWebhookRenewal {
    $RenewalDate = (Get-Date).AddDays(1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
    $body = @{
        'expirationDateTime' = "$RenewalDate"
    } | ConvertTo-Json

    $Tenants = Get-Tenants -IncludeErrors

    $WebhookTable = Get-CIPPTable -TableName webhookTable
    try {
        $WebhookData = Get-AzDataTableEntity @WebhookTable | Where-Object { $null -ne $_.SubscriptionID -and $_.SubscriptionID -ne '' -and ((Get-Date($_.Expiration)) -le ((Get-Date).AddHours(2))) }
    } catch {
        $WebhookData = @()
    }

    if (($WebhookData | Measure-Object).Count -gt 0) {
        Write-LogMessage -API 'Scheduler_RenewGraphSubscriptions' -tenant 'none' -message 'Starting Graph Subscription Renewal' -sev Info
        foreach ($UpdateSub in $WebhookData) {
            try {
                $TenantFilter = $UpdateSub.PartitionKey
                if ($Tenants.defaultDomainName -notcontains $TenantFilter -and $Tenants.customerId -notcontains $TenantFilter) {
                    Write-LogMessage -API 'Renew_Graph_Subscriptions' -message "Removing Subscription Renewal for $($UpdateSub.SubscriptionID) as tenant $TenantFilter is not in the tenant list." -Sev 'Warning' -tenant $TenantFilter
                    Remove-AzDataTableEntity -Force @WebhookTable -Entity $UpdateSub
                    continue
                }

                try {
                    $null = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/subscriptions/$($UpdateSub.SubscriptionID)" -tenantid $TenantFilter -type PATCH -body $body -Verbose
                    $UpdateSub.Expiration = $RenewalDate
                    $null = Add-AzDataTableEntity @WebhookTable -Entity $UpdateSub -Force
                    Write-LogMessage -API 'Renew_Graph_Subscriptions' -message "Renewed Subscription:$($UpdateSub.SubscriptionID)" -Sev 'Info' -tenant $TenantFilter

                } catch {
                    # Rebuild creation parameters
                    $BaseURL = "$(([uri]($UpdateSub.WebhookNotificationUrl)).Host)"
                    if ($UpdateSub.TypeofSubscription) {
                        $TypeofSubscription = "$($UpdateSub.TypeofSubscription)"
                    } else {
                        $TypeofSubscription = 'updated'
                    }
                    $Resource = "$($UpdateSub.Resource)"
                    $EventType = "$($UpdateSub.EventType)"

                    Write-LogMessage -API 'Renew_Graph_Subscriptions' -message "Recreating: $($UpdateSub.SubscriptionID) as renewal failed." -Sev 'Info' -tenant $TenantFilter
                    $CreateResult = New-CIPPGraphSubscription -TenantFilter $TenantFilter -TypeofSubscription $TypeofSubscription -BaseURL $BaseURL -Resource $Resource -EventType $EventType -Headers 'GraphSubscriptionRenewal' -Recreate

                    if ($CreateResult -match 'Created Webhook subscription for') {
                        Remove-AzDataTableEntity -Force @WebhookTable -Entity $UpdateSub
                    }
                }
            } catch {
                Write-LogMessage -API 'Renew_Graph_Subscriptions' -message "Failed to renew Webhook Subscription: $($UpdateSub.SubscriptionID). Linenumber: $($_.InvocationInfo.ScriptLineNumber) Error: $($_.Exception.message)" -Sev 'Error' -tenant $TenantFilter
            }
        }
    }
}
#EndRegion './Public/Webhooks/Invoke-CIPPGraphWebhookRenewal.ps1' 57
#Region './Public/Webhooks/Invoke-CIPPPartnerWebhookProcessing.ps1' -1

function Invoke-CippPartnerWebhookProcessing {
    [CmdletBinding()]
    param (
        $Data
    )

    try {
        if ($Data.AuditUri) {
            $AuditLog = New-GraphGetRequest -uri $Data.AuditUri -tenantid $env:TenantID -NoAuthCheck $true -scope 'https://api.partnercenter.microsoft.com/.default'
        }

        Switch ($Data.EventName) {
            'test-created' {
                Write-LogMessage -API 'Webhooks' -message 'Partner Center webhook test received' -Sev 'Info'
            }
            default {
                if ($Data.EventName -eq 'granular-admin-relationship-approved') {
                    if ($AuditLog.resourceNewValue) {
                        $AuditObj = $AuditLog.resourceNewValue | ConvertFrom-Json
                        Write-LogMessage -API 'Webhooks' -message "Partner Webhook: GDAP Relationship for $($AuditObj.customer.organizationDisplayName) was approved, starting onboarding" -LogData $AuditObj -Sev 'Alert'
                        $Id = $AuditObj.Id
                        $OnboardingSteps = [PSCustomObject]@{
                            'Step1' = @{
                                'Status'  = 'pending'
                                'Title'   = 'Step 1: GDAP Invite'
                                'Message' = 'Waiting for onboarding job to start'
                            }
                            'Step2' = @{
                                'Status'  = 'pending'
                                'Title'   = 'Step 2: GDAP Role Test'
                                'Message' = 'Waiting for Step 1'
                            }
                            'Step3' = @{
                                'Status'  = 'pending'
                                'Title'   = 'Step 3: GDAP Group Mapping'
                                'Message' = 'Waiting for Step 2'
                            }
                            'Step4' = @{
                                'Status'  = 'pending'
                                'Title'   = 'Step 4: CPV Refresh'
                                'Message' = 'Waiting for Step 3'
                            }
                            'Step5' = @{
                                'Status'  = 'pending'
                                'Title'   = 'Step 5: Graph API Test'
                                'Message' = 'Waiting for Step 4'
                            }
                        }
                        $TenantOnboarding = [PSCustomObject]@{
                            PartitionKey    = 'Onboarding'
                            RowKey          = [string]$Id
                            CustomerId      = ''
                            Status          = 'queued'
                            OnboardingSteps = [string](ConvertTo-Json -InputObject $OnboardingSteps -Compress)
                            Relationship    = ''
                            Logs            = ''
                            Exception       = ''
                        }

                        $OnboardItem = @{ Id = $Id }

                        # Check for partner webhook onboarding settings
                        $ConfigTable = Get-CIPPTable -TableName Config
                        $WebhookConfig = Get-CIPPAzDataTableEntity @ConfigTable -Filter "RowKey eq 'PartnerWebhookOnboarding'"
                        if ($WebhookConfig.StandardsExcludeAllTenants -eq $true) {
                            $OnboardItem.StandardsExcludeAllTenants = $true
                        }

                        # Add onboarding entry to the table
                        $OnboardTable = Get-CIPPTable -TableName 'TenantOnboarding'
                        Add-CIPPAzDataTableEntity @OnboardTable -Entity $TenantOnboarding -Force -ErrorAction Stop

                        # Start onboarding
                        Push-ExecOnboardTenantQueue -Item $OnboardItem
                    } else {
                        if ($AuditLog) {
                            Write-LogMessage -API 'Webhooks' -message "Partner Center $($Data.EventName) audit log webhook received" -LogData $AuditObj -Sev 'Alert'
                        } else {
                            Write-LogMessage -API 'Webhooks' -message "Partner Center $($Data.EventName) webhook received" -LogData $Data -Sev 'Alert'
                        }
                    }
                }
            }
        }
    } catch {
        Write-LogMessage -API 'Webhooks' -message 'Error processing Partner Center webhook' -LogData (Get-CippException -Exception $_) -Sev 'Error'
    }
}
#EndRegion './Public/Webhooks/Invoke-CIPPPartnerWebhookProcessing.ps1' 89
#Region './Public/Webhooks/Invoke-CIPPWebhookProcessing.ps1' -1

function Invoke-CippWebhookProcessing {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $Data,
        $Resource,
        $Operations,
        $CIPPURL,
        $APIName = 'Process webhook',
        $Headers
    )

    $AuditLogTable = Get-CIPPTable -TableName 'AuditLogs'
    $AuditLog = Get-CIPPAzDataTableEntity @AuditLogTable -Filter "PartitionKey eq '$TenantFilter' and RowKey eq '$($Data.Id)'"

    if ($AuditLog) {
        Write-Host "Audit Log already exists for $($Data.Id). Skipping processing."
        return
    }

    $Tenant = Get-Tenants -IncludeErrors | Where-Object { $_.defaultDomainName -eq $TenantFilter }
    Write-Host "Received data. Our Action List is $($Data.CIPPAction)"

    $ActionList = ($Data.CIPPAction | ConvertFrom-Json -ErrorAction SilentlyContinue).value
    $ActionResults = foreach ($action in $ActionList) {
        Write-Host "this is our action: $($action | ConvertTo-Json -Depth 15 -Compress)"
        switch ($action) {
            'disableUser' {
                try {
                    Set-CIPPSignInState -TenantFilter $TenantFilter -User $Data.UserId -AccountEnabled $false -APIName 'Alert Engine' -Headers 'Alert Engine'
                } catch {
                    Write-Host "Failed to disable user $($Data.UserId)`: $($_.Exception.Message)"
                }
            }
            'becremediate' {
                $Username = (New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users/$($Data.UserId)" -tenantid $TenantFilter).UserPrincipalName
                try {
                    Set-CIPPResetPassword -UserID $Username -tenantFilter $TenantFilter -APIName 'Alert Engine' -Headers 'Alert Engine'
                } catch {
                    Write-Host "Failed to reset password for $Username`: $($_.Exception.Message)"
                }
                try {
                    Set-CIPPSignInState -userid $Username -AccountEnabled $false -tenantFilter $TenantFilter -APIName 'Alert Engine' -Headers 'Alert Engine'
                } catch {
                    Write-Host "Failed to disable sign-in for $Username`: $($_.Exception.Message)"
                }
                try {
                    Revoke-CIPPSessions -userid $Username -username $Username -Headers 'Alert Engine' -APIName 'Alert Engine' -tenantFilter $TenantFilter
                } catch {
                    Write-Host "Failed to revoke sessions for $Username`: $($_.Exception.Message)"
                }
                $RuleDisabled = 0
                New-ExoRequest -anchor $Username -tenantid $TenantFilter -cmdlet 'Get-InboxRule' -cmdParams @{Mailbox = $Username; IncludeHidden = $true } | Where-Object { $_.Name -ne 'Junk E-Mail Rule' -and $_.Name -notlike 'Microsoft.Exchange.OOF.*' } | ForEach-Object {
                    $null = New-ExoRequest -anchor $Username -tenantid $TenantFilter -cmdlet 'Disable-InboxRule' -cmdParams @{Confirm = $false; Identity = $_.Identity }
                    "Disabled Inbox Rule $($_.Identity) for $Username"
                    $RuleDisabled++
                }
                if ($RuleDisabled) {
                    "Disabled $RuleDisabled Inbox Rules for $Username"
                } else {
                    "No Inbox Rules found for $Username. We have not disabled any rules."
                }
                "Completed BEC Remediate for $Username"
                Write-LogMessage -API 'BECRemediate' -tenant $tenantfilter -message "Executed Remediation for $Username" -sev 'Info'
            }
            'cippcommand' {
                $CommandSplat = @{}
                $action.parameters.psobject.properties | ForEach-Object { $CommandSplat.Add($_.name, $_.value) }
                if ($CommandSplat['userid']) { $CommandSplat['userid'] = $Data.UserId }
                if ($CommandSplat['tenantfilter']) { $CommandSplat['tenantfilter'] = $TenantFilter }
                if ($CommandSplat['tenant']) { $CommandSplat['tenant'] = $TenantFilter }
                if ($CommandSplat['user']) { $CommandSplat['user'] = $Data.UserId }
                if ($CommandSplat['username']) { $CommandSplat['username'] = $Data.UserId }
                & $action.command.value @CommandSplat
            }
        }
    }

    # Save audit log entry to table
    $LocationInfo = $Data.CIPPLocationInfo | ConvertFrom-Json -ErrorAction SilentlyContinue
    $AuditRecord = $Data.AuditRecord | ConvertFrom-Json -ErrorAction SilentlyContinue
    $GenerateJSON = New-CIPPAlertTemplate -format 'json' -data $Data -ActionResults $ActionResults -CIPPURL $CIPPURL -AlertComment $WebhookRule.AlertComment
    $JsonContent = @{
        Title                 = $GenerateJSON.Title
        ActionUrl             = $GenerateJSON.ButtonUrl
        ActionText            = $GenerateJSON.ButtonText
        RawData               = $Data
        IP                    = $Data.ClientIP
        PotentialLocationInfo = $LocationInfo
        ActionsTaken          = $ActionResults
        AuditRecord           = $AuditRecord
    } | ConvertTo-Json -Depth 15 -Compress

    $CIPPAlert = @{
        Type         = 'table'
        Title        = $GenerateJSON.Title
        JSONContent  = $JsonContent
        TenantFilter = $TenantFilter
        TableName    = 'AuditLogs'
        RowKey       = $Data.Id
    }
    $LogId = Send-CIPPAlert @CIPPAlert

    $AuditLogLink = '{0}/tenant/administration/audit-logs/log?logId={1}&tenantFilter={2}' -f $CIPPURL, $LogId, $Tenant.defaultDomainName
    $GenerateEmail = New-CIPPAlertTemplate -format 'html' -data $Data -ActionResults $ActionResults -CIPPURL $CIPPURL -Tenant $Tenant.defaultDomainName -AuditLogLink $AuditLogLink -AlertComment $WebhookRule.AlertComment

    Write-Host 'Going to create the content'
    foreach ($action in $ActionList ) {
        switch ($action) {
            'generatemail' {
                $CIPPAlert = @{
                    Type         = 'email'
                    Title        = $GenerateEmail.title
                    HTMLContent  = $GenerateEmail.htmlcontent
                    TenantFilter = $TenantFilter
                }
                Write-Host 'Going to send the mail'
                Send-CIPPAlert @CIPPAlert
                Write-Host 'email should be sent'
            }
            'generatePSA' {
                $CIPPAlert = @{
                    Type         = 'psa'
                    Title        = $GenerateEmail.title
                    HTMLContent  = $GenerateEmail.htmlcontent
                    TenantFilter = $TenantFilter
                }
                Send-CIPPAlert @CIPPAlert
            }
            'generateWebhook' {
                $CippAlert = @{
                    Type         = 'webhook'
                    Title        = $GenerateJSON.Title
                    JSONContent  = $JsonContent
                    TenantFilter = $TenantFilter
                }
                Write-Host 'Sending Webhook Content'
                Send-CIPPAlert @CippAlert
            }
        }
    }
}

#EndRegion './Public/Webhooks/Invoke-CIPPWebhookProcessing.ps1' 144
#Region './Public/Webhooks/Invoke-RemoveWebhookAlert.ps1' -1

#using namespace System.Net

Function Invoke-RemoveWebhookAlert {
    <#
    .FUNCTIONALITY
        Entrypoint
    .ROLE
        CIPP.Alert.ReadWrite
    #>
    [CmdletBinding()]
    param($Request, $TriggerMetadata)

    $APIName = $Request.Params.CIPPEndpoint
    try {
        $WebhookTable = Get-CIPPTable -TableName 'SchedulerConfig'
        $WebhookRow = Get-CIPPAzDataTableEntity @WebhookTable -Filter "PartitionKey eq 'WebhookAlert'" | Where-Object -Property Tenant -EQ $Request.query.TenantFilter
        Write-Host "The webhook count is $($WebhookRow.count)"
        if ($WebhookRow.count -gt 1) {
            $Entity = $WebhookRow | Where-Object -Property RowKey -EQ $Request.query.ID
            Remove-AzDataTableEntity -Force @WebhookTable -Entity $Entity | Out-Null
            $Results = "Removed Alert Rule for $($Request.query.TenantFilter)"
        } else {
            if ($Request.query.TenantFilter -eq 'AllTenants') {
                $Tenants = Get-Tenants -IncludeAll -IncludeErrors | Select-Object -ExpandProperty defaultDomainName
                try {
                    $CompleteObject = @{
                        tenant       = 'AllTenants'
                        type         = 'webhookcreation'
                        RowKey       = 'AllTenantsWebhookCreation'
                        PartitionKey = 'webhookcreation'
                    }
                    Remove-AzDataTableEntity -Force @Table -Entity $CompleteObject -ErrorAction SilentlyContinue | Out-Null
                } catch {
                    Write-LogMessage -headers $Request.Headers -API $APIName -message "Failed to remove webhook for AllTenants. $($_.Exception.Message)" -Sev 'Error'
                }
            } else {
                $Tenants = $Request.query.TenantFilter
            }

            $Results = foreach ($Tenant in $Tenants) {
                Remove-CIPPGraphSubscription -TenantFilter $Tenant -Type 'AuditLog'
                $Entity = $WebhookRow | Where-Object -Property RowKey -EQ $Request.query.ID
                Remove-AzDataTableEntity -Force @WebhookTable -Entity $Entity | Out-Null
                "Removed Alert Rule for $($Request.query.TenantFilter)"
            }
        }
        $body = [pscustomobject]@{'Results' = $Results }
    } catch {
        Write-LogMessage -headers $Request.Headers -API $APINAME -message "Failed to remove webhook alert. $($_.Exception.Message)" -Sev 'Error'
        $body = [pscustomobject]@{'Results' = "Failed to remove webhook alert: $($_.Exception.Message)" }
    }

    return [HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::OK
            Body       = $body
        }
}
#EndRegion './Public/Webhooks/Invoke-RemoveWebhookAlert.ps1' 58
#Region './Public/Webhooks/New-CIPPGraphSubscription.ps1' -1

function New-CIPPGraphSubscription {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $TypeofSubscription,
        $AllowedLocations,
        $BaseURL,
        $Resource,
        $EventType,
        $APIName = 'Create Webhook',
        $Headers,
        [Switch]$Recreate,
        [switch]$PartnerCenter
    )
    $CIPPID = (New-Guid).GUID
    $WebhookTable = Get-CIPPTable -TableName 'webhookTable'

    try {
        if ($PartnerCenter.IsPresent) {
            $WebhookFilter = "PartitionKey eq '$($env:TenantID)'"
            $ExistingWebhooks = Get-CIPPAzDataTableEntity @WebhookTable -Filter $WebhookFilter
            $CIPPID = $env:TenantID
            $MatchedWebhook = $ExistingWebhooks | Where-Object { $_.Resource -eq 'PartnerCenter' -and $_.RowKey -eq $CIPPID }

            # Required event types
            $EventList = [System.Collections.Generic.List[string]]@('test-created', 'granular-admin-relationship-approved')
            if (($EventType | Measure-Object).count -gt 0) {
                foreach ($Event in $EventType) {
                    if ($EventList -notcontains $Event) {
                        $EventList.Add($Event)
                    }
                }
            }

            $Body = [PSCustomObject]@{
                WebhookUrl    = "https://$BaseURL/API/PublicWebhooks?CIPPID=$($CIPPID)&Type=PartnerCenter"
                WebhookEvents = @($EventList)
            }
            try {
                $EventCompare = Compare-Object $EventList ($MatchedWebhook.EventType | ConvertFrom-Json -ErrorAction Stop)
            } catch {
                $EventCompare = $false
            }
            try {
                $Uri = 'https://api.partnercenter.microsoft.com/webhooks/v1/registration'
                try {
                    $Existing = New-GraphGetRequest -NoAuthCheck $true -uri $Uri -tenantid $env:TenantID -scope 'https://api.partnercenter.microsoft.com/.default'
                } catch { $Existing = $false }
                if (!$Existing -or $Existing.webhookUrl -ne $MatchedWebhook.WebhookNotificationUrl -or $EventCompare) {
                    if ($Existing.WebhookUrl) {
                        $Action = 'Updated'
                        $Method = 'PUT'
                    } else {
                        $Action = 'Created'
                        $Method = 'POST'
                    }

                    $Uri = 'https://api.partnercenter.microsoft.com/webhooks/v1/registration'
                    $GraphRequest = New-GraphPOSTRequest -uri $Uri -type $Method -tenantid $env:TenantID -scope 'https://api.partnercenter.microsoft.com/.default' -body ($Body | ConvertTo-Json) -NoAuthCheck $true

                    $WebhookRow = @{
                        PartitionKey           = [string]$CIPPID
                        RowKey                 = [string]$CIPPID
                        EventType              = [string](ConvertTo-Json -InputObject $EventList)
                        Resource               = [string]'PartnerCenter'
                        SubscriptionID         = [string]$GraphRequest.SubscriberId
                        Expiration             = 'Does Not Expire'
                        WebhookNotificationUrl = [string]$Body.WebhookUrl
                    }
                    $null = Add-CIPPAzDataTableEntity @WebhookTable -Entity $WebhookRow -Force
                    Write-LogMessage -headers $Headers -API $APIName -message "$Action Partner Center Webhook subscription" -Sev 'Info' -tenant 'PartnerTenant'
                    return "$Action Partner Center Webhook subscription"
                } else {
                    Write-LogMessage -headers $Headers -API $APIName -message 'Existing Partner Center Webhook subscription found' -Sev 'Info' -tenant 'PartnerTenant'
                    return 'Existing Partner Center Webhook subscription found'
                }
            } catch {
                Write-LogMessage -headers $Headers -API $APIName -message "Failed to create Partner Center Webhook Subscription: $($_.Exception.Message)" -Sev 'Error' -tenant 'PartnerTenant'
                return "Failed to create Partner Webhook Subscription: $($_.Exception.Message)"
            }

        } else {
            # First check if there is an existing Webhook in place
            $WebhookFilter = "PartitionKey eq '$($TenantFilter)'"
            $ExistingWebhooks = Get-CIPPAzDataTableEntity @WebhookTable -Filter $WebhookFilter
            $MatchedWebhook = $ExistingWebhooks | Where-Object { $_.Resource -eq $Resource }
            if (($MatchedWebhook | Measure-Object).count -eq 0 -or $Recreate.IsPresent) {
                $expiredate = (Get-Date).AddDays(1).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
                $params = @{
                    changeType         = $TypeofSubscription
                    notificationUrl    = "https://$BaseURL/API/PublicWebhooks?EventType=$EventType&CIPPID=$($CIPPID)&Type=GraphSubscription"
                    resource           = $Resource
                    expirationDateTime = $expiredate
                } | ConvertTo-Json

                if ($BaseURL -match 'localhost' -or $BaseURL -match '127.0.0.1') {
                    return 'Cannot create graph subscription for local development'
                }

                $GraphRequest = New-GraphPostRequest -uri 'https://graph.microsoft.com/beta/subscriptions' -tenantid $TenantFilter -type POST -body $params -verbose
                #If creation is succesfull, we store the GUID in the storage table webhookTable to make sure we can check against this later on.
                #We store the GUID as rowkey, the event type, the resource, and the expiration date as properties, we also add the Tenant name so we can easily find this later on.
                #We don't store the return, because Ms decided that a renewal or re-authenticate does not change the url, but does change the id...
                $WebhookRow = @{
                    PartitionKey           = [string]$TenantFilter
                    RowKey                 = [string]$CIPPID
                    EventType              = [string]$EventType
                    Resource               = [string]$Resource
                    Expiration             = [string]$expiredate
                    SubscriptionID         = [string]$GraphRequest.id
                    TypeofSubscription     = [string]$TypeofSubscription
                    WebhookNotificationUrl = [string]$GraphRequest.notificationUrl
                }
                $null = Add-CIPPAzDataTableEntity @WebhookTable -Entity $WebhookRow
                #todo: add remove webhook function, add check webhook function, add list webhooks function
                #add refresh webhook function based on table.
                Write-LogMessage -headers $Headers -API $APIName -message "Created Graph Webhook subscription for $($TenantFilter)" -Sev 'Info' -tenant $TenantFilter
            } else {
                Write-LogMessage -headers $Headers -API $APIName -message "Existing Graph Webhook subscription for $($TenantFilter) found" -Sev 'Info' -tenant $TenantFilter
            }
        }
        return "Created Webhook subscription for $($TenantFilter)"
    } catch {
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to create Webhook Subscription: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter
        Return "Failed to create Webhook Subscription for $($TenantFilter): $($_.Exception.Message)"
    }
}
#EndRegion './Public/Webhooks/New-CIPPGraphSubscription.ps1' 128
#Region './Public/Webhooks/Remove-CIPPGraphSubscription.ps1' -1

function Remove-CIPPGraphSubscription {
    [CmdletBinding()]
    param (
        $TenantFilter,
        $CIPPID,
        $APIName = 'Remove Graph Webhook',
        $Type,
        $EventType,
        $Headers,
        $Cleanup = $false
    )
    try {
        if ($Cleanup) {
            #list all subscriptions on the management API
            $Subscriptions = New-GraphPOSTRequest -type GET -uri "https://manage.office.com/api/v1.0/$($TenantFilter)/activity/feed/subscriptions/list" -scope 'https://manage.office.com/.default' -tenantid $TenantFilter -verbose
            foreach ($Sub in $Subscriptions | Where-Object { $_.webhook.address -like '*CIPP*' -and $_.webhook.address -notlike '*version=3*' }) {
                Try {
                    $AuditLog = New-GraphPOSTRequest -uri "https://manage.office.com/api/v1.0/$($TenantFilter)/activity/feed/subscriptions/stop?contentType=$($sub.contentType)" -scope 'https://manage.office.com/.default' -tenantid $TenantFilter -type POST -body '{}' -verbose
                    Try {
                        $WebhookRow = Get-CIPPAzDataTableEntity @WebhookTable | Where-Object { $_.PartitionKey -eq $TenantFilter -and $_.Resource -eq $EventType -and $_.version -ne '2' }
                        $null = Remove-AzDataTableEntity -Force @WebhookTable -Entity $Entity
                    } catch {
                        Write-LogMessage -headers $Headers -API $APIName -message 'Deleted an audit log webhook that was already removed from CIPP' -Sev 'Info' -tenant $TenantFilter

                    }
                } catch {
                    Write-LogMessage -headers $Headers -API $APIName -message "Failed to cleanup old audit logs: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter
                }
            }
        } else {
            $WebhookTable = Get-CIPPTable -TableName 'webhookTable'
            if ($type -eq 'AuditLog') {
                $WebhookRow = Get-CIPPAzDataTableEntity @WebhookTable | Where-Object { $_.PartitionKey -eq $TenantFilter -and $_.Resource -eq $EventType }
            } else {
                $WebhookRow = Get-CIPPAzDataTableEntity @WebhookTable | Where-Object { $_.RowKey -eq $CIPPID }
            }
            $Entity = $WebhookRow | Select-Object PartitionKey, RowKey
            if ($Type -eq 'AuditLog') {
                try {
                    $AuditLog = New-GraphPOSTRequest -uri "https://manage.office.com/api/v1.0/$($TenantFilter)/activity/feed/subscriptions/stop?contentType=$($EventType)" -scope 'https://manage.office.com/.default' -tenantid $TenantFilter -type POST -body '{}' -verbose
                } catch {
                    Write-LogMessage -headers $Headers -API $APIName -message "Failed to remove webhook subscription at Microsoft's side: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter
                }
                $null = Remove-AzDataTableEntity -Force @WebhookTable -Entity $Entity
            } else {
                $OldID = (New-GraphGetRequest -uri 'https://graph.microsoft.com/beta/subscriptions' -tenantid $TenantFilter) | Where-Object { $_.notificationUrl -eq $WebhookRow.WebhookNotificationUrl }
                $GraphRequest = New-GraphPostRequest -uri "https://graph.microsoft.com/beta/subscriptions/$($oldId.ID)" -tenantid $TenantFilter -type DELETE -body {} -Verbose
                $null = Remove-AzDataTableEntity -Force @WebhookTable -Entity $Entity
            }
            return "Removed webhook subscription to $($WebhookRow.resource) for $($TenantFilter)"
        }
    } catch {
        Write-LogMessage -headers $Headers -API $APIName -message "Failed to renew Webhook Subscription: $($_.Exception.Message)" -Sev 'Error' -tenant $TenantFilter
        return "Failed to remove Webhook Subscription $($GraphRequest.value.notificationUrl): $($_.Exception.Message)"
    }
}
#EndRegion './Public/Webhooks/Remove-CIPPGraphSubscription.ps1' 57
#Region './Public/Webhooks/Test-CIPPAuditLogRules.ps1' -1

function Test-CIPPAuditLogRules {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        $TenantFilter,
        [Parameter(Mandatory = $true)]
        $Rows
    )

    try {
        # Helper function to map GUIDs and partner UPNs to user objects
        function Add-CIPPGuidMappings {
            param(
                [Parameter(Mandatory = $true)]
                $DataObject,
                [Parameter(Mandatory = $true)]
                $Users,
                [Parameter(Mandatory = $true)]
                $Groups,
                [Parameter(Mandatory = $true)]
                $Devices,
                [Parameter(Mandatory = $true)]
                $ServicePrincipals,
                [Parameter(Mandatory = $true)]
                $PartnerUsers,
                [Parameter(Mandatory = $false)]
                [string]$PropertyPrefix = ''
            )

            $DataObject.PSObject.Properties | ForEach-Object {
                # Check for standard GUID format OR partner UPN formats
                if ($_.Value -match '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$' -or
                    $_.Value -match 'user_[0-9a-f]{32}@[^@]+\.onmicrosoft\.com' -or
                    $_.Value -match '[^\\]+\.onmicrosoft\.com\\tenant:\s*[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12},\s*object:\s*[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}') {

                    # Use regex from guid-resolver hook to match various partner user formats
                    # Format 1: user_<objectid>@<tenant>.onmicrosoft.com
                    if ($_.Value -match 'user_([0-9a-f]{32})@([^@]+\.onmicrosoft\.com)') {
                        $hexId = $matches[1]
                        $tenantDomain = $matches[2]
                        if ($hexId.Length -eq 32) {
                            # Convert the 32-character hex string to GUID format
                            $guid = "$($hexId.Substring(0,8))-$($hexId.Substring(8,4))-$($hexId.Substring(12,4))-$($hexId.Substring(16,4))-$($hexId.Substring(20,12))"
                            Write-Information "Found partner UPN format: $($_.Value) with GUID: $guid and tenant: $tenantDomain"

                            # Check partner users for this GUID
                            foreach ($PartnerUser in $PartnerUsers) {
                                if ($PartnerUser.id -eq $guid) {
                                    $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $PartnerUser.userPrincipalName -Force -ErrorAction SilentlyContinue
                                    Write-Information "Mapped Partner User UPN: $($PartnerUser.userPrincipalName) to $PropertyPrefix$($_.Name)"
                                    return
                                }
                            }
                        }
                    }

                    # Format 2: TenantName.onmicrosoft.com\tenant: <tenant-guid>, object: <object-guid>
                    if ($_.Value -match '([^\\]+\.onmicrosoft\.com)\\tenant:\s*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}),\s*object:\s*([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})') {
                        $customerTenantDomain = $matches[1]
                        $partnerTenantGuid = $matches[2]
                        $objectGuid = $matches[3]
                        Write-Information "Found partner exchange format: customer tenant $customerTenantDomain, partner tenant $partnerTenantGuid, object $objectGuid"

                        # Check partner users for this object GUID
                        foreach ($PartnerUser in $PartnerUsers) {
                            if ($PartnerUser.id -eq $objectGuid) {
                                $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $PartnerUser.userPrincipalName -Force -ErrorAction SilentlyContinue
                                Write-Information "Mapped Partner User UPN: $($PartnerUser.userPrincipalName) to $PropertyPrefix$($_.Name)"
                                return
                            }
                        }
                    }

                    # Check standard directory objects (users, groups, devices, service principals)
                    foreach ($User in $Users) {
                        if ($User.id -eq $_.Value) {
                            $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $User.userPrincipalName -Force -ErrorAction SilentlyContinue
                            Write-Information "Mapped User: $($User.userPrincipalName) to $PropertyPrefix$($_.Name)"
                            return
                        }
                    }
                    foreach ($Group in $Groups) {
                        if ($Group.id -eq $_.Value) {
                            $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $Group -Force -ErrorAction SilentlyContinue
                            Write-Information "Mapped Group: $($Group.displayName) to $PropertyPrefix$($_.Name)"
                            return
                        }
                    }
                    foreach ($Device in $Devices) {
                        if ($Device.id -eq $_.Value) {
                            $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $Device -Force -ErrorAction SilentlyContinue
                            Write-Information "Mapped Device: $($Device.displayName) to $PropertyPrefix$($_.Name)"
                            return
                        }
                    }
                    foreach ($ServicePrincipal in $ServicePrincipals) {
                        if ($ServicePrincipal.id -eq $_.Value -or $ServicePrincipal.appId -eq $_.Value) {
                            $DataObject | Add-Member -NotePropertyName "$PropertyPrefix$($_.Name)" -NotePropertyValue $ServicePrincipal -Force -ErrorAction SilentlyContinue
                            Write-Information "Mapped Service Principal: $($ServicePrincipal.displayName) to $PropertyPrefix$($_.Name)"
                            return
                        }
                    }
                }
            }
        }

        #$FunctionStartTime = Get-Date

        $Results = [PSCustomObject]@{
            TotalLogs     = 0
            MatchedLogs   = 0
            MatchedRules  = @()
            DataToProcess = @()
        }

        # Get the CacheWebhooks table for removing processed rows
        $CacheWebhooksTable = Get-CippTable -TableName 'CacheWebhooks'

        $ExtendedPropertiesIgnoreList = @(
            'SAS:EndAuth'
            'SAS:ProcessAuth'
            'deviceAuth:ReprocessTls'
            'Consent:Set'
        )

        $TrustedIPTable = Get-CIPPTable -TableName 'trustedIps'
        $ConfigTable = Get-CIPPTable -TableName 'WebhookRules'
        $ConfigEntries = Get-CIPPAzDataTableEntity @ConfigTable
        $Configuration = $ConfigEntries | Where-Object { ($_.Tenants -match $TenantFilter -or $_.Tenants -match 'AllTenants') } | ForEach-Object {
            [pscustomobject]@{
                Tenants    = ($_.Tenants | ConvertFrom-Json)
                Excluded   = ($_.excludedTenants | ConvertFrom-Json -ErrorAction SilentlyContinue)
                Conditions = $_.Conditions
                Actions    = $_.Actions
                LogType    = $_.Type
            }
        }

        # Collect bulk data for users/groups/devices/applications
        $Requests = @(
            @{
                id     = 'users'
                url    = '/users?$select=id,displayName,userPrincipalName,accountEnabled&$top=999'
                method = 'GET'
            }
            @{
                id     = 'groups'
                url    = '/groups?$select=id,displayName,mailEnabled,securityEnabled&$top=999'
                method = 'GET'
            }
            @{
                id     = 'devices'
                url    = '/devices?$select=id,displayName,deviceId&$top=999'
                method = 'GET'
            }
            @{
                id     = 'servicePrincipals'
                url    = '/servicePrincipals?$select=id,displayName&$top=999'
                method = 'GET'
            }
        )
        $Response = New-GraphBulkRequest -TenantId $TenantFilter -Requests $Requests

        # partner users
        $PartnerUsers = New-GraphGetRequest -uri "https://graph.microsoft.com/beta/users?`$select=id,displayName,userPrincipalName,accountEnabled&`$top=999" -AsApp $true -NoAuthCheck $true

        $Users = ($Response | Where-Object { $_.id -eq 'users' }).body.value
        $Groups = ($Response | Where-Object { $_.id -eq 'groups' }).body.value ?? @()
        $Devices = ($Response | Where-Object { $_.id -eq 'devices' }).body.value ?? @()
        $ServicePrincipals = ($Response | Where-Object { $_.id -eq 'servicePrincipals' }).body.value

        Write-Warning '## Audit Log Configuration ##'
        Write-Information ($Configuration | ConvertTo-Json -Depth 10)

        try {
            $LogCount = $Rows.count
            $RunGuid = (New-Guid).Guid
            Write-Warning "Logs to process: $LogCount - RunGuid: $($RunGuid) - $($TenantFilter)"
            $Results.TotalLogs = $LogCount
            Write-Information "RunGuid: $RunGuid - Collecting logs"
            $SearchResults = $Rows
        } catch {
            Write-Warning "Error getting audit logs: $($_.Exception.Message)"
            Write-LogMessage -API 'Webhooks' -message 'Error Processing Audit logs' -LogData (Get-CippException -Exception $_) -sev Error -tenant $TenantFilter
            throw $_
        }

        $AuditLogUserExclusions = Get-CIPPTable -TableName 'AuditLogUserExclusions'
        $ExcludedUsers = Get-CIPPAzDataTableEntity @AuditLogUserExclusions -Filter "PartitionKey eq '$TenantFilter'"

        if ($LogCount -gt 0) {
            $LocationTable = Get-CIPPTable -TableName 'knownlocationdbv2'
            $ProcessedData = foreach ($AuditRecord in $SearchResults) {
                $RecordStartTime = Get-Date
                Write-Information "Processing RowKey $($AuditRecord.id)"
                $RootProperties = $AuditRecord | Select-Object * -ExcludeProperty auditData
                $Data = $AuditRecord.auditData | Select-Object *, CIPPAction, CIPPClause, CIPPGeoLocation, CIPPBadRepIP, CIPPHostedIP, CIPPIPDetected, CIPPLocationInfo, CIPPExtendedProperties, CIPPDeviceProperties, CIPPParameters, CIPPModifiedProperties, AuditRecord -ErrorAction SilentlyContinue
                try {
                    # Attempt to locate GUIDs in $Data and match them with their corresponding user, group, device, or service principal recursively by checking each key/value once located lets store these mapped values in a CIPP$KeyName property
                    Write-Information 'Checking Data for GUIDs to map to users, groups, devices, or service principals'
                    Add-CIPPGuidMappings -DataObject $Data -Users $Users -Groups $Groups -Devices $Devices -ServicePrincipals $ServicePrincipals -PartnerUsers $PartnerUsers -PropertyPrefix 'CIPP'

                    # Also check root properties for GUIDs and partner UPNs
                    Write-Information 'Checking RootProperties for GUIDs to map to users, groups, devices, or service principals'
                    Add-CIPPGuidMappings -DataObject $RootProperties -Users $Users -Groups $Groups -Devices $Devices -ServicePrincipals $ServicePrincipals -PartnerUsers $PartnerUsers

                    if ($Data.ExtendedProperties) {
                        $Data.CIPPExtendedProperties = ($Data.ExtendedProperties | ConvertTo-Json -Compress)
                        $Data.ExtendedProperties | ForEach-Object {
                            if ($_.Value -in $ExtendedPropertiesIgnoreList) {
                                #write-warning "No need to process this operation as its in our ignore list. Some extended information: $($data.operation):$($_.Value) - $($TenantFilter)"
                                continue
                            }
                            $Data | Add-Member -NotePropertyName $_.Name -NotePropertyValue $_.Value -Force -ErrorAction SilentlyContinue
                        }
                    }
                    if ($Data.DeviceProperties) {
                        $Data.CIPPDeviceProperties = ($Data.DeviceProperties | ConvertTo-Json -Compress)
                        $Data.DeviceProperties | ForEach-Object { $Data | Add-Member -NotePropertyName $_.Name -NotePropertyValue $_.Value -Force -ErrorAction SilentlyContinue }
                    }
                    if ($Data.parameters) {
                        $Data.CIPPParameters = ($Data.parameters | ConvertTo-Json -Compress)
                        $Data.parameters | ForEach-Object { $Data | Add-Member -NotePropertyName $_.Name -NotePropertyValue $_.Value -Force -ErrorAction SilentlyContinue }
                    }
                    if ($Data.ModifiedProperties) {
                        $Data.CIPPModifiedProperties = ($Data.ModifiedProperties | ConvertTo-Json -Compress)
                        try {
                            $Data.ModifiedProperties | ForEach-Object { $Data | Add-Member -NotePropertyName "$($_.Name)" -NotePropertyValue "$($_.NewValue)" -Force -ErrorAction SilentlyContinue }
                        } catch {
                            ##write-warning ($Data.ModifiedProperties | ConvertTo-Json -Depth 10)
                        }
                        try {
                            $Data.ModifiedProperties | ForEach-Object { $Data | Add-Member -NotePropertyName $("Previous_Value_$($_.Name)") -NotePropertyValue "$($_.OldValue)" -Force -ErrorAction SilentlyContinue }
                        } catch {
                            ##write-warning ($Data.ModifiedProperties | ConvertTo-Json -Depth 10)
                        }
                    }


                    $HasLocationData = $false
                    if (![string]::IsNullOrEmpty($Data.clientip) -and $Data.clientip -notmatch '[X]+') {
                        # Ignore IP addresses that have been redacted

                        $IPRegex = '^(?<IP>(?:\d{1,3}(?:\.\d{1,3}){3}|\[[0-9a-fA-F:]+\]|[0-9a-fA-F:]+))(?::\d+)?$'
                        $Data.clientip = $Data.clientip -replace $IPRegex, '$1' -replace '[\[\]]', ''

                        # Check if IP is on trusted IP list
                        $TrustedIP = Get-CIPPAzDataTableEntity @TrustedIPTable -Filter "((PartitionKey eq '$TenantFilter') or (PartitionKey eq 'AllTenants')) and RowKey eq '$($Data.clientip)' and state eq 'Trusted'"
                        if ($TrustedIP) {
                            #write-warning "IP $($Data.clientip) is trusted"
                            $Trusted = $true
                        }
                        if (!$Trusted) {
                            $CacheLookupStartTime = Get-Date
                            $Location = Get-AzDataTableEntity @LocationTable -Filter "PartitionKey eq 'ip' and RowKey eq '$($Data.clientIp)'" | Select-Object -ExcludeProperty Tenant
                            $CacheLookupEndTime = Get-Date
                            $CacheLookupSeconds = ($CacheLookupEndTime - $CacheLookupStartTime).TotalSeconds
                            Write-Warning "Cache lookup for IP $($Data.clientip) took $CacheLookupSeconds seconds"

                            if ($Location) {
                                $Country = $Location.CountryOrRegion
                                $City = $Location.City
                                $Proxy = $Location.Proxy
                                $hosting = $Location.Hosting
                                $ASName = $Location.ASName
                            } else {
                                try {
                                    $IPLookupStartTime = Get-Date
                                    $Location = Get-CIPPGeoIPLocation -IP $Data.clientip
                                    $IPLookupEndTime = Get-Date
                                    $IPLookupSeconds = ($IPLookupEndTime - $IPLookupStartTime).TotalSeconds
                                    Write-Warning "IP lookup for $($Data.clientip) took $IPLookupSeconds seconds"
                                } catch {
                                    #write-warning "Unable to get IP location for $($Data.clientip): $($_.Exception.Message)"
                                }
                                $Country = if ($Location.countryCode) { $Location.countryCode } else { 'Unknown' }
                                $City = if ($Location.city) { $Location.city } else { 'Unknown' }
                                $Proxy = if ($Location.proxy -ne $null) { $Location.proxy } else { 'Unknown' }
                                $hosting = if ($Location.hosting -ne $null) { $Location.hosting } else { 'Unknown' }
                                $ASName = if ($Location.asname) { $Location.asname } else { 'Unknown' }
                                $IP = $Data.ClientIP
                                $LocationInfo = @{
                                    RowKey          = [string]$Data.clientip
                                    PartitionKey    = 'ip'
                                    Tenant          = [string]$TenantFilter
                                    CountryOrRegion = "$Country"
                                    City            = "$City"
                                    Proxy           = "$Proxy"
                                    Hosting         = "$hosting"
                                    ASName          = "$ASName"
                                }

                                try {
                                    $null = Add-CIPPAzDataTableEntity @LocationTable -Entity $LocationInfo -Force
                                } catch {
                                    #write-warning "Failed to add location info for $($Data.clientip) to cache: $($_.Exception.Message)"

                                }
                            }
                            $Data.CIPPGeoLocation = $Country
                            $Data.CIPPBadRepIP = $Proxy
                            $Data.CIPPHostedIP = $hosting
                            $Data.CIPPIPDetected = $IP
                            $Data.CIPPLocationInfo = ($Location | ConvertTo-Json -Compress)
                            $HasLocationData = $true
                        }
                    }
                    $Data.AuditRecord = [string]($RootProperties | ConvertTo-Json -Compress)
                    $Data | Select-Object *,
                    @{n = 'HasLocationData'; exp = { $HasLocationData } } -ExcludeProperty ExtendedProperties, DeviceProperties, parameters
                } catch {
                    #write-warning "Audit log: Error processing data: $($_.Exception.Message)`r`n$($_.InvocationInfo.PositionMessage)"
                    Write-LogMessage -API 'Webhooks' -message 'Error Processing Audit Log Data' -LogData (Get-CippException -Exception $_) -sev Error -tenant $TenantFilter
                }

                Write-Information "Removing row $($AuditRecord.id) from cache"
                try {
                    Write-Information 'Removing processed rows from cache'
                    $RowEntity = Get-CIPPAzDataTableEntity @CacheWebhooksTable -Filter "PartitionKey eq '$TenantFilter' and RowKey eq '$($AuditRecord.id)'"
                    Remove-AzDataTableEntity @CacheWebhooksTable -Entity $RowEntity -Force
                    Write-Information "Removed row $($AuditRecord.id) from cache"
                } catch {
                    Write-Information "Error removing rows from cache: $($_.Exception.Message)"
                } finally {
                    $RecordEndTime = Get-Date
                    $RecordSeconds = ($RecordEndTime - $RecordStartTime).TotalSeconds
                    Write-Warning "Task took $RecordSeconds seconds for RowKey $($AuditRecord.id)"
                }
            }
            #write-warning "Processed Data: $(($ProcessedData | Measure-Object).Count) - This should be higher than 0 in many cases, because the where object has not run yet."
            #write-warning "Creating filters - $(($ProcessedData.operation | Sort-Object -Unique) -join ',') - $($TenantFilter)"

            try {
                $Where = foreach ($Config in $Configuration) {
                    if ($TenantFilter -in $Config.Excluded.value) {
                        continue
                    }
                    $conditions = $Config.Conditions | ConvertFrom-Json | Where-Object { $Config.Input.value -ne '' }
                    $actions = $Config.Actions
                    $conditionStrings = [System.Collections.Generic.List[string]]::new()
                    $CIPPClause = [System.Collections.Generic.List[string]]::new()
                    $AddedLocationCondition = $false
                    foreach ($condition in $conditions) {
                        if ($condition.Property.label -eq 'CIPPGeoLocation' -and !$AddedLocationCondition) {
                            $conditionStrings.Add("`$_.HasLocationData -eq `$true")
                            $CIPPClause.Add('HasLocationData is true')
                            $ExcludedUsers = $ExcludedUsers | Where-Object { $_.Type -eq 'Location' }
                            # Build single -notin condition against all excluded user keys
                            $ExcludedUserKeys = @($ExcludedUsers.RowKey)
                            if ($ExcludedUserKeys.Count -gt 0) {
                                $conditionStrings.Add("`$(`$_.CIPPUserKey) -notin @('$($ExcludedUserKeys -join "', '")')")
                                $CIPPClause.Add("CIPPUserKey not in [$($ExcludedUserKeys -join ', ')]")
                            }
                            $AddedLocationCondition = $true
                        }
                        $value = if ($condition.Input.value -is [array]) {
                            $arrayAsString = $condition.Input.value | ForEach-Object {
                                "'$_'"
                            }
                            "@($($arrayAsString -join ', '))"
                        } else { "'$($condition.Input.value)'" }

                        $conditionStrings.Add("`$(`$_.$($condition.Property.label)) -$($condition.Operator.value) $value")
                        $CIPPClause.Add("$($condition.Property.label) is $($condition.Operator.label) $value")
                    }
                    $finalCondition = $conditionStrings -join ' -AND '

                    [PSCustomObject]@{
                        clause         = $finalCondition
                        expectedAction = $actions
                        CIPPClause     = $CIPPClause
                    }
                }
            } catch {
                Write-Warning "Error creating where clause: $($_.Exception.Message)"
                Write-Information $_.InvocationInfo.PositionMessage
                #Write-LogMessage -API 'Webhooks' -message 'Error creating where clause' -LogData (Get-CippException -Exception $_) -sev Error -tenant $TenantFilter
                throw $_
            }

            $MatchedRules = [System.Collections.Generic.List[string]]::new()
            $DataToProcess = foreach ($clause in $Where) {
                try {
                    $ClauseStartTime = Get-Date
                    Write-Warning "Webhook: Processing clause: $($clause.clause)"
                    $ReturnedData = $ProcessedData | Where-Object { Invoke-Expression $clause.clause }
                    if ($ReturnedData) {
                        Write-Warning "Webhook: There is matching data: $(($ReturnedData.operation | Select-Object -Unique) -join ', ')"
                        $ReturnedData = foreach ($item in $ReturnedData) {
                            $item.CIPPAction = $clause.expectedAction
                            $item.CIPPClause = $clause.CIPPClause -join ' and '
                            $MatchedRules.Add($clause.CIPPClause -join ' and ')
                            $item
                        }
                    }
                    $ClauseEndTime = Get-Date
                    $ClauseSeconds = ($ClauseEndTime - $ClauseStartTime).TotalSeconds
                    Write-Warning "Task took $ClauseSeconds seconds for clause: $($clause.clause)"
                    $ReturnedData
                } catch {
                    Write-Warning "Error processing clause: $($clause.clause): $($_.Exception.Message)"
                }
            }
            $Results.MatchedRules = @($MatchedRules | Select-Object -Unique)
            $Results.MatchedLogs = ($DataToProcess | Measure-Object).Count
            $Results.DataToProcess = $DataToProcess
        }

        if ($DataToProcess) {
            $CippConfigTable = Get-CippTable -tablename Config
            $CippConfig = Get-CIPPAzDataTableEntity @CippConfigTable -Filter "PartitionKey eq 'InstanceProperties' and RowKey eq 'CIPPURL'"
            $CIPPURL = 'https://{0}' -f $CippConfig.Value
            foreach ($AuditLog in $DataToProcess) {
                Write-Information "Processing $($AuditLog.operation)"
                $Webhook = @{
                    Data         = $AuditLog
                    CIPPURL      = [string]$CIPPURL
                    TenantFilter = $TenantFilter
                }
                try {
                    Invoke-CippWebhookProcessing @Webhook
                } catch {
                    Write-Warning "Error sending final step of auditlog processing: $($_.Exception.Message)"
                    Write-Information $_.InvocationInfo.PositionMessage
                }
            }
        }

        try {
            Write-Information 'Removing processed rows from cache'
            foreach ($Row in $Rows) {
                if ($Row.id) {
                    $RowEntity = Get-CIPPAzDataTableEntity @CacheWebhooksTable -Filter "PartitionKey eq '$TenantFilter' and RowKey eq '$($Row.id)'"
                    if ($RowEntity) {
                        Remove-AzDataTableEntity @CacheWebhooksTable -Entity $RowEntity -Force
                        Write-Information "Removed row $($Row.id) from cache at final pass."
                    }
                }
            }
        } catch {
            Write-Information "Error removing rows from cache: $($_.Exception.Message)"
        }

    } catch {
        Write-Warning "An error occurred during the Test-CIPPAuditLogRules execution: $($_.Exception.Message)"
        Write-Information $_.InvocationInfo.PositionMessage
    }
    return $Results
}
#EndRegion './Public/Webhooks/Test-CIPPAuditLogRules.ps1' 450

